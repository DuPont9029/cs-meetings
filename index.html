<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjIxIiBoZWlnaHQ9IjcxNyIgdmlld0JveD0iMCAwIDYyMSA3MTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yODAuNjA0IDY3Ljg5NzdMNDMuODY4MyAyMDQuNTc3TDEwNy4wODggMjQxLjA3N0wyODAuNjA0IDE0MC44OThWNjcuODk3N1oiIGZpbGw9IiNGRkQ5MDAiLz4KPHBhdGggZD0iTTEwNy4wODggMjQxLjA3N0w0My44NjgzIDIwNC41NzdWNTEyLjU3N0w3NS40NzgyIDQ5NC4zMjdMOTEuMjgzMSA0ODUuMjAyTDEwNy4wODggNDc2LjA3N0wxMDcuMDg4IDI0MS4wNzdaIiBmaWxsPSIjRkYwMDYyIi8+CjxwYXRoIGQ9Ik00My44NjgzIDUxMi41NzdMMjgwLjYwNCA2NDkuMjU3VjU3Ni4yNTdMMTA3LjA4OCA0NzYuMDc3TDkxLjI4MzEgNDg1LjIwMkw3NS40NzgyIDQ5NC4zMjdMNDMuODY4MyA1MTIuNTc3WiIgZmlsbD0iI0ZGNDAwMCIvPgo8cGF0aCBkPSJNMzQwLjYwNCAxNDAuODk4VjMwOC41NzdIMzcwLjYwNEg0MDAuNjA0VjE3NS41MzlMNTE0LjEyIDI0MS4wNzdMNTQ1LjczIDIyMi44MjdMNTc3LjM0IDIwNC41NzdMMzQwLjYwNCA2Ny44OTc3VjEyMy41NzdWMTQwLjg5OFoiIGZpbGw9IiNGRjAwMDAiLz4KPHBhdGggZD0iTTM0MC42MDQgMzY4LjU3N0g0MDAuNjA0SDUxNC4xMkg1NzYuODIxTDU3Ni42MDQgMzA4LjU3N0g1MTQuMTJINDQ3LjVINDAwLjYwNEgzNzAuNjA0SDM0MC42MDRWMzY4LjU3N1oiIGZpbGw9IiMzNTg0NDUiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zMTAuMTA0IDAuNTc3MTQ4TDYxOS43MDggMTc5LjMyN1Y1MzYuODI3TDMxMC4xMDQgNzE1LjU3N0wwLjUgNTM2LjgyN1YxNzkuMzI3TDMxMC4xMDQgMC41NzcxNDhaTTQzLjg2ODMgMjA0LjU3N0wyODAuNjA0IDY3Ljg5NzdWMTQwLjg5OEwxMDcuMDg4IDI0MS4wNzdMMTA3LjA4OCA0NzYuMDc3TDI4MC42MDQgNTc2LjI1N1Y2NDkuMjU3TDQzLjg2ODMgNTEyLjU3N1YyMDQuNTc3Wk0zNDAuNjA0IDMwOC41NzdWMTQwLjg5OFYxMjMuNTc3VjY3Ljg5NzdMNTc3LjM0IDIwNC41NzdMNTQ1LjczIDIyMi44MjdMNTE0LjEyIDI0MS4wNzdMNDAwLjYwNCAxNzUuNTM5VjMwOC41NzdINDQ3LjVINTE0LjEySDU3Ni42MDRMNTc2LjgyMSAzNjguNTc3TDU3Ny4zNCA1MTIuNTc3TDUxNC4xMiA1NDkuMDc3TDM0MC42MDQgNjQ5LjI1N1Y1NzYuMjU3TDUxNC4xMiA0NzYuMDc3VjM2OC41NzdINDAwLjYwNEgzNDAuNjA0VjMwOC41NzdaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTUxNC4xMiA0NzYuMDc3VjM2OC41NzdINTc2LjgyMUw1NzcuMzQgNTEyLjU3N0w1MTQuMTIgNTQ5LjA3N1Y0NzYuMDc3WiIgZmlsbD0iIzAwQjdGRiIvPgo8cGF0aCBkPSJNMzQwLjYwNCA1NzYuMjU3VjY0OS4yNTdMNTE0LjEyIDU0OS4wNzdWNDc2LjA3N0wzNDAuNjA0IDU3Ni4yNTdaIiBmaWxsPSIjMzczNjM2Ii8+CjxwYXRoIGQ9Ik00My44NjgzIDIwNC41NzdMMjgwLjYwNCA2Ny44OTc3VjE0MC44OThMMTA3LjA4OCAyNDEuMDc3TTQzLjg2ODMgMjA0LjU3N0wxMDcuMDg4IDI0MS4wNzdNNDMuODY4MyAyMDQuNTc3VjUxMi41NzdNMTA3LjA4OCAyNDEuMDc3TDEwNy4wODggNDc2LjA3N00zNDAuNjA0IDM2OC41NzdINDAwLjYwNEg1MTQuMTJNMzQwLjYwNCAzNjguNTc3VjE0MC44OThNMzQwLjYwNCAzNjguNTc3VjMwOC41NzdNMzQwLjYwNCAzNjguNTc3SDUxNC4xMk0zNDAuNjA0IDE0MC44OThWMTIzLjU3N1Y2Ny44OTc3TTM0MC42MDQgMTQwLjg5OFY2Ny44OTc3TTM0MC42MDQgMTQwLjg5OFYzMDguNTc3TTM0MC42MDQgMzA4LjU3N0gzNzAuNjA0SDQwMC42MDRNNDMuODY4MyA1MTIuNTc3TDI4MC42MDQgNjQ5LjI1N1Y1NzYuMjU3TDEwNy4wODggNDc2LjA3N000My44NjgzIDUxMi41NzdMNzUuNDc4MiA0OTQuMzI3TDkxLjI4MzEgNDg1LjIwMk00My44NjgzIDUxMi41NzdMOTEuMjgzMSA0ODUuMjAyTTQzLjg2ODMgNTEyLjU3N0wxMDcuMDg4IDQ3Ni4wNzdNNTE0LjEyIDQ3Ni4wNzdWMzY4LjU3N001MTQuMTIgNDc2LjA3N0wzNDAuNjA0IDU3Ni4yNTdWNjQ5LjI1N0w1MTQuMTIgNTQ5LjA3N001MTQuMTIgNDc2LjA3N1Y1NDkuMDc3TTEwNy4wODggNDc2LjA3N0w5MS4yODMxIDQ4NS4yMDJNMzQwLjYwNCA2Ny44OTc3TDU3Ny4zNCAyMDQuNTc3TDU0NS43MyAyMjIuODI3TDUxNC4xMiAyNDEuMDc3TDQwMC42MDQgMTc1LjUzOVYzMDguNTc3TTQwMC42MDQgMzA4LjU3N0g0NDcuNUg1MTQuMTJINTc2LjYwNEw1NzYuODIxIDM2OC41NzdNNTE0LjEyIDM2OC41NzdINTc2LjgyMU01NzYuODIxIDM2OC41NzdMNTc3LjM0IDUxMi41NzdMNTE0LjEyIDU0OS4wNzdNNjE5LjcwOCAxNzkuMzI3TDMxMC4xMDQgMC41NzcxNDhMMC41IDE3OS4zMjdWNTM2LjgyN0wzMTAuMTA0IDcxNS41NzdMNjE5LjcwOCA1MzYuODI3VjE3OS4zMjdaIiBzdHJva2U9IiMzNzM2MzYiLz4KPC9zdmc+Cg==">
    <title>Comitato Studentesco - Richiesta Assemblea</title>
    <script>
      const __$G =
        typeof globalThis !== "undefined"
          ? globalThis
          : typeof window !== "undefined"
          ? window
          : typeof global !== "undefined"
          ? global
          : typeof self !== "undefined"
          ? self
          : {};
      (function (global, factory) {
        typeof exports === "object" && typeof module !== "undefined"
          ? factory(exports)
          : typeof define === "function" && define.amd
          ? define(["exports"], factory)
          : ((global =
              typeof globalThis !== "undefined" ? globalThis : global || self),
            factory((global.ethers = {})));
      })(this, function (exports) {
        "use strict";
        const version = "6.11.1";
        function checkType(value, type, name) {
          const types = type.split("|").map((t) => t.trim());
          for (let i = 0; i < types.length; i++) {
            switch (type) {
              case "any":
                return;
              case "bigint":
              case "boolean":
              case "number":
              case "string":
                if (typeof value === type) {
                  return;
                }
            }
          }
          const error = new Error(`invalid value for type ${type}`);
          error.code = "INVALID_ARGUMENT";
          error.argument = `value.${name}`;
          error.value = value;
          throw error;
        }
        async function resolveProperties(value) {
          const keys = Object.keys(value);
          const results = await Promise.all(
            keys.map((k) => Promise.resolve(value[k]))
          );
          return results.reduce((accum, v, index) => {
            accum[keys[index]] = v;
            return accum;
          }, {});
        }
        function defineProperties(target, values, types) {
          for (let key in values) {
            let value = values[key];
            const type = types ? types[key] : null;
            if (type) {
              checkType(value, type, key);
            }
            Object.defineProperty(target, key, {
              enumerable: true,
              value: value,
              writable: false,
            });
          }
        }
        function stringify$1(value) {
          if (value == null) {
            return "null";
          }
          if (Array.isArray(value)) {
            return "[ " + value.map(stringify$1).join(", ") + " ]";
          }
          if (value instanceof Uint8Array) {
            const HEX = "0123456789abcdef";
            let result = "0x";
            for (let i = 0; i < value.length; i++) {
              result += HEX[value[i] >> 4];
              result += HEX[value[i] & 15];
            }
            return result;
          }
          if (typeof value === "object" && typeof value.toJSON === "function") {
            return stringify$1(value.toJSON());
          }
          switch (typeof value) {
            case "boolean":
            case "symbol":
              return value.toString();
            case "bigint":
              return BigInt(value).toString();
            case "number":
              return value.toString();
            case "string":
              return JSON.stringify(value);
            case "object": {
              const keys = Object.keys(value);
              keys.sort();
              return (
                "{ " +
                keys
                  .map((k) => `${stringify$1(k)}: ${stringify$1(value[k])}`)
                  .join(", ") +
                " }"
              );
            }
          }
          return `[ COULD NOT SERIALIZE ]`;
        }
        function isError(error, code) {
          return error && error.code === code;
        }
        function isCallException(error) {
          return isError(error, "CALL_EXCEPTION");
        }
        function makeError(message, code, info) {
          let shortMessage = message;
          {
            const details = [];
            if (info) {
              if ("message" in info || "code" in info || "name" in info) {
                throw new Error(
                  `value will overwrite populated values: ${stringify$1(info)}`
                );
              }
              for (const key in info) {
                if (key === "shortMessage") {
                  continue;
                }
                const value = info[key];
                details.push(key + "=" + stringify$1(value));
              }
            }
            details.push(`code=${code}`);
            details.push(`version=${version}`);
            if (details.length) {
              message += " (" + details.join(", ") + ")";
            }
          }
          let error;
          switch (code) {
            case "INVALID_ARGUMENT":
              error = new TypeError(message);
              break;
            case "NUMERIC_FAULT":
            case "BUFFER_OVERRUN":
              error = new RangeError(message);
              break;
            default:
              error = new Error(message);
          }
          defineProperties(error, { code: code });
          if (info) {
            Object.assign(error, info);
          }
          if (error.shortMessage == null) {
            defineProperties(error, { shortMessage: shortMessage });
          }
          return error;
        }
        function assert(check, message, code, info) {
          if (!check) {
            throw makeError(message, code, info);
          }
        }
        function assertArgument(check, message, name, value) {
          assert(check, message, "INVALID_ARGUMENT", {
            argument: name,
            value: value,
          });
        }
        function assertArgumentCount(count, expectedCount, message) {
          if (message == null) {
            message = "";
          }
          if (message) {
            message = ": " + message;
          }
          assert(
            count >= expectedCount,
            "missing arguemnt" + message,
            "MISSING_ARGUMENT",
            { count: count, expectedCount: expectedCount }
          );
          assert(
            count <= expectedCount,
            "too many arguments" + message,
            "UNEXPECTED_ARGUMENT",
            { count: count, expectedCount: expectedCount }
          );
        }
        const _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce(
          (accum, form) => {
            try {
              if ("test".normalize(form) !== "test") {
                throw new Error("bad");
              }
              if (form === "NFD") {
                const check = String.fromCharCode(233).normalize("NFD");
                const expected = String.fromCharCode(101, 769);
                if (check !== expected) {
                  throw new Error("broken");
                }
              }
              accum.push(form);
            } catch (error) {}
            return accum;
          },
          []
        );
        function assertNormalize(form) {
          assert(
            _normalizeForms.indexOf(form) >= 0,
            "platform missing String.prototype.normalize",
            "UNSUPPORTED_OPERATION",
            { operation: "String.prototype.normalize", info: { form: form } }
          );
        }
        function assertPrivate(givenGuard, guard, className) {
          if (className == null) {
            className = "";
          }
          if (givenGuard !== guard) {
            let method = className,
              operation = "new";
            if (className) {
              method += ".";
              operation += " " + className;
            }
            assert(
              false,
              `private constructor; use ${method}from* methods`,
              "UNSUPPORTED_OPERATION",
              { operation: operation }
            );
          }
        }
        function _getBytes(value, name, copy) {
          if (value instanceof Uint8Array) {
            if (copy) {
              return new Uint8Array(value);
            }
            return value;
          }
          if (
            typeof value === "string" &&
            value.match(/^0x([0-9a-f][0-9a-f])*$/i)
          ) {
            const result = new Uint8Array((value.length - 2) / 2);
            let offset = 2;
            for (let i = 0; i < result.length; i++) {
              result[i] = parseInt(value.substring(offset, offset + 2), 16);
              offset += 2;
            }
            return result;
          }
          assertArgument(
            false,
            "invalid BytesLike value",
            name || "value",
            value
          );
        }
        function getBytes(value, name) {
          return _getBytes(value, name, false);
        }
        function getBytesCopy(value, name) {
          return _getBytes(value, name, true);
        }
        function isHexString(value, length) {
          if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
            return false;
          }
          if (typeof length === "number" && value.length !== 2 + 2 * length) {
            return false;
          }
          if (length === true && value.length % 2 !== 0) {
            return false;
          }
          return true;
        }
        function isBytesLike(value) {
          return isHexString(value, true) || value instanceof Uint8Array;
        }
        const HexCharacters = "0123456789abcdef";
        function hexlify(data) {
          const bytes = getBytes(data);
          let result = "0x";
          for (let i = 0; i < bytes.length; i++) {
            const v = bytes[i];
            result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
          }
          return result;
        }
        function concat(datas) {
          return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
        }
        function dataLength(data) {
          if (isHexString(data, true)) {
            return (data.length - 2) / 2;
          }
          return getBytes(data).length;
        }
        function dataSlice(data, start, end) {
          const bytes = getBytes(data);
          if (end != null && end > bytes.length) {
            assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
              buffer: bytes,
              length: bytes.length,
              offset: end,
            });
          }
          return hexlify(
            bytes.slice(
              start == null ? 0 : start,
              end == null ? bytes.length : end
            )
          );
        }
        function stripZerosLeft(data) {
          let bytes = hexlify(data).substring(2);
          while (bytes.startsWith("00")) {
            bytes = bytes.substring(2);
          }
          return "0x" + bytes;
        }
        function zeroPad(data, length, left) {
          const bytes = getBytes(data);
          assert(
            length >= bytes.length,
            "padding exceeds data length",
            "BUFFER_OVERRUN",
            {
              buffer: new Uint8Array(bytes),
              length: length,
              offset: length + 1,
            }
          );
          const result = new Uint8Array(length);
          result.fill(0);
          if (left) {
            result.set(bytes, length - bytes.length);
          } else {
            result.set(bytes, 0);
          }
          return hexlify(result);
        }
        function zeroPadValue(data, length) {
          return zeroPad(data, length, true);
        }
        function zeroPadBytes(data, length) {
          return zeroPad(data, length, false);
        }
        const BN_0$a = BigInt(0);
        const BN_1$5 = BigInt(1);
        const maxValue = 9007199254740991;
        function fromTwos(_value, _width) {
          const value = getUint(_value, "value");
          const width = BigInt(getNumber(_width, "width"));
          assert(value >> width === BN_0$a, "overflow", "NUMERIC_FAULT", {
            operation: "fromTwos",
            fault: "overflow",
            value: _value,
          });
          if (value >> (width - BN_1$5)) {
            const mask = (BN_1$5 << width) - BN_1$5;
            return -((~value & mask) + BN_1$5);
          }
          return value;
        }
        function toTwos(_value, _width) {
          let value = getBigInt(_value, "value");
          const width = BigInt(getNumber(_width, "width"));
          const limit = BN_1$5 << (width - BN_1$5);
          if (value < BN_0$a) {
            value = -value;
            assert(value <= limit, "too low", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: _value,
            });
            const mask = (BN_1$5 << width) - BN_1$5;
            return (~value & mask) + BN_1$5;
          } else {
            assert(value < limit, "too high", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: _value,
            });
          }
          return value;
        }
        function mask(_value, _bits) {
          const value = getUint(_value, "value");
          const bits = BigInt(getNumber(_bits, "bits"));
          return value & ((BN_1$5 << bits) - BN_1$5);
        }
        function getBigInt(value, name) {
          switch (typeof value) {
            case "bigint":
              return value;
            case "number":
              assertArgument(
                Number.isInteger(value),
                "underflow",
                name || "value",
                value
              );
              assertArgument(
                value >= -maxValue && value <= maxValue,
                "overflow",
                name || "value",
                value
              );
              return BigInt(value);
            case "string":
              try {
                if (value === "") {
                  throw new Error("empty string");
                }
                if (value[0] === "-" && value[1] !== "-") {
                  return -BigInt(value.substring(1));
                }
                return BigInt(value);
              } catch (e) {
                assertArgument(
                  false,
                  `invalid BigNumberish string: ${e.message}`,
                  name || "value",
                  value
                );
              }
          }
          assertArgument(
            false,
            "invalid BigNumberish value",
            name || "value",
            value
          );
        }
        function getUint(value, name) {
          const result = getBigInt(value, name);
          assert(
            result >= BN_0$a,
            "unsigned value cannot be negative",
            "NUMERIC_FAULT",
            { fault: "overflow", operation: "getUint", value: value }
          );
          return result;
        }
        const Nibbles$1 = "0123456789abcdef";
        function toBigInt(value) {
          if (value instanceof Uint8Array) {
            let result = "0x0";
            for (const v of value) {
              result += Nibbles$1[v >> 4];
              result += Nibbles$1[v & 15];
            }
            return BigInt(result);
          }
          return getBigInt(value);
        }
        function getNumber(value, name) {
          switch (typeof value) {
            case "bigint":
              assertArgument(
                value >= -maxValue && value <= maxValue,
                "overflow",
                name || "value",
                value
              );
              return Number(value);
            case "number":
              assertArgument(
                Number.isInteger(value),
                "underflow",
                name || "value",
                value
              );
              assertArgument(
                value >= -maxValue && value <= maxValue,
                "overflow",
                name || "value",
                value
              );
              return value;
            case "string":
              try {
                if (value === "") {
                  throw new Error("empty string");
                }
                return getNumber(BigInt(value), name);
              } catch (e) {
                assertArgument(
                  false,
                  `invalid numeric string: ${e.message}`,
                  name || "value",
                  value
                );
              }
          }
          assertArgument(
            false,
            "invalid numeric value",
            name || "value",
            value
          );
        }
        function toNumber(value) {
          return getNumber(toBigInt(value));
        }
        function toBeHex(_value, _width) {
          const value = getUint(_value, "value");
          let result = value.toString(16);
          if (_width == null) {
            if (result.length % 2) {
              result = "0" + result;
            }
          } else {
            const width = getNumber(_width, "width");
            assert(
              width * 2 >= result.length,
              `value exceeds width (${width} bytes)`,
              "NUMERIC_FAULT",
              { operation: "toBeHex", fault: "overflow", value: _value }
            );
            while (result.length < width * 2) {
              result = "0" + result;
            }
          }
          return "0x" + result;
        }
        function toBeArray(_value) {
          const value = getUint(_value, "value");
          if (value === BN_0$a) {
            return new Uint8Array([]);
          }
          let hex = value.toString(16);
          if (hex.length % 2) {
            hex = "0" + hex;
          }
          const result = new Uint8Array(hex.length / 2);
          for (let i = 0; i < result.length; i++) {
            const offset = i * 2;
            result[i] = parseInt(hex.substring(offset, offset + 2), 16);
          }
          return result;
        }
        function toQuantity(value) {
          let result = hexlify(
            isBytesLike(value) ? value : toBeArray(value)
          ).substring(2);
          while (result.startsWith("0")) {
            result = result.substring(1);
          }
          if (result === "") {
            result = "0";
          }
          return "0x" + result;
        }
        const Alphabet =
          "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        let Lookup = null;
        function getAlpha(letter) {
          if (Lookup == null) {
            Lookup = {};
            for (let i = 0; i < Alphabet.length; i++) {
              Lookup[Alphabet[i]] = BigInt(i);
            }
          }
          const result = Lookup[letter];
          assertArgument(
            result != null,
            `invalid base58 value`,
            "letter",
            letter
          );
          return result;
        }
        const BN_0$9 = BigInt(0);
        const BN_58 = BigInt(58);
        function encodeBase58(_value) {
          const bytes = getBytes(_value);
          let value = toBigInt(bytes);
          let result = "";
          while (value) {
            result = Alphabet[Number(value % BN_58)] + result;
            value /= BN_58;
          }
          for (let i = 0; i < bytes.length; i++) {
            if (bytes[i]) {
              break;
            }
            result = Alphabet[0] + result;
          }
          return result;
        }
        function decodeBase58(value) {
          let result = BN_0$9;
          for (let i = 0; i < value.length; i++) {
            result *= BN_58;
            result += getAlpha(value[i]);
          }
          return result;
        }
        function decodeBase64(textData) {
          textData = atob(textData);
          const data = new Uint8Array(textData.length);
          for (let i = 0; i < textData.length; i++) {
            data[i] = textData.charCodeAt(i);
          }
          return getBytes(data);
        }
        function encodeBase64(_data) {
          const data = getBytes(_data);
          let textData = "";
          for (let i = 0; i < data.length; i++) {
            textData += String.fromCharCode(data[i]);
          }
          return btoa(textData);
        }
        class EventPayload {
          filter;
          emitter;
          #listener;
          constructor(emitter, listener, filter) {
            this.#listener = listener;
            defineProperties(this, { emitter: emitter, filter: filter });
          }
          async removeListener() {
            if (this.#listener == null) {
              return;
            }
            await this.emitter.off(this.filter, this.#listener);
          }
        }
        function errorFunc(reason, offset, bytes, output, badCodepoint) {
          assertArgument(
            false,
            `invalid codepoint at offset ${offset}; ${reason}`,
            "bytes",
            bytes
          );
        }
        function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
          if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
            let i = 0;
            for (let o = offset + 1; o < bytes.length; o++) {
              if (bytes[o] >> 6 !== 2) {
                break;
              }
              i++;
            }
            return i;
          }
          if (reason === "OVERRUN") {
            return bytes.length - offset - 1;
          }
          return 0;
        }
        function replaceFunc(reason, offset, bytes, output, badCodepoint) {
          if (reason === "OVERLONG") {
            assertArgument(
              typeof badCodepoint === "number",
              "invalid bad code point for replacement",
              "badCodepoint",
              badCodepoint
            );
            output.push(badCodepoint);
            return 0;
          }
          output.push(65533);
          return ignoreFunc(reason, offset, bytes);
        }
        const Utf8ErrorFuncs = Object.freeze({
          error: errorFunc,
          ignore: ignoreFunc,
          replace: replaceFunc,
        });
        function getUtf8CodePoints(_bytes, onError) {
          if (onError == null) {
            onError = Utf8ErrorFuncs.error;
          }
          const bytes = getBytes(_bytes, "bytes");
          const result = [];
          let i = 0;
          while (i < bytes.length) {
            const c = bytes[i++];
            if (c >> 7 === 0) {
              result.push(c);
              continue;
            }
            let extraLength = null;
            let overlongMask = null;
            if ((c & 224) === 192) {
              extraLength = 1;
              overlongMask = 127;
            } else if ((c & 240) === 224) {
              extraLength = 2;
              overlongMask = 2047;
            } else if ((c & 248) === 240) {
              extraLength = 3;
              overlongMask = 65535;
            } else {
              if ((c & 192) === 128) {
                i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
              } else {
                i += onError("BAD_PREFIX", i - 1, bytes, result);
              }
              continue;
            }
            if (i - 1 + extraLength >= bytes.length) {
              i += onError("OVERRUN", i - 1, bytes, result);
              continue;
            }
            let res = c & ((1 << (8 - extraLength - 1)) - 1);
            for (let j = 0; j < extraLength; j++) {
              let nextChar = bytes[i];
              if ((nextChar & 192) != 128) {
                i += onError("MISSING_CONTINUE", i, bytes, result);
                res = null;
                break;
              }
              res = (res << 6) | (nextChar & 63);
              i++;
            }
            if (res === null) {
              continue;
            }
            if (res > 1114111) {
              i += onError(
                "OUT_OF_RANGE",
                i - 1 - extraLength,
                bytes,
                result,
                res
              );
              continue;
            }
            if (res >= 55296 && res <= 57343) {
              i += onError(
                "UTF16_SURROGATE",
                i - 1 - extraLength,
                bytes,
                result,
                res
              );
              continue;
            }
            if (res <= overlongMask) {
              i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
              continue;
            }
            result.push(res);
          }
          return result;
        }
        function toUtf8Bytes(str, form) {
          assertArgument(
            typeof str === "string",
            "invalid string value",
            "str",
            str
          );
          if (form != null) {
            assertNormalize(form);
            str = str.normalize(form);
          }
          let result = [];
          for (let i = 0; i < str.length; i++) {
            const c = str.charCodeAt(i);
            if (c < 128) {
              result.push(c);
            } else if (c < 2048) {
              result.push((c >> 6) | 192);
              result.push((c & 63) | 128);
            } else if ((c & 64512) == 55296) {
              i++;
              const c2 = str.charCodeAt(i);
              assertArgument(
                i < str.length && (c2 & 64512) === 56320,
                "invalid surrogate pair",
                "str",
                str
              );
              const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
              result.push((pair >> 18) | 240);
              result.push(((pair >> 12) & 63) | 128);
              result.push(((pair >> 6) & 63) | 128);
              result.push((pair & 63) | 128);
            } else {
              result.push((c >> 12) | 224);
              result.push(((c >> 6) & 63) | 128);
              result.push((c & 63) | 128);
            }
          }
          return new Uint8Array(result);
        }
        function _toUtf8String(codePoints) {
          return codePoints
            .map((codePoint) => {
              if (codePoint <= 65535) {
                return String.fromCharCode(codePoint);
              }
              codePoint -= 65536;
              return String.fromCharCode(
                ((codePoint >> 10) & 1023) + 55296,
                (codePoint & 1023) + 56320
              );
            })
            .join("");
        }
        function toUtf8String(bytes, onError) {
          return _toUtf8String(getUtf8CodePoints(bytes, onError));
        }
        function toUtf8CodePoints(str, form) {
          return getUtf8CodePoints(toUtf8Bytes(str, form));
        }
        function createGetUrl(options) {
          async function getUrl(req, _signal) {
            const protocol = req.url.split(":")[0].toLowerCase();
            assert(
              protocol === "http" || protocol === "https",
              `unsupported protocol ${protocol}`,
              "UNSUPPORTED_OPERATION",
              { info: { protocol: protocol }, operation: "request" }
            );
            assert(
              protocol === "https" ||
                !req.credentials ||
                req.allowInsecureAuthentication,
              "insecure authorized connections unsupported",
              "UNSUPPORTED_OPERATION",
              { operation: "request" }
            );
            let signal = undefined;
            if (_signal) {
              const controller = new AbortController();
              signal = controller.signal;
              _signal.addListener(() => {
                controller.abort();
              });
            }
            const init = {
              method: req.method,
              headers: new Headers(Array.from(req)),
              body: req.body || undefined,
              signal: signal,
            };
            const resp = await fetch(req.url, init);
            const headers = {};
            resp.headers.forEach((value, key) => {
              headers[key.toLowerCase()] = value;
            });
            const respBody = await resp.arrayBuffer();
            const body = respBody == null ? null : new Uint8Array(respBody);
            return {
              statusCode: resp.status,
              statusMessage: resp.statusText,
              headers: headers,
              body: body,
            };
          }
          return getUrl;
        }
        const MAX_ATTEMPTS = 12;
        const SLOT_INTERVAL = 250;
        let defaultGetUrlFunc = createGetUrl();
        const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
        const reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
        let locked$5 = false;
        async function dataGatewayFunc(url, signal) {
          try {
            const match = url.match(reData);
            if (!match) {
              throw new Error("invalid data");
            }
            return new FetchResponse(
              200,
              "OK",
              { "content-type": match[1] || "text/plain" },
              match[2] ? decodeBase64(match[3]) : unpercent(match[3])
            );
          } catch (error) {
            return new FetchResponse(
              599,
              "BAD REQUEST (invalid data: URI)",
              {},
              null,
              new FetchRequest(url)
            );
          }
        }
        function getIpfsGatewayFunc(baseUrl) {
          async function gatewayIpfs(url, signal) {
            try {
              const match = url.match(reIpfs);
              if (!match) {
                throw new Error("invalid link");
              }
              return new FetchRequest(`${baseUrl}${match[2]}`);
            } catch (error) {
              return new FetchResponse(
                599,
                "BAD REQUEST (invalid IPFS URI)",
                {},
                null,
                new FetchRequest(url)
              );
            }
          }
          return gatewayIpfs;
        }
        const Gateways = {
          data: dataGatewayFunc,
          ipfs: getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/"),
        };
        const fetchSignals = new WeakMap();
        class FetchCancelSignal {
          #listeners;
          #cancelled;
          constructor(request) {
            this.#listeners = [];
            this.#cancelled = false;
            fetchSignals.set(request, () => {
              if (this.#cancelled) {
                return;
              }
              this.#cancelled = true;
              for (const listener of this.#listeners) {
                setTimeout(() => {
                  listener();
                }, 0);
              }
              this.#listeners = [];
            });
          }
          addListener(listener) {
            assert(
              !this.#cancelled,
              "singal already cancelled",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchCancelSignal.addCancelListener" }
            );
            this.#listeners.push(listener);
          }
          get cancelled() {
            return this.#cancelled;
          }
          checkSignal() {
            assert(!this.cancelled, "cancelled", "CANCELLED", {});
          }
        }
        function checkSignal(signal) {
          if (signal == null) {
            throw new Error("missing signal; should not happen");
          }
          signal.checkSignal();
          return signal;
        }
        class FetchRequest {
          #allowInsecure;
          #gzip;
          #headers;
          #method;
          #timeout;
          #url;
          #body;
          #bodyType;
          #creds;
          #preflight;
          #process;
          #retry;
          #signal;
          #throttle;
          #getUrlFunc;
          get url() {
            return this.#url;
          }
          set url(url) {
            this.#url = String(url);
          }
          get body() {
            if (this.#body == null) {
              return null;
            }
            return new Uint8Array(this.#body);
          }
          set body(body) {
            if (body == null) {
              this.#body = undefined;
              this.#bodyType = undefined;
            } else if (typeof body === "string") {
              this.#body = toUtf8Bytes(body);
              this.#bodyType = "text/plain";
            } else if (body instanceof Uint8Array) {
              this.#body = body;
              this.#bodyType = "application/octet-stream";
            } else if (typeof body === "object") {
              this.#body = toUtf8Bytes(JSON.stringify(body));
              this.#bodyType = "application/json";
            } else {
              throw new Error("invalid body");
            }
          }
          hasBody() {
            return this.#body != null;
          }
          get method() {
            if (this.#method) {
              return this.#method;
            }
            if (this.hasBody()) {
              return "POST";
            }
            return "GET";
          }
          set method(method) {
            if (method == null) {
              method = "";
            }
            this.#method = String(method).toUpperCase();
          }
          get headers() {
            const headers = Object.assign({}, this.#headers);
            if (this.#creds) {
              headers["authorization"] = `Basic ${encodeBase64(
                toUtf8Bytes(this.#creds)
              )}`;
            }
            if (this.allowGzip) {
              headers["accept-encoding"] = "gzip";
            }
            if (headers["content-type"] == null && this.#bodyType) {
              headers["content-type"] = this.#bodyType;
            }
            if (this.body) {
              headers["content-length"] = String(this.body.length);
            }
            return headers;
          }
          getHeader(key) {
            return this.headers[key.toLowerCase()];
          }
          setHeader(key, value) {
            this.#headers[String(key).toLowerCase()] = String(value);
          }
          clearHeaders() {
            this.#headers = {};
          }
          [Symbol.iterator]() {
            const headers = this.headers;
            const keys = Object.keys(headers);
            let index = 0;
            return {
              next: () => {
                if (index < keys.length) {
                  const key = keys[index++];
                  return { value: [key, headers[key]], done: false };
                }
                return { value: undefined, done: true };
              },
            };
          }
          get credentials() {
            return this.#creds || null;
          }
          setCredentials(username, password) {
            assertArgument(
              !username.match(/:/),
              "invalid basic authentication username",
              "username",
              "[REDACTED]"
            );
            this.#creds = `${username}:${password}`;
          }
          get allowGzip() {
            return this.#gzip;
          }
          set allowGzip(value) {
            this.#gzip = !!value;
          }
          get allowInsecureAuthentication() {
            return !!this.#allowInsecure;
          }
          set allowInsecureAuthentication(value) {
            this.#allowInsecure = !!value;
          }
          get timeout() {
            return this.#timeout;
          }
          set timeout(timeout) {
            assertArgument(
              timeout >= 0,
              "timeout must be non-zero",
              "timeout",
              timeout
            );
            this.#timeout = timeout;
          }
          get preflightFunc() {
            return this.#preflight || null;
          }
          set preflightFunc(preflight) {
            this.#preflight = preflight;
          }
          get processFunc() {
            return this.#process || null;
          }
          set processFunc(process) {
            this.#process = process;
          }
          get retryFunc() {
            return this.#retry || null;
          }
          set retryFunc(retry) {
            this.#retry = retry;
          }
          get getUrlFunc() {
            return this.#getUrlFunc || defaultGetUrlFunc;
          }
          set getUrlFunc(value) {
            this.#getUrlFunc = value;
          }
          constructor(url) {
            this.#url = String(url);
            this.#allowInsecure = false;
            this.#gzip = true;
            this.#headers = {};
            this.#method = "";
            this.#timeout = 3e5;
            this.#throttle = {
              slotInterval: SLOT_INTERVAL,
              maxAttempts: MAX_ATTEMPTS,
            };
            this.#getUrlFunc = null;
          }
          toString() {
            return `<FetchRequest method=${JSON.stringify(
              this.method
            )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
          }
          setThrottleParams(params) {
            if (params.slotInterval != null) {
              this.#throttle.slotInterval = params.slotInterval;
            }
            if (params.maxAttempts != null) {
              this.#throttle.maxAttempts = params.maxAttempts;
            }
          }
          async #send(attempt, expires, delay, _request, _response) {
            if (attempt >= this.#throttle.maxAttempts) {
              return _response.makeServerError("exceeded maximum retry limit");
            }
            assert(getTime$2() <= expires, "timeout", "TIMEOUT", {
              operation: "request.send",
              reason: "timeout",
              request: _request,
            });
            if (delay > 0) {
              await wait(delay);
            }
            let req = this.clone();
            const scheme = (req.url.split(":")[0] || "").toLowerCase();
            if (scheme in Gateways) {
              const result = await Gateways[scheme](
                req.url,
                checkSignal(_request.#signal)
              );
              if (result instanceof FetchResponse) {
                let response = result;
                if (this.processFunc) {
                  checkSignal(_request.#signal);
                  try {
                    response = await this.processFunc(req, response);
                  } catch (error) {
                    if (
                      error.throttle == null ||
                      typeof error.stall !== "number"
                    ) {
                      response
                        .makeServerError(
                          "error in post-processing function",
                          error
                        )
                        .assertOk();
                    }
                  }
                }
                return response;
              }
              req = result;
            }
            if (this.preflightFunc) {
              req = await this.preflightFunc(req);
            }
            const resp = await this.getUrlFunc(
              req,
              checkSignal(_request.#signal)
            );
            let response = new FetchResponse(
              resp.statusCode,
              resp.statusMessage,
              resp.headers,
              resp.body,
              _request
            );
            if (response.statusCode === 301 || response.statusCode === 302) {
              try {
                const location = response.headers.location || "";
                return req
                  .redirect(location)
                  .#send(attempt + 1, expires, 0, _request, response);
              } catch (error) {}
              return response;
            } else if (response.statusCode === 429) {
              if (
                this.retryFunc == null ||
                (await this.retryFunc(req, response, attempt))
              ) {
                const retryAfter = response.headers["retry-after"];
                let delay =
                  this.#throttle.slotInterval *
                  Math.trunc(Math.random() * Math.pow(2, attempt));
                if (
                  typeof retryAfter === "string" &&
                  retryAfter.match(/^[1-9][0-9]*$/)
                ) {
                  delay = parseInt(retryAfter);
                }
                return req
                  .clone()
                  .#send(attempt + 1, expires, delay, _request, response);
              }
            }
            if (this.processFunc) {
              checkSignal(_request.#signal);
              try {
                response = await this.processFunc(req, response);
              } catch (error) {
                if (error.throttle == null || typeof error.stall !== "number") {
                  response
                    .makeServerError("error in post-processing function", error)
                    .assertOk();
                }
                let delay =
                  this.#throttle.slotInterval *
                  Math.trunc(Math.random() * Math.pow(2, attempt));
                if (error.stall >= 0) {
                  delay = error.stall;
                }
                return req
                  .clone()
                  .#send(attempt + 1, expires, delay, _request, response);
              }
            }
            return response;
          }
          send() {
            assert(
              this.#signal == null,
              "request already sent",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchRequest.send" }
            );
            this.#signal = new FetchCancelSignal(this);
            return this.#send(
              0,
              getTime$2() + this.timeout,
              0,
              this,
              new FetchResponse(0, "", {}, null, this)
            );
          }
          cancel() {
            assert(
              this.#signal != null,
              "request has not been sent",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchRequest.cancel" }
            );
            const signal = fetchSignals.get(this);
            if (!signal) {
              throw new Error("missing signal; should not happen");
            }
            signal();
          }
          redirect(location) {
            const current = this.url.split(":")[0].toLowerCase();
            const target = location.split(":")[0].toLowerCase();
            assert(
              this.method === "GET" &&
                (current !== "https" || target !== "http") &&
                location.match(/^https?:/),
              `unsupported redirect`,
              "UNSUPPORTED_OPERATION",
              {
                operation: `redirect(${this.method} ${JSON.stringify(
                  this.url
                )} => ${JSON.stringify(location)})`,
              }
            );
            const req = new FetchRequest(location);
            req.method = "GET";
            req.allowGzip = this.allowGzip;
            req.timeout = this.timeout;
            req.#headers = Object.assign({}, this.#headers);
            if (this.#body) {
              req.#body = new Uint8Array(this.#body);
            }
            req.#bodyType = this.#bodyType;
            return req;
          }
          clone() {
            const clone = new FetchRequest(this.url);
            clone.#method = this.#method;
            if (this.#body) {
              clone.#body = this.#body;
            }
            clone.#bodyType = this.#bodyType;
            clone.#headers = Object.assign({}, this.#headers);
            clone.#creds = this.#creds;
            if (this.allowGzip) {
              clone.allowGzip = true;
            }
            clone.timeout = this.timeout;
            if (this.allowInsecureAuthentication) {
              clone.allowInsecureAuthentication = true;
            }
            clone.#preflight = this.#preflight;
            clone.#process = this.#process;
            clone.#retry = this.#retry;
            clone.#getUrlFunc = this.#getUrlFunc;
            return clone;
          }
          static lockConfig() {
            locked$5 = true;
          }
          static getGateway(scheme) {
            return Gateways[scheme.toLowerCase()] || null;
          }
          static registerGateway(scheme, func) {
            scheme = scheme.toLowerCase();
            if (scheme === "http" || scheme === "https") {
              throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
            }
            if (locked$5) {
              throw new Error("gateways locked");
            }
            Gateways[scheme] = func;
          }
          static registerGetUrl(getUrl) {
            if (locked$5) {
              throw new Error("gateways locked");
            }
            defaultGetUrlFunc = getUrl;
          }
          static createGetUrlFunc(options) {
            return createGetUrl();
          }
          static createDataGateway() {
            return dataGatewayFunc;
          }
          static createIpfsGatewayFunc(baseUrl) {
            return getIpfsGatewayFunc(baseUrl);
          }
        }
        class FetchResponse {
          #statusCode;
          #statusMessage;
          #headers;
          #body;
          #request;
          #error;
          toString() {
            return `<FetchResponse status=${
              this.statusCode
            } body=${this.#body ? hexlify(this.#body) : "null"}>`;
          }
          get statusCode() {
            return this.#statusCode;
          }
          get statusMessage() {
            return this.#statusMessage;
          }
          get headers() {
            return Object.assign({}, this.#headers);
          }
          get body() {
            return this.#body == null ? null : new Uint8Array(this.#body);
          }
          get bodyText() {
            try {
              return this.#body == null ? "" : toUtf8String(this.#body);
            } catch (error) {
              assert(
                false,
                "response body is not valid UTF-8 data",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyText", info: { response: this } }
              );
            }
          }
          get bodyJson() {
            try {
              return JSON.parse(this.bodyText);
            } catch (error) {
              assert(
                false,
                "response body is not valid JSON",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyJson", info: { response: this } }
              );
            }
          }
          [Symbol.iterator]() {
            const headers = this.headers;
            const keys = Object.keys(headers);
            let index = 0;
            return {
              next: () => {
                if (index < keys.length) {
                  const key = keys[index++];
                  return { value: [key, headers[key]], done: false };
                }
                return { value: undefined, done: true };
              },
            };
          }
          constructor(statusCode, statusMessage, headers, body, request) {
            this.#statusCode = statusCode;
            this.#statusMessage = statusMessage;
            this.#headers = Object.keys(headers).reduce((accum, k) => {
              accum[k.toLowerCase()] = String(headers[k]);
              return accum;
            }, {});
            this.#body = body == null ? null : new Uint8Array(body);
            this.#request = request || null;
            this.#error = { message: "" };
          }
          makeServerError(message, error) {
            let statusMessage;
            if (!message) {
              message = `${this.statusCode} ${this.statusMessage}`;
              statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
            } else {
              statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
            }
            const response = new FetchResponse(
              599,
              statusMessage,
              this.headers,
              this.body,
              this.#request || undefined
            );
            response.#error = { message: message, error: error };
            return response;
          }
          throwThrottleError(message, stall) {
            if (stall == null) {
              stall = -1;
            } else {
              assertArgument(
                Number.isInteger(stall) && stall >= 0,
                "invalid stall timeout",
                "stall",
                stall
              );
            }
            const error = new Error(message || "throttling requests");
            defineProperties(error, { stall: stall, throttle: true });
            throw error;
          }
          getHeader(key) {
            return this.headers[key.toLowerCase()];
          }
          hasBody() {
            return this.#body != null;
          }
          get request() {
            return this.#request;
          }
          ok() {
            return (
              this.#error.message === "" &&
              this.statusCode >= 200 &&
              this.statusCode < 300
            );
          }
          assertOk() {
            if (this.ok()) {
              return;
            }
            let { message, error } = this.#error;
            if (message === "") {
              message = `server response ${this.statusCode} ${this.statusMessage}`;
            }
            let requestUrl = null;
            if (this.request) {
              requestUrl = this.request.url;
            }
            let responseBody = null;
            try {
              if (this.#body) {
                responseBody = toUtf8String(this.#body);
              }
            } catch (e) {}
            assert(false, message, "SERVER_ERROR", {
              request: this.request || "unknown request",
              response: this,
              error: error,
              info: {
                requestUrl: requestUrl,
                responseBody: responseBody,
                responseStatus: `${this.statusCode} ${this.statusMessage}`,
              },
            });
          }
        }
        function getTime$2() {
          return new Date().getTime();
        }
        function unpercent(value) {
          return toUtf8Bytes(
            value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
              return String.fromCharCode(parseInt(code, 16));
            })
          );
        }
        function wait(delay) {
          return new Promise((resolve) => setTimeout(resolve, delay));
        }
        const BN_N1 = BigInt(-1);
        const BN_0$8 = BigInt(0);
        const BN_1$4 = BigInt(1);
        const BN_5 = BigInt(5);
        const _guard$5 = {};
        let Zeros$1 = "0000";
        while (Zeros$1.length < 80) {
          Zeros$1 += Zeros$1;
        }
        function getTens(decimals) {
          let result = Zeros$1;
          while (result.length < decimals) {
            result += result;
          }
          return BigInt("1" + result.substring(0, decimals));
        }
        function checkValue(val, format, safeOp) {
          const width = BigInt(format.width);
          if (format.signed) {
            const limit = BN_1$4 << (width - BN_1$4);
            assert(
              safeOp == null || (val >= -limit && val < limit),
              "overflow",
              "NUMERIC_FAULT",
              { operation: safeOp, fault: "overflow", value: val }
            );
            if (val > BN_0$8) {
              val = fromTwos(mask(val, width), width);
            } else {
              val = -fromTwos(mask(-val, width), width);
            }
          } else {
            const limit = BN_1$4 << width;
            assert(
              safeOp == null || (val >= 0 && val < limit),
              "overflow",
              "NUMERIC_FAULT",
              { operation: safeOp, fault: "overflow", value: val }
            );
            val = ((val % limit) + limit) % limit & (limit - BN_1$4);
          }
          return val;
        }
        function getFormat(value) {
          if (typeof value === "number") {
            value = `fixed128x${value}`;
          }
          let signed = true;
          let width = 128;
          let decimals = 18;
          if (typeof value === "string") {
            if (value === "fixed");
            else if (value === "ufixed") {
              signed = false;
            } else {
              const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
              assertArgument(match, "invalid fixed format", "format", value);
              signed = match[1] !== "u";
              width = parseInt(match[2]);
              decimals = parseInt(match[3]);
            }
          } else if (value) {
            const v = value;
            const check = (key, type, defaultValue) => {
              if (v[key] == null) {
                return defaultValue;
              }
              assertArgument(
                typeof v[key] === type,
                "invalid fixed format (" + key + " not " + type + ")",
                "format." + key,
                v[key]
              );
              return v[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
          }
          assertArgument(
            width % 8 === 0,
            "invalid FixedNumber width (not byte aligned)",
            "format.width",
            width
          );
          assertArgument(
            decimals <= 80,
            "invalid FixedNumber decimals (too large)",
            "format.decimals",
            decimals
          );
          const name =
            (signed ? "" : "u") +
            "fixed" +
            String(width) +
            "x" +
            String(decimals);
          return {
            signed: signed,
            width: width,
            decimals: decimals,
            name: name,
          };
        }
        function toString(val, decimals) {
          let negative = "";
          if (val < BN_0$8) {
            negative = "-";
            val *= BN_N1;
          }
          let str = val.toString();
          if (decimals === 0) {
            return negative + str;
          }
          while (str.length <= decimals) {
            str = Zeros$1 + str;
          }
          const index = str.length - decimals;
          str = str.substring(0, index) + "." + str.substring(index);
          while (str[0] === "0" && str[1] !== ".") {
            str = str.substring(1);
          }
          while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
            str = str.substring(0, str.length - 1);
          }
          return negative + str;
        }
        class FixedNumber {
          format;
          #format;
          #val;
          #tens;
          _value;
          constructor(guard, value, format) {
            assertPrivate(guard, _guard$5, "FixedNumber");
            this.#val = value;
            this.#format = format;
            const _value = toString(value, format.decimals);
            defineProperties(this, { format: format.name, _value: _value });
            this.#tens = getTens(format.decimals);
          }
          get signed() {
            return this.#format.signed;
          }
          get width() {
            return this.#format.width;
          }
          get decimals() {
            return this.#format.decimals;
          }
          get value() {
            return this.#val;
          }
          #checkFormat(other) {
            assertArgument(
              this.format === other.format,
              "incompatible format; use fixedNumber.toFormat",
              "other",
              other
            );
          }
          #checkValue(val, safeOp) {
            val = checkValue(val, this.#format, safeOp);
            return new FixedNumber(_guard$5, val, this.#format);
          }
          #add(o, safeOp) {
            this.#checkFormat(o);
            return this.#checkValue(this.#val + o.#val, safeOp);
          }
          addUnsafe(other) {
            return this.#add(other);
          }
          add(other) {
            return this.#add(other, "add");
          }
          #sub(o, safeOp) {
            this.#checkFormat(o);
            return this.#checkValue(this.#val - o.#val, safeOp);
          }
          subUnsafe(other) {
            return this.#sub(other);
          }
          sub(other) {
            return this.#sub(other, "sub");
          }
          #mul(o, safeOp) {
            this.#checkFormat(o);
            return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);
          }
          mulUnsafe(other) {
            return this.#mul(other);
          }
          mul(other) {
            return this.#mul(other, "mul");
          }
          mulSignal(other) {
            this.#checkFormat(other);
            const value = this.#val * other.#val;
            assert(
              value % this.#tens === BN_0$8,
              "precision lost during signalling mul",
              "NUMERIC_FAULT",
              { operation: "mulSignal", fault: "underflow", value: this }
            );
            return this.#checkValue(value / this.#tens, "mulSignal");
          }
          #div(o, safeOp) {
            assert(o.#val !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
              operation: "div",
              fault: "divide-by-zero",
              value: this,
            });
            this.#checkFormat(o);
            return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);
          }
          divUnsafe(other) {
            return this.#div(other);
          }
          div(other) {
            return this.#div(other, "div");
          }
          divSignal(other) {
            assert(other.#val !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
              operation: "div",
              fault: "divide-by-zero",
              value: this,
            });
            this.#checkFormat(other);
            const value = this.#val * this.#tens;
            assert(
              value % other.#val === BN_0$8,
              "precision lost during signalling div",
              "NUMERIC_FAULT",
              { operation: "divSignal", fault: "underflow", value: this }
            );
            return this.#checkValue(value / other.#val, "divSignal");
          }
          cmp(other) {
            let a = this.value,
              b = other.value;
            const delta = this.decimals - other.decimals;
            if (delta > 0) {
              b *= getTens(delta);
            } else if (delta < 0) {
              a *= getTens(-delta);
            }
            if (a < b) {
              return -1;
            }
            if (a > b) {
              return 1;
            }
            return 0;
          }
          eq(other) {
            return this.cmp(other) === 0;
          }
          lt(other) {
            return this.cmp(other) < 0;
          }
          lte(other) {
            return this.cmp(other) <= 0;
          }
          gt(other) {
            return this.cmp(other) > 0;
          }
          gte(other) {
            return this.cmp(other) >= 0;
          }
          floor() {
            let val = this.#val;
            if (this.#val < BN_0$8) {
              val -= this.#tens - BN_1$4;
            }
            val = (this.#val / this.#tens) * this.#tens;
            return this.#checkValue(val, "floor");
          }
          ceiling() {
            let val = this.#val;
            if (this.#val > BN_0$8) {
              val += this.#tens - BN_1$4;
            }
            val = (this.#val / this.#tens) * this.#tens;
            return this.#checkValue(val, "ceiling");
          }
          round(decimals) {
            if (decimals == null) {
              decimals = 0;
            }
            if (decimals >= this.decimals) {
              return this;
            }
            const delta = this.decimals - decimals;
            const bump = BN_5 * getTens(delta - 1);
            let value = this.value + bump;
            const tens = getTens(delta);
            value = (value / tens) * tens;
            checkValue(value, this.#format, "round");
            return new FixedNumber(_guard$5, value, this.#format);
          }
          isZero() {
            return this.#val === BN_0$8;
          }
          isNegative() {
            return this.#val < BN_0$8;
          }
          toString() {
            return this._value;
          }
          toUnsafeFloat() {
            return parseFloat(this.toString());
          }
          toFormat(format) {
            return FixedNumber.fromString(this.toString(), format);
          }
          static fromValue(_value, _decimals, _format) {
            const decimals = _decimals == null ? 0 : getNumber(_decimals);
            const format = getFormat(_format);
            let value = getBigInt(_value, "value");
            const delta = decimals - format.decimals;
            if (delta > 0) {
              const tens = getTens(delta);
              assert(
                value % tens === BN_0$8,
                "value loses precision for format",
                "NUMERIC_FAULT",
                { operation: "fromValue", fault: "underflow", value: _value }
              );
              value /= tens;
            } else if (delta < 0) {
              value *= getTens(-delta);
            }
            checkValue(value, format, "fromValue");
            return new FixedNumber(_guard$5, value, format);
          }
          static fromString(_value, _format) {
            const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
            assertArgument(
              match && match[2].length + match[3].length > 0,
              "invalid FixedNumber string value",
              "value",
              _value
            );
            const format = getFormat(_format);
            let whole = match[2] || "0",
              decimal = match[3] || "";
            while (decimal.length < format.decimals) {
              decimal += Zeros$1;
            }
            assert(
              decimal.substring(format.decimals).match(/^0*$/),
              "too many decimals for format",
              "NUMERIC_FAULT",
              { operation: "fromString", fault: "underflow", value: _value }
            );
            decimal = decimal.substring(0, format.decimals);
            const value = BigInt(match[1] + whole + decimal);
            checkValue(value, format, "fromString");
            return new FixedNumber(_guard$5, value, format);
          }
          static fromBytes(_value, _format) {
            let value = toBigInt(getBytes(_value, "value"));
            const format = getFormat(_format);
            if (format.signed) {
              value = fromTwos(value, format.width);
            }
            checkValue(value, format, "fromBytes");
            return new FixedNumber(_guard$5, value, format);
          }
        }
        function hexlifyByte(value) {
          let result = value.toString(16);
          while (result.length < 2) {
            result = "0" + result;
          }
          return "0x" + result;
        }
        function unarrayifyInteger(data, offset, length) {
          let result = 0;
          for (let i = 0; i < length; i++) {
            result = result * 256 + data[offset + i];
          }
          return result;
        }
        function _decodeChildren(data, offset, childOffset, length) {
          const result = [];
          while (childOffset < offset + 1 + length) {
            const decoded = _decode(data, childOffset);
            result.push(decoded.result);
            childOffset += decoded.consumed;
            assert(
              childOffset <= offset + 1 + length,
              "child data too short",
              "BUFFER_OVERRUN",
              { buffer: data, length: length, offset: offset }
            );
          }
          return { consumed: 1 + length, result: result };
        }
        function _decode(data, offset) {
          assert(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
            buffer: data,
            length: 0,
            offset: 1,
          });
          const checkOffset = (offset) => {
            assert(
              offset <= data.length,
              "data short segment too short",
              "BUFFER_OVERRUN",
              { buffer: data, length: data.length, offset: offset }
            );
          };
          if (data[offset] >= 248) {
            const lengthLength = data[offset] - 247;
            checkOffset(offset + 1 + lengthLength);
            const length = unarrayifyInteger(data, offset + 1, lengthLength);
            checkOffset(offset + 1 + lengthLength + length);
            return _decodeChildren(
              data,
              offset,
              offset + 1 + lengthLength,
              lengthLength + length
            );
          } else if (data[offset] >= 192) {
            const length = data[offset] - 192;
            checkOffset(offset + 1 + length);
            return _decodeChildren(data, offset, offset + 1, length);
          } else if (data[offset] >= 184) {
            const lengthLength = data[offset] - 183;
            checkOffset(offset + 1 + lengthLength);
            const length = unarrayifyInteger(data, offset + 1, lengthLength);
            checkOffset(offset + 1 + lengthLength + length);
            const result = hexlify(
              data.slice(
                offset + 1 + lengthLength,
                offset + 1 + lengthLength + length
              )
            );
            return { consumed: 1 + lengthLength + length, result: result };
          } else if (data[offset] >= 128) {
            const length = data[offset] - 128;
            checkOffset(offset + 1 + length);
            const result = hexlify(data.slice(offset + 1, offset + 1 + length));
            return { consumed: 1 + length, result: result };
          }
          return { consumed: 1, result: hexlifyByte(data[offset]) };
        }
        function decodeRlp(_data) {
          const data = getBytes(_data, "data");
          const decoded = _decode(data, 0);
          assertArgument(
            decoded.consumed === data.length,
            "unexpected junk after rlp payload",
            "data",
            _data
          );
          return decoded.result;
        }
        function arrayifyInteger(value) {
          const result = [];
          while (value) {
            result.unshift(value & 255);
            value >>= 8;
          }
          return result;
        }
        function _encode(object) {
          if (Array.isArray(object)) {
            let payload = [];
            object.forEach(function (child) {
              payload = payload.concat(_encode(child));
            });
            if (payload.length <= 55) {
              payload.unshift(192 + payload.length);
              return payload;
            }
            const length = arrayifyInteger(payload.length);
            length.unshift(247 + length.length);
            return length.concat(payload);
          }
          const data = Array.prototype.slice.call(getBytes(object, "object"));
          if (data.length === 1 && data[0] <= 127) {
            return data;
          } else if (data.length <= 55) {
            data.unshift(128 + data.length);
            return data;
          }
          const length = arrayifyInteger(data.length);
          length.unshift(183 + length.length);
          return length.concat(data);
        }
        const nibbles = "0123456789abcdef";
        function encodeRlp(object) {
          let result = "0x";
          for (const v of _encode(object)) {
            result += nibbles[v >> 4];
            result += nibbles[v & 15];
          }
          return result;
        }
        const names = [
          "wei",
          "kwei",
          "mwei",
          "gwei",
          "szabo",
          "finney",
          "ether",
        ];
        function formatUnits(value, unit) {
          let decimals = 18;
          if (typeof unit === "string") {
            const index = names.indexOf(unit);
            assertArgument(index >= 0, "invalid unit", "unit", unit);
            decimals = 3 * index;
          } else if (unit != null) {
            decimals = getNumber(unit, "unit");
          }
          return FixedNumber.fromValue(value, decimals, {
            decimals: decimals,
            width: 512,
          }).toString();
        }
        function parseUnits$1(value, unit) {
          assertArgument(
            typeof value === "string",
            "value must be a string",
            "value",
            value
          );
          let decimals = 18;
          if (typeof unit === "string") {
            const index = names.indexOf(unit);
            assertArgument(index >= 0, "invalid unit", "unit", unit);
            decimals = 3 * index;
          } else if (unit != null) {
            decimals = getNumber(unit, "unit");
          }
          return FixedNumber.fromString(value, {
            decimals: decimals,
            width: 512,
          }).value;
        }
        function formatEther(wei) {
          return formatUnits(wei, 18);
        }
        function parseEther(ether) {
          return parseUnits$1(ether, 18);
        }
        function uuidV4(randomBytes) {
          const bytes = getBytes(randomBytes, "randomBytes");
          bytes[6] = (bytes[6] & 15) | 64;
          bytes[8] = (bytes[8] & 63) | 128;
          const value = hexlify(bytes);
          return [
            value.substring(2, 10),
            value.substring(10, 14),
            value.substring(14, 18),
            value.substring(18, 22),
            value.substring(22, 34),
          ].join("-");
        }
        const WordSize = 32;
        const Padding = new Uint8Array(WordSize);
        const passProperties$1 = ["then"];
        const _guard$4 = {};
        function throwError(name, error) {
          const wrapped = new Error(
            `deferred error during ABI decoding triggered accessing ${name}`
          );
          wrapped.error = error;
          throw wrapped;
        }
        class Result extends Array {
          #names;
          constructor(...args) {
            const guard = args[0];
            let items = args[1];
            let names = (args[2] || []).slice();
            let wrap = true;
            if (guard !== _guard$4) {
              items = args;
              names = [];
              wrap = false;
            }
            super(items.length);
            items.forEach((item, index) => {
              this[index] = item;
            });
            const nameCounts = names.reduce((accum, name) => {
              if (typeof name === "string") {
                accum.set(name, (accum.get(name) || 0) + 1);
              }
              return accum;
            }, new Map());
            this.#names = Object.freeze(
              items.map((item, index) => {
                const name = names[index];
                if (name != null && nameCounts.get(name) === 1) {
                  return name;
                }
                return null;
              })
            );
            if (!wrap) {
              return;
            }
            Object.freeze(this);
            return new Proxy(this, {
              get: (target, prop, receiver) => {
                if (typeof prop === "string") {
                  if (prop.match(/^[0-9]+$/)) {
                    const index = getNumber(prop, "%index");
                    if (index < 0 || index >= this.length) {
                      throw new RangeError("out of result range");
                    }
                    const item = target[index];
                    if (item instanceof Error) {
                      throwError(`index ${index}`, item);
                    }
                    return item;
                  }
                  if (passProperties$1.indexOf(prop) >= 0) {
                    return Reflect.get(target, prop, receiver);
                  }
                  const value = target[prop];
                  if (value instanceof Function) {
                    return function (...args) {
                      return value.apply(
                        this === receiver ? target : this,
                        args
                      );
                    };
                  } else if (!(prop in target)) {
                    return target.getValue.apply(
                      this === receiver ? target : this,
                      [prop]
                    );
                  }
                }
                return Reflect.get(target, prop, receiver);
              },
            });
          }
          toArray() {
            const result = [];
            this.forEach((item, index) => {
              if (item instanceof Error) {
                throwError(`index ${index}`, item);
              }
              result.push(item);
            });
            return result;
          }
          toObject() {
            return this.#names.reduce((accum, name, index) => {
              assert(
                name != null,
                "value at index ${ index } unnamed",
                "UNSUPPORTED_OPERATION",
                { operation: "toObject()" }
              );
              if (!(name in accum)) {
                accum[name] = this.getValue(name);
              }
              return accum;
            }, {});
          }
          slice(start, end) {
            if (start == null) {
              start = 0;
            }
            if (start < 0) {
              start += this.length;
              if (start < 0) {
                start = 0;
              }
            }
            if (end == null) {
              end = this.length;
            }
            if (end < 0) {
              end += this.length;
              if (end < 0) {
                end = 0;
              }
            }
            if (end > this.length) {
              end = this.length;
            }
            const result = [],
              names = [];
            for (let i = start; i < end; i++) {
              result.push(this[i]);
              names.push(this.#names[i]);
            }
            return new Result(_guard$4, result, names);
          }
          filter(callback, thisArg) {
            const result = [],
              names = [];
            for (let i = 0; i < this.length; i++) {
              const item = this[i];
              if (item instanceof Error) {
                throwError(`index ${i}`, item);
              }
              if (callback.call(thisArg, item, i, this)) {
                result.push(item);
                names.push(this.#names[i]);
              }
            }
            return new Result(_guard$4, result, names);
          }
          map(callback, thisArg) {
            const result = [];
            for (let i = 0; i < this.length; i++) {
              const item = this[i];
              if (item instanceof Error) {
                throwError(`index ${i}`, item);
              }
              result.push(callback.call(thisArg, item, i, this));
            }
            return result;
          }
          getValue(name) {
            const index = this.#names.indexOf(name);
            if (index === -1) {
              return undefined;
            }
            const value = this[index];
            if (value instanceof Error) {
              throwError(`property ${JSON.stringify(name)}`, value.error);
            }
            return value;
          }
          static fromItems(items, keys) {
            return new Result(_guard$4, items, keys);
          }
        }
        function checkResultErrors(result) {
          const errors = [];
          const checkErrors = function (path, object) {
            if (!Array.isArray(object)) {
              return;
            }
            for (let key in object) {
              const childPath = path.slice();
              childPath.push(key);
              try {
                checkErrors(childPath, object[key]);
              } catch (error) {
                errors.push({ path: childPath, error: error });
              }
            }
          };
          checkErrors([], result);
          return errors;
        }
        function getValue$1(value) {
          let bytes = toBeArray(value);
          assert(
            bytes.length <= WordSize,
            "value out-of-bounds",
            "BUFFER_OVERRUN",
            { buffer: bytes, length: WordSize, offset: bytes.length }
          );
          if (bytes.length !== WordSize) {
            bytes = getBytesCopy(
              concat([Padding.slice(bytes.length % WordSize), bytes])
            );
          }
          return bytes;
        }
        class Coder {
          name;
          type;
          localName;
          dynamic;
          constructor(name, type, localName, dynamic) {
            defineProperties(
              this,
              {
                name: name,
                type: type,
                localName: localName,
                dynamic: dynamic,
              },
              {
                name: "string",
                type: "string",
                localName: "string",
                dynamic: "boolean",
              }
            );
          }
          _throwError(message, value) {
            assertArgument(false, message, this.localName, value);
          }
        }
        class Writer {
          #data;
          #dataLength;
          constructor() {
            this.#data = [];
            this.#dataLength = 0;
          }
          get data() {
            return concat(this.#data);
          }
          get length() {
            return this.#dataLength;
          }
          #writeData(data) {
            this.#data.push(data);
            this.#dataLength += data.length;
            return data.length;
          }
          appendWriter(writer) {
            return this.#writeData(getBytesCopy(writer.data));
          }
          writeBytes(value) {
            let bytes = getBytesCopy(value);
            const paddingOffset = bytes.length % WordSize;
            if (paddingOffset) {
              bytes = getBytesCopy(
                concat([bytes, Padding.slice(paddingOffset)])
              );
            }
            return this.#writeData(bytes);
          }
          writeValue(value) {
            return this.#writeData(getValue$1(value));
          }
          writeUpdatableValue() {
            const offset = this.#data.length;
            this.#data.push(Padding);
            this.#dataLength += WordSize;
            return (value) => {
              this.#data[offset] = getValue$1(value);
            };
          }
        }
        class Reader {
          allowLoose;
          #data;
          #offset;
          #bytesRead;
          #parent;
          #maxInflation;
          constructor(data, allowLoose, maxInflation) {
            defineProperties(this, { allowLoose: !!allowLoose });
            this.#data = getBytesCopy(data);
            this.#bytesRead = 0;
            this.#parent = null;
            this.#maxInflation = maxInflation != null ? maxInflation : 1024;
            this.#offset = 0;
          }
          get data() {
            return hexlify(this.#data);
          }
          get dataLength() {
            return this.#data.length;
          }
          get consumed() {
            return this.#offset;
          }
          get bytes() {
            return new Uint8Array(this.#data);
          }
          #incrementBytesRead(count) {
            if (this.#parent) {
              return this.#parent.#incrementBytesRead(count);
            }
            this.#bytesRead += count;
            assert(
              this.#maxInflation < 1 ||
                this.#bytesRead <= this.#maxInflation * this.dataLength,
              `compressed ABI data exceeds inflation ratio of ${
                this.#maxInflation
              } ( see: https:/\/github.com/ethers-io/ethers.js/issues/4537 )`,
              "BUFFER_OVERRUN",
              {
                buffer: getBytesCopy(this.#data),
                offset: this.#offset,
                length: count,
                info: {
                  bytesRead: this.#bytesRead,
                  dataLength: this.dataLength,
                },
              }
            );
          }
          #peekBytes(offset, length, loose) {
            let alignedLength = Math.ceil(length / WordSize) * WordSize;
            if (this.#offset + alignedLength > this.#data.length) {
              if (
                this.allowLoose &&
                loose &&
                this.#offset + length <= this.#data.length
              ) {
                alignedLength = length;
              } else {
                assert(false, "data out-of-bounds", "BUFFER_OVERRUN", {
                  buffer: getBytesCopy(this.#data),
                  length: this.#data.length,
                  offset: this.#offset + alignedLength,
                });
              }
            }
            return this.#data.slice(this.#offset, this.#offset + alignedLength);
          }
          subReader(offset) {
            const reader = new Reader(
              this.#data.slice(this.#offset + offset),
              this.allowLoose,
              this.#maxInflation
            );
            reader.#parent = this;
            return reader;
          }
          readBytes(length, loose) {
            let bytes = this.#peekBytes(0, length, !!loose);
            this.#incrementBytesRead(length);
            this.#offset += bytes.length;
            return bytes.slice(0, length);
          }
          readValue() {
            return toBigInt(this.readBytes(WordSize));
          }
          readIndex() {
            return toNumber(this.readBytes(WordSize));
          }
        }
        function number(n) {
          if (!Number.isSafeInteger(n) || n < 0)
            throw new Error(`Wrong positive integer: ${n}`);
        }
        function bytes(b, ...lengths) {
          if (!(b instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          if (lengths.length > 0 && !lengths.includes(b.length))
            throw new Error(
              `Expected Uint8Array of length ${lengths}, not of length=${b.length}`
            );
        }
        function hash(hash) {
          if (typeof hash !== "function" || typeof hash.create !== "function")
            throw new Error("Hash should be wrapped by utils.wrapConstructor");
          number(hash.outputLen);
          number(hash.blockLen);
        }
        function exists(instance, checkFinished = true) {
          if (instance.destroyed)
            throw new Error("Hash instance has been destroyed");
          if (checkFinished && instance.finished)
            throw new Error("Hash#digest() has already been called");
        }
        function output(out, instance) {
          bytes(out);
          const min = instance.outputLen;
          if (out.length < min) {
            throw new Error(
              `digestInto() expects output buffer of length at least ${min}`
            );
          }
        }
        const crypto$1 =
          typeof globalThis === "object" && "crypto" in globalThis
            ? globalThis.crypto
            : undefined;
        const u8a$1 = (a) => a instanceof Uint8Array;
        const u32 = (arr) =>
          new Uint32Array(
            arr.buffer,
            arr.byteOffset,
            Math.floor(arr.byteLength / 4)
          );
        const createView = (arr) =>
          new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
        const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
        const isLE =
          new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
        if (!isLE)
          throw new Error("Non little-endian hardware is not supported");
        const nextTick = async () => {};
        async function asyncLoop(iters, tick, cb) {
          let ts = Date.now();
          for (let i = 0; i < iters; i++) {
            cb(i);
            const diff = Date.now() - ts;
            if (diff >= 0 && diff < tick) continue;
            await nextTick();
            ts += diff;
          }
        }
        function utf8ToBytes$1(str) {
          if (typeof str !== "string")
            throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
          return new Uint8Array(new TextEncoder().encode(str));
        }
        function toBytes(data) {
          if (typeof data === "string") data = utf8ToBytes$1(data);
          if (!u8a$1(data))
            throw new Error(`expected Uint8Array, got ${typeof data}`);
          return data;
        }
        function concatBytes$1(...arrays) {
          const r = new Uint8Array(
            arrays.reduce((sum, a) => sum + a.length, 0)
          );
          let pad = 0;
          arrays.forEach((a) => {
            if (!u8a$1(a)) throw new Error("Uint8Array expected");
            r.set(a, pad);
            pad += a.length;
          });
          return r;
        }
        class Hash {
          clone() {
            return this._cloneInto();
          }
        }
        const toStr = {}.toString;
        function checkOpts(defaults, opts) {
          if (opts !== undefined && toStr.call(opts) !== "[object Object]")
            throw new Error("Options should be object or undefined");
          const merged = Object.assign(defaults, opts);
          return merged;
        }
        function wrapConstructor(hashCons) {
          const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
          const tmp = hashCons();
          hashC.outputLen = tmp.outputLen;
          hashC.blockLen = tmp.blockLen;
          hashC.create = () => hashCons();
          return hashC;
        }
        function randomBytes$2(bytesLength = 32) {
          if (crypto$1 && typeof crypto$1.getRandomValues === "function") {
            return crypto$1.getRandomValues(new Uint8Array(bytesLength));
          }
          throw new Error("crypto.getRandomValues must be defined");
        }
        class HMAC extends Hash {
          constructor(hash$1, _key) {
            super();
            this.finished = false;
            this.destroyed = false;
            hash(hash$1);
            const key = toBytes(_key);
            this.iHash = hash$1.create();
            if (typeof this.iHash.update !== "function")
              throw new Error(
                "Expected instance of class which extends utils.Hash"
              );
            this.blockLen = this.iHash.blockLen;
            this.outputLen = this.iHash.outputLen;
            const blockLen = this.blockLen;
            const pad = new Uint8Array(blockLen);
            pad.set(
              key.length > blockLen ? hash$1.create().update(key).digest() : key
            );
            for (let i = 0; i < pad.length; i++) pad[i] ^= 54;
            this.iHash.update(pad);
            this.oHash = hash$1.create();
            for (let i = 0; i < pad.length; i++) pad[i] ^= 54 ^ 92;
            this.oHash.update(pad);
            pad.fill(0);
          }
          update(buf) {
            exists(this);
            this.iHash.update(buf);
            return this;
          }
          digestInto(out) {
            exists(this);
            bytes(out, this.outputLen);
            this.finished = true;
            this.iHash.digestInto(out);
            this.oHash.update(out);
            this.oHash.digestInto(out);
            this.destroy();
          }
          digest() {
            const out = new Uint8Array(this.oHash.outputLen);
            this.digestInto(out);
            return out;
          }
          _cloneInto(to) {
            to || (to = Object.create(Object.getPrototypeOf(this), {}));
            const { oHash, iHash, finished, destroyed, blockLen, outputLen } =
              this;
            to = to;
            to.finished = finished;
            to.destroyed = destroyed;
            to.blockLen = blockLen;
            to.outputLen = outputLen;
            to.oHash = oHash._cloneInto(to.oHash);
            to.iHash = iHash._cloneInto(to.iHash);
            return to;
          }
          destroy() {
            this.destroyed = true;
            this.oHash.destroy();
            this.iHash.destroy();
          }
        }
        const hmac = (hash, key, message) =>
          new HMAC(hash, key).update(message).digest();
        hmac.create = (hash, key) => new HMAC(hash, key);
        function pbkdf2Init(hash$1, _password, _salt, _opts) {
          hash(hash$1);
          const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
          const { c, dkLen, asyncTick } = opts;
          number(c);
          number(dkLen);
          number(asyncTick);
          if (c < 1) throw new Error("PBKDF2: iterations (c) should be >= 1");
          const password = toBytes(_password);
          const salt = toBytes(_salt);
          const DK = new Uint8Array(dkLen);
          const PRF = hmac.create(hash$1, password);
          const PRFSalt = PRF._cloneInto().update(salt);
          return {
            c: c,
            dkLen: dkLen,
            asyncTick: asyncTick,
            DK: DK,
            PRF: PRF,
            PRFSalt: PRFSalt,
          };
        }
        function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
          PRF.destroy();
          PRFSalt.destroy();
          if (prfW) prfW.destroy();
          u.fill(0);
          return DK;
        }
        function pbkdf2$1(hash, password, salt, opts) {
          const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(
            hash,
            password,
            salt,
            opts
          );
          let prfW;
          const arr = new Uint8Array(4);
          const view = createView(arr);
          const u = new Uint8Array(PRF.outputLen);
          for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
            const Ti = DK.subarray(pos, pos + PRF.outputLen);
            view.setInt32(0, ti, false);
            (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
            Ti.set(u.subarray(0, Ti.length));
            for (let ui = 1; ui < c; ui++) {
              PRF._cloneInto(prfW).update(u).digestInto(u);
              for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
            }
          }
          return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
        }
        function setBigUint64(view, byteOffset, value, isLE) {
          if (typeof view.setBigUint64 === "function")
            return view.setBigUint64(byteOffset, value, isLE);
          const _32n = BigInt(32);
          const _u32_max = BigInt(4294967295);
          const wh = Number((value >> _32n) & _u32_max);
          const wl = Number(value & _u32_max);
          const h = isLE ? 4 : 0;
          const l = isLE ? 0 : 4;
          view.setUint32(byteOffset + h, wh, isLE);
          view.setUint32(byteOffset + l, wl, isLE);
        }
        class SHA2 extends Hash {
          constructor(blockLen, outputLen, padOffset, isLE) {
            super();
            this.blockLen = blockLen;
            this.outputLen = outputLen;
            this.padOffset = padOffset;
            this.isLE = isLE;
            this.finished = false;
            this.length = 0;
            this.pos = 0;
            this.destroyed = false;
            this.buffer = new Uint8Array(blockLen);
            this.view = createView(this.buffer);
          }
          update(data) {
            exists(this);
            const { view, buffer, blockLen } = this;
            data = toBytes(data);
            const len = data.length;
            for (let pos = 0; pos < len; ) {
              const take = Math.min(blockLen - this.pos, len - pos);
              if (take === blockLen) {
                const dataView = createView(data);
                for (; blockLen <= len - pos; pos += blockLen)
                  this.process(dataView, pos);
                continue;
              }
              buffer.set(data.subarray(pos, pos + take), this.pos);
              this.pos += take;
              pos += take;
              if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
              }
            }
            this.length += data.length;
            this.roundClean();
            return this;
          }
          digestInto(out) {
            exists(this);
            output(out, this);
            this.finished = true;
            const { buffer, view, blockLen, isLE } = this;
            let { pos } = this;
            buffer[pos++] = 128;
            this.buffer.subarray(pos).fill(0);
            if (this.padOffset > blockLen - pos) {
              this.process(view, 0);
              pos = 0;
            }
            for (let i = pos; i < blockLen; i++) buffer[i] = 0;
            setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
            this.process(view, 0);
            const oview = createView(out);
            const len = this.outputLen;
            if (len % 4)
              throw new Error("_sha2: outputLen should be aligned to 32bit");
            const outLen = len / 4;
            const state = this.get();
            if (outLen > state.length)
              throw new Error("_sha2: outputLen bigger than state");
            for (let i = 0; i < outLen; i++)
              oview.setUint32(4 * i, state[i], isLE);
          }
          digest() {
            const { buffer, outputLen } = this;
            this.digestInto(buffer);
            const res = buffer.slice(0, outputLen);
            this.destroy();
            return res;
          }
          _cloneInto(to) {
            to || (to = new this.constructor());
            to.set(...this.get());
            const { blockLen, buffer, length, finished, destroyed, pos } = this;
            to.length = length;
            to.pos = pos;
            to.finished = finished;
            to.destroyed = destroyed;
            if (length % blockLen) to.buffer.set(buffer);
            return to;
          }
        }
        const Chi = (a, b, c) => (a & b) ^ (~a & c);
        const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
        const SHA256_K = new Uint32Array([
          1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
          2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
          1925078388, 2162078206, 2614888103, 3248222580, 3835390401,
          4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692,
          1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
          3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912,
          1294757372, 1396182291, 1695183700, 1986661051, 2177026350,
          2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
          3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616,
          659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
          1955562222, 2024104815, 2227730452, 2361852424, 2428436474,
          2756734187, 3204031479, 3329325298,
        ]);
        const IV = new Uint32Array([
          1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
          2600822924, 528734635, 1541459225,
        ]);
        const SHA256_W = new Uint32Array(64);
        class SHA256 extends SHA2 {
          constructor() {
            super(64, 32, 8, false);
            this.A = IV[0] | 0;
            this.B = IV[1] | 0;
            this.C = IV[2] | 0;
            this.D = IV[3] | 0;
            this.E = IV[4] | 0;
            this.F = IV[5] | 0;
            this.G = IV[6] | 0;
            this.H = IV[7] | 0;
          }
          get() {
            const { A, B, C, D, E, F, G, H } = this;
            return [A, B, C, D, E, F, G, H];
          }
          set(A, B, C, D, E, F, G, H) {
            this.A = A | 0;
            this.B = B | 0;
            this.C = C | 0;
            this.D = D | 0;
            this.E = E | 0;
            this.F = F | 0;
            this.G = G | 0;
            this.H = H | 0;
          }
          process(view, offset) {
            for (let i = 0; i < 16; i++, offset += 4)
              SHA256_W[i] = view.getUint32(offset, false);
            for (let i = 16; i < 64; i++) {
              const W15 = SHA256_W[i - 15];
              const W2 = SHA256_W[i - 2];
              const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
              const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
              SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
            }
            let { A, B, C, D, E, F, G, H } = this;
            for (let i = 0; i < 64; i++) {
              const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
              const T1 =
                (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
              const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
              const T2 = (sigma0 + Maj(A, B, C)) | 0;
              H = G;
              G = F;
              F = E;
              E = (D + T1) | 0;
              D = C;
              C = B;
              B = A;
              A = (T1 + T2) | 0;
            }
            A = (A + this.A) | 0;
            B = (B + this.B) | 0;
            C = (C + this.C) | 0;
            D = (D + this.D) | 0;
            E = (E + this.E) | 0;
            F = (F + this.F) | 0;
            G = (G + this.G) | 0;
            H = (H + this.H) | 0;
            this.set(A, B, C, D, E, F, G, H);
          }
          roundClean() {
            SHA256_W.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0);
            this.buffer.fill(0);
          }
        }
        const sha256$1 = wrapConstructor(() => new SHA256());
        const U32_MASK64 = BigInt(2 ** 32 - 1);
        const _32n = BigInt(32);
        function fromBig(n, le = false) {
          if (le)
            return {
              h: Number(n & U32_MASK64),
              l: Number((n >> _32n) & U32_MASK64),
            };
          return {
            h: Number((n >> _32n) & U32_MASK64) | 0,
            l: Number(n & U32_MASK64) | 0,
          };
        }
        function split$1(lst, le = false) {
          let Ah = new Uint32Array(lst.length);
          let Al = new Uint32Array(lst.length);
          for (let i = 0; i < lst.length; i++) {
            const { h, l } = fromBig(lst[i], le);
            [Ah[i], Al[i]] = [h, l];
          }
          return [Ah, Al];
        }
        const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
        const shrSH = (h, _l, s) => h >>> s;
        const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
        const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
        const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
        const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
        const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
        const rotr32H = (_h, l) => l;
        const rotr32L = (h, _l) => h;
        const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
        const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
        const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
        const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
        function add(Ah, Al, Bh, Bl) {
          const l = (Al >>> 0) + (Bl >>> 0);
          return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
        }
        const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
        const add3H = (low, Ah, Bh, Ch) =>
          (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
        const add4L = (Al, Bl, Cl, Dl) =>
          (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
        const add4H = (low, Ah, Bh, Ch, Dh) =>
          (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
        const add5L = (Al, Bl, Cl, Dl, El) =>
          (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
        const add5H = (low, Ah, Bh, Ch, Dh, Eh) =>
          (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
        const u64 = {
          fromBig: fromBig,
          split: split$1,
          toBig: toBig,
          shrSH: shrSH,
          shrSL: shrSL,
          rotrSH: rotrSH,
          rotrSL: rotrSL,
          rotrBH: rotrBH,
          rotrBL: rotrBL,
          rotr32H: rotr32H,
          rotr32L: rotr32L,
          rotlSH: rotlSH,
          rotlSL: rotlSL,
          rotlBH: rotlBH,
          rotlBL: rotlBL,
          add: add,
          add3L: add3L,
          add3H: add3H,
          add4L: add4L,
          add4H: add4H,
          add5H: add5H,
          add5L: add5L,
        };
        var u64$1 = u64;
        const [SHA512_Kh, SHA512_Kl] = (() =>
          u64$1.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((n) => BigInt(n))
          ))();
        const SHA512_W_H = new Uint32Array(80);
        const SHA512_W_L = new Uint32Array(80);
        class SHA512 extends SHA2 {
          constructor() {
            super(128, 64, 16, false);
            this.Ah = 1779033703 | 0;
            this.Al = 4089235720 | 0;
            this.Bh = 3144134277 | 0;
            this.Bl = 2227873595 | 0;
            this.Ch = 1013904242 | 0;
            this.Cl = 4271175723 | 0;
            this.Dh = 2773480762 | 0;
            this.Dl = 1595750129 | 0;
            this.Eh = 1359893119 | 0;
            this.El = 2917565137 | 0;
            this.Fh = 2600822924 | 0;
            this.Fl = 725511199 | 0;
            this.Gh = 528734635 | 0;
            this.Gl = 4215389547 | 0;
            this.Hh = 1541459225 | 0;
            this.Hl = 327033209 | 0;
          }
          get() {
            const {
              Ah,
              Al,
              Bh,
              Bl,
              Ch,
              Cl,
              Dh,
              Dl,
              Eh,
              El,
              Fh,
              Fl,
              Gh,
              Gl,
              Hh,
              Hl,
            } = this;
            return [
              Ah,
              Al,
              Bh,
              Bl,
              Ch,
              Cl,
              Dh,
              Dl,
              Eh,
              El,
              Fh,
              Fl,
              Gh,
              Gl,
              Hh,
              Hl,
            ];
          }
          set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
            this.Ah = Ah | 0;
            this.Al = Al | 0;
            this.Bh = Bh | 0;
            this.Bl = Bl | 0;
            this.Ch = Ch | 0;
            this.Cl = Cl | 0;
            this.Dh = Dh | 0;
            this.Dl = Dl | 0;
            this.Eh = Eh | 0;
            this.El = El | 0;
            this.Fh = Fh | 0;
            this.Fl = Fl | 0;
            this.Gh = Gh | 0;
            this.Gl = Gl | 0;
            this.Hh = Hh | 0;
            this.Hl = Hl | 0;
          }
          process(view, offset) {
            for (let i = 0; i < 16; i++, offset += 4) {
              SHA512_W_H[i] = view.getUint32(offset);
              SHA512_W_L[i] = view.getUint32((offset += 4));
            }
            for (let i = 16; i < 80; i++) {
              const W15h = SHA512_W_H[i - 15] | 0;
              const W15l = SHA512_W_L[i - 15] | 0;
              const s0h =
                u64$1.rotrSH(W15h, W15l, 1) ^
                u64$1.rotrSH(W15h, W15l, 8) ^
                u64$1.shrSH(W15h, W15l, 7);
              const s0l =
                u64$1.rotrSL(W15h, W15l, 1) ^
                u64$1.rotrSL(W15h, W15l, 8) ^
                u64$1.shrSL(W15h, W15l, 7);
              const W2h = SHA512_W_H[i - 2] | 0;
              const W2l = SHA512_W_L[i - 2] | 0;
              const s1h =
                u64$1.rotrSH(W2h, W2l, 19) ^
                u64$1.rotrBH(W2h, W2l, 61) ^
                u64$1.shrSH(W2h, W2l, 6);
              const s1l =
                u64$1.rotrSL(W2h, W2l, 19) ^
                u64$1.rotrBL(W2h, W2l, 61) ^
                u64$1.shrSL(W2h, W2l, 6);
              const SUMl = u64$1.add4L(
                s0l,
                s1l,
                SHA512_W_L[i - 7],
                SHA512_W_L[i - 16]
              );
              const SUMh = u64$1.add4H(
                SUMl,
                s0h,
                s1h,
                SHA512_W_H[i - 7],
                SHA512_W_H[i - 16]
              );
              SHA512_W_H[i] = SUMh | 0;
              SHA512_W_L[i] = SUMl | 0;
            }
            let {
              Ah,
              Al,
              Bh,
              Bl,
              Ch,
              Cl,
              Dh,
              Dl,
              Eh,
              El,
              Fh,
              Fl,
              Gh,
              Gl,
              Hh,
              Hl,
            } = this;
            for (let i = 0; i < 80; i++) {
              const sigma1h =
                u64$1.rotrSH(Eh, El, 14) ^
                u64$1.rotrSH(Eh, El, 18) ^
                u64$1.rotrBH(Eh, El, 41);
              const sigma1l =
                u64$1.rotrSL(Eh, El, 14) ^
                u64$1.rotrSL(Eh, El, 18) ^
                u64$1.rotrBL(Eh, El, 41);
              const CHIh = (Eh & Fh) ^ (~Eh & Gh);
              const CHIl = (El & Fl) ^ (~El & Gl);
              const T1ll = u64$1.add5L(
                Hl,
                sigma1l,
                CHIl,
                SHA512_Kl[i],
                SHA512_W_L[i]
              );
              const T1h = u64$1.add5H(
                T1ll,
                Hh,
                sigma1h,
                CHIh,
                SHA512_Kh[i],
                SHA512_W_H[i]
              );
              const T1l = T1ll | 0;
              const sigma0h =
                u64$1.rotrSH(Ah, Al, 28) ^
                u64$1.rotrBH(Ah, Al, 34) ^
                u64$1.rotrBH(Ah, Al, 39);
              const sigma0l =
                u64$1.rotrSL(Ah, Al, 28) ^
                u64$1.rotrBL(Ah, Al, 34) ^
                u64$1.rotrBL(Ah, Al, 39);
              const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
              const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
              Hh = Gh | 0;
              Hl = Gl | 0;
              Gh = Fh | 0;
              Gl = Fl | 0;
              Fh = Eh | 0;
              Fl = El | 0;
              ({ h: Eh, l: El } = u64$1.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
              Dh = Ch | 0;
              Dl = Cl | 0;
              Ch = Bh | 0;
              Cl = Bl | 0;
              Bh = Ah | 0;
              Bl = Al | 0;
              const All = u64$1.add3L(T1l, sigma0l, MAJl);
              Ah = u64$1.add3H(All, T1h, sigma0h, MAJh);
              Al = All | 0;
            }
            ({ h: Ah, l: Al } = u64$1.add(
              this.Ah | 0,
              this.Al | 0,
              Ah | 0,
              Al | 0
            ));
            ({ h: Bh, l: Bl } = u64$1.add(
              this.Bh | 0,
              this.Bl | 0,
              Bh | 0,
              Bl | 0
            ));
            ({ h: Ch, l: Cl } = u64$1.add(
              this.Ch | 0,
              this.Cl | 0,
              Ch | 0,
              Cl | 0
            ));
            ({ h: Dh, l: Dl } = u64$1.add(
              this.Dh | 0,
              this.Dl | 0,
              Dh | 0,
              Dl | 0
            ));
            ({ h: Eh, l: El } = u64$1.add(
              this.Eh | 0,
              this.El | 0,
              Eh | 0,
              El | 0
            ));
            ({ h: Fh, l: Fl } = u64$1.add(
              this.Fh | 0,
              this.Fl | 0,
              Fh | 0,
              Fl | 0
            ));
            ({ h: Gh, l: Gl } = u64$1.add(
              this.Gh | 0,
              this.Gl | 0,
              Gh | 0,
              Gl | 0
            ));
            ({ h: Hh, l: Hl } = u64$1.add(
              this.Hh | 0,
              this.Hl | 0,
              Hh | 0,
              Hl | 0
            ));
            this.set(
              Ah,
              Al,
              Bh,
              Bl,
              Ch,
              Cl,
              Dh,
              Dl,
              Eh,
              El,
              Fh,
              Fl,
              Gh,
              Gl,
              Hh,
              Hl
            );
          }
          roundClean() {
            SHA512_W_H.fill(0);
            SHA512_W_L.fill(0);
          }
          destroy() {
            this.buffer.fill(0);
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        const sha512$1 = wrapConstructor(() => new SHA512());
        function getGlobal$1() {
          if (typeof self !== "undefined") {
            return self;
          }
          if (typeof window !== "undefined") {
            return window;
          }
          if (typeof global !== "undefined") {
            return global;
          }
          throw new Error("unable to locate global object");
        }
        const anyGlobal = getGlobal$1();
        const crypto = anyGlobal.crypto || anyGlobal.msCrypto;
        function createHash(algo) {
          switch (algo) {
            case "sha256":
              return sha256$1.create();
            case "sha512":
              return sha512$1.create();
          }
          assertArgument(
            false,
            "invalid hashing algorithm name",
            "algorithm",
            algo
          );
        }
        function createHmac(_algo, key) {
          const algo = { sha256: sha256$1, sha512: sha512$1 }[_algo];
          assertArgument(
            algo != null,
            "invalid hmac algorithm",
            "algorithm",
            _algo
          );
          return hmac.create(algo, key);
        }
        function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
          const algo = { sha256: sha256$1, sha512: sha512$1 }[_algo];
          assertArgument(
            algo != null,
            "invalid pbkdf2 algorithm",
            "algorithm",
            _algo
          );
          return pbkdf2$1(algo, password, salt, {
            c: iterations,
            dkLen: keylen,
          });
        }
        function randomBytes$1(length) {
          assert(
            crypto != null,
            "platform does not support secure random numbers",
            "UNSUPPORTED_OPERATION",
            { operation: "randomBytes" }
          );
          assertArgument(
            Number.isInteger(length) && length > 0 && length <= 1024,
            "invalid length",
            "length",
            length
          );
          const result = new Uint8Array(length);
          crypto.getRandomValues(result);
          return result;
        }
        let locked$4 = false;
        const _computeHmac = function (algorithm, key, data) {
          return createHmac(algorithm, key).update(data).digest();
        };
        let __computeHmac = _computeHmac;
        function computeHmac(algorithm, _key, _data) {
          const key = getBytes(_key, "key");
          const data = getBytes(_data, "data");
          return hexlify(__computeHmac(algorithm, key, data));
        }
        computeHmac._ = _computeHmac;
        computeHmac.lock = function () {
          locked$4 = true;
        };
        computeHmac.register = function (func) {
          if (locked$4) {
            throw new Error("computeHmac is locked");
          }
          __computeHmac = func;
        };
        Object.freeze(computeHmac);
        const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
        const _0n$4 = BigInt(0);
        const _1n$5 = BigInt(1);
        const _2n$3 = BigInt(2);
        const _7n = BigInt(7);
        const _256n = BigInt(256);
        const _0x71n = BigInt(113);
        for (let round = 0, R = _1n$5, x = 1, y = 0; round < 24; round++) {
          [x, y] = [y, (2 * x + 3 * y) % 5];
          SHA3_PI.push(2 * (5 * y + x));
          SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
          let t = _0n$4;
          for (let j = 0; j < 7; j++) {
            R = ((R << _1n$5) ^ ((R >> _7n) * _0x71n)) % _256n;
            if (R & _2n$3) t ^= _1n$5 << ((_1n$5 << BigInt(j)) - _1n$5);
          }
          _SHA3_IOTA.push(t);
        }
        const [SHA3_IOTA_H, SHA3_IOTA_L] = split$1(_SHA3_IOTA, true);
        const rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
        const rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));
        function keccakP(s, rounds = 24) {
          const B = new Uint32Array(5 * 2);
          for (let round = 24 - rounds; round < 24; round++) {
            for (let x = 0; x < 10; x++)
              B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
            for (let x = 0; x < 10; x += 2) {
              const idx1 = (x + 8) % 10;
              const idx0 = (x + 2) % 10;
              const B0 = B[idx0];
              const B1 = B[idx0 + 1];
              const Th = rotlH(B0, B1, 1) ^ B[idx1];
              const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
              for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
              }
            }
            let curH = s[2];
            let curL = s[3];
            for (let t = 0; t < 24; t++) {
              const shift = SHA3_ROTL[t];
              const Th = rotlH(curH, curL, shift);
              const Tl = rotlL(curH, curL, shift);
              const PI = SHA3_PI[t];
              curH = s[PI];
              curL = s[PI + 1];
              s[PI] = Th;
              s[PI + 1] = Tl;
            }
            for (let y = 0; y < 50; y += 10) {
              for (let x = 0; x < 10; x++) B[x] = s[y + x];
              for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
            }
            s[0] ^= SHA3_IOTA_H[round];
            s[1] ^= SHA3_IOTA_L[round];
          }
          B.fill(0);
        }
        class Keccak extends Hash {
          constructor(
            blockLen,
            suffix,
            outputLen,
            enableXOF = false,
            rounds = 24
          ) {
            super();
            this.blockLen = blockLen;
            this.suffix = suffix;
            this.outputLen = outputLen;
            this.enableXOF = enableXOF;
            this.rounds = rounds;
            this.pos = 0;
            this.posOut = 0;
            this.finished = false;
            this.destroyed = false;
            number(outputLen);
            if (0 >= this.blockLen || this.blockLen >= 200)
              throw new Error("Sha3 supports only keccak-f1600 function");
            this.state = new Uint8Array(200);
            this.state32 = u32(this.state);
          }
          keccak() {
            keccakP(this.state32, this.rounds);
            this.posOut = 0;
            this.pos = 0;
          }
          update(data) {
            exists(this);
            const { blockLen, state } = this;
            data = toBytes(data);
            const len = data.length;
            for (let pos = 0; pos < len; ) {
              const take = Math.min(blockLen - this.pos, len - pos);
              for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
              if (this.pos === blockLen) this.keccak();
            }
            return this;
          }
          finish() {
            if (this.finished) return;
            this.finished = true;
            const { state, suffix, pos, blockLen } = this;
            state[pos] ^= suffix;
            if ((suffix & 128) !== 0 && pos === blockLen - 1) this.keccak();
            state[blockLen - 1] ^= 128;
            this.keccak();
          }
          writeInto(out) {
            exists(this, false);
            bytes(out);
            this.finish();
            const bufferOut = this.state;
            const { blockLen } = this;
            for (let pos = 0, len = out.length; pos < len; ) {
              if (this.posOut >= blockLen) this.keccak();
              const take = Math.min(blockLen - this.posOut, len - pos);
              out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
              this.posOut += take;
              pos += take;
            }
            return out;
          }
          xofInto(out) {
            if (!this.enableXOF)
              throw new Error("XOF is not possible for this instance");
            return this.writeInto(out);
          }
          xof(bytes) {
            number(bytes);
            return this.xofInto(new Uint8Array(bytes));
          }
          digestInto(out) {
            output(out, this);
            if (this.finished) throw new Error("digest() was already called");
            this.writeInto(out);
            this.destroy();
            return out;
          }
          digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
          }
          destroy() {
            this.destroyed = true;
            this.state.fill(0);
          }
          _cloneInto(to) {
            const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
            to ||
              (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
            to.state32.set(this.state32);
            to.pos = this.pos;
            to.posOut = this.posOut;
            to.finished = this.finished;
            to.rounds = rounds;
            to.suffix = suffix;
            to.outputLen = outputLen;
            to.enableXOF = enableXOF;
            to.destroyed = this.destroyed;
            return to;
          }
        }
        const gen = (suffix, blockLen, outputLen) =>
          wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
        const keccak_256 = gen(1, 136, 256 / 8);
        let locked$3 = false;
        const _keccak256 = function (data) {
          return keccak_256(data);
        };
        let __keccak256 = _keccak256;
        function keccak256(_data) {
          const data = getBytes(_data, "data");
          return hexlify(__keccak256(data));
        }
        keccak256._ = _keccak256;
        keccak256.lock = function () {
          locked$3 = true;
        };
        keccak256.register = function (func) {
          if (locked$3) {
            throw new TypeError("keccak256 is locked");
          }
          __keccak256 = func;
        };
        Object.freeze(keccak256);
        const Rho = new Uint8Array([
          7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
        ]);
        const Id = Uint8Array.from({ length: 16 }, (_, i) => i);
        const Pi = Id.map((i) => (9 * i + 5) % 16);
        let idxL = [Id];
        let idxR = [Pi];
        for (let i = 0; i < 4; i++)
          for (let j of [idxL, idxR]) j.push(j[i].map((k) => Rho[k]));
        const shifts = [
          [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
          [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
          [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
          [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
          [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
        ].map((i) => new Uint8Array(i));
        const shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
        const shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
        const Kl = new Uint32Array([
          0, 1518500249, 1859775393, 2400959708, 2840853838,
        ]);
        const Kr = new Uint32Array([
          1352829926, 1548603684, 1836072691, 2053994217, 0,
        ]);
        const rotl$1 = (word, shift) =>
          (word << shift) | (word >>> (32 - shift));
        function f(group, x, y, z) {
          if (group === 0) return x ^ y ^ z;
          else if (group === 1) return (x & y) | (~x & z);
          else if (group === 2) return (x | ~y) ^ z;
          else if (group === 3) return (x & z) | (y & ~z);
          else return x ^ (y | ~z);
        }
        const BUF = new Uint32Array(16);
        class RIPEMD160 extends SHA2 {
          constructor() {
            super(64, 20, 8, true);
            this.h0 = 1732584193 | 0;
            this.h1 = 4023233417 | 0;
            this.h2 = 2562383102 | 0;
            this.h3 = 271733878 | 0;
            this.h4 = 3285377520 | 0;
          }
          get() {
            const { h0, h1, h2, h3, h4 } = this;
            return [h0, h1, h2, h3, h4];
          }
          set(h0, h1, h2, h3, h4) {
            this.h0 = h0 | 0;
            this.h1 = h1 | 0;
            this.h2 = h2 | 0;
            this.h3 = h3 | 0;
            this.h4 = h4 | 0;
          }
          process(view, offset) {
            for (let i = 0; i < 16; i++, offset += 4)
              BUF[i] = view.getUint32(offset, true);
            let al = this.h0 | 0,
              ar = al,
              bl = this.h1 | 0,
              br = bl,
              cl = this.h2 | 0,
              cr = cl,
              dl = this.h3 | 0,
              dr = dl,
              el = this.h4 | 0,
              er = el;
            for (let group = 0; group < 5; group++) {
              const rGroup = 4 - group;
              const hbl = Kl[group],
                hbr = Kr[group];
              const rl = idxL[group],
                rr = idxR[group];
              const sl = shiftsL[group],
                sr = shiftsR[group];
              for (let i = 0; i < 16; i++) {
                const tl =
                  (rotl$1(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) +
                    el) |
                  0;
                (al = el),
                  (el = dl),
                  (dl = rotl$1(cl, 10) | 0),
                  (cl = bl),
                  (bl = tl);
              }
              for (let i = 0; i < 16; i++) {
                const tr =
                  (rotl$1(
                    ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr,
                    sr[i]
                  ) +
                    er) |
                  0;
                (ar = er),
                  (er = dr),
                  (dr = rotl$1(cr, 10) | 0),
                  (cr = br),
                  (br = tr);
              }
            }
            this.set(
              (this.h1 + cl + dr) | 0,
              (this.h2 + dl + er) | 0,
              (this.h3 + el + ar) | 0,
              (this.h4 + al + br) | 0,
              (this.h0 + bl + cr) | 0
            );
          }
          roundClean() {
            BUF.fill(0);
          }
          destroy() {
            this.destroyed = true;
            this.buffer.fill(0);
            this.set(0, 0, 0, 0, 0);
          }
        }
        const ripemd160$1 = wrapConstructor(() => new RIPEMD160());
        let locked$2 = false;
        const _ripemd160 = function (data) {
          return ripemd160$1(data);
        };
        let __ripemd160 = _ripemd160;
        function ripemd160(_data) {
          const data = getBytes(_data, "data");
          return hexlify(__ripemd160(data));
        }
        ripemd160._ = _ripemd160;
        ripemd160.lock = function () {
          locked$2 = true;
        };
        ripemd160.register = function (func) {
          if (locked$2) {
            throw new TypeError("ripemd160 is locked");
          }
          __ripemd160 = func;
        };
        Object.freeze(ripemd160);
        let locked$1 = false;
        const _pbkdf2 = function (password, salt, iterations, keylen, algo) {
          return pbkdf2Sync(password, salt, iterations, keylen, algo);
        };
        let __pbkdf2 = _pbkdf2;
        function pbkdf2(_password, _salt, iterations, keylen, algo) {
          const password = getBytes(_password, "password");
          const salt = getBytes(_salt, "salt");
          return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
        }
        pbkdf2._ = _pbkdf2;
        pbkdf2.lock = function () {
          locked$1 = true;
        };
        pbkdf2.register = function (func) {
          if (locked$1) {
            throw new Error("pbkdf2 is locked");
          }
          __pbkdf2 = func;
        };
        Object.freeze(pbkdf2);
        let locked = false;
        const _randomBytes = function (length) {
          return new Uint8Array(randomBytes$1(length));
        };
        let __randomBytes = _randomBytes;
        function randomBytes(length) {
          return __randomBytes(length);
        }
        randomBytes._ = _randomBytes;
        randomBytes.lock = function () {
          locked = true;
        };
        randomBytes.register = function (func) {
          if (locked) {
            throw new Error("randomBytes is locked");
          }
          __randomBytes = func;
        };
        Object.freeze(randomBytes);
        const rotl = (a, b) => (a << b) | (a >>> (32 - b));
        function XorAndSalsa(prev, pi, input, ii, out, oi) {
          let y00 = prev[pi++] ^ input[ii++],
            y01 = prev[pi++] ^ input[ii++];
          let y02 = prev[pi++] ^ input[ii++],
            y03 = prev[pi++] ^ input[ii++];
          let y04 = prev[pi++] ^ input[ii++],
            y05 = prev[pi++] ^ input[ii++];
          let y06 = prev[pi++] ^ input[ii++],
            y07 = prev[pi++] ^ input[ii++];
          let y08 = prev[pi++] ^ input[ii++],
            y09 = prev[pi++] ^ input[ii++];
          let y10 = prev[pi++] ^ input[ii++],
            y11 = prev[pi++] ^ input[ii++];
          let y12 = prev[pi++] ^ input[ii++],
            y13 = prev[pi++] ^ input[ii++];
          let y14 = prev[pi++] ^ input[ii++],
            y15 = prev[pi++] ^ input[ii++];
          let x00 = y00,
            x01 = y01,
            x02 = y02,
            x03 = y03,
            x04 = y04,
            x05 = y05,
            x06 = y06,
            x07 = y07,
            x08 = y08,
            x09 = y09,
            x10 = y10,
            x11 = y11,
            x12 = y12,
            x13 = y13,
            x14 = y14,
            x15 = y15;
          for (let i = 0; i < 8; i += 2) {
            x04 ^= rotl((x00 + x12) | 0, 7);
            x08 ^= rotl((x04 + x00) | 0, 9);
            x12 ^= rotl((x08 + x04) | 0, 13);
            x00 ^= rotl((x12 + x08) | 0, 18);
            x09 ^= rotl((x05 + x01) | 0, 7);
            x13 ^= rotl((x09 + x05) | 0, 9);
            x01 ^= rotl((x13 + x09) | 0, 13);
            x05 ^= rotl((x01 + x13) | 0, 18);
            x14 ^= rotl((x10 + x06) | 0, 7);
            x02 ^= rotl((x14 + x10) | 0, 9);
            x06 ^= rotl((x02 + x14) | 0, 13);
            x10 ^= rotl((x06 + x02) | 0, 18);
            x03 ^= rotl((x15 + x11) | 0, 7);
            x07 ^= rotl((x03 + x15) | 0, 9);
            x11 ^= rotl((x07 + x03) | 0, 13);
            x15 ^= rotl((x11 + x07) | 0, 18);
            x01 ^= rotl((x00 + x03) | 0, 7);
            x02 ^= rotl((x01 + x00) | 0, 9);
            x03 ^= rotl((x02 + x01) | 0, 13);
            x00 ^= rotl((x03 + x02) | 0, 18);
            x06 ^= rotl((x05 + x04) | 0, 7);
            x07 ^= rotl((x06 + x05) | 0, 9);
            x04 ^= rotl((x07 + x06) | 0, 13);
            x05 ^= rotl((x04 + x07) | 0, 18);
            x11 ^= rotl((x10 + x09) | 0, 7);
            x08 ^= rotl((x11 + x10) | 0, 9);
            x09 ^= rotl((x08 + x11) | 0, 13);
            x10 ^= rotl((x09 + x08) | 0, 18);
            x12 ^= rotl((x15 + x14) | 0, 7);
            x13 ^= rotl((x12 + x15) | 0, 9);
            x14 ^= rotl((x13 + x12) | 0, 13);
            x15 ^= rotl((x14 + x13) | 0, 18);
          }
          out[oi++] = (y00 + x00) | 0;
          out[oi++] = (y01 + x01) | 0;
          out[oi++] = (y02 + x02) | 0;
          out[oi++] = (y03 + x03) | 0;
          out[oi++] = (y04 + x04) | 0;
          out[oi++] = (y05 + x05) | 0;
          out[oi++] = (y06 + x06) | 0;
          out[oi++] = (y07 + x07) | 0;
          out[oi++] = (y08 + x08) | 0;
          out[oi++] = (y09 + x09) | 0;
          out[oi++] = (y10 + x10) | 0;
          out[oi++] = (y11 + x11) | 0;
          out[oi++] = (y12 + x12) | 0;
          out[oi++] = (y13 + x13) | 0;
          out[oi++] = (y14 + x14) | 0;
          out[oi++] = (y15 + x15) | 0;
        }
        function BlockMix(input, ii, out, oi, r) {
          let head = oi + 0;
          let tail = oi + 16 * r;
          for (let i = 0; i < 16; i++)
            out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
          for (let i = 0; i < r; i++, head += 16, ii += 16) {
            XorAndSalsa(out, tail, input, ii, out, head);
            if (i > 0) tail += 16;
            XorAndSalsa(out, head, input, (ii += 16), out, tail);
          }
        }
        function scryptInit(password, salt, _opts) {
          const opts = checkOpts(
            { dkLen: 32, asyncTick: 10, maxmem: 1024 ** 3 + 1024 },
            _opts
          );
          const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
          number(N);
          number(r);
          number(p);
          number(dkLen);
          number(asyncTick);
          number(maxmem);
          if (onProgress !== undefined && typeof onProgress !== "function")
            throw new Error("progressCb should be function");
          const blockSize = 128 * r;
          const blockSize32 = blockSize / 4;
          if (
            N <= 1 ||
            (N & (N - 1)) !== 0 ||
            N >= 2 ** (blockSize / 8) ||
            N > 2 ** 32
          ) {
            throw new Error(
              "Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32"
            );
          }
          if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {
            throw new Error(
              "Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)"
            );
          }
          if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
            throw new Error(
              "Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32"
            );
          }
          const memUsed = blockSize * (N + p);
          if (memUsed > maxmem) {
            throw new Error(
              `Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`
            );
          }
          const B = pbkdf2$1(sha256$1, password, salt, {
            c: 1,
            dkLen: blockSize * p,
          });
          const B32 = u32(B);
          const V = u32(new Uint8Array(blockSize * N));
          const tmp = u32(new Uint8Array(blockSize));
          let blockMixCb = () => {};
          if (onProgress) {
            const totalBlockMix = 2 * N * p;
            const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
            let blockMixCnt = 0;
            blockMixCb = () => {
              blockMixCnt++;
              if (
                onProgress &&
                (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix)
              )
                onProgress(blockMixCnt / totalBlockMix);
            };
          }
          return {
            N: N,
            r: r,
            p: p,
            dkLen: dkLen,
            blockSize32: blockSize32,
            V: V,
            B32: B32,
            B: B,
            tmp: tmp,
            blockMixCb: blockMixCb,
            asyncTick: asyncTick,
          };
        }
        function scryptOutput(password, dkLen, B, V, tmp) {
          const res = pbkdf2$1(sha256$1, password, B, { c: 1, dkLen: dkLen });
          B.fill(0);
          V.fill(0);
          tmp.fill(0);
          return res;
        }
        function scrypt$1(password, salt, opts) {
          const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } =
            scryptInit(password, salt, opts);
          for (let pi = 0; pi < p; pi++) {
            const Pi = blockSize32 * pi;
            for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i];
            for (let i = 0, pos = 0; i < N - 1; i++) {
              BlockMix(V, pos, V, (pos += blockSize32), r);
              blockMixCb();
            }
            BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
            blockMixCb();
            for (let i = 0; i < N; i++) {
              const j = B32[Pi + blockSize32 - 16] % N;
              for (let k = 0; k < blockSize32; k++)
                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
              BlockMix(tmp, 0, B32, Pi, r);
              blockMixCb();
            }
          }
          return scryptOutput(password, dkLen, B, V, tmp);
        }
        async function scryptAsync(password, salt, opts) {
          const {
            N,
            r,
            p,
            dkLen,
            blockSize32,
            V,
            B32,
            B,
            tmp,
            blockMixCb,
            asyncTick,
          } = scryptInit(password, salt, opts);
          for (let pi = 0; pi < p; pi++) {
            const Pi = blockSize32 * pi;
            for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i];
            let pos = 0;
            await asyncLoop(N - 1, asyncTick, () => {
              BlockMix(V, pos, V, (pos += blockSize32), r);
              blockMixCb();
            });
            BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
            blockMixCb();
            await asyncLoop(N, asyncTick, () => {
              const j = B32[Pi + blockSize32 - 16] % N;
              for (let k = 0; k < blockSize32; k++)
                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
              BlockMix(tmp, 0, B32, Pi, r);
              blockMixCb();
            });
          }
          return scryptOutput(password, dkLen, B, V, tmp);
        }
        let lockedSync = false,
          lockedAsync = false;
        const _scryptAsync = async function (
          passwd,
          salt,
          N,
          r,
          p,
          dkLen,
          onProgress
        ) {
          return await scryptAsync(passwd, salt, {
            N: N,
            r: r,
            p: p,
            dkLen: dkLen,
            onProgress: onProgress,
          });
        };
        const _scryptSync = function (passwd, salt, N, r, p, dkLen) {
          return scrypt$1(passwd, salt, { N: N, r: r, p: p, dkLen: dkLen });
        };
        let __scryptAsync = _scryptAsync;
        let __scryptSync = _scryptSync;
        async function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {
          const passwd = getBytes(_passwd, "passwd");
          const salt = getBytes(_salt, "salt");
          return hexlify(
            await __scryptAsync(passwd, salt, N, r, p, dkLen, progress)
          );
        }
        scrypt._ = _scryptAsync;
        scrypt.lock = function () {
          lockedAsync = true;
        };
        scrypt.register = function (func) {
          if (lockedAsync) {
            throw new Error("scrypt is locked");
          }
          __scryptAsync = func;
        };
        Object.freeze(scrypt);
        function scryptSync(_passwd, _salt, N, r, p, dkLen) {
          const passwd = getBytes(_passwd, "passwd");
          const salt = getBytes(_salt, "salt");
          return hexlify(__scryptSync(passwd, salt, N, r, p, dkLen));
        }
        scryptSync._ = _scryptSync;
        scryptSync.lock = function () {
          lockedSync = true;
        };
        scryptSync.register = function (func) {
          if (lockedSync) {
            throw new Error("scryptSync is locked");
          }
          __scryptSync = func;
        };
        Object.freeze(scryptSync);
        const _sha256 = function (data) {
          return createHash("sha256").update(data).digest();
        };
        const _sha512 = function (data) {
          return createHash("sha512").update(data).digest();
        };
        let __sha256 = _sha256;
        let __sha512 = _sha512;
        let locked256 = false,
          locked512 = false;
        function sha256(_data) {
          const data = getBytes(_data, "data");
          return hexlify(__sha256(data));
        }
        sha256._ = _sha256;
        sha256.lock = function () {
          locked256 = true;
        };
        sha256.register = function (func) {
          if (locked256) {
            throw new Error("sha256 is locked");
          }
          __sha256 = func;
        };
        Object.freeze(sha256);
        function sha512(_data) {
          const data = getBytes(_data, "data");
          return hexlify(__sha512(data));
        }
        sha512._ = _sha512;
        sha512.lock = function () {
          locked512 = true;
        };
        sha512.register = function (func) {
          if (locked512) {
            throw new Error("sha512 is locked");
          }
          __sha512 = func;
        };
        Object.freeze(sha256);
        const _0n$3 = BigInt(0);
        const _1n$4 = BigInt(1);
        const _2n$2 = BigInt(2);
        const u8a = (a) => a instanceof Uint8Array;
        const hexes = Array.from({ length: 256 }, (_, i) =>
          i.toString(16).padStart(2, "0")
        );
        function bytesToHex(bytes) {
          if (!u8a(bytes)) throw new Error("Uint8Array expected");
          let hex = "";
          for (let i = 0; i < bytes.length; i++) {
            hex += hexes[bytes[i]];
          }
          return hex;
        }
        function numberToHexUnpadded(num) {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        }
        function hexToNumber(hex) {
          if (typeof hex !== "string")
            throw new Error("hex string expected, got " + typeof hex);
          return BigInt(hex === "" ? "0" : `0x${hex}`);
        }
        function hexToBytes(hex) {
          if (typeof hex !== "string")
            throw new Error("hex string expected, got " + typeof hex);
          const len = hex.length;
          if (len % 2)
            throw new Error(
              "padded hex string expected, got unpadded hex of length " + len
            );
          const array = new Uint8Array(len / 2);
          for (let i = 0; i < array.length; i++) {
            const j = i * 2;
            const hexByte = hex.slice(j, j + 2);
            const byte = Number.parseInt(hexByte, 16);
            if (Number.isNaN(byte) || byte < 0)
              throw new Error("Invalid byte sequence");
            array[i] = byte;
          }
          return array;
        }
        function bytesToNumberBE(bytes) {
          return hexToNumber(bytesToHex(bytes));
        }
        function bytesToNumberLE(bytes) {
          if (!u8a(bytes)) throw new Error("Uint8Array expected");
          return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
        }
        function numberToBytesBE(n, len) {
          return hexToBytes(n.toString(16).padStart(len * 2, "0"));
        }
        function numberToBytesLE(n, len) {
          return numberToBytesBE(n, len).reverse();
        }
        function numberToVarBytesBE(n) {
          return hexToBytes(numberToHexUnpadded(n));
        }
        function ensureBytes(title, hex, expectedLength) {
          let res;
          if (typeof hex === "string") {
            try {
              res = hexToBytes(hex);
            } catch (e) {
              throw new Error(
                `${title} must be valid hex string, got "${hex}". Cause: ${e}`
              );
            }
          } else if (u8a(hex)) {
            res = Uint8Array.from(hex);
          } else {
            throw new Error(`${title} must be hex string or Uint8Array`);
          }
          const len = res.length;
          if (typeof expectedLength === "number" && len !== expectedLength)
            throw new Error(
              `${title} expected ${expectedLength} bytes, got ${len}`
            );
          return res;
        }
        function concatBytes(...arrays) {
          const r = new Uint8Array(
            arrays.reduce((sum, a) => sum + a.length, 0)
          );
          let pad = 0;
          arrays.forEach((a) => {
            if (!u8a(a)) throw new Error("Uint8Array expected");
            r.set(a, pad);
            pad += a.length;
          });
          return r;
        }
        function equalBytes(b1, b2) {
          if (b1.length !== b2.length) return false;
          for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;
          return true;
        }
        function utf8ToBytes(str) {
          if (typeof str !== "string")
            throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
          return new Uint8Array(new TextEncoder().encode(str));
        }
        function bitLen(n) {
          let len;
          for (len = 0; n > _0n$3; n >>= _1n$4, len += 1);
          return len;
        }
        function bitGet(n, pos) {
          return (n >> BigInt(pos)) & _1n$4;
        }
        const bitSet = (n, pos, value) => {
          return n | ((value ? _1n$4 : _0n$3) << BigInt(pos));
        };
        const bitMask = (n) => (_2n$2 << BigInt(n - 1)) - _1n$4;
        const u8n = (data) => new Uint8Array(data);
        const u8fr = (arr) => Uint8Array.from(arr);
        function createHmacDrbg(hashLen, qByteLen, hmacFn) {
          if (typeof hashLen !== "number" || hashLen < 2)
            throw new Error("hashLen must be a number");
          if (typeof qByteLen !== "number" || qByteLen < 2)
            throw new Error("qByteLen must be a number");
          if (typeof hmacFn !== "function")
            throw new Error("hmacFn must be a function");
          let v = u8n(hashLen);
          let k = u8n(hashLen);
          let i = 0;
          const reset = () => {
            v.fill(1);
            k.fill(0);
            i = 0;
          };
          const h = (...b) => hmacFn(k, v, ...b);
          const reseed = (seed = u8n()) => {
            k = h(u8fr([0]), seed);
            v = h();
            if (seed.length === 0) return;
            k = h(u8fr([1]), seed);
            v = h();
          };
          const gen = () => {
            if (i++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let len = 0;
            const out = [];
            while (len < qByteLen) {
              v = h();
              const sl = v.slice();
              out.push(sl);
              len += v.length;
            }
            return concatBytes(...out);
          };
          const genUntil = (seed, pred) => {
            reset();
            reseed(seed);
            let res = undefined;
            while (!(res = pred(gen()))) reseed();
            reset();
            return res;
          };
          return genUntil;
        }
        const validatorFns = {
          bigint: (val) => typeof val === "bigint",
          function: (val) => typeof val === "function",
          boolean: (val) => typeof val === "boolean",
          string: (val) => typeof val === "string",
          stringOrUint8Array: (val) =>
            typeof val === "string" || val instanceof Uint8Array,
          isSafeInteger: (val) => Number.isSafeInteger(val),
          array: (val) => Array.isArray(val),
          field: (val, object) => object.Fp.isValid(val),
          hash: (val) =>
            typeof val === "function" && Number.isSafeInteger(val.outputLen),
        };
        function validateObject(object, validators, optValidators = {}) {
          const checkField = (fieldName, type, isOptional) => {
            const checkVal = validatorFns[type];
            if (typeof checkVal !== "function")
              throw new Error(`Invalid validator "${type}", expected function`);
            const val = object[fieldName];
            if (isOptional && val === undefined) return;
            if (!checkVal(val, object)) {
              throw new Error(
                `Invalid param ${String(
                  fieldName
                )}=${val} (${typeof val}), expected ${type}`
              );
            }
          };
          for (const [fieldName, type] of Object.entries(validators))
            checkField(fieldName, type, false);
          for (const [fieldName, type] of Object.entries(optValidators))
            checkField(fieldName, type, true);
          return object;
        }
        var ut = Object.freeze({
          __proto__: null,
          bitGet: bitGet,
          bitLen: bitLen,
          bitMask: bitMask,
          bitSet: bitSet,
          bytesToHex: bytesToHex,
          bytesToNumberBE: bytesToNumberBE,
          bytesToNumberLE: bytesToNumberLE,
          concatBytes: concatBytes,
          createHmacDrbg: createHmacDrbg,
          ensureBytes: ensureBytes,
          equalBytes: equalBytes,
          hexToBytes: hexToBytes,
          hexToNumber: hexToNumber,
          numberToBytesBE: numberToBytesBE,
          numberToBytesLE: numberToBytesLE,
          numberToHexUnpadded: numberToHexUnpadded,
          numberToVarBytesBE: numberToVarBytesBE,
          utf8ToBytes: utf8ToBytes,
          validateObject: validateObject,
        });
        const _0n$2 = BigInt(0),
          _1n$3 = BigInt(1),
          _2n$1 = BigInt(2),
          _3n$1 = BigInt(3);
        const _4n = BigInt(4),
          _5n = BigInt(5),
          _8n = BigInt(8);
        BigInt(9);
        BigInt(16);
        function mod(a, b) {
          const result = a % b;
          return result >= _0n$2 ? result : b + result;
        }
        function pow(num, power, modulo) {
          if (modulo <= _0n$2 || power < _0n$2)
            throw new Error("Expected power/modulo > 0");
          if (modulo === _1n$3) return _0n$2;
          let res = _1n$3;
          while (power > _0n$2) {
            if (power & _1n$3) res = (res * num) % modulo;
            num = (num * num) % modulo;
            power >>= _1n$3;
          }
          return res;
        }
        function pow2(x, power, modulo) {
          let res = x;
          while (power-- > _0n$2) {
            res *= res;
            res %= modulo;
          }
          return res;
        }
        function invert(number, modulo) {
          if (number === _0n$2 || modulo <= _0n$2) {
            throw new Error(
              `invert: expected positive integers, got n=${number} mod=${modulo}`
            );
          }
          let a = mod(number, modulo);
          let b = modulo;
          let x = _0n$2,
            u = _1n$3;
          while (a !== _0n$2) {
            const q = b / a;
            const r = b % a;
            const m = x - u * q;
            (b = a), (a = r), (x = u), (u = m);
          }
          const gcd = b;
          if (gcd !== _1n$3) throw new Error("invert: does not exist");
          return mod(x, modulo);
        }
        function tonelliShanks(P) {
          const legendreC = (P - _1n$3) / _2n$1;
          let Q, S, Z;
          for (Q = P - _1n$3, S = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S++);
          for (Z = _2n$1; Z < P && pow(Z, legendreC, P) !== P - _1n$3; Z++);
          if (S === 1) {
            const p1div4 = (P + _1n$3) / _4n;
            return function tonelliFast(Fp, n) {
              const root = Fp.pow(n, p1div4);
              if (!Fp.eql(Fp.sqr(root), n))
                throw new Error("Cannot find square root");
              return root;
            };
          }
          const Q1div2 = (Q + _1n$3) / _2n$1;
          return function tonelliSlow(Fp, n) {
            if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
              throw new Error("Cannot find square root");
            let r = S;
            let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
            let x = Fp.pow(n, Q1div2);
            let b = Fp.pow(n, Q);
            while (!Fp.eql(b, Fp.ONE)) {
              if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO;
              let m = 1;
              for (let t2 = Fp.sqr(b); m < r; m++) {
                if (Fp.eql(t2, Fp.ONE)) break;
                t2 = Fp.sqr(t2);
              }
              const ge = Fp.pow(g, _1n$3 << BigInt(r - m - 1));
              g = Fp.sqr(ge);
              x = Fp.mul(x, ge);
              b = Fp.mul(b, g);
              r = m;
            }
            return x;
          };
        }
        function FpSqrt(P) {
          if (P % _4n === _3n$1) {
            const p1div4 = (P + _1n$3) / _4n;
            return function sqrt3mod4(Fp, n) {
              const root = Fp.pow(n, p1div4);
              if (!Fp.eql(Fp.sqr(root), n))
                throw new Error("Cannot find square root");
              return root;
            };
          }
          if (P % _8n === _5n) {
            const c1 = (P - _5n) / _8n;
            return function sqrt5mod8(Fp, n) {
              const n2 = Fp.mul(n, _2n$1);
              const v = Fp.pow(n2, c1);
              const nv = Fp.mul(n, v);
              const i = Fp.mul(Fp.mul(nv, _2n$1), v);
              const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
              if (!Fp.eql(Fp.sqr(root), n))
                throw new Error("Cannot find square root");
              return root;
            };
          }
          return tonelliShanks(P);
        }
        const FIELD_FIELDS = [
          "create",
          "isValid",
          "is0",
          "neg",
          "inv",
          "sqrt",
          "sqr",
          "eql",
          "add",
          "sub",
          "mul",
          "pow",
          "div",
          "addN",
          "subN",
          "mulN",
          "sqrN",
        ];
        function validateField(field) {
          const initial = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger",
          };
          const opts = FIELD_FIELDS.reduce((map, val) => {
            map[val] = "function";
            return map;
          }, initial);
          return validateObject(field, opts);
        }
        function FpPow(f, num, power) {
          if (power < _0n$2) throw new Error("Expected power > 0");
          if (power === _0n$2) return f.ONE;
          if (power === _1n$3) return num;
          let p = f.ONE;
          let d = num;
          while (power > _0n$2) {
            if (power & _1n$3) p = f.mul(p, d);
            d = f.sqr(d);
            power >>= _1n$3;
          }
          return p;
        }
        function FpInvertBatch(f, nums) {
          const tmp = new Array(nums.length);
          const lastMultiplied = nums.reduce((acc, num, i) => {
            if (f.is0(num)) return acc;
            tmp[i] = acc;
            return f.mul(acc, num);
          }, f.ONE);
          const inverted = f.inv(lastMultiplied);
          nums.reduceRight((acc, num, i) => {
            if (f.is0(num)) return acc;
            tmp[i] = f.mul(acc, tmp[i]);
            return f.mul(acc, num);
          }, inverted);
          return tmp;
        }
        function nLength(n, nBitLength) {
          const _nBitLength =
            nBitLength !== undefined ? nBitLength : n.toString(2).length;
          const nByteLength = Math.ceil(_nBitLength / 8);
          return { nBitLength: _nBitLength, nByteLength: nByteLength };
        }
        function Field(ORDER, bitLen, isLE = false, redef = {}) {
          if (ORDER <= _0n$2)
            throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
          const { nBitLength: BITS, nByteLength: BYTES } = nLength(
            ORDER,
            bitLen
          );
          if (BYTES > 2048)
            throw new Error("Field lengths over 2048 bytes are not supported");
          const sqrtP = FpSqrt(ORDER);
          const f = Object.freeze({
            ORDER: ORDER,
            BITS: BITS,
            BYTES: BYTES,
            MASK: bitMask(BITS),
            ZERO: _0n$2,
            ONE: _1n$3,
            create: (num) => mod(num, ORDER),
            isValid: (num) => {
              if (typeof num !== "bigint")
                throw new Error(
                  `Invalid field element: expected bigint, got ${typeof num}`
                );
              return _0n$2 <= num && num < ORDER;
            },
            is0: (num) => num === _0n$2,
            isOdd: (num) => (num & _1n$3) === _1n$3,
            neg: (num) => mod(-num, ORDER),
            eql: (lhs, rhs) => lhs === rhs,
            sqr: (num) => mod(num * num, ORDER),
            add: (lhs, rhs) => mod(lhs + rhs, ORDER),
            sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
            mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
            pow: (num, power) => FpPow(f, num, power),
            div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
            sqrN: (num) => num * num,
            addN: (lhs, rhs) => lhs + rhs,
            subN: (lhs, rhs) => lhs - rhs,
            mulN: (lhs, rhs) => lhs * rhs,
            inv: (num) => invert(num, ORDER),
            sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
            invertBatch: (lst) => FpInvertBatch(f, lst),
            cmov: (a, b, c) => (c ? b : a),
            toBytes: (num) =>
              isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
            fromBytes: (bytes) => {
              if (bytes.length !== BYTES)
                throw new Error(
                  `Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`
                );
              return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
            },
          });
          return Object.freeze(f);
        }
        function getFieldBytesLength(fieldOrder) {
          if (typeof fieldOrder !== "bigint")
            throw new Error("field order must be bigint");
          const bitLength = fieldOrder.toString(2).length;
          return Math.ceil(bitLength / 8);
        }
        function getMinHashLength(fieldOrder) {
          const length = getFieldBytesLength(fieldOrder);
          return length + Math.ceil(length / 2);
        }
        function mapHashToField(key, fieldOrder, isLE = false) {
          const len = key.length;
          const fieldLen = getFieldBytesLength(fieldOrder);
          const minLen = getMinHashLength(fieldOrder);
          if (len < 16 || len < minLen || len > 1024)
            throw new Error(
              `expected ${minLen}-1024 bytes of input, got ${len}`
            );
          const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);
          const reduced = mod(num, fieldOrder - _1n$3) + _1n$3;
          return isLE
            ? numberToBytesLE(reduced, fieldLen)
            : numberToBytesBE(reduced, fieldLen);
        }
        const _0n$1 = BigInt(0);
        const _1n$2 = BigInt(1);
        function wNAF(c, bits) {
          const constTimeNegate = (condition, item) => {
            const neg = item.negate();
            return condition ? neg : item;
          };
          const opts = (W) => {
            const windows = Math.ceil(bits / W) + 1;
            const windowSize = 2 ** (W - 1);
            return { windows: windows, windowSize: windowSize };
          };
          return {
            constTimeNegate: constTimeNegate,
            unsafeLadder(elm, n) {
              let p = c.ZERO;
              let d = elm;
              while (n > _0n$1) {
                if (n & _1n$2) p = p.add(d);
                d = d.double();
                n >>= _1n$2;
              }
              return p;
            },
            precomputeWindow(elm, W) {
              const { windows, windowSize } = opts(W);
              const points = [];
              let p = elm;
              let base = p;
              for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                for (let i = 1; i < windowSize; i++) {
                  base = base.add(p);
                  points.push(base);
                }
                p = base.double();
              }
              return points;
            },
            wNAF(W, precomputes, n) {
              const { windows, windowSize } = opts(W);
              let p = c.ZERO;
              let f = c.BASE;
              const mask = BigInt(2 ** W - 1);
              const maxNumber = 2 ** W;
              const shiftBy = BigInt(W);
              for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                let wbits = Number(n & mask);
                n >>= shiftBy;
                if (wbits > windowSize) {
                  wbits -= maxNumber;
                  n += _1n$2;
                }
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1;
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) {
                  f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                } else {
                  p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
              }
              return { p: p, f: f };
            },
            wNAFCached(P, precomputesMap, n, transform) {
              const W = P._WINDOW_SIZE || 1;
              let comp = precomputesMap.get(P);
              if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                  precomputesMap.set(P, transform(comp));
                }
              }
              return this.wNAF(W, comp, n);
            },
          };
        }
        function validateBasic(curve) {
          validateField(curve.Fp);
          validateObject(
            curve,
            { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
            { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
          );
          return Object.freeze({
            ...nLength(curve.n, curve.nBitLength),
            ...curve,
            ...{ p: curve.Fp.ORDER },
          });
        }
        function validatePointOpts(curve) {
          const opts = validateBasic(curve);
          validateObject(
            opts,
            { a: "field", b: "field" },
            {
              allowedPrivateKeyLengths: "array",
              wrapPrivateKey: "boolean",
              isTorsionFree: "function",
              clearCofactor: "function",
              allowInfinityPoint: "boolean",
              fromBytes: "function",
              toBytes: "function",
            }
          );
          const { endo, Fp, a } = opts;
          if (endo) {
            if (!Fp.eql(a, Fp.ZERO)) {
              throw new Error(
                "Endomorphism can only be defined for Koblitz curves that have a=0"
              );
            }
            if (
              typeof endo !== "object" ||
              typeof endo.beta !== "bigint" ||
              typeof endo.splitScalar !== "function"
            ) {
              throw new Error(
                "Expected endomorphism with beta: bigint and splitScalar: function"
              );
            }
          }
          return Object.freeze({ ...opts });
        }
        const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
        const DER = {
          Err: class DERErr extends Error {
            constructor(m = "") {
              super(m);
            }
          },
          _parseInt(data) {
            const { Err: E } = DER;
            if (data.length < 2 || data[0] !== 2)
              throw new E("Invalid signature integer tag");
            const len = data[1];
            const res = data.subarray(2, len + 2);
            if (!len || res.length !== len)
              throw new E("Invalid signature integer: wrong length");
            if (res[0] & 128)
              throw new E("Invalid signature integer: negative");
            if (res[0] === 0 && !(res[1] & 128))
              throw new E(
                "Invalid signature integer: unnecessary leading zero"
              );
            return { d: b2n(res), l: data.subarray(len + 2) };
          },
          toSig(hex) {
            const { Err: E } = DER;
            const data = typeof hex === "string" ? h2b(hex) : hex;
            if (!(data instanceof Uint8Array)) throw new Error("ui8a expected");
            let l = data.length;
            if (l < 2 || data[0] != 48) throw new E("Invalid signature tag");
            if (data[1] !== l - 2)
              throw new E("Invalid signature: incorrect length");
            const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
            const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
            if (rBytesLeft.length)
              throw new E("Invalid signature: left bytes after parsing");
            return { r: r, s: s };
          },
          hexFromSig(sig) {
            const slice = (s) => (Number.parseInt(s[0], 16) & 8 ? "00" + s : s);
            const h = (num) => {
              const hex = num.toString(16);
              return hex.length & 1 ? `0${hex}` : hex;
            };
            const s = slice(h(sig.s));
            const r = slice(h(sig.r));
            const shl = s.length / 2;
            const rhl = r.length / 2;
            const sl = h(shl);
            const rl = h(rhl);
            return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
          },
        };
        const _0n = BigInt(0),
          _1n$1 = BigInt(1);
        BigInt(2);
        const _3n = BigInt(3);
        BigInt(4);
        function weierstrassPoints(opts) {
          const CURVE = validatePointOpts(opts);
          const { Fp } = CURVE;
          const toBytes =
            CURVE.toBytes ||
            ((_c, point, _isCompressed) => {
              const a = point.toAffine();
              return concatBytes(
                Uint8Array.from([4]),
                Fp.toBytes(a.x),
                Fp.toBytes(a.y)
              );
            });
          const fromBytes =
            CURVE.fromBytes ||
            ((bytes) => {
              const tail = bytes.subarray(1);
              const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
              const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
              return { x: x, y: y };
            });
          function weierstrassEquation(x) {
            const { a, b } = CURVE;
            const x2 = Fp.sqr(x);
            const x3 = Fp.mul(x2, x);
            return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
          }
          if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
            throw new Error("bad generator point: equation left != right");
          function isWithinCurveOrder(num) {
            return typeof num === "bigint" && _0n < num && num < CURVE.n;
          }
          function assertGE(num) {
            if (!isWithinCurveOrder(num))
              throw new Error("Expected valid bigint: 0 < bigint < curve.n");
          }
          function normPrivateKeyToScalar(key) {
            const {
              allowedPrivateKeyLengths: lengths,
              nByteLength,
              wrapPrivateKey,
              n,
            } = CURVE;
            if (lengths && typeof key !== "bigint") {
              if (key instanceof Uint8Array) key = bytesToHex(key);
              if (typeof key !== "string" || !lengths.includes(key.length))
                throw new Error("Invalid key");
              key = key.padStart(nByteLength * 2, "0");
            }
            let num;
            try {
              num =
                typeof key === "bigint"
                  ? key
                  : bytesToNumberBE(
                      ensureBytes("private key", key, nByteLength)
                    );
            } catch (error) {
              throw new Error(
                `private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`
              );
            }
            if (wrapPrivateKey) num = mod(num, n);
            assertGE(num);
            return num;
          }
          const pointPrecomputes = new Map();
          function assertPrjPoint(other) {
            if (!(other instanceof Point))
              throw new Error("ProjectivePoint expected");
          }
          class Point {
            constructor(px, py, pz) {
              this.px = px;
              this.py = py;
              this.pz = pz;
              if (px == null || !Fp.isValid(px)) throw new Error("x required");
              if (py == null || !Fp.isValid(py)) throw new Error("y required");
              if (pz == null || !Fp.isValid(pz)) throw new Error("z required");
            }
            static fromAffine(p) {
              const { x, y } = p || {};
              if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error("invalid affine point");
              if (p instanceof Point)
                throw new Error("projective point not allowed");
              const is0 = (i) => Fp.eql(i, Fp.ZERO);
              if (is0(x) && is0(y)) return Point.ZERO;
              return new Point(x, y, Fp.ONE);
            }
            get x() {
              return this.toAffine().x;
            }
            get y() {
              return this.toAffine().y;
            }
            static normalizeZ(points) {
              const toInv = Fp.invertBatch(points.map((p) => p.pz));
              return points
                .map((p, i) => p.toAffine(toInv[i]))
                .map(Point.fromAffine);
            }
            static fromHex(hex) {
              const P = Point.fromAffine(
                fromBytes(ensureBytes("pointHex", hex))
              );
              P.assertValidity();
              return P;
            }
            static fromPrivateKey(privateKey) {
              return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
            }
            _setWindowSize(windowSize) {
              this._WINDOW_SIZE = windowSize;
              pointPrecomputes.delete(this);
            }
            assertValidity() {
              if (this.is0()) {
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;
                throw new Error("bad point: ZERO");
              }
              const { x, y } = this.toAffine();
              if (!Fp.isValid(x) || !Fp.isValid(y))
                throw new Error("bad point: x or y not FE");
              const left = Fp.sqr(y);
              const right = weierstrassEquation(x);
              if (!Fp.eql(left, right))
                throw new Error("bad point: equation left != right");
              if (!this.isTorsionFree())
                throw new Error("bad point: not in prime-order subgroup");
            }
            hasEvenY() {
              const { y } = this.toAffine();
              if (Fp.isOdd) return !Fp.isOdd(y);
              throw new Error("Field doesn't support isOdd");
            }
            equals(other) {
              assertPrjPoint(other);
              const { px: X1, py: Y1, pz: Z1 } = this;
              const { px: X2, py: Y2, pz: Z2 } = other;
              const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
              const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
              return U1 && U2;
            }
            negate() {
              return new Point(this.px, Fp.neg(this.py), this.pz);
            }
            double() {
              const { a, b } = CURVE;
              const b3 = Fp.mul(b, _3n);
              const { px: X1, py: Y1, pz: Z1 } = this;
              let X3 = Fp.ZERO,
                Y3 = Fp.ZERO,
                Z3 = Fp.ZERO;
              let t0 = Fp.mul(X1, X1);
              let t1 = Fp.mul(Y1, Y1);
              let t2 = Fp.mul(Z1, Z1);
              let t3 = Fp.mul(X1, Y1);
              t3 = Fp.add(t3, t3);
              Z3 = Fp.mul(X1, Z1);
              Z3 = Fp.add(Z3, Z3);
              X3 = Fp.mul(a, Z3);
              Y3 = Fp.mul(b3, t2);
              Y3 = Fp.add(X3, Y3);
              X3 = Fp.sub(t1, Y3);
              Y3 = Fp.add(t1, Y3);
              Y3 = Fp.mul(X3, Y3);
              X3 = Fp.mul(t3, X3);
              Z3 = Fp.mul(b3, Z3);
              t2 = Fp.mul(a, t2);
              t3 = Fp.sub(t0, t2);
              t3 = Fp.mul(a, t3);
              t3 = Fp.add(t3, Z3);
              Z3 = Fp.add(t0, t0);
              t0 = Fp.add(Z3, t0);
              t0 = Fp.add(t0, t2);
              t0 = Fp.mul(t0, t3);
              Y3 = Fp.add(Y3, t0);
              t2 = Fp.mul(Y1, Z1);
              t2 = Fp.add(t2, t2);
              t0 = Fp.mul(t2, t3);
              X3 = Fp.sub(X3, t0);
              Z3 = Fp.mul(t2, t1);
              Z3 = Fp.add(Z3, Z3);
              Z3 = Fp.add(Z3, Z3);
              return new Point(X3, Y3, Z3);
            }
            add(other) {
              assertPrjPoint(other);
              const { px: X1, py: Y1, pz: Z1 } = this;
              const { px: X2, py: Y2, pz: Z2 } = other;
              let X3 = Fp.ZERO,
                Y3 = Fp.ZERO,
                Z3 = Fp.ZERO;
              const a = CURVE.a;
              const b3 = Fp.mul(CURVE.b, _3n);
              let t0 = Fp.mul(X1, X2);
              let t1 = Fp.mul(Y1, Y2);
              let t2 = Fp.mul(Z1, Z2);
              let t3 = Fp.add(X1, Y1);
              let t4 = Fp.add(X2, Y2);
              t3 = Fp.mul(t3, t4);
              t4 = Fp.add(t0, t1);
              t3 = Fp.sub(t3, t4);
              t4 = Fp.add(X1, Z1);
              let t5 = Fp.add(X2, Z2);
              t4 = Fp.mul(t4, t5);
              t5 = Fp.add(t0, t2);
              t4 = Fp.sub(t4, t5);
              t5 = Fp.add(Y1, Z1);
              X3 = Fp.add(Y2, Z2);
              t5 = Fp.mul(t5, X3);
              X3 = Fp.add(t1, t2);
              t5 = Fp.sub(t5, X3);
              Z3 = Fp.mul(a, t4);
              X3 = Fp.mul(b3, t2);
              Z3 = Fp.add(X3, Z3);
              X3 = Fp.sub(t1, Z3);
              Z3 = Fp.add(t1, Z3);
              Y3 = Fp.mul(X3, Z3);
              t1 = Fp.add(t0, t0);
              t1 = Fp.add(t1, t0);
              t2 = Fp.mul(a, t2);
              t4 = Fp.mul(b3, t4);
              t1 = Fp.add(t1, t2);
              t2 = Fp.sub(t0, t2);
              t2 = Fp.mul(a, t2);
              t4 = Fp.add(t4, t2);
              t0 = Fp.mul(t1, t4);
              Y3 = Fp.add(Y3, t0);
              t0 = Fp.mul(t5, t4);
              X3 = Fp.mul(t3, X3);
              X3 = Fp.sub(X3, t0);
              t0 = Fp.mul(t3, t1);
              Z3 = Fp.mul(t5, Z3);
              Z3 = Fp.add(Z3, t0);
              return new Point(X3, Y3, Z3);
            }
            subtract(other) {
              return this.add(other.negate());
            }
            is0() {
              return this.equals(Point.ZERO);
            }
            wNAF(n) {
              return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
                const toInv = Fp.invertBatch(comp.map((p) => p.pz));
                return comp
                  .map((p, i) => p.toAffine(toInv[i]))
                  .map(Point.fromAffine);
              });
            }
            multiplyUnsafe(n) {
              const I = Point.ZERO;
              if (n === _0n) return I;
              assertGE(n);
              if (n === _1n$1) return this;
              const { endo } = CURVE;
              if (!endo) return wnaf.unsafeLadder(this, n);
              let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
              let k1p = I;
              let k2p = I;
              let d = this;
              while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n$1) k1p = k1p.add(d);
                if (k2 & _1n$1) k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n$1;
                k2 >>= _1n$1;
              }
              if (k1neg) k1p = k1p.negate();
              if (k2neg) k2p = k2p.negate();
              k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
              return k1p.add(k2p);
            }
            multiply(scalar) {
              assertGE(scalar);
              let n = scalar;
              let point, fake;
              const { endo } = CURVE;
              if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
              } else {
                const { p, f } = this.wNAF(n);
                point = p;
                fake = f;
              }
              return Point.normalizeZ([point, fake])[0];
            }
            multiplyAndAddUnsafe(Q, a, b) {
              const G = Point.BASE;
              const mul = (P, a) =>
                a === _0n || a === _1n$1 || !P.equals(G)
                  ? P.multiplyUnsafe(a)
                  : P.multiply(a);
              const sum = mul(this, a).add(mul(Q, b));
              return sum.is0() ? undefined : sum;
            }
            toAffine(iz) {
              const { px: x, py: y, pz: z } = this;
              const is0 = this.is0();
              if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);
              const ax = Fp.mul(x, iz);
              const ay = Fp.mul(y, iz);
              const zz = Fp.mul(z, iz);
              if (is0) return { x: Fp.ZERO, y: Fp.ZERO };
              if (!Fp.eql(zz, Fp.ONE)) throw new Error("invZ was invalid");
              return { x: ax, y: ay };
            }
            isTorsionFree() {
              const { h: cofactor, isTorsionFree } = CURVE;
              if (cofactor === _1n$1) return true;
              if (isTorsionFree) return isTorsionFree(Point, this);
              throw new Error(
                "isTorsionFree() has not been declared for the elliptic curve"
              );
            }
            clearCofactor() {
              const { h: cofactor, clearCofactor } = CURVE;
              if (cofactor === _1n$1) return this;
              if (clearCofactor) return clearCofactor(Point, this);
              return this.multiplyUnsafe(CURVE.h);
            }
            toRawBytes(isCompressed = true) {
              this.assertValidity();
              return toBytes(Point, this, isCompressed);
            }
            toHex(isCompressed = true) {
              return bytesToHex(this.toRawBytes(isCompressed));
            }
          }
          Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
          Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
          const _bits = CURVE.nBitLength;
          const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
          return {
            CURVE: CURVE,
            ProjectivePoint: Point,
            normPrivateKeyToScalar: normPrivateKeyToScalar,
            weierstrassEquation: weierstrassEquation,
            isWithinCurveOrder: isWithinCurveOrder,
          };
        }
        function validateOpts(curve) {
          const opts = validateBasic(curve);
          validateObject(
            opts,
            { hash: "hash", hmac: "function", randomBytes: "function" },
            { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }
          );
          return Object.freeze({ lowS: true, ...opts });
        }
        function weierstrass(curveDef) {
          const CURVE = validateOpts(curveDef);
          const { Fp, n: CURVE_ORDER } = CURVE;
          const compressedLen = Fp.BYTES + 1;
          const uncompressedLen = 2 * Fp.BYTES + 1;
          function isValidFieldElement(num) {
            return _0n < num && num < Fp.ORDER;
          }
          function modN(a) {
            return mod(a, CURVE_ORDER);
          }
          function invN(a) {
            return invert(a, CURVE_ORDER);
          }
          const {
            ProjectivePoint: Point,
            normPrivateKeyToScalar,
            weierstrassEquation,
            isWithinCurveOrder,
          } = weierstrassPoints({
            ...CURVE,
            toBytes(_c, point, isCompressed) {
              const a = point.toAffine();
              const x = Fp.toBytes(a.x);
              const cat = concatBytes;
              if (isCompressed) {
                return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
              } else {
                return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
              }
            },
            fromBytes(bytes) {
              const len = bytes.length;
              const head = bytes[0];
              const tail = bytes.subarray(1);
              if (len === compressedLen && (head === 2 || head === 3)) {
                const x = bytesToNumberBE(tail);
                if (!isValidFieldElement(x))
                  throw new Error("Point is not on curve");
                const y2 = weierstrassEquation(x);
                let y = Fp.sqrt(y2);
                const isYOdd = (y & _1n$1) === _1n$1;
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd) y = Fp.neg(y);
                return { x: x, y: y };
              } else if (len === uncompressedLen && head === 4) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x: x, y: y };
              } else {
                throw new Error(
                  `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`
                );
              }
            },
          });
          const numToNByteStr = (num) =>
            bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
          function isBiggerThanHalfOrder(number) {
            const HALF = CURVE_ORDER >> _1n$1;
            return number > HALF;
          }
          function normalizeS(s) {
            return isBiggerThanHalfOrder(s) ? modN(-s) : s;
          }
          const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
          class Signature {
            constructor(r, s, recovery) {
              this.r = r;
              this.s = s;
              this.recovery = recovery;
              this.assertValidity();
            }
            static fromCompact(hex) {
              const l = CURVE.nByteLength;
              hex = ensureBytes("compactSignature", hex, l * 2);
              return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
            }
            static fromDER(hex) {
              const { r, s } = DER.toSig(ensureBytes("DER", hex));
              return new Signature(r, s);
            }
            assertValidity() {
              if (!isWithinCurveOrder(this.r))
                throw new Error("r must be 0 < r < CURVE.n");
              if (!isWithinCurveOrder(this.s))
                throw new Error("s must be 0 < s < CURVE.n");
            }
            addRecoveryBit(recovery) {
              return new Signature(this.r, this.s, recovery);
            }
            recoverPublicKey(msgHash) {
              const { r, s, recovery: rec } = this;
              const h = bits2int_modN(ensureBytes("msgHash", msgHash));
              if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error("recovery id invalid");
              const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
              if (radj >= Fp.ORDER)
                throw new Error("recovery id 2 or 3 invalid");
              const prefix = (rec & 1) === 0 ? "02" : "03";
              const R = Point.fromHex(prefix + numToNByteStr(radj));
              const ir = invN(radj);
              const u1 = modN(-h * ir);
              const u2 = modN(s * ir);
              const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
              if (!Q) throw new Error("point at infinify");
              Q.assertValidity();
              return Q;
            }
            hasHighS() {
              return isBiggerThanHalfOrder(this.s);
            }
            normalizeS() {
              return this.hasHighS()
                ? new Signature(this.r, modN(-this.s), this.recovery)
                : this;
            }
            toDERRawBytes() {
              return hexToBytes(this.toDERHex());
            }
            toDERHex() {
              return DER.hexFromSig({ r: this.r, s: this.s });
            }
            toCompactRawBytes() {
              return hexToBytes(this.toCompactHex());
            }
            toCompactHex() {
              return numToNByteStr(this.r) + numToNByteStr(this.s);
            }
          }
          const utils = {
            isValidPrivateKey(privateKey) {
              try {
                normPrivateKeyToScalar(privateKey);
                return true;
              } catch (error) {
                return false;
              }
            },
            normPrivateKeyToScalar: normPrivateKeyToScalar,
            randomPrivateKey: () => {
              const length = getMinHashLength(CURVE.n);
              return mapHashToField(CURVE.randomBytes(length), CURVE.n);
            },
            precompute(windowSize = 8, point = Point.BASE) {
              point._setWindowSize(windowSize);
              point.multiply(BigInt(3));
              return point;
            },
          };
          function getPublicKey(privateKey, isCompressed = true) {
            return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
          }
          function isProbPub(item) {
            const arr = item instanceof Uint8Array;
            const str = typeof item === "string";
            const len = (arr || str) && item.length;
            if (arr) return len === compressedLen || len === uncompressedLen;
            if (str)
              return len === 2 * compressedLen || len === 2 * uncompressedLen;
            if (item instanceof Point) return true;
            return false;
          }
          function getSharedSecret(privateA, publicB, isCompressed = true) {
            if (isProbPub(privateA))
              throw new Error("first arg must be private key");
            if (!isProbPub(publicB))
              throw new Error("second arg must be public key");
            const b = Point.fromHex(publicB);
            return b
              .multiply(normPrivateKeyToScalar(privateA))
              .toRawBytes(isCompressed);
          }
          const bits2int =
            CURVE.bits2int ||
            function (bytes) {
              const num = bytesToNumberBE(bytes);
              const delta = bytes.length * 8 - CURVE.nBitLength;
              return delta > 0 ? num >> BigInt(delta) : num;
            };
          const bits2int_modN =
            CURVE.bits2int_modN ||
            function (bytes) {
              return modN(bits2int(bytes));
            };
          const ORDER_MASK = bitMask(CURVE.nBitLength);
          function int2octets(num) {
            if (typeof num !== "bigint") throw new Error("bigint expected");
            if (!(_0n <= num && num < ORDER_MASK))
              throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
            return numberToBytesBE(num, CURVE.nByteLength);
          }
          function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
            if (["recovered", "canonical"].some((k) => k in opts))
              throw new Error("sign() legacy options not supported");
            const { hash, randomBytes } = CURVE;
            let { lowS, prehash, extraEntropy: ent } = opts;
            if (lowS == null) lowS = true;
            msgHash = ensureBytes("msgHash", msgHash);
            if (prehash)
              msgHash = ensureBytes("prehashed msgHash", hash(msgHash));
            const h1int = bits2int_modN(msgHash);
            const d = normPrivateKeyToScalar(privateKey);
            const seedArgs = [int2octets(d), int2octets(h1int)];
            if (ent != null) {
              const e = ent === true ? randomBytes(Fp.BYTES) : ent;
              seedArgs.push(ensureBytes("extraEntropy", e));
            }
            const seed = concatBytes(...seedArgs);
            const m = h1int;
            function k2sig(kBytes) {
              const k = bits2int(kBytes);
              if (!isWithinCurveOrder(k)) return;
              const ik = invN(k);
              const q = Point.BASE.multiply(k).toAffine();
              const r = modN(q.x);
              if (r === _0n) return;
              const s = modN(ik * modN(m + r * d));
              if (s === _0n) return;
              let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1);
              let normS = s;
              if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s);
                recovery ^= 1;
              }
              return new Signature(r, normS, recovery);
            }
            return { seed: seed, k2sig: k2sig };
          }
          const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
          const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
          function sign(msgHash, privKey, opts = defaultSigOpts) {
            const { seed, k2sig } = prepSig(msgHash, privKey, opts);
            const C = CURVE;
            const drbg = createHmacDrbg(
              C.hash.outputLen,
              C.nByteLength,
              C.hmac
            );
            return drbg(seed, k2sig);
          }
          Point.BASE._setWindowSize(8);
          function verify(
            signature,
            msgHash,
            publicKey,
            opts = defaultVerOpts
          ) {
            const sg = signature;
            msgHash = ensureBytes("msgHash", msgHash);
            publicKey = ensureBytes("publicKey", publicKey);
            if ("strict" in opts)
              throw new Error("options.strict was renamed to lowS");
            const { lowS, prehash } = opts;
            let _sig = undefined;
            let P;
            try {
              if (typeof sg === "string" || sg instanceof Uint8Array) {
                try {
                  _sig = Signature.fromDER(sg);
                } catch (derError) {
                  if (!(derError instanceof DER.Err)) throw derError;
                  _sig = Signature.fromCompact(sg);
                }
              } else if (
                typeof sg === "object" &&
                typeof sg.r === "bigint" &&
                typeof sg.s === "bigint"
              ) {
                const { r, s } = sg;
                _sig = new Signature(r, s);
              } else {
                throw new Error("PARSE");
              }
              P = Point.fromHex(publicKey);
            } catch (error) {
              if (error.message === "PARSE")
                throw new Error(
                  `signature must be Signature instance, Uint8Array or hex string`
                );
              return false;
            }
            if (lowS && _sig.hasHighS()) return false;
            if (prehash) msgHash = CURVE.hash(msgHash);
            const { r, s } = _sig;
            const h = bits2int_modN(msgHash);
            const is = invN(s);
            const u1 = modN(h * is);
            const u2 = modN(r * is);
            const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
            if (!R) return false;
            const v = modN(R.x);
            return v === r;
          }
          return {
            CURVE: CURVE,
            getPublicKey: getPublicKey,
            getSharedSecret: getSharedSecret,
            sign: sign,
            verify: verify,
            ProjectivePoint: Point,
            Signature: Signature,
            utils: utils,
          };
        }
        function getHash(hash) {
          return {
            hash: hash,
            hmac: (key, ...msgs) => hmac(hash, key, concatBytes$1(...msgs)),
            randomBytes: randomBytes$2,
          };
        }
        function createCurve(curveDef, defHash) {
          const create = (hash) =>
            weierstrass({ ...curveDef, ...getHash(hash) });
          return Object.freeze({ ...create(defHash), create: create });
        }
        const secp256k1P = BigInt(
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
        );
        const secp256k1N = BigInt(
          "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
        );
        const _1n = BigInt(1);
        const _2n = BigInt(2);
        const divNearest = (a, b) => (a + b / _2n) / b;
        function sqrtMod(y) {
          const P = secp256k1P;
          const _3n = BigInt(3),
            _6n = BigInt(6),
            _11n = BigInt(11),
            _22n = BigInt(22);
          const _23n = BigInt(23),
            _44n = BigInt(44),
            _88n = BigInt(88);
          const b2 = (y * y * y) % P;
          const b3 = (b2 * b2 * y) % P;
          const b6 = (pow2(b3, _3n, P) * b3) % P;
          const b9 = (pow2(b6, _3n, P) * b3) % P;
          const b11 = (pow2(b9, _2n, P) * b2) % P;
          const b22 = (pow2(b11, _11n, P) * b11) % P;
          const b44 = (pow2(b22, _22n, P) * b22) % P;
          const b88 = (pow2(b44, _44n, P) * b44) % P;
          const b176 = (pow2(b88, _88n, P) * b88) % P;
          const b220 = (pow2(b176, _44n, P) * b44) % P;
          const b223 = (pow2(b220, _3n, P) * b3) % P;
          const t1 = (pow2(b223, _23n, P) * b22) % P;
          const t2 = (pow2(t1, _6n, P) * b2) % P;
          const root = pow2(t2, _2n, P);
          if (!Fp.eql(Fp.sqr(root), y))
            throw new Error("Cannot find square root");
          return root;
        }
        const Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
        const secp256k1 = createCurve(
          {
            a: BigInt(0),
            b: BigInt(7),
            Fp: Fp,
            n: secp256k1N,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            h: BigInt(1),
            lowS: true,
            endo: {
              beta: BigInt(
                "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
              ),
              splitScalar: (k) => {
                const n = secp256k1N;
                const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
                const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
                const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
                const b2 = a1;
                const POW_2_128 = BigInt("0x100000000000000000000000000000000");
                const c1 = divNearest(b2 * k, n);
                const c2 = divNearest(-b1 * k, n);
                let k1 = mod(k - c1 * a1 - c2 * a2, n);
                let k2 = mod(-c1 * b1 - c2 * b2, n);
                const k1neg = k1 > POW_2_128;
                const k2neg = k2 > POW_2_128;
                if (k1neg) k1 = n - k1;
                if (k2neg) k2 = n - k2;
                if (k1 > POW_2_128 || k2 > POW_2_128) {
                  throw new Error("splitScalar: Endomorphism failed, k=" + k);
                }
                return { k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2 };
              },
            },
          },
          sha256$1
        );
        BigInt(0);
        secp256k1.ProjectivePoint;
        const ZeroAddress = "0x0000000000000000000000000000000000000000";
        const ZeroHash =
          "0x0000000000000000000000000000000000000000000000000000000000000000";
        const N$1 = BigInt(
          "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
        );
        const WeiPerEther = BigInt("1000000000000000000");
        const MaxUint256 = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
        const MinInt256 =
          BigInt(
            "0x8000000000000000000000000000000000000000000000000000000000000000"
          ) * BigInt(-1);
        const MaxInt256 = BigInt(
          "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
        const EtherSymbol = "";
        const MessagePrefix = "Ethereum Signed Message:\n";
        const BN_0$7 = BigInt(0);
        const BN_1$3 = BigInt(1);
        const BN_2$3 = BigInt(2);
        const BN_27$1 = BigInt(27);
        const BN_28$1 = BigInt(28);
        const BN_35$1 = BigInt(35);
        const _guard$3 = {};
        function toUint256(value) {
          return zeroPadValue(toBeArray(value), 32);
        }
        class Signature {
          #r;
          #s;
          #v;
          #networkV;
          get r() {
            return this.#r;
          }
          set r(value) {
            assertArgument(
              dataLength(value) === 32,
              "invalid r",
              "value",
              value
            );
            this.#r = hexlify(value);
          }
          get s() {
            return this.#s;
          }
          set s(_value) {
            assertArgument(
              dataLength(_value) === 32,
              "invalid s",
              "value",
              _value
            );
            const value = hexlify(_value);
            assertArgument(
              parseInt(value.substring(0, 3)) < 8,
              "non-canonical s",
              "value",
              value
            );
            this.#s = value;
          }
          get v() {
            return this.#v;
          }
          set v(value) {
            const v = getNumber(value, "value");
            assertArgument(v === 27 || v === 28, "invalid v", "v", value);
            this.#v = v;
          }
          get networkV() {
            return this.#networkV;
          }
          get legacyChainId() {
            const v = this.networkV;
            if (v == null) {
              return null;
            }
            return Signature.getChainId(v);
          }
          get yParity() {
            return this.v === 27 ? 0 : 1;
          }
          get yParityAndS() {
            const yParityAndS = getBytes(this.s);
            if (this.yParity) {
              yParityAndS[0] |= 128;
            }
            return hexlify(yParityAndS);
          }
          get compactSerialized() {
            return concat([this.r, this.yParityAndS]);
          }
          get serialized() {
            return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
          }
          constructor(guard, r, s, v) {
            assertPrivate(guard, _guard$3, "Signature");
            this.#r = r;
            this.#s = s;
            this.#v = v;
            this.#networkV = null;
          }
          [Symbol.for("nodejs.util.inspect.custom")]() {
            return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
          }
          clone() {
            const clone = new Signature(_guard$3, this.r, this.s, this.v);
            if (this.networkV) {
              clone.#networkV = this.networkV;
            }
            return clone;
          }
          toJSON() {
            const networkV = this.networkV;
            return {
              _type: "signature",
              networkV: networkV != null ? networkV.toString() : null,
              r: this.r,
              s: this.s,
              v: this.v,
            };
          }
          static getChainId(v) {
            const bv = getBigInt(v, "v");
            if (bv == BN_27$1 || bv == BN_28$1) {
              return BN_0$7;
            }
            assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v);
            return (bv - BN_35$1) / BN_2$3;
          }
          static getChainIdV(chainId, v) {
            return getBigInt(chainId) * BN_2$3 + BigInt(35 + v - 27);
          }
          static getNormalizedV(v) {
            const bv = getBigInt(v);
            if (bv === BN_0$7 || bv === BN_27$1) {
              return 27;
            }
            if (bv === BN_1$3 || bv === BN_28$1) {
              return 28;
            }
            assertArgument(bv >= BN_35$1, "invalid v", "v", v);
            return bv & BN_1$3 ? 27 : 28;
          }
          static from(sig) {
            function assertError(check, message) {
              assertArgument(check, message, "signature", sig);
            }
            if (sig == null) {
              return new Signature(_guard$3, ZeroHash, ZeroHash, 27);
            }
            if (typeof sig === "string") {
              const bytes = getBytes(sig, "signature");
              if (bytes.length === 64) {
                const r = hexlify(bytes.slice(0, 32));
                const s = bytes.slice(32, 64);
                const v = s[0] & 128 ? 28 : 27;
                s[0] &= 127;
                return new Signature(_guard$3, r, hexlify(s), v);
              }
              if (bytes.length === 65) {
                const r = hexlify(bytes.slice(0, 32));
                const s = bytes.slice(32, 64);
                assertError((s[0] & 128) === 0, "non-canonical s");
                const v = Signature.getNormalizedV(bytes[64]);
                return new Signature(_guard$3, r, hexlify(s), v);
              }
              assertError(false, "invalid raw signature length");
            }
            if (sig instanceof Signature) {
              return sig.clone();
            }
            const _r = sig.r;
            assertError(_r != null, "missing r");
            const r = toUint256(_r);
            const s = (function (s, yParityAndS) {
              if (s != null) {
                return toUint256(s);
              }
              if (yParityAndS != null) {
                assertError(
                  isHexString(yParityAndS, 32),
                  "invalid yParityAndS"
                );
                const bytes = getBytes(yParityAndS);
                bytes[0] &= 127;
                return hexlify(bytes);
              }
              assertError(false, "missing s");
            })(sig.s, sig.yParityAndS);
            assertError((getBytes(s)[0] & 128) == 0, "non-canonical s");
            const { networkV, v } = (function (_v, yParityAndS, yParity) {
              if (_v != null) {
                const v = getBigInt(_v);
                return {
                  networkV: v >= BN_35$1 ? v : undefined,
                  v: Signature.getNormalizedV(v),
                };
              }
              if (yParityAndS != null) {
                assertError(
                  isHexString(yParityAndS, 32),
                  "invalid yParityAndS"
                );
                return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
              }
              if (yParity != null) {
                switch (getNumber(yParity, "sig.yParity")) {
                  case 0:
                    return { v: 27 };
                  case 1:
                    return { v: 28 };
                }
                assertError(false, "invalid yParity");
              }
              assertError(false, "missing v");
            })(sig.v, sig.yParityAndS, sig.yParity);
            const result = new Signature(_guard$3, r, s, v);
            if (networkV) {
              result.#networkV = networkV;
            }
            assertError(
              sig.yParity == null ||
                getNumber(sig.yParity, "sig.yParity") === result.yParity,
              "yParity mismatch"
            );
            assertError(
              sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS,
              "yParityAndS mismatch"
            );
            return result;
          }
        }
        class SigningKey {
          #privateKey;
          constructor(privateKey) {
            assertArgument(
              dataLength(privateKey) === 32,
              "invalid private key",
              "privateKey",
              "[REDACTED]"
            );
            this.#privateKey = hexlify(privateKey);
          }
          get privateKey() {
            return this.#privateKey;
          }
          get publicKey() {
            return SigningKey.computePublicKey(this.#privateKey);
          }
          get compressedPublicKey() {
            return SigningKey.computePublicKey(this.#privateKey, true);
          }
          sign(digest) {
            assertArgument(
              dataLength(digest) === 32,
              "invalid digest length",
              "digest",
              digest
            );
            const sig = secp256k1.sign(
              getBytesCopy(digest),
              getBytesCopy(this.#privateKey),
              { lowS: true }
            );
            return Signature.from({
              r: toBeHex(sig.r, 32),
              s: toBeHex(sig.s, 32),
              v: sig.recovery ? 28 : 27,
            });
          }
          computeSharedSecret(other) {
            const pubKey = SigningKey.computePublicKey(other);
            return hexlify(
              secp256k1.getSharedSecret(
                getBytesCopy(this.#privateKey),
                getBytes(pubKey),
                false
              )
            );
          }
          static computePublicKey(key, compressed) {
            let bytes = getBytes(key, "key");
            if (bytes.length === 32) {
              const pubKey = secp256k1.getPublicKey(bytes, !!compressed);
              return hexlify(pubKey);
            }
            if (bytes.length === 64) {
              const pub = new Uint8Array(65);
              pub[0] = 4;
              pub.set(bytes, 1);
              bytes = pub;
            }
            const point = secp256k1.ProjectivePoint.fromHex(bytes);
            return hexlify(point.toRawBytes(compressed));
          }
          static recoverPublicKey(digest, signature) {
            assertArgument(
              dataLength(digest) === 32,
              "invalid digest length",
              "digest",
              digest
            );
            const sig = Signature.from(signature);
            let secpSig = secp256k1.Signature.fromCompact(
              getBytesCopy(concat([sig.r, sig.s]))
            );
            secpSig = secpSig.addRecoveryBit(sig.yParity);
            const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
            assertArgument(
              pubKey != null,
              "invalid signautre for digest",
              "signature",
              signature
            );
            return "0x" + pubKey.toHex(false);
          }
          static addPoints(p0, p1, compressed) {
            const pub0 = secp256k1.ProjectivePoint.fromHex(
              SigningKey.computePublicKey(p0).substring(2)
            );
            const pub1 = secp256k1.ProjectivePoint.fromHex(
              SigningKey.computePublicKey(p1).substring(2)
            );
            return "0x" + pub0.add(pub1).toHex(!!compressed);
          }
        }
        function lock() {
          computeHmac.lock();
          keccak256.lock();
          pbkdf2.lock();
          randomBytes.lock();
          ripemd160.lock();
          scrypt.lock();
          scryptSync.lock();
          sha256.lock();
          sha512.lock();
          randomBytes.lock();
        }
        const BN_0$6 = BigInt(0);
        const BN_36 = BigInt(36);
        function getChecksumAddress(address) {
          address = address.toLowerCase();
          const chars = address.substring(2).split("");
          const expanded = new Uint8Array(40);
          for (let i = 0; i < 40; i++) {
            expanded[i] = chars[i].charCodeAt(0);
          }
          const hashed = getBytes(keccak256(expanded));
          for (let i = 0; i < 40; i += 2) {
            if (hashed[i >> 1] >> 4 >= 8) {
              chars[i] = chars[i].toUpperCase();
            }
            if ((hashed[i >> 1] & 15) >= 8) {
              chars[i + 1] = chars[i + 1].toUpperCase();
            }
          }
          return "0x" + chars.join("");
        }
        const ibanLookup = {};
        for (let i = 0; i < 10; i++) {
          ibanLookup[String(i)] = String(i);
        }
        for (let i = 0; i < 26; i++) {
          ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
        }
        const safeDigits = 15;
        function ibanChecksum(address) {
          address = address.toUpperCase();
          address = address.substring(4) + address.substring(0, 2) + "00";
          let expanded = address
            .split("")
            .map((c) => {
              return ibanLookup[c];
            })
            .join("");
          while (expanded.length >= safeDigits) {
            let block = expanded.substring(0, safeDigits);
            expanded =
              (parseInt(block, 10) % 97) + expanded.substring(block.length);
          }
          let checksum = String(98 - (parseInt(expanded, 10) % 97));
          while (checksum.length < 2) {
            checksum = "0" + checksum;
          }
          return checksum;
        }
        const Base36 = (function () {
          const result = {};
          for (let i = 0; i < 36; i++) {
            const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
            result[key] = BigInt(i);
          }
          return result;
        })();
        function fromBase36(value) {
          value = value.toLowerCase();
          let result = BN_0$6;
          for (let i = 0; i < value.length; i++) {
            result = result * BN_36 + Base36[value[i]];
          }
          return result;
        }
        function getAddress(address) {
          assertArgument(
            typeof address === "string",
            "invalid address",
            "address",
            address
          );
          if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
            if (!address.startsWith("0x")) {
              address = "0x" + address;
            }
            const result = getChecksumAddress(address);
            assertArgument(
              !address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) ||
                result === address,
              "bad address checksum",
              "address",
              address
            );
            return result;
          }
          if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
            assertArgument(
              address.substring(2, 4) === ibanChecksum(address),
              "bad icap checksum",
              "address",
              address
            );
            let result = fromBase36(address.substring(4)).toString(16);
            while (result.length < 40) {
              result = "0" + result;
            }
            return getChecksumAddress("0x" + result);
          }
          assertArgument(false, "invalid address", "address", address);
        }
        function getIcapAddress(address) {
          let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
          while (base36.length < 30) {
            base36 = "0" + base36;
          }
          return "XE" + ibanChecksum("XE00" + base36) + base36;
        }
        function getCreateAddress(tx) {
          const from = getAddress(tx.from);
          const nonce = getBigInt(tx.nonce, "tx.nonce");
          let nonceHex = nonce.toString(16);
          if (nonceHex === "0") {
            nonceHex = "0x";
          } else if (nonceHex.length % 2) {
            nonceHex = "0x0" + nonceHex;
          } else {
            nonceHex = "0x" + nonceHex;
          }
          return getAddress(
            dataSlice(keccak256(encodeRlp([from, nonceHex])), 12)
          );
        }
        function getCreate2Address(_from, _salt, _initCodeHash) {
          const from = getAddress(_from);
          const salt = getBytes(_salt, "salt");
          const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
          assertArgument(
            salt.length === 32,
            "salt must be 32 bytes",
            "salt",
            _salt
          );
          assertArgument(
            initCodeHash.length === 32,
            "initCodeHash must be 32 bytes",
            "initCodeHash",
            _initCodeHash
          );
          return getAddress(
            dataSlice(keccak256(concat(["0xff", from, salt, initCodeHash])), 12)
          );
        }
        function isAddressable(value) {
          return value && typeof value.getAddress === "function";
        }
        function isAddress(value) {
          try {
            getAddress(value);
            return true;
          } catch (error) {}
          return false;
        }
        async function checkAddress(target, promise) {
          const result = await promise;
          if (
            result == null ||
            result === "0x0000000000000000000000000000000000000000"
          ) {
            assert(
              typeof target !== "string",
              "unconfigured name",
              "UNCONFIGURED_NAME",
              { value: target }
            );
            assertArgument(
              false,
              "invalid AddressLike value; did not resolve to a value address",
              "target",
              target
            );
          }
          return getAddress(result);
        }
        function resolveAddress(target, resolver) {
          if (typeof target === "string") {
            if (target.match(/^0x[0-9a-f]{40}$/i)) {
              return getAddress(target);
            }
            assert(
              resolver != null,
              "ENS resolution requires a provider",
              "UNSUPPORTED_OPERATION",
              { operation: "resolveName" }
            );
            return checkAddress(target, resolver.resolveName(target));
          } else if (isAddressable(target)) {
            return checkAddress(target, target.getAddress());
          } else if (target && typeof target.then === "function") {
            return checkAddress(target, target);
          }
          assertArgument(
            false,
            "unsupported addressable value",
            "target",
            target
          );
        }
        const _gaurd = {};
        function n(value, width) {
          let signed = false;
          if (width < 0) {
            signed = true;
            width *= -1;
          }
          return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, {
            signed: signed,
            width: width,
          });
        }
        function b(value, size) {
          return new Typed(_gaurd, `bytes${size ? size : ""}`, value, {
            size: size,
          });
        }
        const _typedSymbol = Symbol.for("_ethers_typed");
        class Typed {
          type;
          value;
          #options;
          _typedSymbol;
          constructor(gaurd, type, value, options) {
            if (options == null) {
              options = null;
            }
            assertPrivate(_gaurd, gaurd, "Typed");
            defineProperties(this, {
              _typedSymbol: _typedSymbol,
              type: type,
              value: value,
            });
            this.#options = options;
            this.format();
          }
          format() {
            if (this.type === "array") {
              throw new Error("");
            } else if (this.type === "dynamicArray") {
              throw new Error("");
            } else if (this.type === "tuple") {
              return `tuple(${this.value.map((v) => v.format()).join(",")})`;
            }
            return this.type;
          }
          defaultValue() {
            return 0;
          }
          minValue() {
            return 0;
          }
          maxValue() {
            return 0;
          }
          isBigInt() {
            return !!this.type.match(/^u?int[0-9]+$/);
          }
          isData() {
            return this.type.startsWith("bytes");
          }
          isString() {
            return this.type === "string";
          }
          get tupleName() {
            if (this.type !== "tuple") {
              throw TypeError("not a tuple");
            }
            return this.#options;
          }
          get arrayLength() {
            if (this.type !== "array") {
              throw TypeError("not an array");
            }
            if (this.#options === true) {
              return -1;
            }
            if (this.#options === false) {
              return this.value.length;
            }
            return null;
          }
          static from(type, value) {
            return new Typed(_gaurd, type, value);
          }
          static uint8(v) {
            return n(v, 8);
          }
          static uint16(v) {
            return n(v, 16);
          }
          static uint24(v) {
            return n(v, 24);
          }
          static uint32(v) {
            return n(v, 32);
          }
          static uint40(v) {
            return n(v, 40);
          }
          static uint48(v) {
            return n(v, 48);
          }
          static uint56(v) {
            return n(v, 56);
          }
          static uint64(v) {
            return n(v, 64);
          }
          static uint72(v) {
            return n(v, 72);
          }
          static uint80(v) {
            return n(v, 80);
          }
          static uint88(v) {
            return n(v, 88);
          }
          static uint96(v) {
            return n(v, 96);
          }
          static uint104(v) {
            return n(v, 104);
          }
          static uint112(v) {
            return n(v, 112);
          }
          static uint120(v) {
            return n(v, 120);
          }
          static uint128(v) {
            return n(v, 128);
          }
          static uint136(v) {
            return n(v, 136);
          }
          static uint144(v) {
            return n(v, 144);
          }
          static uint152(v) {
            return n(v, 152);
          }
          static uint160(v) {
            return n(v, 160);
          }
          static uint168(v) {
            return n(v, 168);
          }
          static uint176(v) {
            return n(v, 176);
          }
          static uint184(v) {
            return n(v, 184);
          }
          static uint192(v) {
            return n(v, 192);
          }
          static uint200(v) {
            return n(v, 200);
          }
          static uint208(v) {
            return n(v, 208);
          }
          static uint216(v) {
            return n(v, 216);
          }
          static uint224(v) {
            return n(v, 224);
          }
          static uint232(v) {
            return n(v, 232);
          }
          static uint240(v) {
            return n(v, 240);
          }
          static uint248(v) {
            return n(v, 248);
          }
          static uint256(v) {
            return n(v, 256);
          }
          static uint(v) {
            return n(v, 256);
          }
          static int8(v) {
            return n(v, -8);
          }
          static int16(v) {
            return n(v, -16);
          }
          static int24(v) {
            return n(v, -24);
          }
          static int32(v) {
            return n(v, -32);
          }
          static int40(v) {
            return n(v, -40);
          }
          static int48(v) {
            return n(v, -48);
          }
          static int56(v) {
            return n(v, -56);
          }
          static int64(v) {
            return n(v, -64);
          }
          static int72(v) {
            return n(v, -72);
          }
          static int80(v) {
            return n(v, -80);
          }
          static int88(v) {
            return n(v, -88);
          }
          static int96(v) {
            return n(v, -96);
          }
          static int104(v) {
            return n(v, -104);
          }
          static int112(v) {
            return n(v, -112);
          }
          static int120(v) {
            return n(v, -120);
          }
          static int128(v) {
            return n(v, -128);
          }
          static int136(v) {
            return n(v, -136);
          }
          static int144(v) {
            return n(v, -144);
          }
          static int152(v) {
            return n(v, -152);
          }
          static int160(v) {
            return n(v, -160);
          }
          static int168(v) {
            return n(v, -168);
          }
          static int176(v) {
            return n(v, -176);
          }
          static int184(v) {
            return n(v, -184);
          }
          static int192(v) {
            return n(v, -192);
          }
          static int200(v) {
            return n(v, -200);
          }
          static int208(v) {
            return n(v, -208);
          }
          static int216(v) {
            return n(v, -216);
          }
          static int224(v) {
            return n(v, -224);
          }
          static int232(v) {
            return n(v, -232);
          }
          static int240(v) {
            return n(v, -240);
          }
          static int248(v) {
            return n(v, -248);
          }
          static int256(v) {
            return n(v, -256);
          }
          static int(v) {
            return n(v, -256);
          }
          static bytes1(v) {
            return b(v, 1);
          }
          static bytes2(v) {
            return b(v, 2);
          }
          static bytes3(v) {
            return b(v, 3);
          }
          static bytes4(v) {
            return b(v, 4);
          }
          static bytes5(v) {
            return b(v, 5);
          }
          static bytes6(v) {
            return b(v, 6);
          }
          static bytes7(v) {
            return b(v, 7);
          }
          static bytes8(v) {
            return b(v, 8);
          }
          static bytes9(v) {
            return b(v, 9);
          }
          static bytes10(v) {
            return b(v, 10);
          }
          static bytes11(v) {
            return b(v, 11);
          }
          static bytes12(v) {
            return b(v, 12);
          }
          static bytes13(v) {
            return b(v, 13);
          }
          static bytes14(v) {
            return b(v, 14);
          }
          static bytes15(v) {
            return b(v, 15);
          }
          static bytes16(v) {
            return b(v, 16);
          }
          static bytes17(v) {
            return b(v, 17);
          }
          static bytes18(v) {
            return b(v, 18);
          }
          static bytes19(v) {
            return b(v, 19);
          }
          static bytes20(v) {
            return b(v, 20);
          }
          static bytes21(v) {
            return b(v, 21);
          }
          static bytes22(v) {
            return b(v, 22);
          }
          static bytes23(v) {
            return b(v, 23);
          }
          static bytes24(v) {
            return b(v, 24);
          }
          static bytes25(v) {
            return b(v, 25);
          }
          static bytes26(v) {
            return b(v, 26);
          }
          static bytes27(v) {
            return b(v, 27);
          }
          static bytes28(v) {
            return b(v, 28);
          }
          static bytes29(v) {
            return b(v, 29);
          }
          static bytes30(v) {
            return b(v, 30);
          }
          static bytes31(v) {
            return b(v, 31);
          }
          static bytes32(v) {
            return b(v, 32);
          }
          static address(v) {
            return new Typed(_gaurd, "address", v);
          }
          static bool(v) {
            return new Typed(_gaurd, "bool", !!v);
          }
          static bytes(v) {
            return new Typed(_gaurd, "bytes", v);
          }
          static string(v) {
            return new Typed(_gaurd, "string", v);
          }
          static array(v, dynamic) {
            throw new Error("not implemented yet");
          }
          static tuple(v, name) {
            throw new Error("not implemented yet");
          }
          static overrides(v) {
            return new Typed(_gaurd, "overrides", Object.assign({}, v));
          }
          static isTyped(value) {
            return (
              value &&
              typeof value === "object" &&
              "_typedSymbol" in value &&
              value._typedSymbol === _typedSymbol
            );
          }
          static dereference(value, type) {
            if (Typed.isTyped(value)) {
              if (value.type !== type) {
                throw new Error(
                  `invalid type: expecetd ${type}, got ${value.type}`
                );
              }
              return value.value;
            }
            return value;
          }
        }
        class AddressCoder extends Coder {
          constructor(localName) {
            super("address", "address", localName, false);
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000";
          }
          encode(writer, _value) {
            let value = Typed.dereference(_value, "string");
            try {
              value = getAddress(value);
            } catch (error) {
              return this._throwError(error.message, _value);
            }
            return writer.writeValue(value);
          }
          decode(reader) {
            return getAddress(toBeHex(reader.readValue(), 20));
          }
        }
        class AnonymousCoder extends Coder {
          coder;
          constructor(coder) {
            super(coder.name, coder.type, "_", coder.dynamic);
            this.coder = coder;
          }
          defaultValue() {
            return this.coder.defaultValue();
          }
          encode(writer, value) {
            return this.coder.encode(writer, value);
          }
          decode(reader) {
            return this.coder.decode(reader);
          }
        }
        function pack(writer, coders, values) {
          let arrayValues = [];
          if (Array.isArray(values)) {
            arrayValues = values;
          } else if (values && typeof values === "object") {
            let unique = {};
            arrayValues = coders.map((coder) => {
              const name = coder.localName;
              assert(
                name,
                "cannot encode object for signature with missing names",
                "INVALID_ARGUMENT",
                { argument: "values", info: { coder: coder }, value: values }
              );
              assert(
                !unique[name],
                "cannot encode object for signature with duplicate names",
                "INVALID_ARGUMENT",
                { argument: "values", info: { coder: coder }, value: values }
              );
              unique[name] = true;
              return values[name];
            });
          } else {
            assertArgument(false, "invalid tuple value", "tuple", values);
          }
          assertArgument(
            coders.length === arrayValues.length,
            "types/value length mismatch",
            "tuple",
            values
          );
          let staticWriter = new Writer();
          let dynamicWriter = new Writer();
          let updateFuncs = [];
          coders.forEach((coder, index) => {
            let value = arrayValues[index];
            if (coder.dynamic) {
              let dynamicOffset = dynamicWriter.length;
              coder.encode(dynamicWriter, value);
              let updateFunc = staticWriter.writeUpdatableValue();
              updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
              });
            } else {
              coder.encode(staticWriter, value);
            }
          });
          updateFuncs.forEach((func) => {
            func(staticWriter.length);
          });
          let length = writer.appendWriter(staticWriter);
          length += writer.appendWriter(dynamicWriter);
          return length;
        }
        function unpack(reader, coders) {
          let values = [];
          let keys = [];
          let baseReader = reader.subReader(0);
          coders.forEach((coder) => {
            let value = null;
            if (coder.dynamic) {
              let offset = reader.readIndex();
              let offsetReader = baseReader.subReader(offset);
              try {
                value = coder.decode(offsetReader);
              } catch (error) {
                if (isError(error, "BUFFER_OVERRUN")) {
                  throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
              }
            } else {
              try {
                value = coder.decode(reader);
              } catch (error) {
                if (isError(error, "BUFFER_OVERRUN")) {
                  throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
              }
            }
            if (value == undefined) {
              throw new Error("investigate");
            }
            values.push(value);
            keys.push(coder.localName || null);
          });
          return Result.fromItems(values, keys);
        }
        class ArrayCoder extends Coder {
          coder;
          length;
          constructor(coder, length, localName) {
            const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
            const dynamic = length === -1 || coder.dynamic;
            super("array", type, localName, dynamic);
            defineProperties(this, { coder: coder, length: length });
          }
          defaultValue() {
            const defaultChild = this.coder.defaultValue();
            const result = [];
            for (let i = 0; i < this.length; i++) {
              result.push(defaultChild);
            }
            return result;
          }
          encode(writer, _value) {
            const value = Typed.dereference(_value, "array");
            if (!Array.isArray(value)) {
              this._throwError("expected array value", value);
            }
            let count = this.length;
            if (count === -1) {
              count = value.length;
              writer.writeValue(value.length);
            }
            assertArgumentCount(
              value.length,
              count,
              "coder array" + (this.localName ? " " + this.localName : "")
            );
            let coders = [];
            for (let i = 0; i < value.length; i++) {
              coders.push(this.coder);
            }
            return pack(writer, coders, value);
          }
          decode(reader) {
            let count = this.length;
            if (count === -1) {
              count = reader.readIndex();
              assert(
                count * WordSize <= reader.dataLength,
                "insufficient data length",
                "BUFFER_OVERRUN",
                {
                  buffer: reader.bytes,
                  offset: count * WordSize,
                  length: reader.dataLength,
                }
              );
            }
            let coders = [];
            for (let i = 0; i < count; i++) {
              coders.push(new AnonymousCoder(this.coder));
            }
            return unpack(reader, coders);
          }
        }
        class BooleanCoder extends Coder {
          constructor(localName) {
            super("bool", "bool", localName, false);
          }
          defaultValue() {
            return false;
          }
          encode(writer, _value) {
            const value = Typed.dereference(_value, "bool");
            return writer.writeValue(value ? 1 : 0);
          }
          decode(reader) {
            return !!reader.readValue();
          }
        }
        class DynamicBytesCoder extends Coder {
          constructor(type, localName) {
            super(type, type, localName, true);
          }
          defaultValue() {
            return "0x";
          }
          encode(writer, value) {
            value = getBytesCopy(value);
            let length = writer.writeValue(value.length);
            length += writer.writeBytes(value);
            return length;
          }
          decode(reader) {
            return reader.readBytes(reader.readIndex(), true);
          }
        }
        class BytesCoder extends DynamicBytesCoder {
          constructor(localName) {
            super("bytes", localName);
          }
          decode(reader) {
            return hexlify(super.decode(reader));
          }
        }
        class FixedBytesCoder extends Coder {
          size;
          constructor(size, localName) {
            let name = "bytes" + String(size);
            super(name, name, localName, false);
            defineProperties(this, { size: size }, { size: "number" });
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
              0,
              2 + this.size * 2
            );
          }
          encode(writer, _value) {
            let data = getBytesCopy(Typed.dereference(_value, this.type));
            if (data.length !== this.size) {
              this._throwError("incorrect data length", _value);
            }
            return writer.writeBytes(data);
          }
          decode(reader) {
            return hexlify(reader.readBytes(this.size));
          }
        }
        const Empty = new Uint8Array([]);
        class NullCoder extends Coder {
          constructor(localName) {
            super("null", "", localName, false);
          }
          defaultValue() {
            return null;
          }
          encode(writer, value) {
            if (value != null) {
              this._throwError("not null", value);
            }
            return writer.writeBytes(Empty);
          }
          decode(reader) {
            reader.readBytes(0);
            return null;
          }
        }
        const BN_0$5 = BigInt(0);
        const BN_1$2 = BigInt(1);
        const BN_MAX_UINT256$1 = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
        class NumberCoder extends Coder {
          size;
          signed;
          constructor(size, signed, localName) {
            const name = (signed ? "int" : "uint") + size * 8;
            super(name, name, localName, false);
            defineProperties(
              this,
              { size: size, signed: signed },
              { size: "number", signed: "boolean" }
            );
          }
          defaultValue() {
            return 0;
          }
          encode(writer, _value) {
            let value = getBigInt(Typed.dereference(_value, this.type));
            let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
            if (this.signed) {
              let bounds = mask(maxUintValue, this.size * 8 - 1);
              if (value > bounds || value < -(bounds + BN_1$2)) {
                this._throwError("value out-of-bounds", _value);
              }
              value = toTwos(value, 8 * WordSize);
            } else if (
              value < BN_0$5 ||
              value > mask(maxUintValue, this.size * 8)
            ) {
              this._throwError("value out-of-bounds", _value);
            }
            return writer.writeValue(value);
          }
          decode(reader) {
            let value = mask(reader.readValue(), this.size * 8);
            if (this.signed) {
              value = fromTwos(value, this.size * 8);
            }
            return value;
          }
        }
        class StringCoder extends DynamicBytesCoder {
          constructor(localName) {
            super("string", localName);
          }
          defaultValue() {
            return "";
          }
          encode(writer, _value) {
            return super.encode(
              writer,
              toUtf8Bytes(Typed.dereference(_value, "string"))
            );
          }
          decode(reader) {
            return toUtf8String(super.decode(reader));
          }
        }
        class TupleCoder extends Coder {
          coders;
          constructor(coders, localName) {
            let dynamic = false;
            const types = [];
            coders.forEach((coder) => {
              if (coder.dynamic) {
                dynamic = true;
              }
              types.push(coder.type);
            });
            const type = "tuple(" + types.join(",") + ")";
            super("tuple", type, localName, dynamic);
            defineProperties(this, { coders: Object.freeze(coders.slice()) });
          }
          defaultValue() {
            const values = [];
            this.coders.forEach((coder) => {
              values.push(coder.defaultValue());
            });
            const uniqueNames = this.coders.reduce((accum, coder) => {
              const name = coder.localName;
              if (name) {
                if (!accum[name]) {
                  accum[name] = 0;
                }
                accum[name]++;
              }
              return accum;
            }, {});
            this.coders.forEach((coder, index) => {
              let name = coder.localName;
              if (!name || uniqueNames[name] !== 1) {
                return;
              }
              if (name === "length") {
                name = "_length";
              }
              if (values[name] != null) {
                return;
              }
              values[name] = values[index];
            });
            return Object.freeze(values);
          }
          encode(writer, _value) {
            const value = Typed.dereference(_value, "tuple");
            return pack(writer, this.coders, value);
          }
          decode(reader) {
            return unpack(reader, this.coders);
          }
        }
        function id(value) {
          return keccak256(toUtf8Bytes(value));
        }
        var COMPRESSED$1 =
          "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
        const FENCED = new Map([
          [8217, "apostrophe"],
          [8260, "fraction slash"],
          [12539, "middle dot"],
        ]);
        const NSM_MAX = 4;
        function decode_arithmetic(bytes) {
          let pos = 0;
          function u16() {
            return (bytes[pos++] << 8) | bytes[pos++];
          }
          let symbol_count = u16();
          let total = 1;
          let acc = [0, 1];
          for (let i = 1; i < symbol_count; i++) {
            acc.push((total += u16()));
          }
          let skip = u16();
          let pos_payload = pos;
          pos += skip;
          let read_width = 0;
          let read_buffer = 0;
          function read_bit() {
            if (read_width == 0) {
              read_buffer = (read_buffer << 8) | bytes[pos++];
              read_width = 8;
            }
            return (read_buffer >> --read_width) & 1;
          }
          const N = 31;
          const FULL = 2 ** N;
          const HALF = FULL >>> 1;
          const QRTR = HALF >> 1;
          const MASK = FULL - 1;
          let register = 0;
          for (let i = 0; i < N; i++) register = (register << 1) | read_bit();
          let symbols = [];
          let low = 0;
          let range = FULL;
          while (true) {
            let value = Math.floor(((register - low + 1) * total - 1) / range);
            let start = 0;
            let end = symbol_count;
            while (end - start > 1) {
              let mid = (start + end) >>> 1;
              if (value < acc[mid]) {
                end = mid;
              } else {
                start = mid;
              }
            }
            if (start == 0) break;
            symbols.push(start);
            let a = low + Math.floor((range * acc[start]) / total);
            let b = low + Math.floor((range * acc[start + 1]) / total) - 1;
            while (((a ^ b) & HALF) == 0) {
              register = ((register << 1) & MASK) | read_bit();
              a = (a << 1) & MASK;
              b = ((b << 1) & MASK) | 1;
            }
            while (a & ~b & QRTR) {
              register =
                (register & HALF) |
                ((register << 1) & (MASK >>> 1)) |
                read_bit();
              a = (a << 1) ^ HALF;
              b = ((b ^ HALF) << 1) | HALF | 1;
            }
            low = a;
            range = 1 + b - a;
          }
          let offset = symbol_count - 4;
          return symbols.map((x) => {
            switch (x - offset) {
              case 3:
                return (
                  offset +
                  65792 +
                  ((bytes[pos_payload++] << 16) |
                    (bytes[pos_payload++] << 8) |
                    bytes[pos_payload++])
                );
              case 2:
                return (
                  offset +
                  256 +
                  ((bytes[pos_payload++] << 8) | bytes[pos_payload++])
                );
              case 1:
                return offset + bytes[pos_payload++];
              default:
                return x - 1;
            }
          });
        }
        function read_payload(v) {
          let pos = 0;
          return () => v[pos++];
        }
        function read_compressed_payload(s) {
          return read_payload(decode_arithmetic(unsafe_atob(s)));
        }
        function unsafe_atob(s) {
          let lookup = [];
          [
            ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          ].forEach((c, i) => (lookup[c.charCodeAt(0)] = i));
          let n = s.length;
          let ret = new Uint8Array((6 * n) >> 3);
          for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
            carry = (carry << 6) | lookup[s.charCodeAt(i)];
            width += 6;
            if (width >= 8) {
              ret[pos++] = carry >> (width -= 8);
            }
          }
          return ret;
        }
        function signed(i) {
          return i & 1 ? ~i >> 1 : i >> 1;
        }
        function read_deltas(n, next) {
          let v = Array(n);
          for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
          return v;
        }
        function read_sorted(next, prev = 0) {
          let ret = [];
          while (true) {
            let x = next();
            let n = next();
            if (!n) break;
            prev += x;
            for (let i = 0; i < n; i++) {
              ret.push(prev + i);
            }
            prev += n + 1;
          }
          return ret;
        }
        function read_sorted_arrays(next) {
          return read_array_while(() => {
            let v = read_sorted(next);
            if (v.length) return v;
          });
        }
        function read_mapped(next) {
          let ret = [];
          while (true) {
            let w = next();
            if (w == 0) break;
            ret.push(read_linear_table(w, next));
          }
          while (true) {
            let w = next() - 1;
            if (w < 0) break;
            ret.push(read_replacement_table(w, next));
          }
          return ret.flat();
        }
        function read_array_while(next) {
          let v = [];
          while (true) {
            let x = next(v.length);
            if (!x) break;
            v.push(x);
          }
          return v;
        }
        function read_transposed(n, w, next) {
          let m = Array(n)
            .fill()
            .map(() => []);
          for (let i = 0; i < w; i++) {
            read_deltas(n, next).forEach((x, j) => m[j].push(x));
          }
          return m;
        }
        function read_linear_table(w, next) {
          let dx = 1 + next();
          let dy = next();
          let vN = read_array_while(next);
          let m = read_transposed(vN.length, 1 + w, next);
          return m.flatMap((v, i) => {
            let [x, ...ys] = v;
            return Array(vN[i])
              .fill()
              .map((_, j) => {
                let j_dy = j * dy;
                return [x + j * dx, ys.map((y) => y + j_dy)];
              });
          });
        }
        function read_replacement_table(w, next) {
          let n = 1 + next();
          let m = read_transposed(n, 1 + w, next);
          return m.map((v) => [v[0], v.slice(1)]);
        }
        function read_trie(next) {
          let ret = [];
          let sorted = read_sorted(next);
          expand(decode([]), []);
          return ret;
          function decode(Q) {
            let S = next();
            let B = read_array_while(() => {
              let cps = read_sorted(next).map((i) => sorted[i]);
              if (cps.length) return decode(cps);
            });
            return { S: S, B: B, Q: Q };
          }
          function expand({ S, B }, cps, saved) {
            if (S & 4 && saved === cps[cps.length - 1]) return;
            if (S & 2) saved = cps[cps.length - 1];
            if (S & 1) ret.push(cps);
            for (let br of B) {
              for (let cp of br.Q) {
                expand(br, [...cps, cp], saved);
              }
            }
          }
        }
        function hex_cp(cp) {
          return cp.toString(16).toUpperCase().padStart(2, "0");
        }
        function quote_cp(cp) {
          return `{${hex_cp(cp)}}`;
        }
        function explode_cp(s) {
          let cps = [];
          for (let pos = 0, len = s.length; pos < len; ) {
            let cp = s.codePointAt(pos);
            pos += cp < 65536 ? 1 : 2;
            cps.push(cp);
          }
          return cps;
        }
        function str_from_cps(cps) {
          const chunk = 4096;
          let len = cps.length;
          if (len < chunk) return String.fromCodePoint(...cps);
          let buf = [];
          for (let i = 0; i < len; ) {
            buf.push(String.fromCodePoint(...cps.slice(i, (i += chunk))));
          }
          return buf.join("");
        }
        function compare_arrays(a, b) {
          let n = a.length;
          let c = n - b.length;
          for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];
          return c;
        }
        var COMPRESSED =
          "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
        const S0 = 44032;
        const L0 = 4352;
        const V0 = 4449;
        const T0 = 4519;
        const L_COUNT = 19;
        const V_COUNT = 21;
        const T_COUNT = 28;
        const N_COUNT = V_COUNT * T_COUNT;
        const S_COUNT = L_COUNT * N_COUNT;
        const S1 = S0 + S_COUNT;
        const L1 = L0 + L_COUNT;
        const V1 = V0 + V_COUNT;
        const T1$1 = T0 + T_COUNT;
        function unpack_cc(packed) {
          return (packed >> 24) & 255;
        }
        function unpack_cp(packed) {
          return packed & 16777215;
        }
        let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;
        function init$1() {
          let r = read_compressed_payload(COMPRESSED);
          SHIFTED_RANK = new Map(
            read_sorted_arrays(r).flatMap((v, i) =>
              v.map((x) => [x, (i + 1) << 24])
            )
          );
          EXCLUSIONS = new Set(read_sorted(r));
          DECOMP = new Map();
          RECOMP = new Map();
          for (let [cp, cps] of read_mapped(r)) {
            if (!EXCLUSIONS.has(cp) && cps.length == 2) {
              let [a, b] = cps;
              let bucket = RECOMP.get(a);
              if (!bucket) {
                bucket = new Map();
                RECOMP.set(a, bucket);
              }
              bucket.set(b, cp);
            }
            DECOMP.set(cp, cps.reverse());
          }
        }
        function is_hangul(cp) {
          return cp >= S0 && cp < S1;
        }
        function compose_pair(a, b) {
          if (a >= L0 && a < L1 && b >= V0 && b < V1) {
            return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
          } else if (
            is_hangul(a) &&
            b > T0 &&
            b < T1$1 &&
            (a - S0) % T_COUNT == 0
          ) {
            return a + (b - T0);
          } else {
            let recomp = RECOMP.get(a);
            if (recomp) {
              recomp = recomp.get(b);
              if (recomp) {
                return recomp;
              }
            }
            return -1;
          }
        }
        function decomposed(cps) {
          if (!SHIFTED_RANK) init$1();
          let ret = [];
          let buf = [];
          let check_order = false;
          function add(cp) {
            let cc = SHIFTED_RANK.get(cp);
            if (cc) {
              check_order = true;
              cp |= cc;
            }
            ret.push(cp);
          }
          for (let cp of cps) {
            while (true) {
              if (cp < 128) {
                ret.push(cp);
              } else if (is_hangul(cp)) {
                let s_index = cp - S0;
                let l_index = (s_index / N_COUNT) | 0;
                let v_index = ((s_index % N_COUNT) / T_COUNT) | 0;
                let t_index = s_index % T_COUNT;
                add(L0 + l_index);
                add(V0 + v_index);
                if (t_index > 0) add(T0 + t_index);
              } else {
                let mapped = DECOMP.get(cp);
                if (mapped) {
                  buf.push(...mapped);
                } else {
                  add(cp);
                }
              }
              if (!buf.length) break;
              cp = buf.pop();
            }
          }
          if (check_order && ret.length > 1) {
            let prev_cc = unpack_cc(ret[0]);
            for (let i = 1; i < ret.length; i++) {
              let cc = unpack_cc(ret[i]);
              if (cc == 0 || prev_cc <= cc) {
                prev_cc = cc;
                continue;
              }
              let j = i - 1;
              while (true) {
                let tmp = ret[j + 1];
                ret[j + 1] = ret[j];
                ret[j] = tmp;
                if (!j) break;
                prev_cc = unpack_cc(ret[--j]);
                if (prev_cc <= cc) break;
              }
              prev_cc = unpack_cc(ret[i]);
            }
          }
          return ret;
        }
        function composed_from_decomposed(v) {
          let ret = [];
          let stack = [];
          let prev_cp = -1;
          let prev_cc = 0;
          for (let packed of v) {
            let cc = unpack_cc(packed);
            let cp = unpack_cp(packed);
            if (prev_cp == -1) {
              if (cc == 0) {
                prev_cp = cp;
              } else {
                ret.push(cp);
              }
            } else if (prev_cc > 0 && prev_cc >= cc) {
              if (cc == 0) {
                ret.push(prev_cp, ...stack);
                stack.length = 0;
                prev_cp = cp;
              } else {
                stack.push(cp);
              }
              prev_cc = cc;
            } else {
              let composed = compose_pair(prev_cp, cp);
              if (composed >= 0) {
                prev_cp = composed;
              } else if (prev_cc == 0 && cc == 0) {
                ret.push(prev_cp);
                prev_cp = cp;
              } else {
                stack.push(cp);
                prev_cc = cc;
              }
            }
          }
          if (prev_cp >= 0) {
            ret.push(prev_cp, ...stack);
          }
          return ret;
        }
        function nfd(cps) {
          return decomposed(cps).map(unpack_cp);
        }
        function nfc(cps) {
          return composed_from_decomposed(decomposed(cps));
        }
        const HYPHEN = 45;
        const STOP_CH = ".";
        const FE0F = 65039;
        const UNIQUE_PH = 1;
        const Array_from = (x) => Array.from(x);
        function group_has_cp(g, cp) {
          return g.P.has(cp) || g.Q.has(cp);
        }
        class Emoji extends Array {
          get is_emoji() {
            return true;
          }
        }
        let MAPPED,
          IGNORED,
          CM,
          NSM,
          ESCAPE,
          GROUPS,
          WHOLE_VALID,
          WHOLE_MAP,
          VALID,
          EMOJI_LIST,
          EMOJI_ROOT;
        function init() {
          if (MAPPED) return;
          let r = read_compressed_payload(COMPRESSED$1);
          const read_sorted_array = () => read_sorted(r);
          const read_sorted_set = () => new Set(read_sorted_array());
          const set_add_many = (set, v) => v.forEach((x) => set.add(x));
          MAPPED = new Map(read_mapped(r));
          IGNORED = read_sorted_set();
          CM = read_sorted_array();
          NSM = new Set(read_sorted_array().map((i) => CM[i]));
          CM = new Set(CM);
          ESCAPE = read_sorted_set();
          read_sorted_set();
          let chunks = read_sorted_arrays(r);
          let unrestricted = r();
          const read_chunked = () => {
            let set = new Set();
            read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
            set_add_many(set, read_sorted_array());
            return set;
          };
          GROUPS = read_array_while((i) => {
            let N = read_array_while(r).map((x) => x + 96);
            if (N.length) {
              let R = i >= unrestricted;
              N[0] -= 32;
              N = str_from_cps(N);
              if (R) N = `Restricted[${N}]`;
              let P = read_chunked();
              let Q = read_chunked();
              let M = !r();
              return { N: N, P: P, Q: Q, M: M, R: R };
            }
          });
          WHOLE_VALID = read_sorted_set();
          WHOLE_MAP = new Map();
          let wholes = read_sorted_array()
            .concat(Array_from(WHOLE_VALID))
            .sort((a, b) => a - b);
          wholes.forEach((cp, i) => {
            let d = r();
            let w = (wholes[i] = d ? wholes[i - d] : { V: [], M: new Map() });
            w.V.push(cp);
            if (!WHOLE_VALID.has(cp)) {
              WHOLE_MAP.set(cp, w);
            }
          });
          for (let { V, M } of new Set(WHOLE_MAP.values())) {
            let recs = [];
            for (let cp of V) {
              let gs = GROUPS.filter((g) => group_has_cp(g, cp));
              let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
              if (!rec) {
                rec = { G: new Set(), V: [] };
                recs.push(rec);
              }
              rec.V.push(cp);
              set_add_many(rec.G, gs);
            }
            let union = recs.flatMap((x) => Array_from(x.G));
            for (let { G, V } of recs) {
              let complement = new Set(union.filter((g) => !G.has(g)));
              for (let cp of V) {
                M.set(cp, complement);
              }
            }
          }
          VALID = new Set();
          let multi = new Set();
          const add_to_union = (cp) =>
            VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
          for (let g of GROUPS) {
            for (let cp of g.P) add_to_union(cp);
            for (let cp of g.Q) add_to_union(cp);
          }
          for (let cp of VALID) {
            if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
              WHOLE_MAP.set(cp, UNIQUE_PH);
            }
          }
          set_add_many(VALID, nfd(VALID));
          EMOJI_LIST = read_trie(r)
            .map((v) => Emoji.from(v))
            .sort(compare_arrays);
          EMOJI_ROOT = new Map();
          for (let cps of EMOJI_LIST) {
            let prev = [EMOJI_ROOT];
            for (let cp of cps) {
              let next = prev.map((node) => {
                let child = node.get(cp);
                if (!child) {
                  child = new Map();
                  node.set(cp, child);
                }
                return child;
              });
              if (cp === FE0F) {
                prev.push(...next);
              } else {
                prev = next;
              }
            }
            for (let x of prev) {
              x.V = cps;
            }
          }
        }
        function quoted_cp(cp) {
          return (
            (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) +
            quote_cp(cp)
          );
        }
        function bidi_qq(s) {
          return `"${s}"\u200E`;
        }
        function check_label_extension(cps) {
          if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
            throw new Error(
              `invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`
            );
          }
        }
        function check_leading_underscore(cps) {
          const UNDERSCORE = 95;
          for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
            if (cps[--i] !== UNDERSCORE) {
              throw new Error("underscore allowed only at start");
            }
          }
        }
        function check_fenced(cps) {
          let cp = cps[0];
          let prev = FENCED.get(cp);
          if (prev) throw error_placement(`leading ${prev}`);
          let n = cps.length;
          let last = -1;
          for (let i = 1; i < n; i++) {
            cp = cps[i];
            let match = FENCED.get(cp);
            if (match) {
              if (last == i) throw error_placement(`${prev} + ${match}`);
              last = i + 1;
              prev = match;
            }
          }
          if (last == n) throw error_placement(`trailing ${prev}`);
        }
        function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
          let buf = [];
          if (is_combining_mark(cps[0])) buf.push("");
          if (cps.length > max) {
            max >>= 1;
            cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
          }
          let prev = 0;
          let n = cps.length;
          for (let i = 0; i < n; i++) {
            let cp = cps[i];
            if (should_escape(cp)) {
              buf.push(str_from_cps(cps.slice(prev, i)));
              buf.push(quoter(cp));
              prev = i + 1;
            }
          }
          buf.push(str_from_cps(cps.slice(prev, n)));
          return buf.join("");
        }
        function is_combining_mark(cp) {
          init();
          return CM.has(cp);
        }
        function should_escape(cp) {
          init();
          return ESCAPE.has(cp);
        }
        function ens_normalize(name) {
          return flatten(split(name, nfc, filter_fe0f));
        }
        function split(name, nf, ef) {
          if (!name) return [];
          init();
          let offset = 0;
          return name.split(STOP_CH).map((label) => {
            let input = explode_cp(label);
            let info = { input: input, offset: offset };
            offset += input.length + 1;
            try {
              let tokens = (info.tokens = tokens_from_str(input, nf, ef));
              let token_count = tokens.length;
              let type;
              if (!token_count) {
                throw new Error(`empty label`);
              }
              let norm = (info.output = tokens.flat());
              check_leading_underscore(norm);
              let emoji = (info.emoji = token_count > 1 || tokens[0].is_emoji);
              if (!emoji && norm.every((cp) => cp < 128)) {
                check_label_extension(norm);
                type = "ASCII";
              } else {
                let chars = tokens.flatMap((x) => (x.is_emoji ? [] : x));
                if (!chars.length) {
                  type = "Emoji";
                } else {
                  if (CM.has(norm[0]))
                    throw error_placement("leading combining mark");
                  for (let i = 1; i < token_count; i++) {
                    let cps = tokens[i];
                    if (!cps.is_emoji && CM.has(cps[0])) {
                      throw error_placement(
                        `emoji + combining mark: "${str_from_cps(
                          tokens[i - 1]
                        )} + ${safe_str_from_cps([cps[0]])}"`
                      );
                    }
                  }
                  check_fenced(norm);
                  let unique = Array_from(new Set(chars));
                  let [g] = determine_group(unique);
                  check_group(g, chars);
                  check_whole(g, unique);
                  type = g.N;
                }
              }
              info.type = type;
            } catch (err) {
              info.error = err;
            }
            return info;
          });
        }
        function check_whole(group, unique) {
          let maker;
          let shared = [];
          for (let cp of unique) {
            let whole = WHOLE_MAP.get(cp);
            if (whole === UNIQUE_PH) return;
            if (whole) {
              let set = whole.M.get(cp);
              maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
              if (!maker.length) return;
            } else {
              shared.push(cp);
            }
          }
          if (maker) {
            for (let g of maker) {
              if (shared.every((cp) => group_has_cp(g, cp))) {
                throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
              }
            }
          }
        }
        function determine_group(unique) {
          let groups = GROUPS;
          for (let cp of unique) {
            let gs = groups.filter((g) => group_has_cp(g, cp));
            if (!gs.length) {
              if (!GROUPS.some((g) => group_has_cp(g, cp))) {
                throw error_disallowed(cp);
              } else {
                throw error_group_member(groups[0], cp);
              }
            }
            groups = gs;
            if (gs.length == 1) break;
          }
          return groups;
        }
        function flatten(split) {
          return split
            .map(({ input, error, output }) => {
              if (error) {
                let msg = error.message;
                throw new Error(
                  split.length == 1
                    ? msg
                    : `Invalid label ${bidi_qq(
                        safe_str_from_cps(input, 63)
                      )}: ${msg}`
                );
              }
              return str_from_cps(output);
            })
            .join(STOP_CH);
        }
        function error_disallowed(cp) {
          return new Error(`disallowed character: ${quoted_cp(cp)}`);
        }
        function error_group_member(g, cp) {
          let quoted = quoted_cp(cp);
          let gg = GROUPS.find((g) => g.P.has(cp));
          if (gg) {
            quoted = `${gg.N} ${quoted}`;
          }
          return new Error(`illegal mixture: ${g.N} + ${quoted}`);
        }
        function error_placement(where) {
          return new Error(`illegal placement: ${where}`);
        }
        function check_group(g, cps) {
          for (let cp of cps) {
            if (!group_has_cp(g, cp)) {
              throw error_group_member(g, cp);
            }
          }
          if (g.M) {
            let decomposed = nfd(cps);
            for (let i = 1, e = decomposed.length; i < e; i++) {
              if (NSM.has(decomposed[i])) {
                let j = i + 1;
                for (let cp; j < e && NSM.has((cp = decomposed[j])); j++) {
                  for (let k = i; k < j; k++) {
                    if (decomposed[k] == cp) {
                      throw new Error(
                        `duplicate non-spacing marks: ${quoted_cp(cp)}`
                      );
                    }
                  }
                }
                if (j - i > NSM_MAX) {
                  throw new Error(
                    `excessive non-spacing marks: ${bidi_qq(
                      safe_str_from_cps(decomposed.slice(i - 1, j))
                    )} (${j - i}/${NSM_MAX})`
                  );
                }
                i = j;
              }
            }
          }
        }
        function tokens_from_str(input, nf, ef) {
          let ret = [];
          let chars = [];
          input = input.slice().reverse();
          while (input.length) {
            let emoji = consume_emoji_reversed(input);
            if (emoji) {
              if (chars.length) {
                ret.push(nf(chars));
                chars = [];
              }
              ret.push(ef(emoji));
            } else {
              let cp = input.pop();
              if (VALID.has(cp)) {
                chars.push(cp);
              } else {
                let cps = MAPPED.get(cp);
                if (cps) {
                  chars.push(...cps);
                } else if (!IGNORED.has(cp)) {
                  throw error_disallowed(cp);
                }
              }
            }
          }
          if (chars.length) {
            ret.push(nf(chars));
          }
          return ret;
        }
        function filter_fe0f(cps) {
          return cps.filter((cp) => cp != FE0F);
        }
        function consume_emoji_reversed(cps, eaten) {
          let node = EMOJI_ROOT;
          let emoji;
          let pos = cps.length;
          while (pos) {
            node = node.get(cps[--pos]);
            if (!node) break;
            let { V } = node;
            if (V) {
              emoji = V;
              if (eaten) eaten.push(...cps.slice(pos).reverse());
              cps.length = pos;
            }
          }
          return emoji;
        }
        const Zeros = new Uint8Array(32);
        Zeros.fill(0);
        function checkComponent(comp) {
          assertArgument(
            comp.length !== 0,
            "invalid ENS name; empty component",
            "comp",
            comp
          );
          return comp;
        }
        function ensNameSplit(name) {
          const bytes = toUtf8Bytes(ensNormalize(name));
          const comps = [];
          if (name.length === 0) {
            return comps;
          }
          let last = 0;
          for (let i = 0; i < bytes.length; i++) {
            const d = bytes[i];
            if (d === 46) {
              comps.push(checkComponent(bytes.slice(last, i)));
              last = i + 1;
            }
          }
          assertArgument(
            last < bytes.length,
            "invalid ENS name; empty component",
            "name",
            name
          );
          comps.push(checkComponent(bytes.slice(last)));
          return comps;
        }
        function ensNormalize(name) {
          try {
            if (name.length === 0) {
              throw new Error("empty label");
            }
            return ens_normalize(name);
          } catch (error) {
            assertArgument(
              false,
              `invalid ENS name (${error.message})`,
              "name",
              name
            );
          }
        }
        function isValidName(name) {
          try {
            return ensNameSplit(name).length !== 0;
          } catch (error) {}
          return false;
        }
        function namehash(name) {
          assertArgument(
            typeof name === "string",
            "invalid ENS name; not a string",
            "name",
            name
          );
          assertArgument(
            name.length,
            `invalid ENS name (empty label)`,
            "name",
            name
          );
          let result = Zeros;
          const comps = ensNameSplit(name);
          while (comps.length) {
            result = keccak256(concat([result, keccak256(comps.pop())]));
          }
          return hexlify(result);
        }
        function dnsEncode(name, _maxLength) {
          const length = _maxLength != null ? _maxLength : 63;
          assertArgument(
            length <= 255,
            "DNS encoded label cannot exceed 255",
            "length",
            length
          );
          return (
            hexlify(
              concat(
                ensNameSplit(name).map((comp) => {
                  assertArgument(
                    comp.length <= length,
                    `label ${JSON.stringify(name)} exceeds ${length} bytes`,
                    "name",
                    name
                  );
                  const bytes = new Uint8Array(comp.length + 1);
                  bytes.set(comp, 1);
                  bytes[0] = bytes.length - 1;
                  return bytes;
                })
              )
            ) + "00"
          );
        }
        function accessSetify(addr, storageKeys) {
          return {
            address: getAddress(addr),
            storageKeys: storageKeys.map((storageKey, index) => {
              assertArgument(
                isHexString(storageKey, 32),
                "invalid slot",
                `storageKeys[${index}]`,
                storageKey
              );
              return storageKey.toLowerCase();
            }),
          };
        }
        function accessListify(value) {
          if (Array.isArray(value)) {
            return value.map((set, index) => {
              if (Array.isArray(set)) {
                assertArgument(
                  set.length === 2,
                  "invalid slot set",
                  `value[${index}]`,
                  set
                );
                return accessSetify(set[0], set[1]);
              }
              assertArgument(
                set != null && typeof set === "object",
                "invalid address-slot set",
                "value",
                value
              );
              return accessSetify(set.address, set.storageKeys);
            });
          }
          assertArgument(
            value != null && typeof value === "object",
            "invalid access list",
            "value",
            value
          );
          const result = Object.keys(value).map((addr) => {
            const storageKeys = value[addr].reduce((accum, storageKey) => {
              accum[storageKey] = true;
              return accum;
            }, {});
            return accessSetify(addr, Object.keys(storageKeys).sort());
          });
          result.sort((a, b) => a.address.localeCompare(b.address));
          return result;
        }
        function computeAddress(key) {
          let pubkey;
          if (typeof key === "string") {
            pubkey = SigningKey.computePublicKey(key, false);
          } else {
            pubkey = key.publicKey;
          }
          return getAddress(
            keccak256("0x" + pubkey.substring(4)).substring(26)
          );
        }
        function recoverAddress(digest, signature) {
          return computeAddress(SigningKey.recoverPublicKey(digest, signature));
        }
        const BN_0$4 = BigInt(0);
        const BN_2$2 = BigInt(2);
        const BN_27 = BigInt(27);
        const BN_28 = BigInt(28);
        const BN_35 = BigInt(35);
        const BN_MAX_UINT = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
        function handleAddress(value) {
          if (value === "0x") {
            return null;
          }
          return getAddress(value);
        }
        function handleAccessList(value, param) {
          try {
            return accessListify(value);
          } catch (error) {
            assertArgument(false, error.message, param, value);
          }
        }
        function handleNumber(_value, param) {
          if (_value === "0x") {
            return 0;
          }
          return getNumber(_value, param);
        }
        function handleUint(_value, param) {
          if (_value === "0x") {
            return BN_0$4;
          }
          const value = getBigInt(_value, param);
          assertArgument(
            value <= BN_MAX_UINT,
            "value exceeds uint size",
            param,
            value
          );
          return value;
        }
        function formatNumber(_value, name) {
          const value = getBigInt(_value, "value");
          const result = toBeArray(value);
          assertArgument(
            result.length <= 32,
            `value too large`,
            `tx.${name}`,
            value
          );
          return result;
        }
        function formatAccessList(value) {
          return accessListify(value).map((set) => [
            set.address,
            set.storageKeys,
          ]);
        }
        function formatHashes(value, param) {
          assertArgument(
            Array.isArray(value),
            `invalid ${param}`,
            "value",
            value
          );
          for (let i = 0; i < value.length; i++) {
            assertArgument(
              isHexString(value[i], 32),
              "invalid ${ param } hash",
              `value[${i}]`,
              value[i]
            );
          }
          return value;
        }
        function _parseLegacy(data) {
          const fields = decodeRlp(data);
          assertArgument(
            Array.isArray(fields) &&
              (fields.length === 9 || fields.length === 6),
            "invalid field count for legacy transaction",
            "data",
            data
          );
          const tx = {
            type: 0,
            nonce: handleNumber(fields[0], "nonce"),
            gasPrice: handleUint(fields[1], "gasPrice"),
            gasLimit: handleUint(fields[2], "gasLimit"),
            to: handleAddress(fields[3]),
            value: handleUint(fields[4], "value"),
            data: hexlify(fields[5]),
            chainId: BN_0$4,
          };
          if (fields.length === 6) {
            return tx;
          }
          const v = handleUint(fields[6], "v");
          const r = handleUint(fields[7], "r");
          const s = handleUint(fields[8], "s");
          if (r === BN_0$4 && s === BN_0$4) {
            tx.chainId = v;
          } else {
            let chainId = (v - BN_35) / BN_2$2;
            if (chainId < BN_0$4) {
              chainId = BN_0$4;
            }
            tx.chainId = chainId;
            assertArgument(
              chainId !== BN_0$4 || v === BN_27 || v === BN_28,
              "non-canonical legacy v",
              "v",
              fields[6]
            );
            tx.signature = Signature.from({
              r: zeroPadValue(fields[7], 32),
              s: zeroPadValue(fields[8], 32),
              v: v,
            });
            tx.hash = keccak256(data);
          }
          return tx;
        }
        function _serializeLegacy(tx, sig) {
          const fields = [
            formatNumber(tx.nonce, "nonce"),
            formatNumber(tx.gasPrice || 0, "gasPrice"),
            formatNumber(tx.gasLimit, "gasLimit"),
            tx.to || "0x",
            formatNumber(tx.value, "value"),
            tx.data,
          ];
          let chainId = BN_0$4;
          if (tx.chainId != BN_0$4) {
            chainId = getBigInt(tx.chainId, "tx.chainId");
            assertArgument(
              !sig || sig.networkV == null || sig.legacyChainId === chainId,
              "tx.chainId/sig.v mismatch",
              "sig",
              sig
            );
          } else if (tx.signature) {
            const legacy = tx.signature.legacyChainId;
            if (legacy != null) {
              chainId = legacy;
            }
          }
          if (!sig) {
            if (chainId !== BN_0$4) {
              fields.push(toBeArray(chainId));
              fields.push("0x");
              fields.push("0x");
            }
            return encodeRlp(fields);
          }
          let v = BigInt(27 + sig.yParity);
          if (chainId !== BN_0$4) {
            v = Signature.getChainIdV(chainId, sig.v);
          } else if (BigInt(sig.v) !== v) {
            assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
          }
          fields.push(toBeArray(v));
          fields.push(toBeArray(sig.r));
          fields.push(toBeArray(sig.s));
          return encodeRlp(fields);
        }
        function _parseEipSignature(tx, fields) {
          let yParity;
          try {
            yParity = handleNumber(fields[0], "yParity");
            if (yParity !== 0 && yParity !== 1) {
              throw new Error("bad yParity");
            }
          } catch (error) {
            assertArgument(false, "invalid yParity", "yParity", fields[0]);
          }
          const r = zeroPadValue(fields[1], 32);
          const s = zeroPadValue(fields[2], 32);
          const signature = Signature.from({ r: r, s: s, yParity: yParity });
          tx.signature = signature;
        }
        function _parseEip1559(data) {
          const fields = decodeRlp(getBytes(data).slice(1));
          assertArgument(
            Array.isArray(fields) &&
              (fields.length === 9 || fields.length === 12),
            "invalid field count for transaction type: 2",
            "data",
            hexlify(data)
          );
          const tx = {
            type: 2,
            chainId: handleUint(fields[0], "chainId"),
            nonce: handleNumber(fields[1], "nonce"),
            maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
            maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
            gasPrice: null,
            gasLimit: handleUint(fields[4], "gasLimit"),
            to: handleAddress(fields[5]),
            value: handleUint(fields[6], "value"),
            data: hexlify(fields[7]),
            accessList: handleAccessList(fields[8], "accessList"),
          };
          if (fields.length === 9) {
            return tx;
          }
          tx.hash = keccak256(data);
          _parseEipSignature(tx, fields.slice(9));
          return tx;
        }
        function _serializeEip1559(tx, sig) {
          const fields = [
            formatNumber(tx.chainId, "chainId"),
            formatNumber(tx.nonce, "nonce"),
            formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
            formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
            formatNumber(tx.gasLimit, "gasLimit"),
            tx.to || "0x",
            formatNumber(tx.value, "value"),
            tx.data,
            formatAccessList(tx.accessList || []),
          ];
          if (sig) {
            fields.push(formatNumber(sig.yParity, "yParity"));
            fields.push(toBeArray(sig.r));
            fields.push(toBeArray(sig.s));
          }
          return concat(["0x02", encodeRlp(fields)]);
        }
        function _parseEip2930(data) {
          const fields = decodeRlp(getBytes(data).slice(1));
          assertArgument(
            Array.isArray(fields) &&
              (fields.length === 8 || fields.length === 11),
            "invalid field count for transaction type: 1",
            "data",
            hexlify(data)
          );
          const tx = {
            type: 1,
            chainId: handleUint(fields[0], "chainId"),
            nonce: handleNumber(fields[1], "nonce"),
            gasPrice: handleUint(fields[2], "gasPrice"),
            gasLimit: handleUint(fields[3], "gasLimit"),
            to: handleAddress(fields[4]),
            value: handleUint(fields[5], "value"),
            data: hexlify(fields[6]),
            accessList: handleAccessList(fields[7], "accessList"),
          };
          if (fields.length === 8) {
            return tx;
          }
          tx.hash = keccak256(data);
          _parseEipSignature(tx, fields.slice(8));
          return tx;
        }
        function _serializeEip2930(tx, sig) {
          const fields = [
            formatNumber(tx.chainId, "chainId"),
            formatNumber(tx.nonce, "nonce"),
            formatNumber(tx.gasPrice || 0, "gasPrice"),
            formatNumber(tx.gasLimit, "gasLimit"),
            tx.to || "0x",
            formatNumber(tx.value, "value"),
            tx.data,
            formatAccessList(tx.accessList || []),
          ];
          if (sig) {
            fields.push(formatNumber(sig.yParity, "recoveryParam"));
            fields.push(toBeArray(sig.r));
            fields.push(toBeArray(sig.s));
          }
          return concat(["0x01", encodeRlp(fields)]);
        }
        function _parseEip4844(data) {
          const fields = decodeRlp(getBytes(data).slice(1));
          assertArgument(
            Array.isArray(fields) &&
              (fields.length === 11 || fields.length === 14),
            "invalid field count for transaction type: 3",
            "data",
            hexlify(data)
          );
          const tx = {
            type: 3,
            chainId: handleUint(fields[0], "chainId"),
            nonce: handleNumber(fields[1], "nonce"),
            maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
            maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
            gasPrice: null,
            gasLimit: handleUint(fields[4], "gasLimit"),
            to: handleAddress(fields[5]),
            value: handleUint(fields[6], "value"),
            data: hexlify(fields[7]),
            accessList: handleAccessList(fields[8], "accessList"),
            maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
            blobVersionedHashes: fields[10],
          };
          assertArgument(
            tx.to != null,
            "invalid address for transaction type: 3",
            "data",
            data
          );
          assertArgument(
            Array.isArray(tx.blobVersionedHashes),
            "invalid blobVersionedHashes: must be an array",
            "data",
            data
          );
          for (let i = 0; i < tx.blobVersionedHashes.length; i++) {
            assertArgument(
              isHexString(tx.blobVersionedHashes[i], 32),
              `invalid blobVersionedHash at index ${i}: must be length 32`,
              "data",
              data
            );
          }
          if (fields.length === 11) {
            return tx;
          }
          tx.hash = keccak256(data);
          _parseEipSignature(tx, fields.slice(11));
          return tx;
        }
        function _serializeEip4844(tx, sig) {
          const fields = [
            formatNumber(tx.chainId, "chainId"),
            formatNumber(tx.nonce, "nonce"),
            formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
            formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
            formatNumber(tx.gasLimit, "gasLimit"),
            tx.to || ZeroAddress,
            formatNumber(tx.value, "value"),
            tx.data,
            formatAccessList(tx.accessList || []),
            formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
            formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes"),
          ];
          if (sig) {
            fields.push(formatNumber(sig.yParity, "yParity"));
            fields.push(toBeArray(sig.r));
            fields.push(toBeArray(sig.s));
          }
          return concat(["0x03", encodeRlp(fields)]);
        }
        class Transaction {
          #type;
          #to;
          #data;
          #nonce;
          #gasLimit;
          #gasPrice;
          #maxPriorityFeePerGas;
          #maxFeePerGas;
          #value;
          #chainId;
          #sig;
          #accessList;
          #maxFeePerBlobGas;
          #blobVersionedHashes;
          get type() {
            return this.#type;
          }
          set type(value) {
            switch (value) {
              case null:
                this.#type = null;
                break;
              case 0:
              case "legacy":
                this.#type = 0;
                break;
              case 1:
              case "berlin":
              case "eip-2930":
                this.#type = 1;
                break;
              case 2:
              case "london":
              case "eip-1559":
                this.#type = 2;
                break;
              case 3:
              case "cancun":
              case "eip-4844":
                this.#type = 3;
                break;
              default:
                assertArgument(
                  false,
                  "unsupported transaction type",
                  "type",
                  value
                );
            }
          }
          get typeName() {
            switch (this.type) {
              case 0:
                return "legacy";
              case 1:
                return "eip-2930";
              case 2:
                return "eip-1559";
              case 3:
                return "eip-4844";
            }
            return null;
          }
          get to() {
            const value = this.#to;
            if (value == null && this.type === 3) {
              return ZeroAddress;
            }
            return value;
          }
          set to(value) {
            this.#to = value == null ? null : getAddress(value);
          }
          get nonce() {
            return this.#nonce;
          }
          set nonce(value) {
            this.#nonce = getNumber(value, "value");
          }
          get gasLimit() {
            return this.#gasLimit;
          }
          set gasLimit(value) {
            this.#gasLimit = getBigInt(value);
          }
          get gasPrice() {
            const value = this.#gasPrice;
            if (value == null && (this.type === 0 || this.type === 1)) {
              return BN_0$4;
            }
            return value;
          }
          set gasPrice(value) {
            this.#gasPrice =
              value == null ? null : getBigInt(value, "gasPrice");
          }
          get maxPriorityFeePerGas() {
            const value = this.#maxPriorityFeePerGas;
            if (value == null) {
              if (this.type === 2 || this.type === 3) {
                return BN_0$4;
              }
              return null;
            }
            return value;
          }
          set maxPriorityFeePerGas(value) {
            this.#maxPriorityFeePerGas =
              value == null ? null : getBigInt(value, "maxPriorityFeePerGas");
          }
          get maxFeePerGas() {
            const value = this.#maxFeePerGas;
            if (value == null) {
              if (this.type === 2 || this.type === 3) {
                return BN_0$4;
              }
              return null;
            }
            return value;
          }
          set maxFeePerGas(value) {
            this.#maxFeePerGas =
              value == null ? null : getBigInt(value, "maxFeePerGas");
          }
          get data() {
            return this.#data;
          }
          set data(value) {
            this.#data = hexlify(value);
          }
          get value() {
            return this.#value;
          }
          set value(value) {
            this.#value = getBigInt(value, "value");
          }
          get chainId() {
            return this.#chainId;
          }
          set chainId(value) {
            this.#chainId = getBigInt(value);
          }
          get signature() {
            return this.#sig || null;
          }
          set signature(value) {
            this.#sig = value == null ? null : Signature.from(value);
          }
          get accessList() {
            const value = this.#accessList || null;
            if (value == null) {
              if (this.type === 1 || this.type === 2 || this.type === 3) {
                return [];
              }
              return null;
            }
            return value;
          }
          set accessList(value) {
            this.#accessList = value == null ? null : accessListify(value);
          }
          get maxFeePerBlobGas() {
            const value = this.#maxFeePerBlobGas;
            if (value == null && this.type === 3) {
              return BN_0$4;
            }
            return value;
          }
          set maxFeePerBlobGas(value) {
            this.#maxFeePerBlobGas =
              value == null ? null : getBigInt(value, "maxFeePerBlobGas");
          }
          get blobVersionedHashes() {
            let value = this.#blobVersionedHashes;
            if (value == null && this.type === 3) {
              return [];
            }
            return value;
          }
          set blobVersionedHashes(value) {
            if (value != null) {
              assertArgument(
                Array.isArray(value),
                "blobVersionedHashes must be an Array",
                "value",
                value
              );
              value = value.slice();
              for (let i = 0; i < value.length; i++) {
                assertArgument(
                  isHexString(value[i], 32),
                  "invalid blobVersionedHash",
                  `value[${i}]`,
                  value[i]
                );
              }
            }
            this.#blobVersionedHashes = value;
          }
          constructor() {
            this.#type = null;
            this.#to = null;
            this.#nonce = 0;
            this.#gasLimit = BN_0$4;
            this.#gasPrice = null;
            this.#maxPriorityFeePerGas = null;
            this.#maxFeePerGas = null;
            this.#data = "0x";
            this.#value = BN_0$4;
            this.#chainId = BN_0$4;
            this.#sig = null;
            this.#accessList = null;
            this.#maxFeePerBlobGas = null;
            this.#blobVersionedHashes = null;
          }
          get hash() {
            if (this.signature == null) {
              return null;
            }
            return keccak256(this.serialized);
          }
          get unsignedHash() {
            return keccak256(this.unsignedSerialized);
          }
          get from() {
            if (this.signature == null) {
              return null;
            }
            return recoverAddress(this.unsignedHash, this.signature);
          }
          get fromPublicKey() {
            if (this.signature == null) {
              return null;
            }
            return SigningKey.recoverPublicKey(
              this.unsignedHash,
              this.signature
            );
          }
          isSigned() {
            return this.signature != null;
          }
          get serialized() {
            assert(
              this.signature != null,
              "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
              "UNSUPPORTED_OPERATION",
              { operation: ".serialized" }
            );
            switch (this.inferType()) {
              case 0:
                return _serializeLegacy(this, this.signature);
              case 1:
                return _serializeEip2930(this, this.signature);
              case 2:
                return _serializeEip1559(this, this.signature);
              case 3:
                return _serializeEip4844(this, this.signature);
            }
            assert(
              false,
              "unsupported transaction type",
              "UNSUPPORTED_OPERATION",
              { operation: ".serialized" }
            );
          }
          get unsignedSerialized() {
            switch (this.inferType()) {
              case 0:
                return _serializeLegacy(this);
              case 1:
                return _serializeEip2930(this);
              case 2:
                return _serializeEip1559(this);
              case 3:
                return _serializeEip4844(this);
            }
            assert(
              false,
              "unsupported transaction type",
              "UNSUPPORTED_OPERATION",
              { operation: ".unsignedSerialized" }
            );
          }
          inferType() {
            const types = this.inferTypes();
            if (types.indexOf(2) >= 0) {
              return 2;
            }
            return types.pop();
          }
          inferTypes() {
            const hasGasPrice = this.gasPrice != null;
            const hasFee =
              this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
            const hasAccessList = this.accessList != null;
            const hasBlob =
              this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;
            if (
              this.maxFeePerGas != null &&
              this.maxPriorityFeePerGas != null
            ) {
              assert(
                this.maxFeePerGas >= this.maxPriorityFeePerGas,
                "priorityFee cannot be more than maxFee",
                "BAD_DATA",
                { value: this }
              );
            }
            assert(
              !hasFee || (this.type !== 0 && this.type !== 1),
              "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
              "BAD_DATA",
              { value: this }
            );
            assert(
              this.type !== 0 || !hasAccessList,
              "legacy transaction cannot have accessList",
              "BAD_DATA",
              { value: this }
            );
            const types = [];
            if (this.type != null) {
              types.push(this.type);
            } else {
              if (hasFee) {
                types.push(2);
              } else if (hasGasPrice) {
                types.push(1);
                if (!hasAccessList) {
                  types.push(0);
                }
              } else if (hasAccessList) {
                types.push(1);
                types.push(2);
              } else if (hasBlob && this.to) {
                types.push(3);
              } else {
                types.push(0);
                types.push(1);
                types.push(2);
                types.push(3);
              }
            }
            types.sort();
            return types;
          }
          isLegacy() {
            return this.type === 0;
          }
          isBerlin() {
            return this.type === 1;
          }
          isLondon() {
            return this.type === 2;
          }
          isCancun() {
            return this.type === 3;
          }
          clone() {
            return Transaction.from(this);
          }
          toJSON() {
            const s = (v) => {
              if (v == null) {
                return null;
              }
              return v.toString();
            };
            return {
              type: this.type,
              to: this.to,
              data: this.data,
              nonce: this.nonce,
              gasLimit: s(this.gasLimit),
              gasPrice: s(this.gasPrice),
              maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
              maxFeePerGas: s(this.maxFeePerGas),
              value: s(this.value),
              chainId: s(this.chainId),
              sig: this.signature ? this.signature.toJSON() : null,
              accessList: this.accessList,
            };
          }
          static from(tx) {
            if (tx == null) {
              return new Transaction();
            }
            if (typeof tx === "string") {
              const payload = getBytes(tx);
              if (payload[0] >= 127) {
                return Transaction.from(_parseLegacy(payload));
              }
              switch (payload[0]) {
                case 1:
                  return Transaction.from(_parseEip2930(payload));
                case 2:
                  return Transaction.from(_parseEip1559(payload));
                case 3:
                  return Transaction.from(_parseEip4844(payload));
              }
              assert(
                false,
                "unsupported transaction type",
                "UNSUPPORTED_OPERATION",
                { operation: "from" }
              );
            }
            const result = new Transaction();
            if (tx.type != null) {
              result.type = tx.type;
            }
            if (tx.to != null) {
              result.to = tx.to;
            }
            if (tx.nonce != null) {
              result.nonce = tx.nonce;
            }
            if (tx.gasLimit != null) {
              result.gasLimit = tx.gasLimit;
            }
            if (tx.gasPrice != null) {
              result.gasPrice = tx.gasPrice;
            }
            if (tx.maxPriorityFeePerGas != null) {
              result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
            }
            if (tx.maxFeePerGas != null) {
              result.maxFeePerGas = tx.maxFeePerGas;
            }
            if (tx.maxFeePerBlobGas != null) {
              result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
            }
            if (tx.data != null) {
              result.data = tx.data;
            }
            if (tx.value != null) {
              result.value = tx.value;
            }
            if (tx.chainId != null) {
              result.chainId = tx.chainId;
            }
            if (tx.signature != null) {
              result.signature = Signature.from(tx.signature);
            }
            if (tx.accessList != null) {
              result.accessList = tx.accessList;
            }
            if (tx.blobVersionedHashes != null) {
              result.blobVersionedHashes = tx.blobVersionedHashes;
            }
            if (tx.hash != null) {
              assertArgument(
                result.isSigned(),
                "unsigned transaction cannot define hash",
                "tx",
                tx
              );
              assertArgument(
                result.hash === tx.hash,
                "hash mismatch",
                "tx",
                tx
              );
            }
            if (tx.from != null) {
              assertArgument(
                result.isSigned(),
                "unsigned transaction cannot define from",
                "tx",
                tx
              );
              assertArgument(
                result.from.toLowerCase() === (tx.from || "").toLowerCase(),
                "from mismatch",
                "tx",
                tx
              );
            }
            return result;
          }
        }
        function hashMessage(message) {
          if (typeof message === "string") {
            message = toUtf8Bytes(message);
          }
          return keccak256(
            concat([
              toUtf8Bytes(MessagePrefix),
              toUtf8Bytes(String(message.length)),
              message,
            ])
          );
        }
        function verifyMessage(message, sig) {
          const digest = hashMessage(message);
          return recoverAddress(digest, sig);
        }
        const regexBytes = new RegExp("^bytes([0-9]+)$");
        const regexNumber = new RegExp("^(u?int)([0-9]*)$");
        const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
        function _pack(type, value, isArray) {
          switch (type) {
            case "address":
              if (isArray) {
                return getBytes(zeroPadValue(value, 32));
              }
              return getBytes(getAddress(value));
            case "string":
              return toUtf8Bytes(value);
            case "bytes":
              return getBytes(value);
            case "bool":
              value = !!value ? "0x01" : "0x00";
              if (isArray) {
                return getBytes(zeroPadValue(value, 32));
              }
              return getBytes(value);
          }
          let match = type.match(regexNumber);
          if (match) {
            let signed = match[1] === "int";
            let size = parseInt(match[2] || "256");
            assertArgument(
              (!match[2] || match[2] === String(size)) &&
                size % 8 === 0 &&
                size !== 0 &&
                size <= 256,
              "invalid number type",
              "type",
              type
            );
            if (isArray) {
              size = 256;
            }
            if (signed) {
              value = toTwos(value, size);
            }
            return getBytes(zeroPadValue(toBeArray(value), size / 8));
          }
          match = type.match(regexBytes);
          if (match) {
            const size = parseInt(match[1]);
            assertArgument(
              String(size) === match[1] && size !== 0 && size <= 32,
              "invalid bytes type",
              "type",
              type
            );
            assertArgument(
              dataLength(value) === size,
              `invalid value for ${type}`,
              "value",
              value
            );
            if (isArray) {
              return getBytes(zeroPadBytes(value, 32));
            }
            return value;
          }
          match = type.match(regexArray);
          if (match && Array.isArray(value)) {
            const baseType = match[1];
            const count = parseInt(match[2] || String(value.length));
            assertArgument(
              count === value.length,
              `invalid array length for ${type}`,
              "value",
              value
            );
            const result = [];
            value.forEach(function (value) {
              result.push(_pack(baseType, value, true));
            });
            return getBytes(concat(result));
          }
          assertArgument(false, "invalid type", "type", type);
        }
        function solidityPacked(types, values) {
          assertArgument(
            types.length === values.length,
            "wrong number of values; expected ${ types.length }",
            "values",
            values
          );
          const tight = [];
          types.forEach(function (type, index) {
            tight.push(_pack(type, values[index]));
          });
          return hexlify(concat(tight));
        }
        function solidityPackedKeccak256(types, values) {
          return keccak256(solidityPacked(types, values));
        }
        function solidityPackedSha256(types, values) {
          return sha256(solidityPacked(types, values));
        }
        const padding = new Uint8Array(32);
        padding.fill(0);
        const BN__1 = BigInt(-1);
        const BN_0$3 = BigInt(0);
        const BN_1$1 = BigInt(1);
        const BN_MAX_UINT256 = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
        function hexPadRight(value) {
          const bytes = getBytes(value);
          const padOffset = bytes.length % 32;
          if (padOffset) {
            return concat([bytes, padding.slice(padOffset)]);
          }
          return hexlify(bytes);
        }
        const hexTrue = toBeHex(BN_1$1, 32);
        const hexFalse = toBeHex(BN_0$3, 32);
        const domainFieldTypes = {
          name: "string",
          version: "string",
          chainId: "uint256",
          verifyingContract: "address",
          salt: "bytes32",
        };
        const domainFieldNames = [
          "name",
          "version",
          "chainId",
          "verifyingContract",
          "salt",
        ];
        function checkString(key) {
          return function (value) {
            assertArgument(
              typeof value === "string",
              `invalid domain value for ${JSON.stringify(key)}`,
              `domain.${key}`,
              value
            );
            return value;
          };
        }
        const domainChecks = {
          name: checkString("name"),
          version: checkString("version"),
          chainId: function (_value) {
            const value = getBigInt(_value, "domain.chainId");
            assertArgument(
              value >= 0,
              "invalid chain ID",
              "domain.chainId",
              _value
            );
            if (Number.isSafeInteger(value)) {
              return Number(value);
            }
            return toQuantity(value);
          },
          verifyingContract: function (value) {
            try {
              return getAddress(value).toLowerCase();
            } catch (error) {}
            assertArgument(
              false,
              `invalid domain value "verifyingContract"`,
              "domain.verifyingContract",
              value
            );
          },
          salt: function (value) {
            const bytes = getBytes(value, "domain.salt");
            assertArgument(
              bytes.length === 32,
              `invalid domain value "salt"`,
              "domain.salt",
              value
            );
            return hexlify(bytes);
          },
        };
        function getBaseEncoder(type) {
          {
            const match = type.match(/^(u?)int(\d+)$/);
            if (match) {
              const signed = match[1] === "";
              const width = parseInt(match[2]);
              assertArgument(
                width % 8 === 0 &&
                  width !== 0 &&
                  width <= 256 &&
                  match[2] === String(width),
                "invalid numeric width",
                "type",
                type
              );
              const boundsUpper = mask(
                BN_MAX_UINT256,
                signed ? width - 1 : width
              );
              const boundsLower = signed
                ? (boundsUpper + BN_1$1) * BN__1
                : BN_0$3;
              return function (_value) {
                const value = getBigInt(_value, "value");
                assertArgument(
                  value >= boundsLower && value <= boundsUpper,
                  `value out-of-bounds for ${type}`,
                  "value",
                  value
                );
                return toBeHex(signed ? toTwos(value, 256) : value, 32);
              };
            }
          }
          {
            const match = type.match(/^bytes(\d+)$/);
            if (match) {
              const width = parseInt(match[1]);
              assertArgument(
                width !== 0 && width <= 32 && match[1] === String(width),
                "invalid bytes width",
                "type",
                type
              );
              return function (value) {
                const bytes = getBytes(value);
                assertArgument(
                  bytes.length === width,
                  `invalid length for ${type}`,
                  "value",
                  value
                );
                return hexPadRight(value);
              };
            }
          }
          switch (type) {
            case "address":
              return function (value) {
                return zeroPadValue(getAddress(value), 32);
              };
            case "bool":
              return function (value) {
                return !value ? hexFalse : hexTrue;
              };
            case "bytes":
              return function (value) {
                return keccak256(value);
              };
            case "string":
              return function (value) {
                return id(value);
              };
          }
          return null;
        }
        function encodeType(name, fields) {
          return `${name}(${fields.map(({ name, type }) => type + " " + name).join(",")})`;
        }
        function splitArray(type) {
          const match = type.match(
            /^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/
          );
          if (match) {
            return {
              base: match[1],
              index: match[2] + match[4],
              array: {
                base: match[1],
                prefix: match[1] + match[2],
                count: match[5] ? parseInt(match[5]) : -1,
              },
            };
          }
          return { base: type };
        }
        class TypedDataEncoder {
          primaryType;
          #types;
          get types() {
            return JSON.parse(this.#types);
          }
          #fullTypes;
          #encoderCache;
          constructor(_types) {
            this.#fullTypes = new Map();
            this.#encoderCache = new Map();
            const links = new Map();
            const parents = new Map();
            const subtypes = new Map();
            const types = {};
            Object.keys(_types).forEach((type) => {
              types[type] = _types[type].map(({ name, type }) => {
                let { base, index } = splitArray(type);
                if (base === "int" && !_types["int"]) {
                  base = "int256";
                }
                if (base === "uint" && !_types["uint"]) {
                  base = "uint256";
                }
                return { name: name, type: base + (index || "") };
              });
              links.set(type, new Set());
              parents.set(type, []);
              subtypes.set(type, new Set());
            });
            this.#types = JSON.stringify(types);
            for (const name in types) {
              const uniqueNames = new Set();
              for (const field of types[name]) {
                assertArgument(
                  !uniqueNames.has(field.name),
                  `duplicate variable name ${JSON.stringify(
                    field.name
                  )} in ${JSON.stringify(name)}`,
                  "types",
                  _types
                );
                uniqueNames.add(field.name);
                const baseType = splitArray(field.type).base;
                assertArgument(
                  baseType !== name,
                  `circular type reference to ${JSON.stringify(baseType)}`,
                  "types",
                  _types
                );
                const encoder = getBaseEncoder(baseType);
                if (encoder) {
                  continue;
                }
                assertArgument(
                  parents.has(baseType),
                  `unknown type ${JSON.stringify(baseType)}`,
                  "types",
                  _types
                );
                parents.get(baseType).push(name);
                links.get(name).add(baseType);
              }
            }
            const primaryTypes = Array.from(parents.keys()).filter(
              (n) => parents.get(n).length === 0
            );
            assertArgument(
              primaryTypes.length !== 0,
              "missing primary type",
              "types",
              _types
            );
            assertArgument(
              primaryTypes.length === 1,
              `ambiguous primary types or unused types: ${primaryTypes
                .map((t) => JSON.stringify(t))
                .join(", ")}`,
              "types",
              _types
            );
            defineProperties(this, { primaryType: primaryTypes[0] });
            function checkCircular(type, found) {
              assertArgument(
                !found.has(type),
                `circular type reference to ${JSON.stringify(type)}`,
                "types",
                _types
              );
              found.add(type);
              for (const child of links.get(type)) {
                if (!parents.has(child)) {
                  continue;
                }
                checkCircular(child, found);
                for (const subtype of found) {
                  subtypes.get(subtype).add(child);
                }
              }
              found.delete(type);
            }
            checkCircular(this.primaryType, new Set());
            for (const [name, set] of subtypes) {
              const st = Array.from(set);
              st.sort();
              this.#fullTypes.set(
                name,
                encodeType(name, types[name]) +
                  st.map((t) => encodeType(t, types[t])).join("")
              );
            }
          }
          getEncoder(type) {
            let encoder = this.#encoderCache.get(type);
            if (!encoder) {
              encoder = this.#getEncoder(type);
              this.#encoderCache.set(type, encoder);
            }
            return encoder;
          }
          #getEncoder(type) {
            {
              const encoder = getBaseEncoder(type);
              if (encoder) {
                return encoder;
              }
            }
            const array = splitArray(type).array;
            if (array) {
              const subtype = array.prefix;
              const subEncoder = this.getEncoder(subtype);
              return (value) => {
                assertArgument(
                  array.count === -1 || array.count === value.length,
                  `array length mismatch; expected length ${array.count}`,
                  "value",
                  value
                );
                let result = value.map(subEncoder);
                if (this.#fullTypes.has(subtype)) {
                  result = result.map(keccak256);
                }
                return keccak256(concat(result));
              };
            }
            const fields = this.types[type];
            if (fields) {
              const encodedType = id(this.#fullTypes.get(type));
              return (value) => {
                const values = fields.map(({ name, type }) => {
                  const result = this.getEncoder(type)(value[name]);
                  if (this.#fullTypes.has(type)) {
                    return keccak256(result);
                  }
                  return result;
                });
                values.unshift(encodedType);
                return concat(values);
              };
            }
            assertArgument(false, `unknown type: ${type}`, "type", type);
          }
          encodeType(name) {
            const result = this.#fullTypes.get(name);
            assertArgument(
              result,
              `unknown type: ${JSON.stringify(name)}`,
              "name",
              name
            );
            return result;
          }
          encodeData(type, value) {
            return this.getEncoder(type)(value);
          }
          hashStruct(name, value) {
            return keccak256(this.encodeData(name, value));
          }
          encode(value) {
            return this.encodeData(this.primaryType, value);
          }
          hash(value) {
            return this.hashStruct(this.primaryType, value);
          }
          _visit(type, value, callback) {
            {
              const encoder = getBaseEncoder(type);
              if (encoder) {
                return callback(type, value);
              }
            }
            const array = splitArray(type).array;
            if (array) {
              assertArgument(
                array.count === -1 || array.count === value.length,
                `array length mismatch; expected length ${array.count}`,
                "value",
                value
              );
              return value.map((v) => this._visit(array.prefix, v, callback));
            }
            const fields = this.types[type];
            if (fields) {
              return fields.reduce((accum, { name, type }) => {
                accum[name] = this._visit(type, value[name], callback);
                return accum;
              }, {});
            }
            assertArgument(false, `unknown type: ${type}`, "type", type);
          }
          visit(value, callback) {
            return this._visit(this.primaryType, value, callback);
          }
          static from(types) {
            return new TypedDataEncoder(types);
          }
          static getPrimaryType(types) {
            return TypedDataEncoder.from(types).primaryType;
          }
          static hashStruct(name, types, value) {
            return TypedDataEncoder.from(types).hashStruct(name, value);
          }
          static hashDomain(domain) {
            const domainFields = [];
            for (const name in domain) {
              if (domain[name] == null) {
                continue;
              }
              const type = domainFieldTypes[name];
              assertArgument(
                type,
                `invalid typed-data domain key: ${JSON.stringify(name)}`,
                "domain",
                domain
              );
              domainFields.push({ name: name, type: type });
            }
            domainFields.sort((a, b) => {
              return (
                domainFieldNames.indexOf(a.name) -
                domainFieldNames.indexOf(b.name)
              );
            });
            return TypedDataEncoder.hashStruct(
              "EIP712Domain",
              { EIP712Domain: domainFields },
              domain
            );
          }
          static encode(domain, types, value) {
            return concat([
              "0x1901",
              TypedDataEncoder.hashDomain(domain),
              TypedDataEncoder.from(types).hash(value),
            ]);
          }
          static hash(domain, types, value) {
            return keccak256(TypedDataEncoder.encode(domain, types, value));
          }
          static async resolveNames(domain, types, value, resolveName) {
            domain = Object.assign({}, domain);
            for (const key in domain) {
              if (domain[key] == null) {
                delete domain[key];
              }
            }
            const ensCache = {};
            if (
              domain.verifyingContract &&
              !isHexString(domain.verifyingContract, 20)
            ) {
              ensCache[domain.verifyingContract] = "0x";
            }
            const encoder = TypedDataEncoder.from(types);
            encoder.visit(value, (type, value) => {
              if (type === "address" && !isHexString(value, 20)) {
                ensCache[value] = "0x";
              }
              return value;
            });
            for (const name in ensCache) {
              ensCache[name] = await resolveName(name);
            }
            if (
              domain.verifyingContract &&
              ensCache[domain.verifyingContract]
            ) {
              domain.verifyingContract = ensCache[domain.verifyingContract];
            }
            value = encoder.visit(value, (type, value) => {
              if (type === "address" && ensCache[value]) {
                return ensCache[value];
              }
              return value;
            });
            return { domain: domain, value: value };
          }
          static getPayload(domain, types, value) {
            TypedDataEncoder.hashDomain(domain);
            const domainValues = {};
            const domainTypes = [];
            domainFieldNames.forEach((name) => {
              const value = domain[name];
              if (value == null) {
                return;
              }
              domainValues[name] = domainChecks[name](value);
              domainTypes.push({ name: name, type: domainFieldTypes[name] });
            });
            const encoder = TypedDataEncoder.from(types);
            types = encoder.types;
            const typesWithDomain = Object.assign({}, types);
            assertArgument(
              typesWithDomain.EIP712Domain == null,
              "types must not contain EIP712Domain type",
              "types.EIP712Domain",
              types
            );
            typesWithDomain.EIP712Domain = domainTypes;
            encoder.encode(value);
            return {
              types: typesWithDomain,
              domain: domainValues,
              primaryType: encoder.primaryType,
              message: encoder.visit(value, (type, value) => {
                if (type.match(/^bytes(\d*)/)) {
                  return hexlify(getBytes(value));
                }
                if (type.match(/^u?int/)) {
                  return getBigInt(value).toString();
                }
                switch (type) {
                  case "address":
                    return value.toLowerCase();
                  case "bool":
                    return !!value;
                  case "string":
                    assertArgument(
                      typeof value === "string",
                      "invalid string",
                      "value",
                      value
                    );
                    return value;
                }
                assertArgument(false, "unsupported type", "type", type);
              }),
            };
          }
        }
        function verifyTypedData(domain, types, value, signature) {
          return recoverAddress(
            TypedDataEncoder.hash(domain, types, value),
            signature
          );
        }
        function setify(items) {
          const result = new Set();
          items.forEach((k) => result.add(k));
          return Object.freeze(result);
        }
        const _kwVisibDeploy = "external public payable override";
        const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
        const _kwVisib =
          "constant external internal payable private public pure view override";
        const KwVisib = setify(_kwVisib.split(" "));
        const _kwTypes =
          "constructor error event fallback function receive struct";
        const KwTypes = setify(_kwTypes.split(" "));
        const _kwModifiers = "calldata memory storage payable indexed";
        const KwModifiers = setify(_kwModifiers.split(" "));
        const _kwOther = "tuple returns";
        const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(
          " "
        );
        const Keywords = setify(_keywords.split(" "));
        const SimpleTokens = {
          "(": "OPEN_PAREN",
          ")": "CLOSE_PAREN",
          "[": "OPEN_BRACKET",
          "]": "CLOSE_BRACKET",
          ",": "COMMA",
          "@": "AT",
        };
        const regexWhitespacePrefix = new RegExp("^(\\s*)");
        const regexNumberPrefix = new RegExp("^([0-9]+)");
        const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
        const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
        const regexType = new RegExp(
          "^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$"
        );
        class TokenString {
          #offset;
          #tokens;
          get offset() {
            return this.#offset;
          }
          get length() {
            return this.#tokens.length - this.#offset;
          }
          constructor(tokens) {
            this.#offset = 0;
            this.#tokens = tokens.slice();
          }
          clone() {
            return new TokenString(this.#tokens);
          }
          reset() {
            this.#offset = 0;
          }
          #subTokenString(from = 0, to = 0) {
            return new TokenString(
              this.#tokens.slice(from, to).map((t) => {
                return Object.freeze(
                  Object.assign({}, t, {
                    match: t.match - from,
                    linkBack: t.linkBack - from,
                    linkNext: t.linkNext - from,
                  })
                );
              })
            );
          }
          popKeyword(allowed) {
            const top = this.peek();
            if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
              throw new Error(`expected keyword ${top.text}`);
            }
            return this.pop().text;
          }
          popType(type) {
            if (this.peek().type !== type) {
              const top = this.peek();
              throw new Error(
                `expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`
              );
            }
            return this.pop().text;
          }
          popParen() {
            const top = this.peek();
            if (top.type !== "OPEN_PAREN") {
              throw new Error("bad start");
            }
            const result = this.#subTokenString(
              this.#offset + 1,
              top.match + 1
            );
            this.#offset = top.match + 1;
            return result;
          }
          popParams() {
            const top = this.peek();
            if (top.type !== "OPEN_PAREN") {
              throw new Error("bad start");
            }
            const result = [];
            while (this.#offset < top.match - 1) {
              const link = this.peek().linkNext;
              result.push(this.#subTokenString(this.#offset + 1, link));
              this.#offset = link;
            }
            this.#offset = top.match + 1;
            return result;
          }
          peek() {
            if (this.#offset >= this.#tokens.length) {
              throw new Error("out-of-bounds");
            }
            return this.#tokens[this.#offset];
          }
          peekKeyword(allowed) {
            const top = this.peekType("KEYWORD");
            return top != null && allowed.has(top) ? top : null;
          }
          peekType(type) {
            if (this.length === 0) {
              return null;
            }
            const top = this.peek();
            return top.type === type ? top.text : null;
          }
          pop() {
            const result = this.peek();
            this.#offset++;
            return result;
          }
          toString() {
            const tokens = [];
            for (let i = this.#offset; i < this.#tokens.length; i++) {
              const token = this.#tokens[i];
              tokens.push(`${token.type}:${token.text}`);
            }
            return `<TokenString ${tokens.join(" ")}>`;
          }
        }
        function lex(text) {
          const tokens = [];
          const throwError = (message) => {
            const token =
              offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
            throw new Error(`invalid token ${token} at ${offset}: ${message}`);
          };
          let brackets = [];
          let commas = [];
          let offset = 0;
          while (offset < text.length) {
            let cur = text.substring(offset);
            let match = cur.match(regexWhitespacePrefix);
            if (match) {
              offset += match[1].length;
              cur = text.substring(offset);
            }
            const token = {
              depth: brackets.length,
              linkBack: -1,
              linkNext: -1,
              match: -1,
              type: "",
              text: "",
              offset: offset,
              value: -1,
            };
            tokens.push(token);
            let type = SimpleTokens[cur[0]] || "";
            if (type) {
              token.type = type;
              token.text = cur[0];
              offset++;
              if (type === "OPEN_PAREN") {
                brackets.push(tokens.length - 1);
                commas.push(tokens.length - 1);
              } else if (type == "CLOSE_PAREN") {
                if (brackets.length === 0) {
                  throwError("no matching open bracket");
                }
                token.match = brackets.pop();
                tokens[token.match].match = tokens.length - 1;
                token.depth--;
                token.linkBack = commas.pop();
                tokens[token.linkBack].linkNext = tokens.length - 1;
              } else if (type === "COMMA") {
                token.linkBack = commas.pop();
                tokens[token.linkBack].linkNext = tokens.length - 1;
                commas.push(tokens.length - 1);
              } else if (type === "OPEN_BRACKET") {
                token.type = "BRACKET";
              } else if (type === "CLOSE_BRACKET") {
                let suffix = tokens.pop().text;
                if (
                  tokens.length > 0 &&
                  tokens[tokens.length - 1].type === "NUMBER"
                ) {
                  const value = tokens.pop().text;
                  suffix = value + suffix;
                  tokens[tokens.length - 1].value = getNumber(value);
                }
                if (
                  tokens.length === 0 ||
                  tokens[tokens.length - 1].type !== "BRACKET"
                ) {
                  throw new Error("missing opening bracket");
                }
                tokens[tokens.length - 1].text += suffix;
              }
              continue;
            }
            match = cur.match(regexIdPrefix);
            if (match) {
              token.text = match[1];
              offset += token.text.length;
              if (Keywords.has(token.text)) {
                token.type = "KEYWORD";
                continue;
              }
              if (token.text.match(regexType)) {
                token.type = "TYPE";
                continue;
              }
              token.type = "ID";
              continue;
            }
            match = cur.match(regexNumberPrefix);
            if (match) {
              token.text = match[1];
              token.type = "NUMBER";
              offset += token.text.length;
              continue;
            }
            throw new Error(
              `unexpected token ${JSON.stringify(cur[0])} at position ${offset}`
            );
          }
          return new TokenString(tokens.map((t) => Object.freeze(t)));
        }
        function allowSingle(set, allowed) {
          let included = [];
          for (const key in allowed.keys()) {
            if (set.has(key)) {
              included.push(key);
            }
          }
          if (included.length > 1) {
            throw new Error(`conflicting types: ${included.join(", ")}`);
          }
        }
        function consumeName(type, tokens) {
          if (tokens.peekKeyword(KwTypes)) {
            const keyword = tokens.pop().text;
            if (keyword !== type) {
              throw new Error(`expected ${type}, got ${keyword}`);
            }
          }
          return tokens.popType("ID");
        }
        function consumeKeywords(tokens, allowed) {
          const keywords = new Set();
          while (true) {
            const keyword = tokens.peekType("KEYWORD");
            if (keyword == null || (allowed && !allowed.has(keyword))) {
              break;
            }
            tokens.pop();
            if (keywords.has(keyword)) {
              throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
            }
            keywords.add(keyword);
          }
          return Object.freeze(keywords);
        }
        function consumeMutability(tokens) {
          let modifiers = consumeKeywords(tokens, KwVisib);
          allowSingle(
            modifiers,
            setify("constant payable nonpayable".split(" "))
          );
          allowSingle(
            modifiers,
            setify("pure view payable nonpayable".split(" "))
          );
          if (modifiers.has("view")) {
            return "view";
          }
          if (modifiers.has("pure")) {
            return "pure";
          }
          if (modifiers.has("payable")) {
            return "payable";
          }
          if (modifiers.has("nonpayable")) {
            return "nonpayable";
          }
          if (modifiers.has("constant")) {
            return "view";
          }
          return "nonpayable";
        }
        function consumeParams(tokens, allowIndexed) {
          return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
        }
        function consumeGas(tokens) {
          if (tokens.peekType("AT")) {
            tokens.pop();
            if (tokens.peekType("NUMBER")) {
              return getBigInt(tokens.pop().text);
            }
            throw new Error("invalid gas");
          }
          return null;
        }
        function consumeEoi(tokens) {
          if (tokens.length) {
            throw new Error(
              `unexpected tokens at offset ${
                tokens.offset
              }: ${tokens.toString()}`
            );
          }
        }
        const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
        function verifyBasicType(type) {
          const match = type.match(regexType);
          assertArgument(match, "invalid type", "type", type);
          if (type === "uint") {
            return "uint256";
          }
          if (type === "int") {
            return "int256";
          }
          if (match[2]) {
            const length = parseInt(match[2]);
            assertArgument(
              length !== 0 && length <= 32,
              "invalid bytes length",
              "type",
              type
            );
          } else if (match[3]) {
            const size = parseInt(match[3]);
            assertArgument(
              size !== 0 && size <= 256 && size % 8 === 0,
              "invalid numeric width",
              "type",
              type
            );
          }
          return type;
        }
        const _guard$2 = {};
        const internal$1 = Symbol.for("_ethers_internal");
        const ParamTypeInternal = "_ParamTypeInternal";
        const ErrorFragmentInternal = "_ErrorInternal";
        const EventFragmentInternal = "_EventInternal";
        const ConstructorFragmentInternal = "_ConstructorInternal";
        const FallbackFragmentInternal = "_FallbackInternal";
        const FunctionFragmentInternal = "_FunctionInternal";
        const StructFragmentInternal = "_StructInternal";
        class ParamType {
          name;
          type;
          baseType;
          indexed;
          components;
          arrayLength;
          arrayChildren;
          constructor(
            guard,
            name,
            type,
            baseType,
            indexed,
            components,
            arrayLength,
            arrayChildren
          ) {
            assertPrivate(guard, _guard$2, "ParamType");
            Object.defineProperty(this, internal$1, {
              value: ParamTypeInternal,
            });
            if (components) {
              components = Object.freeze(components.slice());
            }
            if (baseType === "array") {
              if (arrayLength == null || arrayChildren == null) {
                throw new Error("");
              }
            } else if (arrayLength != null || arrayChildren != null) {
              throw new Error("");
            }
            if (baseType === "tuple") {
              if (components == null) {
                throw new Error("");
              }
            } else if (components != null) {
              throw new Error("");
            }
            defineProperties(this, {
              name: name,
              type: type,
              baseType: baseType,
              indexed: indexed,
              components: components,
              arrayLength: arrayLength,
              arrayChildren: arrayChildren,
            });
          }
          format(format) {
            if (format == null) {
              format = "sighash";
            }
            if (format === "json") {
              const name = this.name || "";
              if (this.isArray()) {
                const result = JSON.parse(this.arrayChildren.format("json"));
                result.name = name;
                result.type += `[${
                  this.arrayLength < 0 ? "" : String(this.arrayLength)
                }]`;
                return JSON.stringify(result);
              }
              const result = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: name,
              };
              if (typeof this.indexed === "boolean") {
                result.indexed = this.indexed;
              }
              if (this.isTuple()) {
                result.components = this.components.map((c) =>
                  JSON.parse(c.format(format))
                );
              }
              return JSON.stringify(result);
            }
            let result = "";
            if (this.isArray()) {
              result += this.arrayChildren.format(format);
              result += `[${
                this.arrayLength < 0 ? "" : String(this.arrayLength)
              }]`;
            } else {
              if (this.isTuple()) {
                result +=
                  "(" +
                  this.components
                    .map((comp) => comp.format(format))
                    .join(format === "full" ? ", " : ",") +
                  ")";
              } else {
                result += this.type;
              }
            }
            if (format !== "sighash") {
              if (this.indexed === true) {
                result += " indexed";
              }
              if (format === "full" && this.name) {
                result += " " + this.name;
              }
            }
            return result;
          }
          isArray() {
            return this.baseType === "array";
          }
          isTuple() {
            return this.baseType === "tuple";
          }
          isIndexable() {
            return this.indexed != null;
          }
          walk(value, process) {
            if (this.isArray()) {
              if (!Array.isArray(value)) {
                throw new Error("invalid array value");
              }
              if (
                this.arrayLength !== -1 &&
                value.length !== this.arrayLength
              ) {
                throw new Error("array is wrong length");
              }
              const _this = this;
              return value.map((v) => _this.arrayChildren.walk(v, process));
            }
            if (this.isTuple()) {
              if (!Array.isArray(value)) {
                throw new Error("invalid tuple value");
              }
              if (value.length !== this.components.length) {
                throw new Error("array is wrong length");
              }
              const _this = this;
              return value.map((v, i) => _this.components[i].walk(v, process));
            }
            return process(this.type, value);
          }
          #walkAsync(promises, value, process, setValue) {
            if (this.isArray()) {
              if (!Array.isArray(value)) {
                throw new Error("invalid array value");
              }
              if (
                this.arrayLength !== -1 &&
                value.length !== this.arrayLength
              ) {
                throw new Error("array is wrong length");
              }
              const childType = this.arrayChildren;
              const result = value.slice();
              result.forEach((value, index) => {
                childType.#walkAsync(promises, value, process, (value) => {
                  result[index] = value;
                });
              });
              setValue(result);
              return;
            }
            if (this.isTuple()) {
              const components = this.components;
              let result;
              if (Array.isArray(value)) {
                result = value.slice();
              } else {
                if (value == null || typeof value !== "object") {
                  throw new Error("invalid tuple value");
                }
                result = components.map((param) => {
                  if (!param.name) {
                    throw new Error(
                      "cannot use object value with unnamed components"
                    );
                  }
                  if (!(param.name in value)) {
                    throw new Error(
                      `missing value for component ${param.name}`
                    );
                  }
                  return value[param.name];
                });
              }
              if (result.length !== this.components.length) {
                throw new Error("array is wrong length");
              }
              result.forEach((value, index) => {
                components[index].#walkAsync(
                  promises,
                  value,
                  process,
                  (value) => {
                    result[index] = value;
                  }
                );
              });
              setValue(result);
              return;
            }
            const result = process(this.type, value);
            if (result.then) {
              promises.push(
                (async function () {
                  setValue(await result);
                })()
              );
            } else {
              setValue(result);
            }
          }
          async walkAsync(value, process) {
            const promises = [];
            const result = [value];
            this.#walkAsync(promises, value, process, (value) => {
              result[0] = value;
            });
            if (promises.length) {
              await Promise.all(promises);
            }
            return result[0];
          }
          static from(obj, allowIndexed) {
            if (ParamType.isParamType(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              try {
                return ParamType.from(lex(obj), allowIndexed);
              } catch (error) {
                assertArgument(false, "invalid param type", "obj", obj);
              }
            } else if (obj instanceof TokenString) {
              let type = "",
                baseType = "";
              let comps = null;
              if (
                consumeKeywords(obj, setify(["tuple"])).has("tuple") ||
                obj.peekType("OPEN_PAREN")
              ) {
                baseType = "tuple";
                comps = obj.popParams().map((t) => ParamType.from(t));
                type = `tuple(${comps.map((c) => c.format()).join(",")})`;
              } else {
                type = verifyBasicType(obj.popType("TYPE"));
                baseType = type;
              }
              let arrayChildren = null;
              let arrayLength = null;
              while (obj.length && obj.peekType("BRACKET")) {
                const bracket = obj.pop();
                arrayChildren = new ParamType(
                  _guard$2,
                  "",
                  type,
                  baseType,
                  null,
                  comps,
                  arrayLength,
                  arrayChildren
                );
                arrayLength = bracket.value;
                type += bracket.text;
                baseType = "array";
                comps = null;
              }
              let indexed = null;
              const keywords = consumeKeywords(obj, KwModifiers);
              if (keywords.has("indexed")) {
                if (!allowIndexed) {
                  throw new Error("");
                }
                indexed = true;
              }
              const name = obj.peekType("ID") ? obj.pop().text : "";
              if (obj.length) {
                throw new Error("leftover tokens");
              }
              return new ParamType(
                _guard$2,
                name,
                type,
                baseType,
                indexed,
                comps,
                arrayLength,
                arrayChildren
              );
            }
            const name = obj.name;
            assertArgument(
              !name || (typeof name === "string" && name.match(regexId)),
              "invalid name",
              "obj.name",
              name
            );
            let indexed = obj.indexed;
            if (indexed != null) {
              assertArgument(
                allowIndexed,
                "parameter cannot be indexed",
                "obj.indexed",
                obj.indexed
              );
              indexed = !!indexed;
            }
            let type = obj.type;
            let arrayMatch = type.match(regexArrayType);
            if (arrayMatch) {
              const arrayLength = parseInt(arrayMatch[2] || "-1");
              const arrayChildren = ParamType.from({
                type: arrayMatch[1],
                components: obj.components,
              });
              return new ParamType(
                _guard$2,
                name || "",
                type,
                "array",
                indexed,
                null,
                arrayLength,
                arrayChildren
              );
            }
            if (
              type === "tuple" ||
              type.startsWith("tuple(") ||
              type.startsWith("(")
            ) {
              const comps =
                obj.components != null
                  ? obj.components.map((c) => ParamType.from(c))
                  : null;
              const tuple = new ParamType(
                _guard$2,
                name || "",
                type,
                "tuple",
                indexed,
                comps,
                null,
                null
              );
              return tuple;
            }
            type = verifyBasicType(obj.type);
            return new ParamType(
              _guard$2,
              name || "",
              type,
              type,
              indexed,
              null,
              null,
              null
            );
          }
          static isParamType(value) {
            return value && value[internal$1] === ParamTypeInternal;
          }
        }
        class Fragment {
          type;
          inputs;
          constructor(guard, type, inputs) {
            assertPrivate(guard, _guard$2, "Fragment");
            inputs = Object.freeze(inputs.slice());
            defineProperties(this, { type: type, inputs: inputs });
          }
          static from(obj) {
            if (typeof obj === "string") {
              try {
                Fragment.from(JSON.parse(obj));
              } catch (e) {}
              return Fragment.from(lex(obj));
            }
            if (obj instanceof TokenString) {
              const type = obj.peekKeyword(KwTypes);
              switch (type) {
                case "constructor":
                  return ConstructorFragment.from(obj);
                case "error":
                  return ErrorFragment.from(obj);
                case "event":
                  return EventFragment.from(obj);
                case "fallback":
                case "receive":
                  return FallbackFragment.from(obj);
                case "function":
                  return FunctionFragment.from(obj);
                case "struct":
                  return StructFragment.from(obj);
              }
            } else if (typeof obj === "object") {
              switch (obj.type) {
                case "constructor":
                  return ConstructorFragment.from(obj);
                case "error":
                  return ErrorFragment.from(obj);
                case "event":
                  return EventFragment.from(obj);
                case "fallback":
                case "receive":
                  return FallbackFragment.from(obj);
                case "function":
                  return FunctionFragment.from(obj);
                case "struct":
                  return StructFragment.from(obj);
              }
              assert(
                false,
                `unsupported type: ${obj.type}`,
                "UNSUPPORTED_OPERATION",
                { operation: "Fragment.from" }
              );
            }
            assertArgument(false, "unsupported frgament object", "obj", obj);
          }
          static isConstructor(value) {
            return ConstructorFragment.isFragment(value);
          }
          static isError(value) {
            return ErrorFragment.isFragment(value);
          }
          static isEvent(value) {
            return EventFragment.isFragment(value);
          }
          static isFunction(value) {
            return FunctionFragment.isFragment(value);
          }
          static isStruct(value) {
            return StructFragment.isFragment(value);
          }
        }
        class NamedFragment extends Fragment {
          name;
          constructor(guard, type, name, inputs) {
            super(guard, type, inputs);
            assertArgument(
              typeof name === "string" && name.match(regexId),
              "invalid identifier",
              "name",
              name
            );
            inputs = Object.freeze(inputs.slice());
            defineProperties(this, { name: name });
          }
        }
        function joinParams(format, params) {
          return (
            "(" +
            params
              .map((p) => p.format(format))
              .join(format === "full" ? ", " : ",") +
            ")"
          );
        }
        class ErrorFragment extends NamedFragment {
          constructor(guard, name, inputs) {
            super(guard, "error", name, inputs);
            Object.defineProperty(this, internal$1, {
              value: ErrorFragmentInternal,
            });
          }
          get selector() {
            return id(this.format("sighash")).substring(0, 10);
          }
          format(format) {
            if (format == null) {
              format = "sighash";
            }
            if (format === "json") {
              return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) =>
                  JSON.parse(input.format(format))
                ),
              });
            }
            const result = [];
            if (format !== "sighash") {
              result.push("error");
            }
            result.push(this.name + joinParams(format, this.inputs));
            return result.join(" ");
          }
          static from(obj) {
            if (ErrorFragment.isFragment(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              return ErrorFragment.from(lex(obj));
            } else if (obj instanceof TokenString) {
              const name = consumeName("error", obj);
              const inputs = consumeParams(obj);
              consumeEoi(obj);
              return new ErrorFragment(_guard$2, name, inputs);
            }
            return new ErrorFragment(
              _guard$2,
              obj.name,
              obj.inputs ? obj.inputs.map(ParamType.from) : []
            );
          }
          static isFragment(value) {
            return value && value[internal$1] === ErrorFragmentInternal;
          }
        }
        class EventFragment extends NamedFragment {
          anonymous;
          constructor(guard, name, inputs, anonymous) {
            super(guard, "event", name, inputs);
            Object.defineProperty(this, internal$1, {
              value: EventFragmentInternal,
            });
            defineProperties(this, { anonymous: anonymous });
          }
          get topicHash() {
            return id(this.format("sighash"));
          }
          format(format) {
            if (format == null) {
              format = "sighash";
            }
            if (format === "json") {
              return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
              });
            }
            const result = [];
            if (format !== "sighash") {
              result.push("event");
            }
            result.push(this.name + joinParams(format, this.inputs));
            if (format !== "sighash" && this.anonymous) {
              result.push("anonymous");
            }
            return result.join(" ");
          }
          static getTopicHash(name, params) {
            params = (params || []).map((p) => ParamType.from(p));
            const fragment = new EventFragment(_guard$2, name, params, false);
            return fragment.topicHash;
          }
          static from(obj) {
            if (EventFragment.isFragment(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              try {
                return EventFragment.from(lex(obj));
              } catch (error) {
                assertArgument(false, "invalid event fragment", "obj", obj);
              }
            } else if (obj instanceof TokenString) {
              const name = consumeName("event", obj);
              const inputs = consumeParams(obj, true);
              const anonymous = !!consumeKeywords(
                obj,
                setify(["anonymous"])
              ).has("anonymous");
              consumeEoi(obj);
              return new EventFragment(_guard$2, name, inputs, anonymous);
            }
            return new EventFragment(
              _guard$2,
              obj.name,
              obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [],
              !!obj.anonymous
            );
          }
          static isFragment(value) {
            return value && value[internal$1] === EventFragmentInternal;
          }
        }
        class ConstructorFragment extends Fragment {
          payable;
          gas;
          constructor(guard, type, inputs, payable, gas) {
            super(guard, type, inputs);
            Object.defineProperty(this, internal$1, {
              value: ConstructorFragmentInternal,
            });
            defineProperties(this, { payable: payable, gas: gas });
          }
          format(format) {
            assert(
              format != null && format !== "sighash",
              "cannot format a constructor for sighash",
              "UNSUPPORTED_OPERATION",
              { operation: "format(sighash)" }
            );
            if (format === "json") {
              return JSON.stringify({
                type: "constructor",
                stateMutability: this.payable ? "payable" : "undefined",
                payable: this.payable,
                gas: this.gas != null ? this.gas : undefined,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
              });
            }
            const result = [`constructor${joinParams(format, this.inputs)}`];
            if (this.payable) {
              result.push("payable");
            }
            if (this.gas != null) {
              result.push(`@${this.gas.toString()}`);
            }
            return result.join(" ");
          }
          static from(obj) {
            if (ConstructorFragment.isFragment(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              try {
                return ConstructorFragment.from(lex(obj));
              } catch (error) {
                assertArgument(
                  false,
                  "invalid constuctor fragment",
                  "obj",
                  obj
                );
              }
            } else if (obj instanceof TokenString) {
              consumeKeywords(obj, setify(["constructor"]));
              const inputs = consumeParams(obj);
              const payable = !!consumeKeywords(obj, KwVisibDeploy).has(
                "payable"
              );
              const gas = consumeGas(obj);
              consumeEoi(obj);
              return new ConstructorFragment(
                _guard$2,
                "constructor",
                inputs,
                payable,
                gas
              );
            }
            return new ConstructorFragment(
              _guard$2,
              "constructor",
              obj.inputs ? obj.inputs.map(ParamType.from) : [],
              !!obj.payable,
              obj.gas != null ? obj.gas : null
            );
          }
          static isFragment(value) {
            return value && value[internal$1] === ConstructorFragmentInternal;
          }
        }
        class FallbackFragment extends Fragment {
          payable;
          constructor(guard, inputs, payable) {
            super(guard, "fallback", inputs);
            Object.defineProperty(this, internal$1, {
              value: FallbackFragmentInternal,
            });
            defineProperties(this, { payable: payable });
          }
          format(format) {
            const type = this.inputs.length === 0 ? "receive" : "fallback";
            if (format === "json") {
              const stateMutability = this.payable ? "payable" : "nonpayable";
              return JSON.stringify({
                type: type,
                stateMutability: stateMutability,
              });
            }
            return `${type}()${this.payable ? " payable" : ""}`;
          }
          static from(obj) {
            if (FallbackFragment.isFragment(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              try {
                return FallbackFragment.from(lex(obj));
              } catch (error) {
                assertArgument(false, "invalid fallback fragment", "obj", obj);
              }
            } else if (obj instanceof TokenString) {
              const errorObj = obj.toString();
              const topIsValid = obj.peekKeyword(
                setify(["fallback", "receive"])
              );
              assertArgument(
                topIsValid,
                "type must be fallback or receive",
                "obj",
                errorObj
              );
              const type = obj.popKeyword(setify(["fallback", "receive"]));
              if (type === "receive") {
                const inputs = consumeParams(obj);
                assertArgument(
                  inputs.length === 0,
                  `receive cannot have arguments`,
                  "obj.inputs",
                  inputs
                );
                consumeKeywords(obj, setify(["payable"]));
                consumeEoi(obj);
                return new FallbackFragment(_guard$2, [], true);
              }
              let inputs = consumeParams(obj);
              if (inputs.length) {
                assertArgument(
                  inputs.length === 1 && inputs[0].type === "bytes",
                  "invalid fallback inputs",
                  "obj.inputs",
                  inputs.map((i) => i.format("minimal")).join(", ")
                );
              } else {
                inputs = [ParamType.from("bytes")];
              }
              const mutability = consumeMutability(obj);
              assertArgument(
                mutability === "nonpayable" || mutability === "payable",
                "fallback cannot be constants",
                "obj.stateMutability",
                mutability
              );
              if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                const outputs = consumeParams(obj);
                assertArgument(
                  outputs.length === 1 && outputs[0].type === "bytes",
                  "invalid fallback outputs",
                  "obj.outputs",
                  outputs.map((i) => i.format("minimal")).join(", ")
                );
              }
              consumeEoi(obj);
              return new FallbackFragment(
                _guard$2,
                inputs,
                mutability === "payable"
              );
            }
            if (obj.type === "receive") {
              return new FallbackFragment(_guard$2, [], true);
            }
            if (obj.type === "fallback") {
              const inputs = [ParamType.from("bytes")];
              const payable = obj.stateMutability === "payable";
              return new FallbackFragment(_guard$2, inputs, payable);
            }
            assertArgument(false, "invalid fallback description", "obj", obj);
          }
          static isFragment(value) {
            return value && value[internal$1] === FallbackFragmentInternal;
          }
        }
        class FunctionFragment extends NamedFragment {
          constant;
          outputs;
          stateMutability;
          payable;
          gas;
          constructor(guard, name, stateMutability, inputs, outputs, gas) {
            super(guard, "function", name, inputs);
            Object.defineProperty(this, internal$1, {
              value: FunctionFragmentInternal,
            });
            outputs = Object.freeze(outputs.slice());
            const constant =
              stateMutability === "view" || stateMutability === "pure";
            const payable = stateMutability === "payable";
            defineProperties(this, {
              constant: constant,
              gas: gas,
              outputs: outputs,
              payable: payable,
              stateMutability: stateMutability,
            });
          }
          get selector() {
            return id(this.format("sighash")).substring(0, 10);
          }
          format(format) {
            if (format == null) {
              format = "sighash";
            }
            if (format === "json") {
              return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability:
                  this.stateMutability !== "nonpayable"
                    ? this.stateMutability
                    : undefined,
                payable: this.payable,
                gas: this.gas != null ? this.gas : undefined,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),
              });
            }
            const result = [];
            if (format !== "sighash") {
              result.push("function");
            }
            result.push(this.name + joinParams(format, this.inputs));
            if (format !== "sighash") {
              if (this.stateMutability !== "nonpayable") {
                result.push(this.stateMutability);
              }
              if (this.outputs && this.outputs.length) {
                result.push("returns");
                result.push(joinParams(format, this.outputs));
              }
              if (this.gas != null) {
                result.push(`@${this.gas.toString()}`);
              }
            }
            return result.join(" ");
          }
          static getSelector(name, params) {
            params = (params || []).map((p) => ParamType.from(p));
            const fragment = new FunctionFragment(
              _guard$2,
              name,
              "view",
              params,
              [],
              null
            );
            return fragment.selector;
          }
          static from(obj) {
            if (FunctionFragment.isFragment(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              try {
                return FunctionFragment.from(lex(obj));
              } catch (error) {
                assertArgument(false, "invalid function fragment", "obj", obj);
              }
            } else if (obj instanceof TokenString) {
              const name = consumeName("function", obj);
              const inputs = consumeParams(obj);
              const mutability = consumeMutability(obj);
              let outputs = [];
              if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                outputs = consumeParams(obj);
              }
              const gas = consumeGas(obj);
              consumeEoi(obj);
              return new FunctionFragment(
                _guard$2,
                name,
                mutability,
                inputs,
                outputs,
                gas
              );
            }
            let stateMutability = obj.stateMutability;
            if (stateMutability == null) {
              stateMutability = "payable";
              if (typeof obj.constant === "boolean") {
                stateMutability = "view";
                if (!obj.constant) {
                  stateMutability = "payable";
                  if (typeof obj.payable === "boolean" && !obj.payable) {
                    stateMutability = "nonpayable";
                  }
                }
              } else if (typeof obj.payable === "boolean" && !obj.payable) {
                stateMutability = "nonpayable";
              }
            }
            return new FunctionFragment(
              _guard$2,
              obj.name,
              stateMutability,
              obj.inputs ? obj.inputs.map(ParamType.from) : [],
              obj.outputs ? obj.outputs.map(ParamType.from) : [],
              obj.gas != null ? obj.gas : null
            );
          }
          static isFragment(value) {
            return value && value[internal$1] === FunctionFragmentInternal;
          }
        }
        class StructFragment extends NamedFragment {
          constructor(guard, name, inputs) {
            super(guard, "struct", name, inputs);
            Object.defineProperty(this, internal$1, {
              value: StructFragmentInternal,
            });
          }
          format() {
            throw new Error("@TODO");
          }
          static from(obj) {
            if (typeof obj === "string") {
              try {
                return StructFragment.from(lex(obj));
              } catch (error) {
                assertArgument(false, "invalid struct fragment", "obj", obj);
              }
            } else if (obj instanceof TokenString) {
              const name = consumeName("struct", obj);
              const inputs = consumeParams(obj);
              consumeEoi(obj);
              return new StructFragment(_guard$2, name, inputs);
            }
            return new StructFragment(
              _guard$2,
              obj.name,
              obj.inputs ? obj.inputs.map(ParamType.from) : []
            );
          }
          static isFragment(value) {
            return value && value[internal$1] === StructFragmentInternal;
          }
        }
        const PanicReasons$1 = new Map();
        PanicReasons$1.set(0, "GENERIC_PANIC");
        PanicReasons$1.set(1, "ASSERT_FALSE");
        PanicReasons$1.set(17, "OVERFLOW");
        PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
        PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
        PanicReasons$1.set(34, "BAD_STORAGE_DATA");
        PanicReasons$1.set(49, "STACK_UNDERFLOW");
        PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
        PanicReasons$1.set(65, "OUT_OF_MEMORY");
        PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
        const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
        const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
        let defaultCoder = null;
        let defaultMaxInflation = 1024;
        function getBuiltinCallException(action, tx, data, abiCoder) {
          let message = "missing revert data";
          let reason = null;
          const invocation = null;
          let revert = null;
          if (data) {
            message = "execution reverted";
            const bytes = getBytes(data);
            data = hexlify(data);
            if (bytes.length === 0) {
              message += " (no data present; likely require(false) occurred";
              reason = "require(false)";
            } else if (bytes.length % 32 !== 4) {
              message += " (could not decode reason; invalid data length)";
            } else if (hexlify(bytes.slice(0, 4)) === "0x08c379a0") {
              try {
                reason = abiCoder.decode(["string"], bytes.slice(4))[0];
                revert = {
                  signature: "Error(string)",
                  name: "Error",
                  args: [reason],
                };
                message += `: ${JSON.stringify(reason)}`;
              } catch (error) {
                message += " (could not decode reason; invalid string data)";
              }
            } else if (hexlify(bytes.slice(0, 4)) === "0x4e487b71") {
              try {
                const code = Number(
                  abiCoder.decode(["uint256"], bytes.slice(4))[0]
                );
                revert = {
                  signature: "Panic(uint256)",
                  name: "Panic",
                  args: [code],
                };
                reason = `Panic due to ${
                  PanicReasons$1.get(code) || "UNKNOWN"
                }(${code})`;
                message += `: ${reason}`;
              } catch (error) {
                message += " (could not decode panic code)";
              }
            } else {
              message += " (unknown custom error)";
            }
          }
          const transaction = {
            to: tx.to ? getAddress(tx.to) : null,
            data: tx.data || "0x",
          };
          if (tx.from) {
            transaction.from = getAddress(tx.from);
          }
          return makeError(message, "CALL_EXCEPTION", {
            action: action,
            data: data,
            reason: reason,
            transaction: transaction,
            invocation: invocation,
            revert: revert,
          });
        }
        class AbiCoder {
          #getCoder(param) {
            if (param.isArray()) {
              return new ArrayCoder(
                this.#getCoder(param.arrayChildren),
                param.arrayLength,
                param.name
              );
            }
            if (param.isTuple()) {
              return new TupleCoder(
                param.components.map((c) => this.#getCoder(c)),
                param.name
              );
            }
            switch (param.baseType) {
              case "address":
                return new AddressCoder(param.name);
              case "bool":
                return new BooleanCoder(param.name);
              case "string":
                return new StringCoder(param.name);
              case "bytes":
                return new BytesCoder(param.name);
              case "":
                return new NullCoder(param.name);
            }
            let match = param.type.match(paramTypeNumber);
            if (match) {
              let size = parseInt(match[2] || "256");
              assertArgument(
                size !== 0 && size <= 256 && size % 8 === 0,
                "invalid " + match[1] + " bit length",
                "param",
                param
              );
              return new NumberCoder(size / 8, match[1] === "int", param.name);
            }
            match = param.type.match(paramTypeBytes);
            if (match) {
              let size = parseInt(match[1]);
              assertArgument(
                size !== 0 && size <= 32,
                "invalid bytes length",
                "param",
                param
              );
              return new FixedBytesCoder(size, param.name);
            }
            assertArgument(false, "invalid type", "type", param.type);
          }
          getDefaultValue(types) {
            const coders = types.map((type) =>
              this.#getCoder(ParamType.from(type))
            );
            const coder = new TupleCoder(coders, "_");
            return coder.defaultValue();
          }
          encode(types, values) {
            assertArgumentCount(
              values.length,
              types.length,
              "types/values length mismatch"
            );
            const coders = types.map((type) =>
              this.#getCoder(ParamType.from(type))
            );
            const coder = new TupleCoder(coders, "_");
            const writer = new Writer();
            coder.encode(writer, values);
            return writer.data;
          }
          decode(types, data, loose) {
            const coders = types.map((type) =>
              this.#getCoder(ParamType.from(type))
            );
            const coder = new TupleCoder(coders, "_");
            return coder.decode(new Reader(data, loose, defaultMaxInflation));
          }
          static _setDefaultMaxInflation(value) {
            assertArgument(
              typeof value === "number" && Number.isInteger(value),
              "invalid defaultMaxInflation factor",
              "value",
              value
            );
            defaultMaxInflation = value;
          }
          static defaultAbiCoder() {
            if (defaultCoder == null) {
              defaultCoder = new AbiCoder();
            }
            return defaultCoder;
          }
          static getBuiltinCallException(action, tx, data) {
            return getBuiltinCallException(
              action,
              tx,
              data,
              AbiCoder.defaultAbiCoder()
            );
          }
        }
        function encodeBytes32String(text) {
          const bytes = toUtf8Bytes(text);
          if (bytes.length > 31) {
            throw new Error("bytes32 string must be less than 32 bytes");
          }
          return zeroPadBytes(bytes, 32);
        }
        function decodeBytes32String(_bytes) {
          const data = getBytes(_bytes, "bytes");
          if (data.length !== 32) {
            throw new Error("invalid bytes32 - not 32 bytes long");
          }
          if (data[31] !== 0) {
            throw new Error("invalid bytes32 string - no null terminator");
          }
          let length = 31;
          while (data[length - 1] === 0) {
            length--;
          }
          return toUtf8String(data.slice(0, length));
        }
        class LogDescription {
          fragment;
          name;
          signature;
          topic;
          args;
          constructor(fragment, topic, args) {
            const name = fragment.name,
              signature = fragment.format();
            defineProperties(this, {
              fragment: fragment,
              name: name,
              signature: signature,
              topic: topic,
              args: args,
            });
          }
        }
        class TransactionDescription {
          fragment;
          name;
          args;
          signature;
          selector;
          value;
          constructor(fragment, selector, args, value) {
            const name = fragment.name,
              signature = fragment.format();
            defineProperties(this, {
              fragment: fragment,
              name: name,
              args: args,
              signature: signature,
              selector: selector,
              value: value,
            });
          }
        }
        class ErrorDescription {
          fragment;
          name;
          args;
          signature;
          selector;
          constructor(fragment, selector, args) {
            const name = fragment.name,
              signature = fragment.format();
            defineProperties(this, {
              fragment: fragment,
              name: name,
              args: args,
              signature: signature,
              selector: selector,
            });
          }
        }
        class Indexed {
          hash;
          _isIndexed;
          static isIndexed(value) {
            return !!(value && value._isIndexed);
          }
          constructor(hash) {
            defineProperties(this, { hash: hash, _isIndexed: true });
          }
        }
        const PanicReasons = {
          0: "generic panic",
          1: "assert(false)",
          17: "arithmetic overflow",
          18: "division or modulo by zero",
          33: "enum overflow",
          34: "invalid encoded storage byte array accessed",
          49: "out-of-bounds array access; popping on an empty array",
          50: "out-of-bounds access of an array or bytesN",
          65: "out of memory",
          81: "uninitialized function",
        };
        const BuiltinErrors = {
          "0x08c379a0": {
            signature: "Error(string)",
            name: "Error",
            inputs: ["string"],
            reason: (message) => {
              return `reverted with reason string ${JSON.stringify(message)}`;
            },
          },
          "0x4e487b71": {
            signature: "Panic(uint256)",
            name: "Panic",
            inputs: ["uint256"],
            reason: (code) => {
              let reason = "unknown panic code";
              if (code >= 0 && code <= 255 && PanicReasons[code.toString()]) {
                reason = PanicReasons[code.toString()];
              }
              return `reverted with panic code 0x${code.toString(
                16
              )} (${reason})`;
            },
          },
        };
        class Interface {
          fragments;
          deploy;
          fallback;
          receive;
          #errors;
          #events;
          #functions;
          #abiCoder;
          constructor(fragments) {
            let abi = [];
            if (typeof fragments === "string") {
              abi = JSON.parse(fragments);
            } else {
              abi = fragments;
            }
            this.#functions = new Map();
            this.#errors = new Map();
            this.#events = new Map();
            const frags = [];
            for (const a of abi) {
              try {
                frags.push(Fragment.from(a));
              } catch (error) {
                console.log(
                  `[Warning] Invalid Fragment ${JSON.stringify(a)}:`,
                  error.message
                );
              }
            }
            defineProperties(this, { fragments: Object.freeze(frags) });
            let fallback = null;
            let receive = false;
            this.#abiCoder = this.getAbiCoder();
            this.fragments.forEach((fragment, index) => {
              let bucket;
              switch (fragment.type) {
                case "constructor":
                  if (this.deploy) {
                    console.log("duplicate definition - constructor");
                    return;
                  }
                  defineProperties(this, { deploy: fragment });
                  return;
                case "fallback":
                  if (fragment.inputs.length === 0) {
                    receive = true;
                  } else {
                    assertArgument(
                      !fallback || fragment.payable !== fallback.payable,
                      "conflicting fallback fragments",
                      `fragments[${index}]`,
                      fragment
                    );
                    fallback = fragment;
                    receive = fallback.payable;
                  }
                  return;
                case "function":
                  bucket = this.#functions;
                  break;
                case "event":
                  bucket = this.#events;
                  break;
                case "error":
                  bucket = this.#errors;
                  break;
                default:
                  return;
              }
              const signature = fragment.format();
              if (bucket.has(signature)) {
                return;
              }
              bucket.set(signature, fragment);
            });
            if (!this.deploy) {
              defineProperties(this, {
                deploy: ConstructorFragment.from("constructor()"),
              });
            }
            defineProperties(this, { fallback: fallback, receive: receive });
          }
          format(minimal) {
            const format = minimal ? "minimal" : "full";
            const abi = this.fragments.map((f) => f.format(format));
            return abi;
          }
          formatJson() {
            const abi = this.fragments.map((f) => f.format("json"));
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
          }
          getAbiCoder() {
            return AbiCoder.defaultAbiCoder();
          }
          #getFunction(key, values, forceUnique) {
            if (isHexString(key)) {
              const selector = key.toLowerCase();
              for (const fragment of this.#functions.values()) {
                if (selector === fragment.selector) {
                  return fragment;
                }
              }
              return null;
            }
            if (key.indexOf("(") === -1) {
              const matching = [];
              for (const [name, fragment] of this.#functions) {
                if (name.split("(")[0] === key) {
                  matching.push(fragment);
                }
              }
              if (values) {
                const lastValue =
                  values.length > 0 ? values[values.length - 1] : null;
                let valueLength = values.length;
                let allowOptions = true;
                if (
                  Typed.isTyped(lastValue) &&
                  lastValue.type === "overrides"
                ) {
                  allowOptions = false;
                  valueLength--;
                }
                for (let i = matching.length - 1; i >= 0; i--) {
                  const inputs = matching[i].inputs.length;
                  if (
                    inputs !== valueLength &&
                    (!allowOptions || inputs !== valueLength - 1)
                  ) {
                    matching.splice(i, 1);
                  }
                }
                for (let i = matching.length - 1; i >= 0; i--) {
                  const inputs = matching[i].inputs;
                  for (let j = 0; j < values.length; j++) {
                    if (!Typed.isTyped(values[j])) {
                      continue;
                    }
                    if (j >= inputs.length) {
                      if (values[j].type === "overrides") {
                        continue;
                      }
                      matching.splice(i, 1);
                      break;
                    }
                    if (values[j].type !== inputs[j].baseType) {
                      matching.splice(i, 1);
                      break;
                    }
                  }
                }
              }
              if (
                matching.length === 1 &&
                values &&
                values.length !== matching[0].inputs.length
              ) {
                const lastArg = values[values.length - 1];
                if (
                  lastArg == null ||
                  Array.isArray(lastArg) ||
                  typeof lastArg !== "object"
                ) {
                  matching.splice(0, 1);
                }
              }
              if (matching.length === 0) {
                return null;
              }
              if (matching.length > 1 && forceUnique) {
                const matchStr = matching
                  .map((m) => JSON.stringify(m.format()))
                  .join(", ");
                assertArgument(
                  false,
                  `ambiguous function description (i.e. matches ${matchStr})`,
                  "key",
                  key
                );
              }
              return matching[0];
            }
            const result = this.#functions.get(
              FunctionFragment.from(key).format()
            );
            if (result) {
              return result;
            }
            return null;
          }
          getFunctionName(key) {
            const fragment = this.#getFunction(key, null, false);
            assertArgument(fragment, "no matching function", "key", key);
            return fragment.name;
          }
          hasFunction(key) {
            return !!this.#getFunction(key, null, false);
          }
          getFunction(key, values) {
            return this.#getFunction(key, values || null, true);
          }
          forEachFunction(callback) {
            const names = Array.from(this.#functions.keys());
            names.sort((a, b) => a.localeCompare(b));
            for (let i = 0; i < names.length; i++) {
              const name = names[i];
              callback(this.#functions.get(name), i);
            }
          }
          #getEvent(key, values, forceUnique) {
            if (isHexString(key)) {
              const eventTopic = key.toLowerCase();
              for (const fragment of this.#events.values()) {
                if (eventTopic === fragment.topicHash) {
                  return fragment;
                }
              }
              return null;
            }
            if (key.indexOf("(") === -1) {
              const matching = [];
              for (const [name, fragment] of this.#events) {
                if (name.split("(")[0] === key) {
                  matching.push(fragment);
                }
              }
              if (values) {
                for (let i = matching.length - 1; i >= 0; i--) {
                  if (matching[i].inputs.length < values.length) {
                    matching.splice(i, 1);
                  }
                }
                for (let i = matching.length - 1; i >= 0; i--) {
                  const inputs = matching[i].inputs;
                  for (let j = 0; j < values.length; j++) {
                    if (!Typed.isTyped(values[j])) {
                      continue;
                    }
                    if (values[j].type !== inputs[j].baseType) {
                      matching.splice(i, 1);
                      break;
                    }
                  }
                }
              }
              if (matching.length === 0) {
                return null;
              }
              if (matching.length > 1 && forceUnique) {
                const matchStr = matching
                  .map((m) => JSON.stringify(m.format()))
                  .join(", ");
                assertArgument(
                  false,
                  `ambiguous event description (i.e. matches ${matchStr})`,
                  "key",
                  key
                );
              }
              return matching[0];
            }
            const result = this.#events.get(EventFragment.from(key).format());
            if (result) {
              return result;
            }
            return null;
          }
          getEventName(key) {
            const fragment = this.#getEvent(key, null, false);
            assertArgument(fragment, "no matching event", "key", key);
            return fragment.name;
          }
          hasEvent(key) {
            return !!this.#getEvent(key, null, false);
          }
          getEvent(key, values) {
            return this.#getEvent(key, values || null, true);
          }
          forEachEvent(callback) {
            const names = Array.from(this.#events.keys());
            names.sort((a, b) => a.localeCompare(b));
            for (let i = 0; i < names.length; i++) {
              const name = names[i];
              callback(this.#events.get(name), i);
            }
          }
          getError(key, values) {
            if (isHexString(key)) {
              const selector = key.toLowerCase();
              if (BuiltinErrors[selector]) {
                return ErrorFragment.from(BuiltinErrors[selector].signature);
              }
              for (const fragment of this.#errors.values()) {
                if (selector === fragment.selector) {
                  return fragment;
                }
              }
              return null;
            }
            if (key.indexOf("(") === -1) {
              const matching = [];
              for (const [name, fragment] of this.#errors) {
                if (name.split("(")[0] === key) {
                  matching.push(fragment);
                }
              }
              if (matching.length === 0) {
                if (key === "Error") {
                  return ErrorFragment.from("error Error(string)");
                }
                if (key === "Panic") {
                  return ErrorFragment.from("error Panic(uint256)");
                }
                return null;
              } else if (matching.length > 1) {
                const matchStr = matching
                  .map((m) => JSON.stringify(m.format()))
                  .join(", ");
                assertArgument(
                  false,
                  `ambiguous error description (i.e. ${matchStr})`,
                  "name",
                  key
                );
              }
              return matching[0];
            }
            key = ErrorFragment.from(key).format();
            if (key === "Error(string)") {
              return ErrorFragment.from("error Error(string)");
            }
            if (key === "Panic(uint256)") {
              return ErrorFragment.from("error Panic(uint256)");
            }
            const result = this.#errors.get(key);
            if (result) {
              return result;
            }
            return null;
          }
          forEachError(callback) {
            const names = Array.from(this.#errors.keys());
            names.sort((a, b) => a.localeCompare(b));
            for (let i = 0; i < names.length; i++) {
              const name = names[i];
              callback(this.#errors.get(name), i);
            }
          }
          _decodeParams(params, data) {
            return this.#abiCoder.decode(params, data);
          }
          _encodeParams(params, values) {
            return this.#abiCoder.encode(params, values);
          }
          encodeDeploy(values) {
            return this._encodeParams(this.deploy.inputs, values || []);
          }
          decodeErrorResult(fragment, data) {
            if (typeof fragment === "string") {
              const f = this.getError(fragment);
              assertArgument(f, "unknown error", "fragment", fragment);
              fragment = f;
            }
            assertArgument(
              dataSlice(data, 0, 4) === fragment.selector,
              `data signature does not match error ${fragment.name}.`,
              "data",
              data
            );
            return this._decodeParams(fragment.inputs, dataSlice(data, 4));
          }
          encodeErrorResult(fragment, values) {
            if (typeof fragment === "string") {
              const f = this.getError(fragment);
              assertArgument(f, "unknown error", "fragment", fragment);
              fragment = f;
            }
            return concat([
              fragment.selector,
              this._encodeParams(fragment.inputs, values || []),
            ]);
          }
          decodeFunctionData(fragment, data) {
            if (typeof fragment === "string") {
              const f = this.getFunction(fragment);
              assertArgument(f, "unknown function", "fragment", fragment);
              fragment = f;
            }
            assertArgument(
              dataSlice(data, 0, 4) === fragment.selector,
              `data signature does not match function ${fragment.name}.`,
              "data",
              data
            );
            return this._decodeParams(fragment.inputs, dataSlice(data, 4));
          }
          encodeFunctionData(fragment, values) {
            if (typeof fragment === "string") {
              const f = this.getFunction(fragment);
              assertArgument(f, "unknown function", "fragment", fragment);
              fragment = f;
            }
            return concat([
              fragment.selector,
              this._encodeParams(fragment.inputs, values || []),
            ]);
          }
          decodeFunctionResult(fragment, data) {
            if (typeof fragment === "string") {
              const f = this.getFunction(fragment);
              assertArgument(f, "unknown function", "fragment", fragment);
              fragment = f;
            }
            let message = "invalid length for result data";
            const bytes = getBytesCopy(data);
            if (bytes.length % 32 === 0) {
              try {
                return this.#abiCoder.decode(fragment.outputs, bytes);
              } catch (error) {
                message = "could not decode result data";
              }
            }
            assert(false, message, "BAD_DATA", {
              value: hexlify(bytes),
              info: { method: fragment.name, signature: fragment.format() },
            });
          }
          makeError(_data, tx) {
            const data = getBytes(_data, "data");
            const error = AbiCoder.getBuiltinCallException("call", tx, data);
            const customPrefix = "execution reverted (unknown custom error)";
            if (error.message.startsWith(customPrefix)) {
              const selector = hexlify(data.slice(0, 4));
              const ef = this.getError(selector);
              if (ef) {
                try {
                  const args = this.#abiCoder.decode(ef.inputs, data.slice(4));
                  error.revert = {
                    name: ef.name,
                    signature: ef.format(),
                    args: args,
                  };
                  error.reason = error.revert.signature;
                  error.message = `execution reverted: ${error.reason}`;
                } catch (e) {
                  error.message = `execution reverted (coult not decode custom error)`;
                }
              }
            }
            const parsed = this.parseTransaction(tx);
            if (parsed) {
              error.invocation = {
                method: parsed.name,
                signature: parsed.signature,
                args: parsed.args,
              };
            }
            return error;
          }
          encodeFunctionResult(fragment, values) {
            if (typeof fragment === "string") {
              const f = this.getFunction(fragment);
              assertArgument(f, "unknown function", "fragment", fragment);
              fragment = f;
            }
            return hexlify(
              this.#abiCoder.encode(fragment.outputs, values || [])
            );
          }
          encodeFilterTopics(fragment, values) {
            if (typeof fragment === "string") {
              const f = this.getEvent(fragment);
              assertArgument(f, "unknown event", "eventFragment", fragment);
              fragment = f;
            }
            assert(
              values.length <= fragment.inputs.length,
              `too many arguments for ${fragment.format()}`,
              "UNEXPECTED_ARGUMENT",
              { count: values.length, expectedCount: fragment.inputs.length }
            );
            const topics = [];
            if (!fragment.anonymous) {
              topics.push(fragment.topicHash);
            }
            const encodeTopic = (param, value) => {
              if (param.type === "string") {
                return id(value);
              } else if (param.type === "bytes") {
                return keccak256(hexlify(value));
              }
              if (param.type === "bool" && typeof value === "boolean") {
                value = value ? "0x01" : "0x00";
              } else if (param.type.match(/^u?int/)) {
                value = toBeHex(value);
              } else if (param.type.match(/^bytes/)) {
                value = zeroPadBytes(value, 32);
              } else if (param.type === "address") {
                this.#abiCoder.encode(["address"], [value]);
              }
              return zeroPadValue(hexlify(value), 32);
            };
            values.forEach((value, index) => {
              const param = fragment.inputs[index];
              if (!param.indexed) {
                assertArgument(
                  value == null,
                  "cannot filter non-indexed parameters; must be null",
                  "contract." + param.name,
                  value
                );
                return;
              }
              if (value == null) {
                topics.push(null);
              } else if (
                param.baseType === "array" ||
                param.baseType === "tuple"
              ) {
                assertArgument(
                  false,
                  "filtering with tuples or arrays not supported",
                  "contract." + param.name,
                  value
                );
              } else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                topics.push(encodeTopic(param, value));
              }
            });
            while (topics.length && topics[topics.length - 1] === null) {
              topics.pop();
            }
            return topics;
          }
          encodeEventLog(fragment, values) {
            if (typeof fragment === "string") {
              const f = this.getEvent(fragment);
              assertArgument(f, "unknown event", "eventFragment", fragment);
              fragment = f;
            }
            const topics = [];
            const dataTypes = [];
            const dataValues = [];
            if (!fragment.anonymous) {
              topics.push(fragment.topicHash);
            }
            assertArgument(
              values.length === fragment.inputs.length,
              "event arguments/values mismatch",
              "values",
              values
            );
            fragment.inputs.forEach((param, index) => {
              const value = values[index];
              if (param.indexed) {
                if (param.type === "string") {
                  topics.push(id(value));
                } else if (param.type === "bytes") {
                  topics.push(keccak256(value));
                } else if (
                  param.baseType === "tuple" ||
                  param.baseType === "array"
                ) {
                  throw new Error("not implemented");
                } else {
                  topics.push(this.#abiCoder.encode([param.type], [value]));
                }
              } else {
                dataTypes.push(param);
                dataValues.push(value);
              }
            });
            return {
              data: this.#abiCoder.encode(dataTypes, dataValues),
              topics: topics,
            };
          }
          decodeEventLog(fragment, data, topics) {
            if (typeof fragment === "string") {
              const f = this.getEvent(fragment);
              assertArgument(f, "unknown event", "eventFragment", fragment);
              fragment = f;
            }
            if (topics != null && !fragment.anonymous) {
              const eventTopic = fragment.topicHash;
              assertArgument(
                isHexString(topics[0], 32) &&
                  topics[0].toLowerCase() === eventTopic,
                "fragment/topic mismatch",
                "topics[0]",
                topics[0]
              );
              topics = topics.slice(1);
            }
            const indexed = [];
            const nonIndexed = [];
            const dynamic = [];
            fragment.inputs.forEach((param, index) => {
              if (param.indexed) {
                if (
                  param.type === "string" ||
                  param.type === "bytes" ||
                  param.baseType === "tuple" ||
                  param.baseType === "array"
                ) {
                  indexed.push(
                    ParamType.from({ type: "bytes32", name: param.name })
                  );
                  dynamic.push(true);
                } else {
                  indexed.push(param);
                  dynamic.push(false);
                }
              } else {
                nonIndexed.push(param);
                dynamic.push(false);
              }
            });
            const resultIndexed =
              topics != null
                ? this.#abiCoder.decode(indexed, concat(topics))
                : null;
            const resultNonIndexed = this.#abiCoder.decode(
              nonIndexed,
              data,
              true
            );
            const values = [];
            const keys = [];
            let nonIndexedIndex = 0,
              indexedIndex = 0;
            fragment.inputs.forEach((param, index) => {
              let value = null;
              if (param.indexed) {
                if (resultIndexed == null) {
                  value = new Indexed(null);
                } else if (dynamic[index]) {
                  value = new Indexed(resultIndexed[indexedIndex++]);
                } else {
                  try {
                    value = resultIndexed[indexedIndex++];
                  } catch (error) {
                    value = error;
                  }
                }
              } else {
                try {
                  value = resultNonIndexed[nonIndexedIndex++];
                } catch (error) {
                  value = error;
                }
              }
              values.push(value);
              keys.push(param.name || null);
            });
            return Result.fromItems(values, keys);
          }
          parseTransaction(tx) {
            const data = getBytes(tx.data, "tx.data");
            const value = getBigInt(
              tx.value != null ? tx.value : 0,
              "tx.value"
            );
            const fragment = this.getFunction(hexlify(data.slice(0, 4)));
            if (!fragment) {
              return null;
            }
            const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
            return new TransactionDescription(
              fragment,
              fragment.selector,
              args,
              value
            );
          }
          parseCallResult(data) {
            throw new Error("@TODO");
          }
          parseLog(log) {
            const fragment = this.getEvent(log.topics[0]);
            if (!fragment || fragment.anonymous) {
              return null;
            }
            return new LogDescription(
              fragment,
              fragment.topicHash,
              this.decodeEventLog(fragment, log.data, log.topics)
            );
          }
          parseError(data) {
            const hexData = hexlify(data);
            const fragment = this.getError(dataSlice(hexData, 0, 4));
            if (!fragment) {
              return null;
            }
            const args = this.#abiCoder.decode(
              fragment.inputs,
              dataSlice(hexData, 4)
            );
            return new ErrorDescription(fragment, fragment.selector, args);
          }
          static from(value) {
            if (value instanceof Interface) {
              return value;
            }
            if (typeof value === "string") {
              return new Interface(JSON.parse(value));
            }
            if (typeof value.format === "function") {
              return new Interface(value.format("json"));
            }
            return new Interface(value);
          }
        }
        const BN_0$2 = BigInt(0);
        function getValue(value) {
          if (value == null) {
            return null;
          }
          return value;
        }
        function toJson(value) {
          if (value == null) {
            return null;
          }
          return value.toString();
        }
        class FeeData {
          gasPrice;
          maxFeePerGas;
          maxPriorityFeePerGas;
          constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
            defineProperties(this, {
              gasPrice: getValue(gasPrice),
              maxFeePerGas: getValue(maxFeePerGas),
              maxPriorityFeePerGas: getValue(maxPriorityFeePerGas),
            });
          }
          toJSON() {
            const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
            return {
              _type: "FeeData",
              gasPrice: toJson(gasPrice),
              maxFeePerGas: toJson(maxFeePerGas),
              maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),
            };
          }
        }
        function copyRequest(req) {
          const result = {};
          if (req.to) {
            result.to = req.to;
          }
          if (req.from) {
            result.from = req.from;
          }
          if (req.data) {
            result.data = hexlify(req.data);
          }
          const bigIntKeys =
            "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(
              /,/
            );
          for (const key of bigIntKeys) {
            if (!(key in req) || req[key] == null) {
              continue;
            }
            result[key] = getBigInt(req[key], `request.${key}`);
          }
          const numberKeys = "type,nonce".split(/,/);
          for (const key of numberKeys) {
            if (!(key in req) || req[key] == null) {
              continue;
            }
            result[key] = getNumber(req[key], `request.${key}`);
          }
          if (req.accessList) {
            result.accessList = accessListify(req.accessList);
          }
          if ("blockTag" in req) {
            result.blockTag = req.blockTag;
          }
          if ("enableCcipRead" in req) {
            result.enableCcipRead = !!req.enableCcipRead;
          }
          if ("customData" in req) {
            result.customData = req.customData;
          }
          return result;
        }
        class Block {
          provider;
          number;
          hash;
          timestamp;
          parentHash;
          parentBeaconBlockRoot;
          nonce;
          difficulty;
          gasLimit;
          gasUsed;
          stateRoot;
          receiptsRoot;
          blobGasUsed;
          excessBlobGas;
          miner;
          extraData;
          baseFeePerGas;
          #transactions;
          constructor(block, provider) {
            this.#transactions = block.transactions.map((tx) => {
              if (typeof tx !== "string") {
                return new TransactionResponse(tx, provider);
              }
              return tx;
            });
            defineProperties(this, {
              provider: provider,
              hash: getValue(block.hash),
              number: block.number,
              timestamp: block.timestamp,
              parentHash: block.parentHash,
              parentBeaconBlockRoot: block.parentBeaconBlockRoot,
              nonce: block.nonce,
              difficulty: block.difficulty,
              gasLimit: block.gasLimit,
              gasUsed: block.gasUsed,
              blobGasUsed: block.blobGasUsed,
              excessBlobGas: block.excessBlobGas,
              miner: block.miner,
              extraData: block.extraData,
              baseFeePerGas: getValue(block.baseFeePerGas),
              stateRoot: block.stateRoot,
              receiptsRoot: block.receiptsRoot,
            });
          }
          get transactions() {
            return this.#transactions.map((tx) => {
              if (typeof tx === "string") {
                return tx;
              }
              return tx.hash;
            });
          }
          get prefetchedTransactions() {
            const txs = this.#transactions.slice();
            if (txs.length === 0) {
              return [];
            }
            assert(
              typeof txs[0] === "object",
              "transactions were not prefetched with block request",
              "UNSUPPORTED_OPERATION",
              { operation: "transactionResponses()" }
            );
            return txs;
          }
          toJSON() {
            const {
              baseFeePerGas,
              difficulty,
              extraData,
              gasLimit,
              gasUsed,
              hash,
              miner,
              nonce,
              number,
              parentHash,
              parentBeaconBlockRoot,
              stateRoot,
              receiptsRoot,
              timestamp,
              transactions,
            } = this;
            return {
              _type: "Block",
              baseFeePerGas: toJson(baseFeePerGas),
              difficulty: toJson(difficulty),
              extraData: extraData,
              gasLimit: toJson(gasLimit),
              gasUsed: toJson(gasUsed),
              blobGasUsed: toJson(this.blobGasUsed),
              excessBlobGas: toJson(this.excessBlobGas),
              hash: hash,
              miner: miner,
              nonce: nonce,
              number: number,
              parentHash: parentHash,
              timestamp: timestamp,
              parentBeaconBlockRoot: parentBeaconBlockRoot,
              stateRoot: stateRoot,
              receiptsRoot: receiptsRoot,
              transactions: transactions,
            };
          }
          [Symbol.iterator]() {
            let index = 0;
            const txs = this.transactions;
            return {
              next: () => {
                if (index < this.length) {
                  return { value: txs[index++], done: false };
                }
                return { value: undefined, done: true };
              },
            };
          }
          get length() {
            return this.#transactions.length;
          }
          get date() {
            if (this.timestamp == null) {
              return null;
            }
            return new Date(this.timestamp * 1e3);
          }
          async getTransaction(indexOrHash) {
            let tx = undefined;
            if (typeof indexOrHash === "number") {
              tx = this.#transactions[indexOrHash];
            } else {
              const hash = indexOrHash.toLowerCase();
              for (const v of this.#transactions) {
                if (typeof v === "string") {
                  if (v !== hash) {
                    continue;
                  }
                  tx = v;
                  break;
                } else {
                  if (v.hash === hash) {
                    continue;
                  }
                  tx = v;
                  break;
                }
              }
            }
            if (tx == null) {
              throw new Error("no such tx");
            }
            if (typeof tx === "string") {
              return await this.provider.getTransaction(tx);
            } else {
              return tx;
            }
          }
          getPrefetchedTransaction(indexOrHash) {
            const txs = this.prefetchedTransactions;
            if (typeof indexOrHash === "number") {
              return txs[indexOrHash];
            }
            indexOrHash = indexOrHash.toLowerCase();
            for (const tx of txs) {
              if (tx.hash === indexOrHash) {
                return tx;
              }
            }
            assertArgument(
              false,
              "no matching transaction",
              "indexOrHash",
              indexOrHash
            );
          }
          isMined() {
            return !!this.hash;
          }
          isLondon() {
            return !!this.baseFeePerGas;
          }
          orphanedEvent() {
            if (!this.isMined()) {
              throw new Error("");
            }
            return createOrphanedBlockFilter(this);
          }
        }
        class Log {
          provider;
          transactionHash;
          blockHash;
          blockNumber;
          removed;
          address;
          data;
          topics;
          index;
          transactionIndex;
          constructor(log, provider) {
            this.provider = provider;
            const topics = Object.freeze(log.topics.slice());
            defineProperties(this, {
              transactionHash: log.transactionHash,
              blockHash: log.blockHash,
              blockNumber: log.blockNumber,
              removed: log.removed,
              address: log.address,
              data: log.data,
              topics: topics,
              index: log.index,
              transactionIndex: log.transactionIndex,
            });
          }
          toJSON() {
            const {
              address,
              blockHash,
              blockNumber,
              data,
              index,
              removed,
              topics,
              transactionHash,
              transactionIndex,
            } = this;
            return {
              _type: "log",
              address: address,
              blockHash: blockHash,
              blockNumber: blockNumber,
              data: data,
              index: index,
              removed: removed,
              topics: topics,
              transactionHash: transactionHash,
              transactionIndex: transactionIndex,
            };
          }
          async getBlock() {
            const block = await this.provider.getBlock(this.blockHash);
            assert(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
            return block;
          }
          async getTransaction() {
            const tx = await this.provider.getTransaction(this.transactionHash);
            assert(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
            return tx;
          }
          async getTransactionReceipt() {
            const receipt = await this.provider.getTransactionReceipt(
              this.transactionHash
            );
            assert(
              !!receipt,
              "failed to find transaction receipt",
              "UNKNOWN_ERROR",
              {}
            );
            return receipt;
          }
          removedEvent() {
            return createRemovedLogFilter(this);
          }
        }
        class TransactionReceipt {
          provider;
          to;
          from;
          contractAddress;
          hash;
          index;
          blockHash;
          blockNumber;
          logsBloom;
          gasUsed;
          blobGasUsed;
          cumulativeGasUsed;
          gasPrice;
          blobGasPrice;
          type;
          status;
          root;
          #logs;
          constructor(tx, provider) {
            this.#logs = Object.freeze(
              tx.logs.map((log) => {
                return new Log(log, provider);
              })
            );
            let gasPrice = BN_0$2;
            if (tx.effectiveGasPrice != null) {
              gasPrice = tx.effectiveGasPrice;
            } else if (tx.gasPrice != null) {
              gasPrice = tx.gasPrice;
            }
            defineProperties(this, {
              provider: provider,
              to: tx.to,
              from: tx.from,
              contractAddress: tx.contractAddress,
              hash: tx.hash,
              index: tx.index,
              blockHash: tx.blockHash,
              blockNumber: tx.blockNumber,
              logsBloom: tx.logsBloom,
              gasUsed: tx.gasUsed,
              cumulativeGasUsed: tx.cumulativeGasUsed,
              blobGasUsed: tx.blobGasUsed,
              gasPrice: gasPrice,
              blobGasPrice: tx.blobGasPrice,
              type: tx.type,
              status: tx.status,
              root: tx.root,
            });
          }
          get logs() {
            return this.#logs;
          }
          toJSON() {
            const {
              to,
              from,
              contractAddress,
              hash,
              index,
              blockHash,
              blockNumber,
              logsBloom,
              logs,
              status,
              root,
            } = this;
            return {
              _type: "TransactionReceipt",
              blockHash: blockHash,
              blockNumber: blockNumber,
              contractAddress: contractAddress,
              cumulativeGasUsed: toJson(this.cumulativeGasUsed),
              from: from,
              gasPrice: toJson(this.gasPrice),
              blobGasUsed: toJson(this.blobGasUsed),
              blobGasPrice: toJson(this.blobGasPrice),
              gasUsed: toJson(this.gasUsed),
              hash: hash,
              index: index,
              logs: logs,
              logsBloom: logsBloom,
              root: root,
              status: status,
              to: to,
            };
          }
          get length() {
            return this.logs.length;
          }
          [Symbol.iterator]() {
            let index = 0;
            return {
              next: () => {
                if (index < this.length) {
                  return { value: this.logs[index++], done: false };
                }
                return { value: undefined, done: true };
              },
            };
          }
          get fee() {
            return this.gasUsed * this.gasPrice;
          }
          async getBlock() {
            const block = await this.provider.getBlock(this.blockHash);
            if (block == null) {
              throw new Error("TODO");
            }
            return block;
          }
          async getTransaction() {
            const tx = await this.provider.getTransaction(this.hash);
            if (tx == null) {
              throw new Error("TODO");
            }
            return tx;
          }
          async getResult() {
            return await this.provider.getTransactionResult(this.hash);
          }
          async confirmations() {
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          removedEvent() {
            return createRemovedTransactionFilter(this);
          }
          reorderedEvent(other) {
            assert(
              !other || other.isMined(),
              "unmined 'other' transction cannot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "reorderedEvent(other)" }
            );
            return createReorderedTransactionFilter(this, other);
          }
        }
        class TransactionResponse {
          provider;
          blockNumber;
          blockHash;
          index;
          hash;
          type;
          to;
          from;
          nonce;
          gasLimit;
          gasPrice;
          maxPriorityFeePerGas;
          maxFeePerGas;
          maxFeePerBlobGas;
          data;
          value;
          chainId;
          signature;
          accessList;
          blobVersionedHashes;
          #startBlock;
          constructor(tx, provider) {
            this.provider = provider;
            this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
            this.blockHash = tx.blockHash != null ? tx.blockHash : null;
            this.hash = tx.hash;
            this.index = tx.index;
            this.type = tx.type;
            this.from = tx.from;
            this.to = tx.to || null;
            this.gasLimit = tx.gasLimit;
            this.nonce = tx.nonce;
            this.data = tx.data;
            this.value = tx.value;
            this.gasPrice = tx.gasPrice;
            this.maxPriorityFeePerGas =
              tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
            this.maxFeePerGas =
              tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
            this.maxFeePerBlobGas =
              tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
            this.chainId = tx.chainId;
            this.signature = tx.signature;
            this.accessList = tx.accessList != null ? tx.accessList : null;
            this.blobVersionedHashes =
              tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
            this.#startBlock = -1;
          }
          toJSON() {
            const {
              blockNumber,
              blockHash,
              index,
              hash,
              type,
              to,
              from,
              nonce,
              data,
              signature,
              accessList,
              blobVersionedHashes,
            } = this;
            return {
              _type: "TransactionResponse",
              accessList: accessList,
              blockNumber: blockNumber,
              blockHash: blockHash,
              blobVersionedHashes: blobVersionedHashes,
              chainId: toJson(this.chainId),
              data: data,
              from: from,
              gasLimit: toJson(this.gasLimit),
              gasPrice: toJson(this.gasPrice),
              hash: hash,
              maxFeePerGas: toJson(this.maxFeePerGas),
              maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
              maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
              nonce: nonce,
              signature: signature,
              to: to,
              index: index,
              type: type,
              value: toJson(this.value),
            };
          }
          async getBlock() {
            let blockNumber = this.blockNumber;
            if (blockNumber == null) {
              const tx = await this.getTransaction();
              if (tx) {
                blockNumber = tx.blockNumber;
              }
            }
            if (blockNumber == null) {
              return null;
            }
            const block = this.provider.getBlock(blockNumber);
            if (block == null) {
              throw new Error("TODO");
            }
            return block;
          }
          async getTransaction() {
            return this.provider.getTransaction(this.hash);
          }
          async confirmations() {
            if (this.blockNumber == null) {
              const { tx, blockNumber } = await resolveProperties({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber(),
              });
              if (tx == null || tx.blockNumber == null) {
                return 0;
              }
              return blockNumber - tx.blockNumber + 1;
            }
            const blockNumber = await this.provider.getBlockNumber();
            return blockNumber - this.blockNumber + 1;
          }
          async wait(_confirms, _timeout) {
            const confirms = _confirms == null ? 1 : _confirms;
            const timeout = _timeout == null ? 0 : _timeout;
            let startBlock = this.#startBlock;
            let nextScan = -1;
            let stopScanning = startBlock === -1 ? true : false;
            const checkReplacement = async () => {
              if (stopScanning) {
                return null;
              }
              const { blockNumber, nonce } = await resolveProperties({
                blockNumber: this.provider.getBlockNumber(),
                nonce: this.provider.getTransactionCount(this.from),
              });
              if (nonce < this.nonce) {
                startBlock = blockNumber;
                return;
              }
              if (stopScanning) {
                return null;
              }
              const mined = await this.getTransaction();
              if (mined && mined.blockNumber != null) {
                return;
              }
              if (nextScan === -1) {
                nextScan = startBlock - 3;
                if (nextScan < this.#startBlock) {
                  nextScan = this.#startBlock;
                }
              }
              while (nextScan <= blockNumber) {
                if (stopScanning) {
                  return null;
                }
                const block = await this.provider.getBlock(nextScan, true);
                if (block == null) {
                  return;
                }
                for (const hash of block) {
                  if (hash === this.hash) {
                    return;
                  }
                }
                for (let i = 0; i < block.length; i++) {
                  const tx = await block.getTransaction(i);
                  if (tx.from === this.from && tx.nonce === this.nonce) {
                    if (stopScanning) {
                      return null;
                    }
                    const receipt = await this.provider.getTransactionReceipt(
                      tx.hash
                    );
                    if (receipt == null) {
                      return;
                    }
                    if (blockNumber - receipt.blockNumber + 1 < confirms) {
                      return;
                    }
                    let reason = "replaced";
                    if (
                      tx.data === this.data &&
                      tx.to === this.to &&
                      tx.value === this.value
                    ) {
                      reason = "repriced";
                    } else if (
                      tx.data === "0x" &&
                      tx.from === tx.to &&
                      tx.value === BN_0$2
                    ) {
                      reason = "cancelled";
                    }
                    assert(
                      false,
                      "transaction was replaced",
                      "TRANSACTION_REPLACED",
                      {
                        cancelled:
                          reason === "replaced" || reason === "cancelled",
                        reason: reason,
                        replacement: tx.replaceableTransaction(startBlock),
                        hash: tx.hash,
                        receipt: receipt,
                      }
                    );
                  }
                }
                nextScan++;
              }
              return;
            };
            const checkReceipt = (receipt) => {
              if (receipt == null || receipt.status !== 0) {
                return receipt;
              }
              assert(
                false,
                "transaction execution reverted",
                "CALL_EXCEPTION",
                {
                  action: "sendTransaction",
                  data: null,
                  reason: null,
                  invocation: null,
                  revert: null,
                  transaction: { to: receipt.to, from: receipt.from, data: "" },
                  receipt: receipt,
                }
              );
            };
            const receipt = await this.provider.getTransactionReceipt(
              this.hash
            );
            if (confirms === 0) {
              return checkReceipt(receipt);
            }
            if (receipt) {
              if ((await receipt.confirmations()) >= confirms) {
                return checkReceipt(receipt);
              }
            } else {
              await checkReplacement();
              if (confirms === 0) {
                return null;
              }
            }
            const waiter = new Promise((resolve, reject) => {
              const cancellers = [];
              const cancel = () => {
                cancellers.forEach((c) => c());
              };
              cancellers.push(() => {
                stopScanning = true;
              });
              if (timeout > 0) {
                const timer = setTimeout(() => {
                  cancel();
                  reject(makeError("wait for transaction timeout", "TIMEOUT"));
                }, timeout);
                cancellers.push(() => {
                  clearTimeout(timer);
                });
              }
              const txListener = async (receipt) => {
                if ((await receipt.confirmations()) >= confirms) {
                  cancel();
                  try {
                    resolve(checkReceipt(receipt));
                  } catch (error) {
                    reject(error);
                  }
                }
              };
              cancellers.push(() => {
                this.provider.off(this.hash, txListener);
              });
              this.provider.on(this.hash, txListener);
              if (startBlock >= 0) {
                const replaceListener = async () => {
                  try {
                    await checkReplacement();
                  } catch (error) {
                    if (isError(error, "TRANSACTION_REPLACED")) {
                      cancel();
                      reject(error);
                      return;
                    }
                  }
                  if (!stopScanning) {
                    this.provider.once("block", replaceListener);
                  }
                };
                cancellers.push(() => {
                  this.provider.off("block", replaceListener);
                });
                this.provider.once("block", replaceListener);
              }
            });
            return await waiter;
          }
          isMined() {
            return this.blockHash != null;
          }
          isLegacy() {
            return this.type === 0;
          }
          isBerlin() {
            return this.type === 1;
          }
          isLondon() {
            return this.type === 2;
          }
          isCancun() {
            return this.type === 3;
          }
          removedEvent() {
            assert(
              this.isMined(),
              "unmined transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            );
            return createRemovedTransactionFilter(this);
          }
          reorderedEvent(other) {
            assert(
              this.isMined(),
              "unmined transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            );
            assert(
              !other || other.isMined(),
              "unmined 'other' transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            );
            return createReorderedTransactionFilter(this, other);
          }
          replaceableTransaction(startBlock) {
            assertArgument(
              Number.isInteger(startBlock) && startBlock >= 0,
              "invalid startBlock",
              "startBlock",
              startBlock
            );
            const tx = new TransactionResponse(this, this.provider);
            tx.#startBlock = startBlock;
            return tx;
          }
        }
        function createOrphanedBlockFilter(block) {
          return {
            orphan: "drop-block",
            hash: block.hash,
            number: block.number,
          };
        }
        function createReorderedTransactionFilter(tx, other) {
          return { orphan: "reorder-transaction", tx: tx, other: other };
        }
        function createRemovedTransactionFilter(tx) {
          return { orphan: "drop-transaction", tx: tx };
        }
        function createRemovedLogFilter(log) {
          return {
            orphan: "drop-log",
            log: {
              transactionHash: log.transactionHash,
              blockHash: log.blockHash,
              blockNumber: log.blockNumber,
              address: log.address,
              data: log.data,
              topics: Object.freeze(log.topics.slice()),
              index: log.index,
            },
          };
        }
        class EventLog extends Log {
          interface;
          fragment;
          args;
          constructor(log, iface, fragment) {
            super(log, log.provider);
            const args = iface.decodeEventLog(fragment, log.data, log.topics);
            defineProperties(this, {
              args: args,
              fragment: fragment,
              interface: iface,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        class UndecodedEventLog extends Log {
          error;
          constructor(log, error) {
            super(log, log.provider);
            defineProperties(this, { error: error });
          }
        }
        class ContractTransactionReceipt extends TransactionReceipt {
          #iface;
          constructor(iface, provider, tx) {
            super(tx, provider);
            this.#iface = iface;
          }
          get logs() {
            return super.logs.map((log) => {
              const fragment = log.topics.length
                ? this.#iface.getEvent(log.topics[0])
                : null;
              if (fragment) {
                try {
                  return new EventLog(log, this.#iface, fragment);
                } catch (error) {
                  return new UndecodedEventLog(log, error);
                }
              }
              return log;
            });
          }
        }
        class ContractTransactionResponse extends TransactionResponse {
          #iface;
          constructor(iface, provider, tx) {
            super(tx, provider);
            this.#iface = iface;
          }
          async wait(confirms, timeout) {
            const receipt = await super.wait(confirms, timeout);
            if (receipt == null) {
              return null;
            }
            return new ContractTransactionReceipt(
              this.#iface,
              this.provider,
              receipt
            );
          }
        }
        class ContractUnknownEventPayload extends EventPayload {
          log;
          constructor(contract, listener, filter, log) {
            super(contract, listener, filter);
            defineProperties(this, { log: log });
          }
          async getBlock() {
            return await this.log.getBlock();
          }
          async getTransaction() {
            return await this.log.getTransaction();
          }
          async getTransactionReceipt() {
            return await this.log.getTransactionReceipt();
          }
        }
        class ContractEventPayload extends ContractUnknownEventPayload {
          constructor(contract, listener, filter, fragment, _log) {
            super(
              contract,
              listener,
              filter,
              new EventLog(_log, contract.interface, fragment)
            );
            const args = contract.interface.decodeEventLog(
              fragment,
              this.log.data,
              this.log.topics
            );
            defineProperties(this, { args: args, fragment: fragment });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        const BN_0$1 = BigInt(0);
        function canCall(value) {
          return value && typeof value.call === "function";
        }
        function canEstimate(value) {
          return value && typeof value.estimateGas === "function";
        }
        function canResolve(value) {
          return value && typeof value.resolveName === "function";
        }
        function canSend(value) {
          return value && typeof value.sendTransaction === "function";
        }
        function getResolver(value) {
          if (value != null) {
            if (canResolve(value)) {
              return value;
            }
            if (value.provider) {
              return value.provider;
            }
          }
          return undefined;
        }
        class PreparedTopicFilter {
          #filter;
          fragment;
          constructor(contract, fragment, args) {
            defineProperties(this, { fragment: fragment });
            if (fragment.inputs.length < args.length) {
              throw new Error("too many arguments");
            }
            const runner = getRunner(contract.runner, "resolveName");
            const resolver = canResolve(runner) ? runner : null;
            this.#filter = (async function () {
              const resolvedArgs = await Promise.all(
                fragment.inputs.map((param, index) => {
                  const arg = args[index];
                  if (arg == null) {
                    return null;
                  }
                  return param.walkAsync(args[index], (type, value) => {
                    if (type === "address") {
                      if (Array.isArray(value)) {
                        return Promise.all(
                          value.map((v) => resolveAddress(v, resolver))
                        );
                      }
                      return resolveAddress(value, resolver);
                    }
                    return value;
                  });
                })
              );
              return contract.interface.encodeFilterTopics(
                fragment,
                resolvedArgs
              );
            })();
          }
          getTopicFilter() {
            return this.#filter;
          }
        }
        function getRunner(value, feature) {
          if (value == null) {
            return null;
          }
          if (typeof value[feature] === "function") {
            return value;
          }
          if (value.provider && typeof value.provider[feature] === "function") {
            return value.provider;
          }
          return null;
        }
        function getProvider(value) {
          if (value == null) {
            return null;
          }
          return value.provider || null;
        }
        async function copyOverrides(arg, allowed) {
          const _overrides = Typed.dereference(arg, "overrides");
          assertArgument(
            typeof _overrides === "object",
            "invalid overrides parameter",
            "overrides",
            arg
          );
          const overrides = copyRequest(_overrides);
          assertArgument(
            overrides.to == null || (allowed || []).indexOf("to") >= 0,
            "cannot override to",
            "overrides.to",
            overrides.to
          );
          assertArgument(
            overrides.data == null || (allowed || []).indexOf("data") >= 0,
            "cannot override data",
            "overrides.data",
            overrides.data
          );
          if (overrides.from) {
            overrides.from = overrides.from;
          }
          return overrides;
        }
        async function resolveArgs(_runner, inputs, args) {
          const runner = getRunner(_runner, "resolveName");
          const resolver = canResolve(runner) ? runner : null;
          return await Promise.all(
            inputs.map((param, index) => {
              return param.walkAsync(args[index], (type, value) => {
                value = Typed.dereference(value, type);
                if (type === "address") {
                  return resolveAddress(value, resolver);
                }
                return value;
              });
            })
          );
        }
        function buildWrappedFallback(contract) {
          const populateTransaction = async function (overrides) {
            const tx = await copyOverrides(overrides, ["data"]);
            tx.to = await contract.getAddress();
            if (tx.from) {
              tx.from = await resolveAddress(
                tx.from,
                getResolver(contract.runner)
              );
            }
            const iface = contract.interface;
            const noValue =
              getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
            const noData = (tx.data || "0x") === "0x";
            if (
              iface.fallback &&
              !iface.fallback.payable &&
              iface.receive &&
              !noData &&
              !noValue
            ) {
              assertArgument(
                false,
                "cannot send data to receive or send value to non-payable fallback",
                "overrides",
                overrides
              );
            }
            assertArgument(
              iface.fallback || noData,
              "cannot send data to receive-only contract",
              "overrides.data",
              tx.data
            );
            const payable =
              iface.receive || (iface.fallback && iface.fallback.payable);
            assertArgument(
              payable || noValue,
              "cannot send value to non-payable fallback",
              "overrides.value",
              tx.value
            );
            assertArgument(
              iface.fallback || noData,
              "cannot send data to receive-only contract",
              "overrides.data",
              tx.data
            );
            return tx;
          };
          const staticCall = async function (overrides) {
            const runner = getRunner(contract.runner, "call");
            assert(
              canCall(runner),
              "contract runner does not support calling",
              "UNSUPPORTED_OPERATION",
              { operation: "call" }
            );
            const tx = await populateTransaction(overrides);
            try {
              return await runner.call(tx);
            } catch (error) {
              if (isCallException(error) && error.data) {
                throw contract.interface.makeError(error.data, tx);
              }
              throw error;
            }
          };
          const send = async function (overrides) {
            const runner = contract.runner;
            assert(
              canSend(runner),
              "contract runner does not support sending transactions",
              "UNSUPPORTED_OPERATION",
              { operation: "sendTransaction" }
            );
            const tx = await runner.sendTransaction(
              await populateTransaction(overrides)
            );
            const provider = getProvider(contract.runner);
            return new ContractTransactionResponse(
              contract.interface,
              provider,
              tx
            );
          };
          const estimateGas = async function (overrides) {
            const runner = getRunner(contract.runner, "estimateGas");
            assert(
              canEstimate(runner),
              "contract runner does not support gas estimation",
              "UNSUPPORTED_OPERATION",
              { operation: "estimateGas" }
            );
            return await runner.estimateGas(
              await populateTransaction(overrides)
            );
          };
          const method = async (overrides) => {
            return await send(overrides);
          };
          defineProperties(method, {
            _contract: contract,
            estimateGas: estimateGas,
            populateTransaction: populateTransaction,
            send: send,
            staticCall: staticCall,
          });
          return method;
        }
        function buildWrappedMethod(contract, key) {
          const getFragment = function (...args) {
            const fragment = contract.interface.getFunction(key, args);
            assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
              operation: "fragment",
              info: { key: key, args: args },
            });
            return fragment;
          };
          const populateTransaction = async function (...args) {
            const fragment = getFragment(...args);
            let overrides = {};
            if (fragment.inputs.length + 1 === args.length) {
              overrides = await copyOverrides(args.pop());
              if (overrides.from) {
                overrides.from = await resolveAddress(
                  overrides.from,
                  getResolver(contract.runner)
                );
              }
            }
            if (fragment.inputs.length !== args.length) {
              throw new Error(
                "internal error: fragment inputs doesn't match arguments; should not happen"
              );
            }
            const resolvedArgs = await resolveArgs(
              contract.runner,
              fragment.inputs,
              args
            );
            return Object.assign(
              {},
              overrides,
              await resolveProperties({
                to: contract.getAddress(),
                data: contract.interface.encodeFunctionData(
                  fragment,
                  resolvedArgs
                ),
              })
            );
          };
          const staticCall = async function (...args) {
            const result = await staticCallResult(...args);
            if (result.length === 1) {
              return result[0];
            }
            return result;
          };
          const send = async function (...args) {
            const runner = contract.runner;
            assert(
              canSend(runner),
              "contract runner does not support sending transactions",
              "UNSUPPORTED_OPERATION",
              { operation: "sendTransaction" }
            );
            const tx = await runner.sendTransaction(
              await populateTransaction(...args)
            );
            const provider = getProvider(contract.runner);
            return new ContractTransactionResponse(
              contract.interface,
              provider,
              tx
            );
          };
          const estimateGas = async function (...args) {
            const runner = getRunner(contract.runner, "estimateGas");
            assert(
              canEstimate(runner),
              "contract runner does not support gas estimation",
              "UNSUPPORTED_OPERATION",
              { operation: "estimateGas" }
            );
            return await runner.estimateGas(await populateTransaction(...args));
          };
          const staticCallResult = async function (...args) {
            const runner = getRunner(contract.runner, "call");
            assert(
              canCall(runner),
              "contract runner does not support calling",
              "UNSUPPORTED_OPERATION",
              { operation: "call" }
            );
            const tx = await populateTransaction(...args);
            let result = "0x";
            try {
              result = await runner.call(tx);
            } catch (error) {
              if (isCallException(error) && error.data) {
                throw contract.interface.makeError(error.data, tx);
              }
              throw error;
            }
            const fragment = getFragment(...args);
            return contract.interface.decodeFunctionResult(fragment, result);
          };
          const method = async (...args) => {
            const fragment = getFragment(...args);
            if (fragment.constant) {
              return await staticCall(...args);
            }
            return await send(...args);
          };
          defineProperties(method, {
            name: contract.interface.getFunctionName(key),
            _contract: contract,
            _key: key,
            getFragment: getFragment,
            estimateGas: estimateGas,
            populateTransaction: populateTransaction,
            send: send,
            staticCall: staticCall,
            staticCallResult: staticCallResult,
          });
          Object.defineProperty(method, "fragment", {
            configurable: false,
            enumerable: true,
            get: () => {
              const fragment = contract.interface.getFunction(key);
              assert(
                fragment,
                "no matching fragment",
                "UNSUPPORTED_OPERATION",
                { operation: "fragment", info: { key: key } }
              );
              return fragment;
            },
          });
          return method;
        }
        function buildWrappedEvent(contract, key) {
          const getFragment = function (...args) {
            const fragment = contract.interface.getEvent(key, args);
            assert(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
              operation: "fragment",
              info: { key: key, args: args },
            });
            return fragment;
          };
          const method = function (...args) {
            return new PreparedTopicFilter(
              contract,
              getFragment(...args),
              args
            );
          };
          defineProperties(method, {
            name: contract.interface.getEventName(key),
            _contract: contract,
            _key: key,
            getFragment: getFragment,
          });
          Object.defineProperty(method, "fragment", {
            configurable: false,
            enumerable: true,
            get: () => {
              const fragment = contract.interface.getEvent(key);
              assert(
                fragment,
                "no matching fragment",
                "UNSUPPORTED_OPERATION",
                { operation: "fragment", info: { key: key } }
              );
              return fragment;
            },
          });
          return method;
        }
        const internal = Symbol.for("_ethersInternal_contract");
        const internalValues = new WeakMap();
        function setInternal(contract, values) {
          internalValues.set(contract[internal], values);
        }
        function getInternal(contract) {
          return internalValues.get(contract[internal]);
        }
        function isDeferred(value) {
          return (
            value &&
            typeof value === "object" &&
            "getTopicFilter" in value &&
            typeof value.getTopicFilter === "function" &&
            value.fragment
          );
        }
        async function getSubInfo(contract, event) {
          let topics;
          let fragment = null;
          if (Array.isArray(event)) {
            const topicHashify = function (name) {
              if (isHexString(name, 32)) {
                return name;
              }
              const fragment = contract.interface.getEvent(name);
              assertArgument(fragment, "unknown fragment", "name", name);
              return fragment.topicHash;
            };
            topics = event.map((e) => {
              if (e == null) {
                return null;
              }
              if (Array.isArray(e)) {
                return e.map(topicHashify);
              }
              return topicHashify(e);
            });
          } else if (event === "*") {
            topics = [null];
          } else if (typeof event === "string") {
            if (isHexString(event, 32)) {
              topics = [event];
            } else {
              fragment = contract.interface.getEvent(event);
              assertArgument(fragment, "unknown fragment", "event", event);
              topics = [fragment.topicHash];
            }
          } else if (isDeferred(event)) {
            topics = await event.getTopicFilter();
          } else if ("fragment" in event) {
            fragment = event.fragment;
            topics = [fragment.topicHash];
          } else {
            assertArgument(false, "unknown event name", "event", event);
          }
          topics = topics.map((t) => {
            if (t == null) {
              return null;
            }
            if (Array.isArray(t)) {
              const items = Array.from(
                new Set(t.map((t) => t.toLowerCase())).values()
              );
              if (items.length === 1) {
                return items[0];
              }
              items.sort();
              return items;
            }
            return t.toLowerCase();
          });
          const tag = topics
            .map((t) => {
              if (t == null) {
                return "null";
              }
              if (Array.isArray(t)) {
                return t.join("|");
              }
              return t;
            })
            .join("&");
          return { fragment: fragment, tag: tag, topics: topics };
        }
        async function hasSub(contract, event) {
          const { subs } = getInternal(contract);
          return subs.get((await getSubInfo(contract, event)).tag) || null;
        }
        async function getSub(contract, operation, event) {
          const provider = getProvider(contract.runner);
          assert(
            provider,
            "contract runner does not support subscribing",
            "UNSUPPORTED_OPERATION",
            { operation: operation }
          );
          const { fragment, tag, topics } = await getSubInfo(contract, event);
          const { addr, subs } = getInternal(contract);
          let sub = subs.get(tag);
          if (!sub) {
            const address = addr ? addr : contract;
            const filter = { address: address, topics: topics };
            const listener = (log) => {
              let foundFragment = fragment;
              if (foundFragment == null) {
                try {
                  foundFragment = contract.interface.getEvent(log.topics[0]);
                } catch (error) {}
              }
              if (foundFragment) {
                const _foundFragment = foundFragment;
                const args = fragment
                  ? contract.interface.decodeEventLog(
                      fragment,
                      log.data,
                      log.topics
                    )
                  : [];
                emit(contract, event, args, (listener) => {
                  return new ContractEventPayload(
                    contract,
                    listener,
                    event,
                    _foundFragment,
                    log
                  );
                });
              } else {
                emit(contract, event, [], (listener) => {
                  return new ContractUnknownEventPayload(
                    contract,
                    listener,
                    event,
                    log
                  );
                });
              }
            };
            let starting = [];
            const start = () => {
              if (starting.length) {
                return;
              }
              starting.push(provider.on(filter, listener));
            };
            const stop = async () => {
              if (starting.length == 0) {
                return;
              }
              let started = starting;
              starting = [];
              await Promise.all(started);
              provider.off(filter, listener);
            };
            sub = { tag: tag, listeners: [], start: start, stop: stop };
            subs.set(tag, sub);
          }
          return sub;
        }
        let lastEmit = Promise.resolve();
        async function _emit(contract, event, args, payloadFunc) {
          await lastEmit;
          const sub = await hasSub(contract, event);
          if (!sub) {
            return false;
          }
          const count = sub.listeners.length;
          sub.listeners = sub.listeners.filter(({ listener, once }) => {
            const passArgs = Array.from(args);
            if (payloadFunc) {
              passArgs.push(payloadFunc(once ? null : listener));
            }
            try {
              listener.call(contract, ...passArgs);
            } catch (error) {}
            return !once;
          });
          if (sub.listeners.length === 0) {
            sub.stop();
            getInternal(contract).subs.delete(sub.tag);
          }
          return count > 0;
        }
        async function emit(contract, event, args, payloadFunc) {
          try {
            await lastEmit;
          } catch (error) {}
          const resultPromise = _emit(contract, event, args, payloadFunc);
          lastEmit = resultPromise;
          return await resultPromise;
        }
        const passProperties = ["then"];
        class BaseContract {
          target;
          interface;
          runner;
          filters;
          [internal];
          fallback;
          constructor(target, abi, runner, _deployTx) {
            assertArgument(
              typeof target === "string" || isAddressable(target),
              "invalid value for Contract target",
              "target",
              target
            );
            if (runner == null) {
              runner = null;
            }
            const iface = Interface.from(abi);
            defineProperties(this, {
              target: target,
              runner: runner,
              interface: iface,
            });
            Object.defineProperty(this, internal, { value: {} });
            let addrPromise;
            let addr = null;
            let deployTx = null;
            if (_deployTx) {
              const provider = getProvider(runner);
              deployTx = new ContractTransactionResponse(
                this.interface,
                provider,
                _deployTx
              );
            }
            let subs = new Map();
            if (typeof target === "string") {
              if (isHexString(target)) {
                addr = target;
                addrPromise = Promise.resolve(target);
              } else {
                const resolver = getRunner(runner, "resolveName");
                if (!canResolve(resolver)) {
                  throw makeError(
                    "contract runner does not support name resolution",
                    "UNSUPPORTED_OPERATION",
                    { operation: "resolveName" }
                  );
                }
                addrPromise = resolver.resolveName(target).then((addr) => {
                  if (addr == null) {
                    throw makeError(
                      "an ENS name used for a contract target must be correctly configured",
                      "UNCONFIGURED_NAME",
                      { value: target }
                    );
                  }
                  getInternal(this).addr = addr;
                  return addr;
                });
              }
            } else {
              addrPromise = target.getAddress().then((addr) => {
                if (addr == null) {
                  throw new Error("TODO");
                }
                getInternal(this).addr = addr;
                return addr;
              });
            }
            setInternal(this, {
              addrPromise: addrPromise,
              addr: addr,
              deployTx: deployTx,
              subs: subs,
            });
            const filters = new Proxy(
              {},
              {
                get: (target, prop, receiver) => {
                  if (
                    typeof prop === "symbol" ||
                    passProperties.indexOf(prop) >= 0
                  ) {
                    return Reflect.get(target, prop, receiver);
                  }
                  try {
                    return this.getEvent(prop);
                  } catch (error) {
                    if (
                      !isError(error, "INVALID_ARGUMENT") ||
                      error.argument !== "key"
                    ) {
                      throw error;
                    }
                  }
                  return undefined;
                },
                has: (target, prop) => {
                  if (passProperties.indexOf(prop) >= 0) {
                    return Reflect.has(target, prop);
                  }
                  return (
                    Reflect.has(target, prop) ||
                    this.interface.hasEvent(String(prop))
                  );
                },
              }
            );
            defineProperties(this, { filters: filters });
            defineProperties(this, {
              fallback:
                iface.receive || iface.fallback
                  ? buildWrappedFallback(this)
                  : null,
            });
            return new Proxy(this, {
              get: (target, prop, receiver) => {
                if (
                  typeof prop === "symbol" ||
                  prop in target ||
                  passProperties.indexOf(prop) >= 0
                ) {
                  return Reflect.get(target, prop, receiver);
                }
                try {
                  return target.getFunction(prop);
                } catch (error) {
                  if (
                    !isError(error, "INVALID_ARGUMENT") ||
                    error.argument !== "key"
                  ) {
                    throw error;
                  }
                }
                return undefined;
              },
              has: (target, prop) => {
                if (
                  typeof prop === "symbol" ||
                  prop in target ||
                  passProperties.indexOf(prop) >= 0
                ) {
                  return Reflect.has(target, prop);
                }
                return target.interface.hasFunction(prop);
              },
            });
          }
          connect(runner) {
            return new BaseContract(this.target, this.interface, runner);
          }
          attach(target) {
            return new BaseContract(target, this.interface, this.runner);
          }
          async getAddress() {
            return await getInternal(this).addrPromise;
          }
          async getDeployedCode() {
            const provider = getProvider(this.runner);
            assert(
              provider,
              "runner does not support .provider",
              "UNSUPPORTED_OPERATION",
              { operation: "getDeployedCode" }
            );
            const code = await provider.getCode(await this.getAddress());
            if (code === "0x") {
              return null;
            }
            return code;
          }
          async waitForDeployment() {
            const deployTx = this.deploymentTransaction();
            if (deployTx) {
              await deployTx.wait();
              return this;
            }
            const code = await this.getDeployedCode();
            if (code != null) {
              return this;
            }
            const provider = getProvider(this.runner);
            assert(
              provider != null,
              "contract runner does not support .provider",
              "UNSUPPORTED_OPERATION",
              { operation: "waitForDeployment" }
            );
            return new Promise((resolve, reject) => {
              const checkCode = async () => {
                try {
                  const code = await this.getDeployedCode();
                  if (code != null) {
                    return resolve(this);
                  }
                  provider.once("block", checkCode);
                } catch (error) {
                  reject(error);
                }
              };
              checkCode();
            });
          }
          deploymentTransaction() {
            return getInternal(this).deployTx;
          }
          getFunction(key) {
            if (typeof key !== "string") {
              key = key.format();
            }
            const func = buildWrappedMethod(this, key);
            return func;
          }
          getEvent(key) {
            if (typeof key !== "string") {
              key = key.format();
            }
            return buildWrappedEvent(this, key);
          }
          async queryTransaction(hash) {
            throw new Error("@TODO");
          }
          async queryFilter(event, fromBlock, toBlock) {
            if (fromBlock == null) {
              fromBlock = 0;
            }
            if (toBlock == null) {
              toBlock = "latest";
            }
            const { addr, addrPromise } = getInternal(this);
            const address = addr ? addr : await addrPromise;
            const { fragment, topics } = await getSubInfo(this, event);
            const filter = {
              address: address,
              topics: topics,
              fromBlock: fromBlock,
              toBlock: toBlock,
            };
            const provider = getProvider(this.runner);
            assert(
              provider,
              "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION",
              { operation: "queryFilter" }
            );
            return (await provider.getLogs(filter)).map((log) => {
              let foundFragment = fragment;
              if (foundFragment == null) {
                try {
                  foundFragment = this.interface.getEvent(log.topics[0]);
                } catch (error) {}
              }
              if (foundFragment) {
                try {
                  return new EventLog(log, this.interface, foundFragment);
                } catch (error) {
                  return new UndecodedEventLog(log, error);
                }
              }
              return new Log(log, provider);
            });
          }
          async on(event, listener) {
            const sub = await getSub(this, "on", event);
            sub.listeners.push({ listener: listener, once: false });
            sub.start();
            return this;
          }
          async once(event, listener) {
            const sub = await getSub(this, "once", event);
            sub.listeners.push({ listener: listener, once: true });
            sub.start();
            return this;
          }
          async emit(event, ...args) {
            return await emit(this, event, args, null);
          }
          async listenerCount(event) {
            if (event) {
              const sub = await hasSub(this, event);
              if (!sub) {
                return 0;
              }
              return sub.listeners.length;
            }
            const { subs } = getInternal(this);
            let total = 0;
            for (const { listeners } of subs.values()) {
              total += listeners.length;
            }
            return total;
          }
          async listeners(event) {
            if (event) {
              const sub = await hasSub(this, event);
              if (!sub) {
                return [];
              }
              return sub.listeners.map(({ listener }) => listener);
            }
            const { subs } = getInternal(this);
            let result = [];
            for (const { listeners } of subs.values()) {
              result = result.concat(listeners.map(({ listener }) => listener));
            }
            return result;
          }
          async off(event, listener) {
            const sub = await hasSub(this, event);
            if (!sub) {
              return this;
            }
            if (listener) {
              const index = sub.listeners
                .map(({ listener }) => listener)
                .indexOf(listener);
              if (index >= 0) {
                sub.listeners.splice(index, 1);
              }
            }
            if (listener == null || sub.listeners.length === 0) {
              sub.stop();
              getInternal(this).subs.delete(sub.tag);
            }
            return this;
          }
          async removeAllListeners(event) {
            if (event) {
              const sub = await hasSub(this, event);
              if (!sub) {
                return this;
              }
              sub.stop();
              getInternal(this).subs.delete(sub.tag);
            } else {
              const { subs } = getInternal(this);
              for (const { tag, stop } of subs.values()) {
                stop();
                subs.delete(tag);
              }
            }
            return this;
          }
          async addListener(event, listener) {
            return await this.on(event, listener);
          }
          async removeListener(event, listener) {
            return await this.off(event, listener);
          }
          static buildClass(abi) {
            class CustomContract extends BaseContract {
              constructor(address, runner = null) {
                super(address, abi, runner);
              }
            }
            return CustomContract;
          }
          static from(target, abi, runner) {
            if (runner == null) {
              runner = null;
            }
            const contract = new this(target, abi, runner);
            return contract;
          }
        }
        function _ContractBase() {
          return BaseContract;
        }
        class Contract extends _ContractBase() {}
        class ContractFactory {
          interface;
          bytecode;
          runner;
          constructor(abi, bytecode, runner) {
            const iface = Interface.from(abi);
            if (bytecode instanceof Uint8Array) {
              bytecode = hexlify(getBytes(bytecode));
            } else {
              if (typeof bytecode === "object") {
                bytecode = bytecode.object;
              }
              if (!bytecode.startsWith("0x")) {
                bytecode = "0x" + bytecode;
              }
              bytecode = hexlify(getBytes(bytecode));
            }
            defineProperties(this, {
              bytecode: bytecode,
              interface: iface,
              runner: runner || null,
            });
          }
          attach(target) {
            return new BaseContract(target, this.interface, this.runner);
          }
          async getDeployTransaction(...args) {
            let overrides = {};
            const fragment = this.interface.deploy;
            if (fragment.inputs.length + 1 === args.length) {
              overrides = await copyOverrides(args.pop());
            }
            if (fragment.inputs.length !== args.length) {
              throw new Error("incorrect number of arguments to constructor");
            }
            const resolvedArgs = await resolveArgs(
              this.runner,
              fragment.inputs,
              args
            );
            const data = concat([
              this.bytecode,
              this.interface.encodeDeploy(resolvedArgs),
            ]);
            return Object.assign({}, overrides, { data: data });
          }
          async deploy(...args) {
            const tx = await this.getDeployTransaction(...args);
            assert(
              this.runner && typeof this.runner.sendTransaction === "function",
              "factory runner does not support sending transactions",
              "UNSUPPORTED_OPERATION",
              { operation: "sendTransaction" }
            );
            const sentTx = await this.runner.sendTransaction(tx);
            const address = getCreateAddress(sentTx);
            return new BaseContract(
              address,
              this.interface,
              this.runner,
              sentTx
            );
          }
          connect(runner) {
            return new ContractFactory(this.interface, this.bytecode, runner);
          }
          static fromSolidity(output, runner) {
            assertArgument(
              output != null,
              "bad compiler output",
              "output",
              output
            );
            if (typeof output === "string") {
              output = JSON.parse(output);
            }
            const abi = output.abi;
            let bytecode = "";
            if (output.bytecode) {
              bytecode = output.bytecode;
            } else if (output.evm && output.evm.bytecode) {
              bytecode = output.evm.bytecode;
            }
            return new this(abi, bytecode, runner);
          }
        }
        function getIpfsLink(link) {
          if (link.match(/^ipfs:\/\/ipfs\//i)) {
            link = link.substring(12);
          } else if (link.match(/^ipfs:\/\//i)) {
            link = link.substring(7);
          } else {
            assertArgument(false, "unsupported IPFS format", "link", link);
          }
          return `https:/\/gateway.ipfs.io/ipfs/${link}`;
        }
        class MulticoinProviderPlugin {
          name;
          constructor(name) {
            defineProperties(this, { name: name });
          }
          connect(proivder) {
            return this;
          }
          supportsCoinType(coinType) {
            return false;
          }
          async encodeAddress(coinType, address) {
            throw new Error("unsupported coin");
          }
          async decodeAddress(coinType, data) {
            throw new Error("unsupported coin");
          }
        }
        const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
        const matchers = [
          new RegExp("^(https)://(.*)$", "i"),
          new RegExp("^(data):(.*)$", "i"),
          matcherIpfs,
          new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
        ];
        class EnsResolver {
          provider;
          address;
          name;
          #supports2544;
          #resolver;
          constructor(provider, address, name) {
            defineProperties(this, {
              provider: provider,
              address: address,
              name: name,
            });
            this.#supports2544 = null;
            this.#resolver = new Contract(
              address,
              [
                "function supportsInterface(bytes4) view returns (bool)",
                "function resolve(bytes, bytes) view returns (bytes)",
                "function addr(bytes32) view returns (address)",
                "function addr(bytes32, uint) view returns (bytes)",
                "function text(bytes32, string) view returns (string)",
                "function contenthash(bytes32) view returns (bytes)",
              ],
              provider
            );
          }
          async supportsWildcard() {
            if (this.#supports2544 == null) {
              this.#supports2544 = (async () => {
                try {
                  return await this.#resolver.supportsInterface("0x9061b923");
                } catch (error) {
                  if (isError(error, "CALL_EXCEPTION")) {
                    return false;
                  }
                  this.#supports2544 = null;
                  throw error;
                }
              })();
            }
            return await this.#supports2544;
          }
          async #fetch(funcName, params) {
            params = (params || []).slice();
            const iface = this.#resolver.interface;
            params.unshift(namehash(this.name));
            let fragment = null;
            if (await this.supportsWildcard()) {
              fragment = iface.getFunction(funcName);
              assert(fragment, "missing fragment", "UNKNOWN_ERROR", {
                info: { funcName: funcName },
              });
              params = [
                dnsEncode(this.name, 255),
                iface.encodeFunctionData(fragment, params),
              ];
              funcName = "resolve(bytes,bytes)";
            }
            params.push({ enableCcipRead: true });
            try {
              const result = await this.#resolver[funcName](...params);
              if (fragment) {
                return iface.decodeFunctionResult(fragment, result)[0];
              }
              return result;
            } catch (error) {
              if (!isError(error, "CALL_EXCEPTION")) {
                throw error;
              }
            }
            return null;
          }
          async getAddress(coinType) {
            if (coinType == null) {
              coinType = 60;
            }
            if (coinType === 60) {
              try {
                const result = await this.#fetch("addr(bytes32)");
                if (result == null || result === ZeroAddress) {
                  return null;
                }
                return result;
              } catch (error) {
                if (isError(error, "CALL_EXCEPTION")) {
                  return null;
                }
                throw error;
              }
            }
            if (coinType >= 0 && coinType < 2147483648) {
              let ethCoinType = coinType + 2147483648;
              const data = await this.#fetch("addr(bytes32,uint)", [
                ethCoinType,
              ]);
              if (isHexString(data, 20)) {
                return getAddress(data);
              }
            }
            let coinPlugin = null;
            for (const plugin of this.provider.plugins) {
              if (!(plugin instanceof MulticoinProviderPlugin)) {
                continue;
              }
              if (plugin.supportsCoinType(coinType)) {
                coinPlugin = plugin;
                break;
              }
            }
            if (coinPlugin == null) {
              return null;
            }
            const data = await this.#fetch("addr(bytes32,uint)", [coinType]);
            if (data == null || data === "0x") {
              return null;
            }
            const address = await coinPlugin.decodeAddress(coinType, data);
            if (address != null) {
              return address;
            }
            assert(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
              operation: `getAddress(${coinType})`,
              info: { coinType: coinType, data: data },
            });
          }
          async getText(key) {
            const data = await this.#fetch("text(bytes32,string)", [key]);
            if (data == null || data === "0x") {
              return null;
            }
            return data;
          }
          async getContentHash() {
            const data = await this.#fetch("contenthash(bytes32)");
            if (data == null || data === "0x") {
              return null;
            }
            const ipfs = data.match(
              /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
            );
            if (ipfs) {
              const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
              const length = parseInt(ipfs[4], 16);
              if (ipfs[5].length === length * 2) {
                return `${scheme}:/\/${encodeBase58("0x" + ipfs[2])}`;
              }
            }
            const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (swarm && swarm[1].length === 64) {
              return `bzz:/\/${swarm[1]}`;
            }
            assert(
              false,
              `invalid or unsupported content hash data`,
              "UNSUPPORTED_OPERATION",
              { operation: "getContentHash()", info: { data: data } }
            );
          }
          async getAvatar() {
            const avatar = await this._getAvatar();
            return avatar.url;
          }
          async _getAvatar() {
            const linkage = [{ type: "name", value: this.name }];
            try {
              const avatar = await this.getText("avatar");
              if (avatar == null) {
                linkage.push({ type: "!avatar", value: "" });
                return { url: null, linkage: linkage };
              }
              linkage.push({ type: "avatar", value: avatar });
              for (let i = 0; i < matchers.length; i++) {
                const match = avatar.match(matchers[i]);
                if (match == null) {
                  continue;
                }
                const scheme = match[1].toLowerCase();
                switch (scheme) {
                  case "https":
                  case "data":
                    linkage.push({ type: "url", value: avatar });
                    return { linkage: linkage, url: avatar };
                  case "ipfs": {
                    const url = getIpfsLink(avatar);
                    linkage.push({ type: "ipfs", value: avatar });
                    linkage.push({ type: "url", value: url });
                    return { linkage: linkage, url: url };
                  }
                  case "erc721":
                  case "erc1155": {
                    const selector =
                      scheme === "erc721"
                        ? "tokenURI(uint256)"
                        : "uri(uint256)";
                    linkage.push({ type: scheme, value: avatar });
                    const owner = await this.getAddress();
                    if (owner == null) {
                      linkage.push({ type: "!owner", value: "" });
                      return { url: null, linkage: linkage };
                    }
                    const comps = (match[2] || "").split("/");
                    if (comps.length !== 2) {
                      linkage.push({
                        type: `!${scheme}caip`,
                        value: match[2] || "",
                      });
                      return { url: null, linkage: linkage };
                    }
                    const tokenId = comps[1];
                    const contract = new Contract(
                      comps[0],
                      [
                        "function tokenURI(uint) view returns (string)",
                        "function ownerOf(uint) view returns (address)",
                        "function uri(uint) view returns (string)",
                        "function balanceOf(address, uint256) view returns (uint)",
                      ],
                      this.provider
                    );
                    if (scheme === "erc721") {
                      const tokenOwner = await contract.ownerOf(tokenId);
                      if (owner !== tokenOwner) {
                        linkage.push({ type: "!owner", value: tokenOwner });
                        return { url: null, linkage: linkage };
                      }
                      linkage.push({ type: "owner", value: tokenOwner });
                    } else if (scheme === "erc1155") {
                      const balance = await contract.balanceOf(owner, tokenId);
                      if (!balance) {
                        linkage.push({ type: "!balance", value: "0" });
                        return { url: null, linkage: linkage };
                      }
                      linkage.push({
                        type: "balance",
                        value: balance.toString(),
                      });
                    }
                    let metadataUrl = await contract[selector](tokenId);
                    if (metadataUrl == null || metadataUrl === "0x") {
                      linkage.push({ type: "!metadata-url", value: "" });
                      return { url: null, linkage: linkage };
                    }
                    linkage.push({
                      type: "metadata-url-base",
                      value: metadataUrl,
                    });
                    if (scheme === "erc1155") {
                      metadataUrl = metadataUrl.replace(
                        "{id}",
                        toBeHex(tokenId, 32).substring(2)
                      );
                      linkage.push({
                        type: "metadata-url-expanded",
                        value: metadataUrl,
                      });
                    }
                    if (metadataUrl.match(/^ipfs:/i)) {
                      metadataUrl = getIpfsLink(metadataUrl);
                    }
                    linkage.push({ type: "metadata-url", value: metadataUrl });
                    let metadata = {};
                    const response = await new FetchRequest(metadataUrl).send();
                    response.assertOk();
                    try {
                      metadata = response.bodyJson;
                    } catch (error) {
                      try {
                        linkage.push({
                          type: "!metadata",
                          value: response.bodyText,
                        });
                      } catch (error) {
                        const bytes = response.body;
                        if (bytes) {
                          linkage.push({
                            type: "!metadata",
                            value: hexlify(bytes),
                          });
                        }
                        return { url: null, linkage: linkage };
                      }
                      return { url: null, linkage: linkage };
                    }
                    if (!metadata) {
                      linkage.push({ type: "!metadata", value: "" });
                      return { url: null, linkage: linkage };
                    }
                    linkage.push({
                      type: "metadata",
                      value: JSON.stringify(metadata),
                    });
                    let imageUrl = metadata.image;
                    if (typeof imageUrl !== "string") {
                      linkage.push({ type: "!imageUrl", value: "" });
                      return { url: null, linkage: linkage };
                    }
                    if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                    } else {
                      const ipfs = imageUrl.match(matcherIpfs);
                      if (ipfs == null) {
                        linkage.push({
                          type: "!imageUrl-ipfs",
                          value: imageUrl,
                        });
                        return { url: null, linkage: linkage };
                      }
                      linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
                      imageUrl = getIpfsLink(imageUrl);
                    }
                    linkage.push({ type: "url", value: imageUrl });
                    return { linkage: linkage, url: imageUrl };
                  }
                }
              }
            } catch (error) {}
            return { linkage: linkage, url: null };
          }
          static async getEnsAddress(provider) {
            const network = await provider.getNetwork();
            const ensPlugin = network.getPlugin(
              "org.ethers.plugins.network.Ens"
            );
            assert(
              ensPlugin,
              "network does not support ENS",
              "UNSUPPORTED_OPERATION",
              { operation: "getEnsAddress", info: { network: network } }
            );
            return ensPlugin.address;
          }
          static async #getResolver(provider, name) {
            const ensAddr = await EnsResolver.getEnsAddress(provider);
            try {
              const contract = new Contract(
                ensAddr,
                ["function resolver(bytes32) view returns (address)"],
                provider
              );
              const addr = await contract.resolver(namehash(name), {
                enableCcipRead: true,
              });
              if (addr === ZeroAddress) {
                return null;
              }
              return addr;
            } catch (error) {
              throw error;
            }
            return null;
          }
          static async fromName(provider, name) {
            let currentName = name;
            while (true) {
              if (currentName === "" || currentName === ".") {
                return null;
              }
              if (name !== "eth" && currentName === "eth") {
                return null;
              }
              const addr = await EnsResolver.#getResolver(
                provider,
                currentName
              );
              if (addr != null) {
                const resolver = new EnsResolver(provider, addr, name);
                if (
                  currentName !== name &&
                  !(await resolver.supportsWildcard())
                ) {
                  return null;
                }
                return resolver;
              }
              currentName = currentName.split(".").slice(1).join(".");
            }
          }
        }
        const BN_0 = BigInt(0);
        function allowNull(format, nullValue) {
          return function (value) {
            if (value == null) {
              return nullValue;
            }
            return format(value);
          };
        }
        function arrayOf(format, allowNull) {
          return (array) => {
            if (allowNull && array == null) {
              return null;
            }
            if (!Array.isArray(array)) {
              throw new Error("not an array");
            }
            return array.map((i) => format(i));
          };
        }
        function object(format, altNames) {
          return (value) => {
            const result = {};
            for (const key in format) {
              let srcKey = key;
              if (altNames && key in altNames && !(srcKey in value)) {
                for (const altKey of altNames[key]) {
                  if (altKey in value) {
                    srcKey = altKey;
                    break;
                  }
                }
              }
              try {
                const nv = format[key](value[srcKey]);
                if (nv !== undefined) {
                  result[key] = nv;
                }
              } catch (error) {
                const message =
                  error instanceof Error ? error.message : "not-an-error";
                assert(
                  false,
                  `invalid value for value.${key} (${message})`,
                  "BAD_DATA",
                  { value: value }
                );
              }
            }
            return result;
          };
        }
        function formatBoolean(value) {
          switch (value) {
            case true:
            case "true":
              return true;
            case false:
            case "false":
              return false;
          }
          assertArgument(
            false,
            `invalid boolean; ${JSON.stringify(value)}`,
            "value",
            value
          );
        }
        function formatData(value) {
          assertArgument(
            isHexString(value, true),
            "invalid data",
            "value",
            value
          );
          return value;
        }
        function formatHash(value) {
          assertArgument(
            isHexString(value, 32),
            "invalid hash",
            "value",
            value
          );
          return value;
        }
        const _formatLog = object(
          {
            address: getAddress,
            blockHash: formatHash,
            blockNumber: getNumber,
            data: formatData,
            index: getNumber,
            removed: allowNull(formatBoolean, false),
            topics: arrayOf(formatHash),
            transactionHash: formatHash,
            transactionIndex: getNumber,
          },
          { index: ["logIndex"] }
        );
        function formatLog(value) {
          return _formatLog(value);
        }
        const _formatBlock = object({
          hash: allowNull(formatHash),
          parentHash: formatHash,
          parentBeaconBlockRoot: allowNull(formatHash, null),
          number: getNumber,
          timestamp: getNumber,
          nonce: allowNull(formatData),
          difficulty: getBigInt,
          gasLimit: getBigInt,
          gasUsed: getBigInt,
          stateRoot: allowNull(formatHash, null),
          receiptsRoot: allowNull(formatHash, null),
          blobGasUsed: allowNull(getBigInt, null),
          excessBlobGas: allowNull(getBigInt, null),
          miner: allowNull(getAddress),
          extraData: formatData,
          baseFeePerGas: allowNull(getBigInt),
        });
        function formatBlock(value) {
          const result = _formatBlock(value);
          result.transactions = value.transactions.map((tx) => {
            if (typeof tx === "string") {
              return tx;
            }
            return formatTransactionResponse(tx);
          });
          return result;
        }
        const _formatReceiptLog = object(
          {
            transactionIndex: getNumber,
            blockNumber: getNumber,
            transactionHash: formatHash,
            address: getAddress,
            topics: arrayOf(formatHash),
            data: formatData,
            index: getNumber,
            blockHash: formatHash,
          },
          { index: ["logIndex"] }
        );
        function formatReceiptLog(value) {
          return _formatReceiptLog(value);
        }
        const _formatTransactionReceipt = object(
          {
            to: allowNull(getAddress, null),
            from: allowNull(getAddress, null),
            contractAddress: allowNull(getAddress, null),
            index: getNumber,
            root: allowNull(hexlify),
            gasUsed: getBigInt,
            blobGasUsed: allowNull(getBigInt, null),
            logsBloom: allowNull(formatData),
            blockHash: formatHash,
            hash: formatHash,
            logs: arrayOf(formatReceiptLog),
            blockNumber: getNumber,
            cumulativeGasUsed: getBigInt,
            effectiveGasPrice: allowNull(getBigInt),
            blobGasPrice: allowNull(getBigInt, null),
            status: allowNull(getNumber),
            type: allowNull(getNumber, 0),
          },
          {
            effectiveGasPrice: ["gasPrice"],
            hash: ["transactionHash"],
            index: ["transactionIndex"],
          }
        );
        function formatTransactionReceipt(value) {
          return _formatTransactionReceipt(value);
        }
        function formatTransactionResponse(value) {
          if (value.to && getBigInt(value.to) === BN_0) {
            value.to = "0x0000000000000000000000000000000000000000";
          }
          const result = object(
            {
              hash: formatHash,
              index: allowNull(getNumber, undefined),
              type: (value) => {
                if (value === "0x" || value == null) {
                  return 0;
                }
                return getNumber(value);
              },
              accessList: allowNull(accessListify, null),
              blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
              blockHash: allowNull(formatHash, null),
              blockNumber: allowNull(getNumber, null),
              transactionIndex: allowNull(getNumber, null),
              from: getAddress,
              gasPrice: allowNull(getBigInt),
              maxPriorityFeePerGas: allowNull(getBigInt),
              maxFeePerGas: allowNull(getBigInt),
              maxFeePerBlobGas: allowNull(getBigInt, null),
              gasLimit: getBigInt,
              to: allowNull(getAddress, null),
              value: getBigInt,
              nonce: getNumber,
              data: formatData,
              creates: allowNull(getAddress, null),
              chainId: allowNull(getBigInt, null),
            },
            { data: ["input"], gasLimit: ["gas"], index: ["transactionIndex"] }
          )(value);
          if (result.to == null && result.creates == null) {
            result.creates = getCreateAddress(result);
          }
          if (
            (value.type === 1 || value.type === 2) &&
            value.accessList == null
          ) {
            result.accessList = [];
          }
          if (value.signature) {
            result.signature = Signature.from(value.signature);
          } else {
            result.signature = Signature.from(value);
          }
          if (result.chainId == null) {
            const chainId = result.signature.legacyChainId;
            if (chainId != null) {
              result.chainId = chainId;
            }
          }
          if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
            result.blockHash = null;
          }
          return result;
        }
        const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
        class NetworkPlugin {
          name;
          constructor(name) {
            defineProperties(this, { name: name });
          }
          clone() {
            return new NetworkPlugin(this.name);
          }
        }
        class GasCostPlugin extends NetworkPlugin {
          effectiveBlock;
          txBase;
          txCreate;
          txDataZero;
          txDataNonzero;
          txAccessListStorageKey;
          txAccessListAddress;
          constructor(effectiveBlock, costs) {
            if (effectiveBlock == null) {
              effectiveBlock = 0;
            }
            super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
            const props = { effectiveBlock: effectiveBlock };
            function set(name, nullish) {
              let value = (costs || {})[name];
              if (value == null) {
                value = nullish;
              }
              assertArgument(
                typeof value === "number",
                `invalud value for ${name}`,
                "costs",
                costs
              );
              props[name] = value;
            }
            set("txBase", 21e3);
            set("txCreate", 32e3);
            set("txDataZero", 4);
            set("txDataNonzero", 16);
            set("txAccessListStorageKey", 1900);
            set("txAccessListAddress", 2400);
            defineProperties(this, props);
          }
          clone() {
            return new GasCostPlugin(this.effectiveBlock, this);
          }
        }
        class EnsPlugin extends NetworkPlugin {
          address;
          targetNetwork;
          constructor(address, targetNetwork) {
            super("org.ethers.plugins.network.Ens");
            defineProperties(this, {
              address: address || EnsAddress,
              targetNetwork: targetNetwork == null ? 1 : targetNetwork,
            });
          }
          clone() {
            return new EnsPlugin(this.address, this.targetNetwork);
          }
        }
        class FeeDataNetworkPlugin extends NetworkPlugin {
          #feeDataFunc;
          get feeDataFunc() {
            return this.#feeDataFunc;
          }
          constructor(feeDataFunc) {
            super("org.ethers.plugins.network.FeeData");
            this.#feeDataFunc = feeDataFunc;
          }
          async getFeeData(provider) {
            return await this.#feeDataFunc(provider);
          }
          clone() {
            return new FeeDataNetworkPlugin(this.#feeDataFunc);
          }
        }
        class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
          #url;
          #processFunc;
          get url() {
            return this.#url;
          }
          get processFunc() {
            return this.#processFunc;
          }
          constructor(url, processFunc) {
            super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
            this.#url = url;
            this.#processFunc = processFunc;
          }
          clone() {
            return this;
          }
        }
        const Networks = new Map();
        class Network {
          #name;
          #chainId;
          #plugins;
          constructor(name, chainId) {
            this.#name = name;
            this.#chainId = getBigInt(chainId);
            this.#plugins = new Map();
          }
          toJSON() {
            return { name: this.name, chainId: String(this.chainId) };
          }
          get name() {
            return this.#name;
          }
          set name(value) {
            this.#name = value;
          }
          get chainId() {
            return this.#chainId;
          }
          set chainId(value) {
            this.#chainId = getBigInt(value, "chainId");
          }
          matches(other) {
            if (other == null) {
              return false;
            }
            if (typeof other === "string") {
              try {
                return this.chainId === getBigInt(other);
              } catch (error) {}
              return this.name === other;
            }
            if (typeof other === "number" || typeof other === "bigint") {
              try {
                return this.chainId === getBigInt(other);
              } catch (error) {}
              return false;
            }
            if (typeof other === "object") {
              if (other.chainId != null) {
                try {
                  return this.chainId === getBigInt(other.chainId);
                } catch (error) {}
                return false;
              }
              if (other.name != null) {
                return this.name === other.name;
              }
              return false;
            }
            return false;
          }
          get plugins() {
            return Array.from(this.#plugins.values());
          }
          attachPlugin(plugin) {
            if (this.#plugins.get(plugin.name)) {
              throw new Error(
                `cannot replace existing plugin: ${plugin.name} `
              );
            }
            this.#plugins.set(plugin.name, plugin.clone());
            return this;
          }
          getPlugin(name) {
            return this.#plugins.get(name) || null;
          }
          getPlugins(basename) {
            return this.plugins.filter(
              (p) => p.name.split("#")[0] === basename
            );
          }
          clone() {
            const clone = new Network(this.name, this.chainId);
            this.plugins.forEach((plugin) => {
              clone.attachPlugin(plugin.clone());
            });
            return clone;
          }
          computeIntrinsicGas(tx) {
            const costs =
              this.getPlugin("org.ethers.plugins.network.GasCost") ||
              new GasCostPlugin();
            let gas = costs.txBase;
            if (tx.to == null) {
              gas += costs.txCreate;
            }
            if (tx.data) {
              for (let i = 2; i < tx.data.length; i += 2) {
                if (tx.data.substring(i, i + 2) === "00") {
                  gas += costs.txDataZero;
                } else {
                  gas += costs.txDataNonzero;
                }
              }
            }
            if (tx.accessList) {
              const accessList = accessListify(tx.accessList);
              for (const addr in accessList) {
                gas +=
                  costs.txAccessListAddress +
                  costs.txAccessListStorageKey *
                    accessList[addr].storageKeys.length;
              }
            }
            return gas;
          }
          static from(network) {
            injectCommonNetworks();
            if (network == null) {
              return Network.from("mainnet");
            }
            if (typeof network === "number") {
              network = BigInt(network);
            }
            if (typeof network === "string" || typeof network === "bigint") {
              const networkFunc = Networks.get(network);
              if (networkFunc) {
                return networkFunc();
              }
              if (typeof network === "bigint") {
                return new Network("unknown", network);
              }
              assertArgument(false, "unknown network", "network", network);
            }
            if (typeof network.clone === "function") {
              const clone = network.clone();
              return clone;
            }
            if (typeof network === "object") {
              assertArgument(
                typeof network.name === "string" &&
                  typeof network.chainId === "number",
                "invalid network object name or chainId",
                "network",
                network
              );
              const custom = new Network(network.name, network.chainId);
              if (network.ensAddress || network.ensNetwork != null) {
                custom.attachPlugin(
                  new EnsPlugin(network.ensAddress, network.ensNetwork)
                );
              }
              return custom;
            }
            assertArgument(false, "invalid network", "network", network);
          }
          static register(nameOrChainId, networkFunc) {
            if (typeof nameOrChainId === "number") {
              nameOrChainId = BigInt(nameOrChainId);
            }
            const existing = Networks.get(nameOrChainId);
            if (existing) {
              assertArgument(
                false,
                `conflicting network for ${JSON.stringify(existing.name)}`,
                "nameOrChainId",
                nameOrChainId
              );
            }
            Networks.set(nameOrChainId, networkFunc);
          }
        }
        function parseUnits(_value, decimals) {
          const value = String(_value);
          if (!value.match(/^[0-9.]+$/)) {
            throw new Error(`invalid gwei value: ${_value}`);
          }
          const comps = value.split(".");
          if (comps.length === 1) {
            comps.push("");
          }
          if (comps.length !== 2) {
            throw new Error(`invalid gwei value: ${_value}`);
          }
          while (comps[1].length < decimals) {
            comps[1] += "0";
          }
          if (comps[1].length > 9) {
            let frac = BigInt(comps[1].substring(0, 9));
            if (!comps[1].substring(9).match(/^0+$/)) {
              frac++;
            }
            comps[1] = frac.toString();
          }
          return BigInt(comps[0] + comps[1]);
        }
        function getGasStationPlugin(url) {
          return new FetchUrlFeeDataNetworkPlugin(
            url,
            async (fetchFeeData, provider, request) => {
              request.setHeader("User-Agent", "ethers");
              let response;
              try {
                const [_response, _feeData] = await Promise.all([
                  request.send(),
                  fetchFeeData(),
                ]);
                response = _response;
                const payload = response.bodyJson.standard;
                const feeData = {
                  gasPrice: _feeData.gasPrice,
                  maxFeePerGas: parseUnits(payload.maxFee, 9),
                  maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9),
                };
                return feeData;
              } catch (error) {
                assert(
                  false,
                  `error encountered with polygon gas station (${JSON.stringify(
                    request.url
                  )})`,
                  "SERVER_ERROR",
                  { request: request, response: response, error: error }
                );
              }
            }
          );
        }
        let injected = false;
        function injectCommonNetworks() {
          if (injected) {
            return;
          }
          injected = true;
          function registerEth(name, chainId, options) {
            const func = function () {
              const network = new Network(name, chainId);
              if (options.ensNetwork != null) {
                network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
              }
              network.attachPlugin(new GasCostPlugin());
              (options.plugins || []).forEach((plugin) => {
                network.attachPlugin(plugin);
              });
              return network;
            };
            Network.register(name, func);
            Network.register(chainId, func);
            if (options.altNames) {
              options.altNames.forEach((name) => {
                Network.register(name, func);
              });
            }
          }
          registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
          registerEth("ropsten", 3, { ensNetwork: 3 });
          registerEth("rinkeby", 4, { ensNetwork: 4 });
          registerEth("goerli", 5, { ensNetwork: 5 });
          registerEth("kovan", 42, { ensNetwork: 42 });
          registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
          registerEth("holesky", 17e3, { ensNetwork: 17e3 });
          registerEth("classic", 61, {});
          registerEth("classicKotti", 6, {});
          registerEth("arbitrum", 42161, { ensNetwork: 1 });
          registerEth("arbitrum-goerli", 421613, {});
          registerEth("arbitrum-sepolia", 421614, {});
          registerEth("base", 8453, { ensNetwork: 1 });
          registerEth("base-goerli", 84531, {});
          registerEth("base-sepolia", 84532, {});
          registerEth("bnb", 56, { ensNetwork: 1 });
          registerEth("bnbt", 97, {});
          registerEth("linea", 59144, { ensNetwork: 1 });
          registerEth("linea-goerli", 59140, {});
          registerEth("matic", 137, {
            ensNetwork: 1,
            plugins: [
              getGasStationPlugin("https://gasstation.polygon.technology/v2"),
            ],
          });
          registerEth("matic-mumbai", 80001, {
            altNames: ["maticMumbai", "maticmum"],
            plugins: [
              getGasStationPlugin(
                "https://gasstation-testnet.polygon.technology/v2"
              ),
            ],
          });
          registerEth("optimism", 10, { ensNetwork: 1, plugins: [] });
          registerEth("optimism-goerli", 420, {});
          registerEth("optimism-sepolia", 11155420, {});
          registerEth("xdai", 100, { ensNetwork: 1 });
        }
        function copy$2(obj) {
          return JSON.parse(JSON.stringify(obj));
        }
        class PollingBlockSubscriber {
          #provider;
          #poller;
          #interval;
          #blockNumber;
          constructor(provider) {
            this.#provider = provider;
            this.#poller = null;
            this.#interval = 4e3;
            this.#blockNumber = -2;
          }
          get pollingInterval() {
            return this.#interval;
          }
          set pollingInterval(value) {
            this.#interval = value;
          }
          async #poll() {
            try {
              const blockNumber = await this.#provider.getBlockNumber();
              if (this.#blockNumber === -2) {
                this.#blockNumber = blockNumber;
                return;
              }
              if (blockNumber !== this.#blockNumber) {
                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {
                  if (this.#poller == null) {
                    return;
                  }
                  await this.#provider.emit("block", b);
                }
                this.#blockNumber = blockNumber;
              }
            } catch (error) {}
            if (this.#poller == null) {
              return;
            }
            this.#poller = this.#provider._setTimeout(
              this.#poll.bind(this),
              this.#interval
            );
          }
          start() {
            if (this.#poller) {
              return;
            }
            this.#poller = this.#provider._setTimeout(
              this.#poll.bind(this),
              this.#interval
            );
            this.#poll();
          }
          stop() {
            if (!this.#poller) {
              return;
            }
            this.#provider._clearTimeout(this.#poller);
            this.#poller = null;
          }
          pause(dropWhilePaused) {
            this.stop();
            if (dropWhilePaused) {
              this.#blockNumber = -2;
            }
          }
          resume() {
            this.start();
          }
        }
        class OnBlockSubscriber {
          #provider;
          #poll;
          #running;
          constructor(provider) {
            this.#provider = provider;
            this.#running = false;
            this.#poll = (blockNumber) => {
              this._poll(blockNumber, this.#provider);
            };
          }
          async _poll(blockNumber, provider) {
            throw new Error("sub-classes must override this");
          }
          start() {
            if (this.#running) {
              return;
            }
            this.#running = true;
            this.#poll(-2);
            this.#provider.on("block", this.#poll);
          }
          stop() {
            if (!this.#running) {
              return;
            }
            this.#running = false;
            this.#provider.off("block", this.#poll);
          }
          pause(dropWhilePaused) {
            this.stop();
          }
          resume() {
            this.start();
          }
        }
        class PollingBlockTagSubscriber extends OnBlockSubscriber {
          #tag;
          #lastBlock;
          constructor(provider, tag) {
            super(provider);
            this.#tag = tag;
            this.#lastBlock = -2;
          }
          pause(dropWhilePaused) {
            if (dropWhilePaused) {
              this.#lastBlock = -2;
            }
            super.pause(dropWhilePaused);
          }
          async _poll(blockNumber, provider) {
            const block = await provider.getBlock(this.#tag);
            if (block == null) {
              return;
            }
            if (this.#lastBlock === -2) {
              this.#lastBlock = block.number;
            } else if (block.number > this.#lastBlock) {
              provider.emit(this.#tag, block.number);
              this.#lastBlock = block.number;
            }
          }
        }
        class PollingOrphanSubscriber extends OnBlockSubscriber {
          #filter;
          constructor(provider, filter) {
            super(provider);
            this.#filter = copy$2(filter);
          }
          async _poll(blockNumber, provider) {
            throw new Error("@TODO");
          }
        }
        class PollingTransactionSubscriber extends OnBlockSubscriber {
          #hash;
          constructor(provider, hash) {
            super(provider);
            this.#hash = hash;
          }
          async _poll(blockNumber, provider) {
            const tx = await provider.getTransactionReceipt(this.#hash);
            if (tx) {
              provider.emit(this.#hash, tx);
            }
          }
        }
        class PollingEventSubscriber {
          #provider;
          #filter;
          #poller;
          #running;
          #blockNumber;
          constructor(provider, filter) {
            this.#provider = provider;
            this.#filter = copy$2(filter);
            this.#poller = this.#poll.bind(this);
            this.#running = false;
            this.#blockNumber = -2;
          }
          async #poll(blockNumber) {
            if (this.#blockNumber === -2) {
              return;
            }
            const filter = copy$2(this.#filter);
            filter.fromBlock = this.#blockNumber + 1;
            filter.toBlock = blockNumber;
            const logs = await this.#provider.getLogs(filter);
            if (logs.length === 0) {
              if (this.#blockNumber < blockNumber - 60) {
                this.#blockNumber = blockNumber - 60;
              }
              return;
            }
            for (const log of logs) {
              this.#provider.emit(this.#filter, log);
              this.#blockNumber = log.blockNumber;
            }
          }
          start() {
            if (this.#running) {
              return;
            }
            this.#running = true;
            if (this.#blockNumber === -2) {
              this.#provider.getBlockNumber().then((blockNumber) => {
                this.#blockNumber = blockNumber;
              });
            }
            this.#provider.on("block", this.#poller);
          }
          stop() {
            if (!this.#running) {
              return;
            }
            this.#running = false;
            this.#provider.off("block", this.#poller);
          }
          pause(dropWhilePaused) {
            this.stop();
            if (dropWhilePaused) {
              this.#blockNumber = -2;
            }
          }
          resume() {
            this.start();
          }
        }
        const BN_2$1 = BigInt(2);
        const MAX_CCIP_REDIRECTS = 10;
        function isPromise$1(value) {
          return value && typeof value.then === "function";
        }
        function getTag(prefix, value) {
          return (
            prefix +
            ":" +
            JSON.stringify(value, (k, v) => {
              if (v == null) {
                return "null";
              }
              if (typeof v === "bigint") {
                return `bigint:${v.toString()}`;
              }
              if (typeof v === "string") {
                return v.toLowerCase();
              }
              if (typeof v === "object" && !Array.isArray(v)) {
                const keys = Object.keys(v);
                keys.sort();
                return keys.reduce((accum, key) => {
                  accum[key] = v[key];
                  return accum;
                }, {});
              }
              return v;
            })
          );
        }
        class UnmanagedSubscriber {
          name;
          constructor(name) {
            defineProperties(this, { name: name });
          }
          start() {}
          stop() {}
          pause(dropWhilePaused) {}
          resume() {}
        }
        function copy$1(value) {
          return JSON.parse(JSON.stringify(value));
        }
        function concisify(items) {
          items = Array.from(new Set(items).values());
          items.sort();
          return items;
        }
        async function getSubscription(_event, provider) {
          if (_event == null) {
            throw new Error("invalid event");
          }
          if (Array.isArray(_event)) {
            _event = { topics: _event };
          }
          if (typeof _event === "string") {
            switch (_event) {
              case "block":
              case "debug":
              case "error":
              case "finalized":
              case "network":
              case "pending":
              case "safe": {
                return { type: _event, tag: _event };
              }
            }
          }
          if (isHexString(_event, 32)) {
            const hash = _event.toLowerCase();
            return {
              type: "transaction",
              tag: getTag("tx", { hash: hash }),
              hash: hash,
            };
          }
          if (_event.orphan) {
            const event = _event;
            return {
              type: "orphan",
              tag: getTag("orphan", event),
              filter: copy$1(event),
            };
          }
          if (_event.address || _event.topics) {
            const event = _event;
            const filter = {
              topics: (event.topics || []).map((t) => {
                if (t == null) {
                  return null;
                }
                if (Array.isArray(t)) {
                  return concisify(t.map((t) => t.toLowerCase()));
                }
                return t.toLowerCase();
              }),
            };
            if (event.address) {
              const addresses = [];
              const promises = [];
              const addAddress = (addr) => {
                if (isHexString(addr)) {
                  addresses.push(addr);
                } else {
                  promises.push(
                    (async () => {
                      addresses.push(await resolveAddress(addr, provider));
                    })()
                  );
                }
              };
              if (Array.isArray(event.address)) {
                event.address.forEach(addAddress);
              } else {
                addAddress(event.address);
              }
              if (promises.length) {
                await Promise.all(promises);
              }
              filter.address = concisify(addresses.map((a) => a.toLowerCase()));
            }
            return {
              filter: filter,
              tag: getTag("event", filter),
              type: "event",
            };
          }
          assertArgument(false, "unknown ProviderEvent", "event", _event);
        }
        function getTime$1() {
          return new Date().getTime();
        }
        const defaultOptions$1 = { cacheTimeout: 250, pollingInterval: 4e3 };
        class AbstractProvider {
          #subs;
          #plugins;
          #pausedState;
          #destroyed;
          #networkPromise;
          #anyNetwork;
          #performCache;
          #lastBlockNumber;
          #nextTimer;
          #timers;
          #disableCcipRead;
          #options;
          constructor(_network, options) {
            this.#options = Object.assign({}, defaultOptions$1, options || {});
            if (_network === "any") {
              this.#anyNetwork = true;
              this.#networkPromise = null;
            } else if (_network) {
              const network = Network.from(_network);
              this.#anyNetwork = false;
              this.#networkPromise = Promise.resolve(network);
              setTimeout(() => {
                this.emit("network", network, null);
              }, 0);
            } else {
              this.#anyNetwork = false;
              this.#networkPromise = null;
            }
            this.#lastBlockNumber = -1;
            this.#performCache = new Map();
            this.#subs = new Map();
            this.#plugins = new Map();
            this.#pausedState = null;
            this.#destroyed = false;
            this.#nextTimer = 1;
            this.#timers = new Map();
            this.#disableCcipRead = false;
          }
          get pollingInterval() {
            return this.#options.pollingInterval;
          }
          get provider() {
            return this;
          }
          get plugins() {
            return Array.from(this.#plugins.values());
          }
          attachPlugin(plugin) {
            if (this.#plugins.get(plugin.name)) {
              throw new Error(
                `cannot replace existing plugin: ${plugin.name} `
              );
            }
            this.#plugins.set(plugin.name, plugin.connect(this));
            return this;
          }
          getPlugin(name) {
            return this.#plugins.get(name) || null;
          }
          get disableCcipRead() {
            return this.#disableCcipRead;
          }
          set disableCcipRead(value) {
            this.#disableCcipRead = !!value;
          }
          async #perform(req) {
            const timeout = this.#options.cacheTimeout;
            if (timeout < 0) {
              return await this._perform(req);
            }
            const tag = getTag(req.method, req);
            let perform = this.#performCache.get(tag);
            if (!perform) {
              perform = this._perform(req);
              this.#performCache.set(tag, perform);
              setTimeout(() => {
                if (this.#performCache.get(tag) === perform) {
                  this.#performCache.delete(tag);
                }
              }, timeout);
            }
            return await perform;
          }
          async ccipReadFetch(tx, calldata, urls) {
            if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
              return null;
            }
            const sender = tx.to.toLowerCase();
            const data = calldata.toLowerCase();
            const errorMessages = [];
            for (let i = 0; i < urls.length; i++) {
              const url = urls[i];
              const href = url
                .replace("{sender}", sender)
                .replace("{data}", data);
              const request = new FetchRequest(href);
              if (url.indexOf("{data}") === -1) {
                request.body = { data: data, sender: sender };
              }
              this.emit("debug", {
                action: "sendCcipReadFetchRequest",
                request: request,
                index: i,
                urls: urls,
              });
              let errorMessage = "unknown error";
              const resp = await request.send();
              try {
                const result = resp.bodyJson;
                if (result.data) {
                  this.emit("debug", {
                    action: "receiveCcipReadFetchResult",
                    request: request,
                    result: result,
                  });
                  return result.data;
                }
                if (result.message) {
                  errorMessage = result.message;
                }
                this.emit("debug", {
                  action: "receiveCcipReadFetchError",
                  request: request,
                  result: result,
                });
              } catch (error) {}
              assert(
                resp.statusCode < 400 || resp.statusCode >= 500,
                `response not found during CCIP fetch: ${errorMessage}`,
                "OFFCHAIN_FAULT",
                {
                  reason: "404_MISSING_RESOURCE",
                  transaction: tx,
                  info: { url: url, errorMessage: errorMessage },
                }
              );
              errorMessages.push(errorMessage);
            }
            assert(
              false,
              `error encountered during CCIP fetch: ${errorMessages
                .map((m) => JSON.stringify(m))
                .join(", ")}`,
              "OFFCHAIN_FAULT",
              {
                reason: "500_SERVER_ERROR",
                transaction: tx,
                info: { urls: urls, errorMessages: errorMessages },
              }
            );
          }
          _wrapBlock(value, network) {
            return new Block(formatBlock(value), this);
          }
          _wrapLog(value, network) {
            return new Log(formatLog(value), this);
          }
          _wrapTransactionReceipt(value, network) {
            return new TransactionReceipt(
              formatTransactionReceipt(value),
              this
            );
          }
          _wrapTransactionResponse(tx, network) {
            return new TransactionResponse(formatTransactionResponse(tx), this);
          }
          _detectNetwork() {
            assert(
              false,
              "sub-classes must implement this",
              "UNSUPPORTED_OPERATION",
              { operation: "_detectNetwork" }
            );
          }
          async _perform(req) {
            assert(
              false,
              `unsupported method: ${req.method}`,
              "UNSUPPORTED_OPERATION",
              { operation: req.method, info: req }
            );
          }
          async getBlockNumber() {
            const blockNumber = getNumber(
              await this.#perform({ method: "getBlockNumber" }),
              "%response"
            );
            if (this.#lastBlockNumber >= 0) {
              this.#lastBlockNumber = blockNumber;
            }
            return blockNumber;
          }
          _getAddress(address) {
            return resolveAddress(address, this);
          }
          _getBlockTag(blockTag) {
            if (blockTag == null) {
              return "latest";
            }
            switch (blockTag) {
              case "earliest":
                return "0x0";
              case "finalized":
              case "latest":
              case "pending":
              case "safe":
                return blockTag;
            }
            if (isHexString(blockTag)) {
              if (isHexString(blockTag, 32)) {
                return blockTag;
              }
              return toQuantity(blockTag);
            }
            if (typeof blockTag === "bigint") {
              blockTag = getNumber(blockTag, "blockTag");
            }
            if (typeof blockTag === "number") {
              if (blockTag >= 0) {
                return toQuantity(blockTag);
              }
              if (this.#lastBlockNumber >= 0) {
                return toQuantity(this.#lastBlockNumber + blockTag);
              }
              return this.getBlockNumber().then((b) =>
                toQuantity(b + blockTag)
              );
            }
            assertArgument(false, "invalid blockTag", "blockTag", blockTag);
          }
          _getFilter(filter) {
            const topics = (filter.topics || []).map((t) => {
              if (t == null) {
                return null;
              }
              if (Array.isArray(t)) {
                return concisify(t.map((t) => t.toLowerCase()));
              }
              return t.toLowerCase();
            });
            const blockHash =
              "blockHash" in filter ? filter.blockHash : undefined;
            const resolve = (_address, fromBlock, toBlock) => {
              let address = undefined;
              switch (_address.length) {
                case 0:
                  break;
                case 1:
                  address = _address[0];
                  break;
                default:
                  _address.sort();
                  address = _address;
              }
              if (blockHash) {
                if (fromBlock != null || toBlock != null) {
                  throw new Error("invalid filter");
                }
              }
              const filter = {};
              if (address) {
                filter.address = address;
              }
              if (topics.length) {
                filter.topics = topics;
              }
              if (fromBlock) {
                filter.fromBlock = fromBlock;
              }
              if (toBlock) {
                filter.toBlock = toBlock;
              }
              if (blockHash) {
                filter.blockHash = blockHash;
              }
              return filter;
            };
            let address = [];
            if (filter.address) {
              if (Array.isArray(filter.address)) {
                for (const addr of filter.address) {
                  address.push(this._getAddress(addr));
                }
              } else {
                address.push(this._getAddress(filter.address));
              }
            }
            let fromBlock = undefined;
            if ("fromBlock" in filter) {
              fromBlock = this._getBlockTag(filter.fromBlock);
            }
            let toBlock = undefined;
            if ("toBlock" in filter) {
              toBlock = this._getBlockTag(filter.toBlock);
            }
            if (
              address.filter((a) => typeof a !== "string").length ||
              (fromBlock != null && typeof fromBlock !== "string") ||
              (toBlock != null && typeof toBlock !== "string")
            ) {
              return Promise.all([
                Promise.all(address),
                fromBlock,
                toBlock,
              ]).then((result) => {
                return resolve(result[0], result[1], result[2]);
              });
            }
            return resolve(address, fromBlock, toBlock);
          }
          _getTransactionRequest(_request) {
            const request = copyRequest(_request);
            const promises = [];
            ["to", "from"].forEach((key) => {
              if (request[key] == null) {
                return;
              }
              const addr = resolveAddress(request[key], this);
              if (isPromise$1(addr)) {
                promises.push(
                  (async function () {
                    request[key] = await addr;
                  })()
                );
              } else {
                request[key] = addr;
              }
            });
            if (request.blockTag != null) {
              const blockTag = this._getBlockTag(request.blockTag);
              if (isPromise$1(blockTag)) {
                promises.push(
                  (async function () {
                    request.blockTag = await blockTag;
                  })()
                );
              } else {
                request.blockTag = blockTag;
              }
            }
            if (promises.length) {
              return (async function () {
                await Promise.all(promises);
                return request;
              })();
            }
            return request;
          }
          async getNetwork() {
            if (this.#networkPromise == null) {
              const detectNetwork = (async () => {
                try {
                  const network = await this._detectNetwork();
                  this.emit("network", network, null);
                  return network;
                } catch (error) {
                  if (this.#networkPromise === detectNetwork) {
                    this.#networkPromise = null;
                  }
                  throw error;
                }
              })();
              this.#networkPromise = detectNetwork;
              return (await detectNetwork).clone();
            }
            const networkPromise = this.#networkPromise;
            const [expected, actual] = await Promise.all([
              networkPromise,
              this._detectNetwork(),
            ]);
            if (expected.chainId !== actual.chainId) {
              if (this.#anyNetwork) {
                this.emit("network", actual, expected);
                if (this.#networkPromise === networkPromise) {
                  this.#networkPromise = Promise.resolve(actual);
                }
              } else {
                assert(
                  false,
                  `network changed: ${expected.chainId} => ${actual.chainId} `,
                  "NETWORK_ERROR",
                  { event: "changed" }
                );
              }
            }
            return expected.clone();
          }
          async getFeeData() {
            const network = await this.getNetwork();
            const getFeeDataFunc = async () => {
              const { _block, gasPrice, priorityFee } = await resolveProperties(
                {
                  _block: this.#getBlock("latest", false),
                  gasPrice: (async () => {
                    try {
                      const value = await this.#perform({
                        method: "getGasPrice",
                      });
                      return getBigInt(value, "%response");
                    } catch (error) {}
                    return null;
                  })(),
                  priorityFee: (async () => {
                    try {
                      const value = await this.#perform({
                        method: "getPriorityFee",
                      });
                      return getBigInt(value, "%response");
                    } catch (error) {}
                    return null;
                  })(),
                }
              );
              let maxFeePerGas = null;
              let maxPriorityFeePerGas = null;
              const block = this._wrapBlock(_block, network);
              if (block && block.baseFeePerGas) {
                maxPriorityFeePerGas =
                  priorityFee != null ? priorityFee : BigInt("1000000000");
                maxFeePerGas =
                  block.baseFeePerGas * BN_2$1 + maxPriorityFeePerGas;
              }
              return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
            };
            const plugin = network.getPlugin(
              "org.ethers.plugins.network.FetchUrlFeeDataPlugin"
            );
            if (plugin) {
              const req = new FetchRequest(plugin.url);
              const feeData = await plugin.processFunc(
                getFeeDataFunc,
                this,
                req
              );
              return new FeeData(
                feeData.gasPrice,
                feeData.maxFeePerGas,
                feeData.maxPriorityFeePerGas
              );
            }
            return await getFeeDataFunc();
          }
          async estimateGas(_tx) {
            let tx = this._getTransactionRequest(_tx);
            if (isPromise$1(tx)) {
              tx = await tx;
            }
            return getBigInt(
              await this.#perform({ method: "estimateGas", transaction: tx }),
              "%response"
            );
          }
          async #call(tx, blockTag, attempt) {
            assert(
              attempt < MAX_CCIP_REDIRECTS,
              "CCIP read exceeded maximum redirections",
              "OFFCHAIN_FAULT",
              {
                reason: "TOO_MANY_REDIRECTS",
                transaction: Object.assign({}, tx, {
                  blockTag: blockTag,
                  enableCcipRead: true,
                }),
              }
            );
            const transaction = copyRequest(tx);
            try {
              return hexlify(
                await this._perform({
                  method: "call",
                  transaction: transaction,
                  blockTag: blockTag,
                })
              );
            } catch (error) {
              if (
                !this.disableCcipRead &&
                isCallException(error) &&
                error.data &&
                attempt >= 0 &&
                blockTag === "latest" &&
                transaction.to != null &&
                dataSlice(error.data, 0, 4) === "0x556f1830"
              ) {
                const data = error.data;
                const txSender = await resolveAddress(transaction.to, this);
                let ccipArgs;
                try {
                  ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
                } catch (error) {
                  assert(false, error.message, "OFFCHAIN_FAULT", {
                    reason: "BAD_DATA",
                    transaction: transaction,
                    info: { data: data },
                  });
                }
                assert(
                  ccipArgs.sender.toLowerCase() === txSender.toLowerCase(),
                  "CCIP Read sender mismatch",
                  "CALL_EXCEPTION",
                  {
                    action: "call",
                    data: data,
                    reason: "OffchainLookup",
                    transaction: transaction,
                    invocation: null,
                    revert: {
                      signature:
                        "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                      name: "OffchainLookup",
                      args: ccipArgs.errorArgs,
                    },
                  }
                );
                const ccipResult = await this.ccipReadFetch(
                  transaction,
                  ccipArgs.calldata,
                  ccipArgs.urls
                );
                assert(
                  ccipResult != null,
                  "CCIP Read failed to fetch data",
                  "OFFCHAIN_FAULT",
                  {
                    reason: "FETCH_FAILED",
                    transaction: transaction,
                    info: { data: error.data, errorArgs: ccipArgs.errorArgs },
                  }
                );
                const tx = {
                  to: txSender,
                  data: concat([
                    ccipArgs.selector,
                    encodeBytes([ccipResult, ccipArgs.extraData]),
                  ]),
                };
                this.emit("debug", {
                  action: "sendCcipReadCall",
                  transaction: tx,
                });
                try {
                  const result = await this.#call(tx, blockTag, attempt + 1);
                  this.emit("debug", {
                    action: "receiveCcipReadCallResult",
                    transaction: Object.assign({}, tx),
                    result: result,
                  });
                  return result;
                } catch (error) {
                  this.emit("debug", {
                    action: "receiveCcipReadCallError",
                    transaction: Object.assign({}, tx),
                    error: error,
                  });
                  throw error;
                }
              }
              throw error;
            }
          }
          async #checkNetwork(promise) {
            const { value } = await resolveProperties({
              network: this.getNetwork(),
              value: promise,
            });
            return value;
          }
          async call(_tx) {
            const { tx, blockTag } = await resolveProperties({
              tx: this._getTransactionRequest(_tx),
              blockTag: this._getBlockTag(_tx.blockTag),
            });
            return await this.#checkNetwork(
              this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1)
            );
          }
          async #getAccountValue(request, _address, _blockTag) {
            let address = this._getAddress(_address);
            let blockTag = this._getBlockTag(_blockTag);
            if (typeof address !== "string" || typeof blockTag !== "string") {
              [address, blockTag] = await Promise.all([address, blockTag]);
            }
            return await this.#checkNetwork(
              this.#perform(
                Object.assign(request, { address: address, blockTag: blockTag })
              )
            );
          }
          async getBalance(address, blockTag) {
            return getBigInt(
              await this.#getAccountValue(
                { method: "getBalance" },
                address,
                blockTag
              ),
              "%response"
            );
          }
          async getTransactionCount(address, blockTag) {
            return getNumber(
              await this.#getAccountValue(
                { method: "getTransactionCount" },
                address,
                blockTag
              ),
              "%response"
            );
          }
          async getCode(address, blockTag) {
            return hexlify(
              await this.#getAccountValue(
                { method: "getCode" },
                address,
                blockTag
              )
            );
          }
          async getStorage(address, _position, blockTag) {
            const position = getBigInt(_position, "position");
            return hexlify(
              await this.#getAccountValue(
                { method: "getStorage", position: position },
                address,
                blockTag
              )
            );
          }
          async broadcastTransaction(signedTx) {
            const { blockNumber, hash, network } = await resolveProperties({
              blockNumber: this.getBlockNumber(),
              hash: this._perform({
                method: "broadcastTransaction",
                signedTransaction: signedTx,
              }),
              network: this.getNetwork(),
            });
            const tx = Transaction.from(signedTx);
            if (tx.hash !== hash) {
              throw new Error("@TODO: the returned hash did not match");
            }
            return this._wrapTransactionResponse(
              tx,
              network
            ).replaceableTransaction(blockNumber);
          }
          async #getBlock(block, includeTransactions) {
            if (isHexString(block, 32)) {
              return await this.#perform({
                method: "getBlock",
                blockHash: block,
                includeTransactions: includeTransactions,
              });
            }
            let blockTag = this._getBlockTag(block);
            if (typeof blockTag !== "string") {
              blockTag = await blockTag;
            }
            return await this.#perform({
              method: "getBlock",
              blockTag: blockTag,
              includeTransactions: includeTransactions,
            });
          }
          async getBlock(block, prefetchTxs) {
            const { network, params } = await resolveProperties({
              network: this.getNetwork(),
              params: this.#getBlock(block, !!prefetchTxs),
            });
            if (params == null) {
              return null;
            }
            return this._wrapBlock(params, network);
          }
          async getTransaction(hash) {
            const { network, params } = await resolveProperties({
              network: this.getNetwork(),
              params: this.#perform({ method: "getTransaction", hash: hash }),
            });
            if (params == null) {
              return null;
            }
            return this._wrapTransactionResponse(params, network);
          }
          async getTransactionReceipt(hash) {
            const { network, params } = await resolveProperties({
              network: this.getNetwork(),
              params: this.#perform({
                method: "getTransactionReceipt",
                hash: hash,
              }),
            });
            if (params == null) {
              return null;
            }
            if (params.gasPrice == null && params.effectiveGasPrice == null) {
              const tx = await this.#perform({
                method: "getTransaction",
                hash: hash,
              });
              if (tx == null) {
                throw new Error(
                  "report this; could not find tx or effectiveGasPrice"
                );
              }
              params.effectiveGasPrice = tx.gasPrice;
            }
            return this._wrapTransactionReceipt(params, network);
          }
          async getTransactionResult(hash) {
            const { result } = await resolveProperties({
              network: this.getNetwork(),
              result: this.#perform({
                method: "getTransactionResult",
                hash: hash,
              }),
            });
            if (result == null) {
              return null;
            }
            return hexlify(result);
          }
          async getLogs(_filter) {
            let filter = this._getFilter(_filter);
            if (isPromise$1(filter)) {
              filter = await filter;
            }
            const { network, params } = await resolveProperties({
              network: this.getNetwork(),
              params: this.#perform({ method: "getLogs", filter: filter }),
            });
            return params.map((p) => this._wrapLog(p, network));
          }
          _getProvider(chainId) {
            assert(
              false,
              "provider cannot connect to target network",
              "UNSUPPORTED_OPERATION",
              { operation: "_getProvider()" }
            );
          }
          async getResolver(name) {
            return await EnsResolver.fromName(this, name);
          }
          async getAvatar(name) {
            const resolver = await this.getResolver(name);
            if (resolver) {
              return await resolver.getAvatar();
            }
            return null;
          }
          async resolveName(name) {
            const resolver = await this.getResolver(name);
            if (resolver) {
              return await resolver.getAddress();
            }
            return null;
          }
          async lookupAddress(address) {
            address = getAddress(address);
            const node = namehash(
              address.substring(2).toLowerCase() + ".addr.reverse"
            );
            try {
              const ensAddr = await EnsResolver.getEnsAddress(this);
              const ensContract = new Contract(
                ensAddr,
                ["function resolver(bytes32) view returns (address)"],
                this
              );
              const resolver = await ensContract.resolver(node);
              if (resolver == null || resolver === ZeroAddress) {
                return null;
              }
              const resolverContract = new Contract(
                resolver,
                ["function name(bytes32) view returns (string)"],
                this
              );
              const name = await resolverContract.name(node);
              const check = await this.resolveName(name);
              if (check !== address) {
                return null;
              }
              return name;
            } catch (error) {
              if (isError(error, "BAD_DATA") && error.value === "0x") {
                return null;
              }
              if (isError(error, "CALL_EXCEPTION")) {
                return null;
              }
              throw error;
            }
            return null;
          }
          async waitForTransaction(hash, _confirms, timeout) {
            const confirms = _confirms != null ? _confirms : 1;
            if (confirms === 0) {
              return this.getTransactionReceipt(hash);
            }
            return new Promise(async (resolve, reject) => {
              let timer = null;
              const listener = async (blockNumber) => {
                try {
                  const receipt = await this.getTransactionReceipt(hash);
                  if (receipt != null) {
                    if (blockNumber - receipt.blockNumber + 1 >= confirms) {
                      resolve(receipt);
                      if (timer) {
                        clearTimeout(timer);
                        timer = null;
                      }
                      return;
                    }
                  }
                } catch (error) {
                  console.log("EEE", error);
                }
                this.once("block", listener);
              };
              if (timeout != null) {
                timer = setTimeout(() => {
                  if (timer == null) {
                    return;
                  }
                  timer = null;
                  this.off("block", listener);
                  reject(
                    makeError("timeout", "TIMEOUT", { reason: "timeout" })
                  );
                }, timeout);
              }
              listener(await this.getBlockNumber());
            });
          }
          async waitForBlock(blockTag) {
            assert(false, "not implemented yet", "NOT_IMPLEMENTED", {
              operation: "waitForBlock",
            });
          }
          _clearTimeout(timerId) {
            const timer = this.#timers.get(timerId);
            if (!timer) {
              return;
            }
            if (timer.timer) {
              clearTimeout(timer.timer);
            }
            this.#timers.delete(timerId);
          }
          _setTimeout(_func, timeout) {
            if (timeout == null) {
              timeout = 0;
            }
            const timerId = this.#nextTimer++;
            const func = () => {
              this.#timers.delete(timerId);
              _func();
            };
            if (this.paused) {
              this.#timers.set(timerId, {
                timer: null,
                func: func,
                time: timeout,
              });
            } else {
              const timer = setTimeout(func, timeout);
              this.#timers.set(timerId, {
                timer: timer,
                func: func,
                time: getTime$1(),
              });
            }
            return timerId;
          }
          _forEachSubscriber(func) {
            for (const sub of this.#subs.values()) {
              func(sub.subscriber);
            }
          }
          _getSubscriber(sub) {
            switch (sub.type) {
              case "debug":
              case "error":
              case "network":
                return new UnmanagedSubscriber(sub.type);
              case "block": {
                const subscriber = new PollingBlockSubscriber(this);
                subscriber.pollingInterval = this.pollingInterval;
                return subscriber;
              }
              case "safe":
              case "finalized":
                return new PollingBlockTagSubscriber(this, sub.type);
              case "event":
                return new PollingEventSubscriber(this, sub.filter);
              case "transaction":
                return new PollingTransactionSubscriber(this, sub.hash);
              case "orphan":
                return new PollingOrphanSubscriber(this, sub.filter);
            }
            throw new Error(`unsupported event: ${sub.type}`);
          }
          _recoverSubscriber(oldSub, newSub) {
            for (const sub of this.#subs.values()) {
              if (sub.subscriber === oldSub) {
                if (sub.started) {
                  sub.subscriber.stop();
                }
                sub.subscriber = newSub;
                if (sub.started) {
                  newSub.start();
                }
                if (this.#pausedState != null) {
                  newSub.pause(this.#pausedState);
                }
                break;
              }
            }
          }
          async #hasSub(event, emitArgs) {
            let sub = await getSubscription(event, this);
            if (
              sub.type === "event" &&
              emitArgs &&
              emitArgs.length > 0 &&
              emitArgs[0].removed === true
            ) {
              sub = await getSubscription(
                { orphan: "drop-log", log: emitArgs[0] },
                this
              );
            }
            return this.#subs.get(sub.tag) || null;
          }
          async #getSub(event) {
            const subscription = await getSubscription(event, this);
            const tag = subscription.tag;
            let sub = this.#subs.get(tag);
            if (!sub) {
              const subscriber = this._getSubscriber(subscription);
              const addressableMap = new WeakMap();
              const nameMap = new Map();
              sub = {
                subscriber: subscriber,
                tag: tag,
                addressableMap: addressableMap,
                nameMap: nameMap,
                started: false,
                listeners: [],
              };
              this.#subs.set(tag, sub);
            }
            return sub;
          }
          async on(event, listener) {
            const sub = await this.#getSub(event);
            sub.listeners.push({ listener: listener, once: false });
            if (!sub.started) {
              sub.subscriber.start();
              sub.started = true;
              if (this.#pausedState != null) {
                sub.subscriber.pause(this.#pausedState);
              }
            }
            return this;
          }
          async once(event, listener) {
            const sub = await this.#getSub(event);
            sub.listeners.push({ listener: listener, once: true });
            if (!sub.started) {
              sub.subscriber.start();
              sub.started = true;
              if (this.#pausedState != null) {
                sub.subscriber.pause(this.#pausedState);
              }
            }
            return this;
          }
          async emit(event, ...args) {
            const sub = await this.#hasSub(event, args);
            if (!sub || sub.listeners.length === 0) {
              return false;
            }
            const count = sub.listeners.length;
            sub.listeners = sub.listeners.filter(({ listener, once }) => {
              const payload = new EventPayload(
                this,
                once ? null : listener,
                event
              );
              try {
                listener.call(this, ...args, payload);
              } catch (error) {}
              return !once;
            });
            if (sub.listeners.length === 0) {
              if (sub.started) {
                sub.subscriber.stop();
              }
              this.#subs.delete(sub.tag);
            }
            return count > 0;
          }
          async listenerCount(event) {
            if (event) {
              const sub = await this.#hasSub(event);
              if (!sub) {
                return 0;
              }
              return sub.listeners.length;
            }
            let total = 0;
            for (const { listeners } of this.#subs.values()) {
              total += listeners.length;
            }
            return total;
          }
          async listeners(event) {
            if (event) {
              const sub = await this.#hasSub(event);
              if (!sub) {
                return [];
              }
              return sub.listeners.map(({ listener }) => listener);
            }
            let result = [];
            for (const { listeners } of this.#subs.values()) {
              result = result.concat(listeners.map(({ listener }) => listener));
            }
            return result;
          }
          async off(event, listener) {
            const sub = await this.#hasSub(event);
            if (!sub) {
              return this;
            }
            if (listener) {
              const index = sub.listeners
                .map(({ listener }) => listener)
                .indexOf(listener);
              if (index >= 0) {
                sub.listeners.splice(index, 1);
              }
            }
            if (!listener || sub.listeners.length === 0) {
              if (sub.started) {
                sub.subscriber.stop();
              }
              this.#subs.delete(sub.tag);
            }
            return this;
          }
          async removeAllListeners(event) {
            if (event) {
              const { tag, started, subscriber } = await this.#getSub(event);
              if (started) {
                subscriber.stop();
              }
              this.#subs.delete(tag);
            } else {
              for (const [tag, { started, subscriber }] of this.#subs) {
                if (started) {
                  subscriber.stop();
                }
                this.#subs.delete(tag);
              }
            }
            return this;
          }
          async addListener(event, listener) {
            return await this.on(event, listener);
          }
          async removeListener(event, listener) {
            return this.off(event, listener);
          }
          get destroyed() {
            return this.#destroyed;
          }
          destroy() {
            this.removeAllListeners();
            for (const timerId of this.#timers.keys()) {
              this._clearTimeout(timerId);
            }
            this.#destroyed = true;
          }
          get paused() {
            return this.#pausedState != null;
          }
          set paused(pause) {
            if (!!pause === this.paused) {
              return;
            }
            if (this.paused) {
              this.resume();
            } else {
              this.pause(false);
            }
          }
          pause(dropWhilePaused) {
            this.#lastBlockNumber = -1;
            if (this.#pausedState != null) {
              if (this.#pausedState == !!dropWhilePaused) {
                return;
              }
              assert(
                false,
                "cannot change pause type; resume first",
                "UNSUPPORTED_OPERATION",
                { operation: "pause" }
              );
            }
            this._forEachSubscriber((s) => s.pause(dropWhilePaused));
            this.#pausedState = !!dropWhilePaused;
            for (const timer of this.#timers.values()) {
              if (timer.timer) {
                clearTimeout(timer.timer);
              }
              timer.time = getTime$1() - timer.time;
            }
          }
          resume() {
            if (this.#pausedState == null) {
              return;
            }
            this._forEachSubscriber((s) => s.resume());
            this.#pausedState = null;
            for (const timer of this.#timers.values()) {
              let timeout = timer.time;
              if (timeout < 0) {
                timeout = 0;
              }
              timer.time = getTime$1();
              setTimeout(timer.func, timeout);
            }
          }
        }
        function _parseString(result, start) {
          try {
            const bytes = _parseBytes(result, start);
            if (bytes) {
              return toUtf8String(bytes);
            }
          } catch (error) {}
          return null;
        }
        function _parseBytes(result, start) {
          if (result === "0x") {
            return null;
          }
          try {
            const offset = getNumber(dataSlice(result, start, start + 32));
            const length = getNumber(dataSlice(result, offset, offset + 32));
            return dataSlice(result, offset + 32, offset + 32 + length);
          } catch (error) {}
          return null;
        }
        function numPad(value) {
          const result = toBeArray(value);
          if (result.length > 32) {
            throw new Error("internal; should not happen");
          }
          const padded = new Uint8Array(32);
          padded.set(result, 32 - result.length);
          return padded;
        }
        function bytesPad(value) {
          if (value.length % 32 === 0) {
            return value;
          }
          const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
          result.set(value);
          return result;
        }
        const empty = new Uint8Array([]);
        function encodeBytes(datas) {
          const result = [];
          let byteCount = 0;
          for (let i = 0; i < datas.length; i++) {
            result.push(empty);
            byteCount += 32;
          }
          for (let i = 0; i < datas.length; i++) {
            const data = getBytes(datas[i]);
            result[i] = numPad(byteCount);
            result.push(numPad(data.length));
            result.push(bytesPad(data));
            byteCount += 32 + Math.ceil(data.length / 32) * 32;
          }
          return concat(result);
        }
        const zeros =
          "0x0000000000000000000000000000000000000000000000000000000000000000";
        function parseOffchainLookup(data) {
          const result = {
            sender: "",
            urls: [],
            calldata: "",
            selector: "",
            extraData: "",
            errorArgs: [],
          };
          assert(
            dataLength(data) >= 5 * 32,
            "insufficient OffchainLookup data",
            "OFFCHAIN_FAULT",
            { reason: "insufficient OffchainLookup data" }
          );
          const sender = dataSlice(data, 0, 32);
          assert(
            dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12),
            "corrupt OffchainLookup sender",
            "OFFCHAIN_FAULT",
            { reason: "corrupt OffchainLookup sender" }
          );
          result.sender = dataSlice(sender, 12);
          try {
            const urls = [];
            const urlsOffset = getNumber(dataSlice(data, 32, 64));
            const urlsLength = getNumber(
              dataSlice(data, urlsOffset, urlsOffset + 32)
            );
            const urlsData = dataSlice(data, urlsOffset + 32);
            for (let u = 0; u < urlsLength; u++) {
              const url = _parseString(urlsData, u * 32);
              if (url == null) {
                throw new Error("abort");
              }
              urls.push(url);
            }
            result.urls = urls;
          } catch (error) {
            assert(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
              reason: "corrupt OffchainLookup urls",
            });
          }
          try {
            const calldata = _parseBytes(data, 64);
            if (calldata == null) {
              throw new Error("abort");
            }
            result.calldata = calldata;
          } catch (error) {
            assert(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
              reason: "corrupt OffchainLookup calldata",
            });
          }
          assert(
            dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28),
            "corrupt OffchainLookup callbaackSelector",
            "OFFCHAIN_FAULT",
            { reason: "corrupt OffchainLookup callbaackSelector" }
          );
          result.selector = dataSlice(data, 96, 100);
          try {
            const extraData = _parseBytes(data, 128);
            if (extraData == null) {
              throw new Error("abort");
            }
            result.extraData = extraData;
          } catch (error) {
            assert(
              false,
              "corrupt OffchainLookup extraData",
              "OFFCHAIN_FAULT",
              { reason: "corrupt OffchainLookup extraData" }
            );
          }
          result.errorArgs = "sender,urls,calldata,selector,extraData"
            .split(/,/)
            .map((k) => result[k]);
          return result;
        }
        function checkProvider(signer, operation) {
          if (signer.provider) {
            return signer.provider;
          }
          assert(false, "missing provider", "UNSUPPORTED_OPERATION", {
            operation: operation,
          });
        }
        async function populate(signer, tx) {
          let pop = copyRequest(tx);
          if (pop.to != null) {
            pop.to = resolveAddress(pop.to, signer);
          }
          if (pop.from != null) {
            const from = pop.from;
            pop.from = Promise.all([
              signer.getAddress(),
              resolveAddress(from, signer),
            ]).then(([address, from]) => {
              assertArgument(
                address.toLowerCase() === from.toLowerCase(),
                "transaction from mismatch",
                "tx.from",
                from
              );
              return address;
            });
          } else {
            pop.from = signer.getAddress();
          }
          return await resolveProperties(pop);
        }
        class AbstractSigner {
          provider;
          constructor(provider) {
            defineProperties(this, { provider: provider || null });
          }
          async getNonce(blockTag) {
            return checkProvider(
              this,
              "getTransactionCount"
            ).getTransactionCount(await this.getAddress(), blockTag);
          }
          async populateCall(tx) {
            const pop = await populate(this, tx);
            return pop;
          }
          async populateTransaction(tx) {
            const provider = checkProvider(this, "populateTransaction");
            const pop = await populate(this, tx);
            if (pop.nonce == null) {
              pop.nonce = await this.getNonce("pending");
            }
            if (pop.gasLimit == null) {
              pop.gasLimit = await this.estimateGas(pop);
            }
            const network = await this.provider.getNetwork();
            if (pop.chainId != null) {
              const chainId = getBigInt(pop.chainId);
              assertArgument(
                chainId === network.chainId,
                "transaction chainId mismatch",
                "tx.chainId",
                tx.chainId
              );
            } else {
              pop.chainId = network.chainId;
            }
            const hasEip1559 =
              pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
            if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
              assertArgument(
                false,
                "eip-1559 transaction do not support gasPrice",
                "tx",
                tx
              );
            } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
              assertArgument(
                false,
                "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
                "tx",
                tx
              );
            }
            if (
              (pop.type === 2 || pop.type == null) &&
              pop.maxFeePerGas != null &&
              pop.maxPriorityFeePerGas != null
            ) {
              pop.type = 2;
            } else if (pop.type === 0 || pop.type === 1) {
              const feeData = await provider.getFeeData();
              assert(
                feeData.gasPrice != null,
                "network does not support gasPrice",
                "UNSUPPORTED_OPERATION",
                { operation: "getGasPrice" }
              );
              if (pop.gasPrice == null) {
                pop.gasPrice = feeData.gasPrice;
              }
            } else {
              const feeData = await provider.getFeeData();
              if (pop.type == null) {
                if (
                  feeData.maxFeePerGas != null &&
                  feeData.maxPriorityFeePerGas != null
                ) {
                  pop.type = 2;
                  if (pop.gasPrice != null) {
                    const gasPrice = pop.gasPrice;
                    delete pop.gasPrice;
                    pop.maxFeePerGas = gasPrice;
                    pop.maxPriorityFeePerGas = gasPrice;
                  } else {
                    if (pop.maxFeePerGas == null) {
                      pop.maxFeePerGas = feeData.maxFeePerGas;
                    }
                    if (pop.maxPriorityFeePerGas == null) {
                      pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                    }
                  }
                } else if (feeData.gasPrice != null) {
                  assert(
                    !hasEip1559,
                    "network does not support EIP-1559",
                    "UNSUPPORTED_OPERATION",
                    { operation: "populateTransaction" }
                  );
                  if (pop.gasPrice == null) {
                    pop.gasPrice = feeData.gasPrice;
                  }
                  pop.type = 0;
                } else {
                  assert(
                    false,
                    "failed to get consistent fee data",
                    "UNSUPPORTED_OPERATION",
                    { operation: "signer.getFeeData" }
                  );
                }
              } else if (pop.type === 2) {
                if (pop.maxFeePerGas == null) {
                  pop.maxFeePerGas = feeData.maxFeePerGas;
                }
                if (pop.maxPriorityFeePerGas == null) {
                  pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
              }
            }
            return await resolveProperties(pop);
          }
          async estimateGas(tx) {
            return checkProvider(this, "estimateGas").estimateGas(
              await this.populateCall(tx)
            );
          }
          async call(tx) {
            return checkProvider(this, "call").call(
              await this.populateCall(tx)
            );
          }
          async resolveName(name) {
            const provider = checkProvider(this, "resolveName");
            return await provider.resolveName(name);
          }
          async sendTransaction(tx) {
            const provider = checkProvider(this, "sendTransaction");
            const pop = await this.populateTransaction(tx);
            delete pop.from;
            const txObj = Transaction.from(pop);
            return await provider.broadcastTransaction(
              await this.signTransaction(txObj)
            );
          }
        }
        class VoidSigner extends AbstractSigner {
          address;
          constructor(address, provider) {
            super(provider);
            defineProperties(this, { address: address });
          }
          async getAddress() {
            return this.address;
          }
          connect(provider) {
            return new VoidSigner(this.address, provider);
          }
          #throwUnsupported(suffix, operation) {
            assert(
              false,
              `VoidSigner cannot sign ${suffix}`,
              "UNSUPPORTED_OPERATION",
              { operation: operation }
            );
          }
          async signTransaction(tx) {
            this.#throwUnsupported("transactions", "signTransaction");
          }
          async signMessage(message) {
            this.#throwUnsupported("messages", "signMessage");
          }
          async signTypedData(domain, types, value) {
            this.#throwUnsupported("typed-data", "signTypedData");
          }
        }
        const shown = new Set();
        function showThrottleMessage(service) {
          if (shown.has(service)) {
            return;
          }
          shown.add(service);
          console.log("========= NOTICE =========");
          console.log(
            `Request-Rate Exceeded for ${service} (this message will not be repeated)`
          );
          console.log("");
          console.log(
            "The default API keys for each service are provided as a highly-throttled,"
          );
          console.log(
            "community resource for low-traffic projects and early prototyping."
          );
          console.log("");
          console.log(
            "While your application will continue to function, we highly recommended"
          );
          console.log(
            "signing up for your own API keys to improve performance, increase your"
          );
          console.log(
            "request rate/limit and enable other perks, such as metrics and advanced APIs."
          );
          console.log("");
          console.log("For more details: https://docs.ethers.org/api-keys/");
          console.log("==========================");
        }
        function copy(obj) {
          return JSON.parse(JSON.stringify(obj));
        }
        class FilterIdSubscriber {
          #provider;
          #filterIdPromise;
          #poller;
          #running;
          #network;
          #hault;
          constructor(provider) {
            this.#provider = provider;
            this.#filterIdPromise = null;
            this.#poller = this.#poll.bind(this);
            this.#running = false;
            this.#network = null;
            this.#hault = false;
          }
          _subscribe(provider) {
            throw new Error("subclasses must override this");
          }
          _emitResults(provider, result) {
            throw new Error("subclasses must override this");
          }
          _recover(provider) {
            throw new Error("subclasses must override this");
          }
          async #poll(blockNumber) {
            try {
              if (this.#filterIdPromise == null) {
                this.#filterIdPromise = this._subscribe(this.#provider);
              }
              let filterId = null;
              try {
                filterId = await this.#filterIdPromise;
              } catch (error) {
                if (
                  !isError(error, "UNSUPPORTED_OPERATION") ||
                  error.operation !== "eth_newFilter"
                ) {
                  throw error;
                }
              }
              if (filterId == null) {
                this.#filterIdPromise = null;
                this.#provider._recoverSubscriber(
                  this,
                  this._recover(this.#provider)
                );
                return;
              }
              const network = await this.#provider.getNetwork();
              if (!this.#network) {
                this.#network = network;
              }
              if (this.#network.chainId !== network.chainId) {
                throw new Error("chaid changed");
              }
              if (this.#hault) {
                return;
              }
              const result = await this.#provider.send("eth_getFilterChanges", [
                filterId,
              ]);
              await this._emitResults(this.#provider, result);
            } catch (error) {
              console.log("@TODO", error);
            }
            this.#provider.once("block", this.#poller);
          }
          #teardown() {
            const filterIdPromise = this.#filterIdPromise;
            if (filterIdPromise) {
              this.#filterIdPromise = null;
              filterIdPromise.then((filterId) => {
                this.#provider.send("eth_uninstallFilter", [filterId]);
              });
            }
          }
          start() {
            if (this.#running) {
              return;
            }
            this.#running = true;
            this.#poll(-2);
          }
          stop() {
            if (!this.#running) {
              return;
            }
            this.#running = false;
            this.#hault = true;
            this.#teardown();
            this.#provider.off("block", this.#poller);
          }
          pause(dropWhilePaused) {
            if (dropWhilePaused) {
              this.#teardown();
            }
            this.#provider.off("block", this.#poller);
          }
          resume() {
            this.start();
          }
        }
        class FilterIdEventSubscriber extends FilterIdSubscriber {
          #event;
          constructor(provider, filter) {
            super(provider);
            this.#event = copy(filter);
          }
          _recover(provider) {
            return new PollingEventSubscriber(provider, this.#event);
          }
          async _subscribe(provider) {
            const filterId = await provider.send("eth_newFilter", [
              this.#event,
            ]);
            return filterId;
          }
          async _emitResults(provider, results) {
            for (const result of results) {
              provider.emit(
                this.#event,
                provider._wrapLog(result, provider._network)
              );
            }
          }
        }
        class FilterIdPendingSubscriber extends FilterIdSubscriber {
          async _subscribe(provider) {
            return await provider.send("eth_newPendingTransactionFilter", []);
          }
          async _emitResults(provider, results) {
            for (const result of results) {
              provider.emit("pending", result);
            }
          }
        }
        const Primitive = "bigint,boolean,function,number,string,symbol".split(
          /,/g
        );
        function deepCopy(value) {
          if (value == null || Primitive.indexOf(typeof value) >= 0) {
            return value;
          }
          if (typeof value.getAddress === "function") {
            return value;
          }
          if (Array.isArray(value)) {
            return value.map(deepCopy);
          }
          if (typeof value === "object") {
            return Object.keys(value).reduce((accum, key) => {
              accum[key] = value[key];
              return accum;
            }, {});
          }
          throw new Error(`should not happen: ${value} (${typeof value})`);
        }
        function stall$3(duration) {
          return new Promise((resolve) => {
            setTimeout(resolve, duration);
          });
        }
        function getLowerCase(value) {
          if (value) {
            return value.toLowerCase();
          }
          return value;
        }
        function isPollable(value) {
          return value && typeof value.pollingInterval === "number";
        }
        const defaultOptions = {
          polling: false,
          staticNetwork: null,
          batchStallTime: 10,
          batchMaxSize: 1 << 20,
          batchMaxCount: 100,
          cacheTimeout: 250,
          pollingInterval: 4e3,
        };
        class JsonRpcSigner extends AbstractSigner {
          address;
          constructor(provider, address) {
            super(provider);
            address = getAddress(address);
            defineProperties(this, { address: address });
          }
          connect(provider) {
            assert(
              false,
              "cannot reconnect JsonRpcSigner",
              "UNSUPPORTED_OPERATION",
              { operation: "signer.connect" }
            );
          }
          async getAddress() {
            return this.address;
          }
          async populateTransaction(tx) {
            return await this.populateCall(tx);
          }
          async sendUncheckedTransaction(_tx) {
            const tx = deepCopy(_tx);
            const promises = [];
            if (tx.from) {
              const _from = tx.from;
              promises.push(
                (async () => {
                  const from = await resolveAddress(_from, this.provider);
                  assertArgument(
                    from != null &&
                      from.toLowerCase() === this.address.toLowerCase(),
                    "from address mismatch",
                    "transaction",
                    _tx
                  );
                  tx.from = from;
                })()
              );
            } else {
              tx.from = this.address;
            }
            if (tx.gasLimit == null) {
              promises.push(
                (async () => {
                  tx.gasLimit = await this.provider.estimateGas({
                    ...tx,
                    from: this.address,
                  });
                })()
              );
            }
            if (tx.to != null) {
              const _to = tx.to;
              promises.push(
                (async () => {
                  tx.to = await resolveAddress(_to, this.provider);
                })()
              );
            }
            if (promises.length) {
              await Promise.all(promises);
            }
            const hexTx = this.provider.getRpcTransaction(tx);
            return this.provider.send("eth_sendTransaction", [hexTx]);
          }
          async sendTransaction(tx) {
            const blockNumber = await this.provider.getBlockNumber();
            const hash = await this.sendUncheckedTransaction(tx);
            return await new Promise((resolve, reject) => {
              const timeouts = [1e3, 100];
              let invalids = 0;
              const checkTx = async () => {
                try {
                  const tx = await this.provider.getTransaction(hash);
                  if (tx != null) {
                    resolve(tx.replaceableTransaction(blockNumber));
                    return;
                  }
                } catch (error) {
                  if (
                    isError(error, "CANCELLED") ||
                    isError(error, "BAD_DATA") ||
                    isError(error, "NETWORK_ERROR")
                  ) {
                    if (error.info == null) {
                      error.info = {};
                    }
                    error.info.sendTransactionHash = hash;
                    reject(error);
                    return;
                  }
                  if (isError(error, "INVALID_ARGUMENT")) {
                    invalids++;
                    if (error.info == null) {
                      error.info = {};
                    }
                    error.info.sendTransactionHash = hash;
                    if (invalids > 10) {
                      reject(error);
                      return;
                    }
                  }
                  this.provider.emit(
                    "error",
                    makeError(
                      "failed to fetch transation after sending (will try again)",
                      "UNKNOWN_ERROR",
                      { error: error }
                    )
                  );
                }
                this.provider._setTimeout(() => {
                  checkTx();
                }, timeouts.pop() || 4e3);
              };
              checkTx();
            });
          }
          async signTransaction(_tx) {
            const tx = deepCopy(_tx);
            if (tx.from) {
              const from = await resolveAddress(tx.from, this.provider);
              assertArgument(
                from != null &&
                  from.toLowerCase() === this.address.toLowerCase(),
                "from address mismatch",
                "transaction",
                _tx
              );
              tx.from = from;
            } else {
              tx.from = this.address;
            }
            const hexTx = this.provider.getRpcTransaction(tx);
            return await this.provider.send("eth_signTransaction", [hexTx]);
          }
          async signMessage(_message) {
            const message =
              typeof _message === "string" ? toUtf8Bytes(_message) : _message;
            return await this.provider.send("personal_sign", [
              hexlify(message),
              this.address.toLowerCase(),
            ]);
          }
          async signTypedData(domain, types, _value) {
            const value = deepCopy(_value);
            const populated = await TypedDataEncoder.resolveNames(
              domain,
              types,
              value,
              async (value) => {
                const address = await resolveAddress(value);
                assertArgument(
                  address != null,
                  "TypedData does not support null address",
                  "value",
                  value
                );
                return address;
              }
            );
            return await this.provider.send("eth_signTypedData_v4", [
              this.address.toLowerCase(),
              JSON.stringify(
                TypedDataEncoder.getPayload(
                  populated.domain,
                  types,
                  populated.value
                )
              ),
            ]);
          }
          async unlock(password) {
            return this.provider.send("personal_unlockAccount", [
              this.address.toLowerCase(),
              password,
              null,
            ]);
          }
          async _legacySignMessage(_message) {
            const message =
              typeof _message === "string" ? toUtf8Bytes(_message) : _message;
            return await this.provider.send("eth_sign", [
              this.address.toLowerCase(),
              hexlify(message),
            ]);
          }
        }
        class JsonRpcApiProvider extends AbstractProvider {
          #options;
          #nextId;
          #payloads;
          #drainTimer;
          #notReady;
          #network;
          #pendingDetectNetwork;
          #scheduleDrain() {
            if (this.#drainTimer) {
              return;
            }
            const stallTime =
              this._getOption("batchMaxCount") === 1
                ? 0
                : this._getOption("batchStallTime");
            this.#drainTimer = setTimeout(() => {
              this.#drainTimer = null;
              const payloads = this.#payloads;
              this.#payloads = [];
              while (payloads.length) {
                const batch = [payloads.shift()];
                while (payloads.length) {
                  if (batch.length === this.#options.batchMaxCount) {
                    break;
                  }
                  batch.push(payloads.shift());
                  const bytes = JSON.stringify(batch.map((p) => p.payload));
                  if (bytes.length > this.#options.batchMaxSize) {
                    payloads.unshift(batch.pop());
                    break;
                  }
                }
                (async () => {
                  const payload =
                    batch.length === 1
                      ? batch[0].payload
                      : batch.map((p) => p.payload);
                  this.emit("debug", {
                    action: "sendRpcPayload",
                    payload: payload,
                  });
                  try {
                    const result = await this._send(payload);
                    this.emit("debug", {
                      action: "receiveRpcResult",
                      result: result,
                    });
                    for (const { resolve, reject, payload } of batch) {
                      if (this.destroyed) {
                        reject(
                          makeError(
                            "provider destroyed; cancelled request",
                            "UNSUPPORTED_OPERATION",
                            { operation: payload.method }
                          )
                        );
                        continue;
                      }
                      const resp = result.filter((r) => r.id === payload.id)[0];
                      if (resp == null) {
                        const error = makeError(
                          "missing response for request",
                          "BAD_DATA",
                          { value: result, info: { payload: payload } }
                        );
                        this.emit("error", error);
                        reject(error);
                        continue;
                      }
                      if ("error" in resp) {
                        reject(this.getRpcError(payload, resp));
                        continue;
                      }
                      resolve(resp.result);
                    }
                  } catch (error) {
                    this.emit("debug", {
                      action: "receiveRpcError",
                      error: error,
                    });
                    for (const { reject } of batch) {
                      reject(error);
                    }
                  }
                })();
              }
            }, stallTime);
          }
          constructor(network, options) {
            super(network, options);
            this.#nextId = 1;
            this.#options = Object.assign({}, defaultOptions, options || {});
            this.#payloads = [];
            this.#drainTimer = null;
            this.#network = null;
            this.#pendingDetectNetwork = null;
            {
              let resolve = null;
              const promise = new Promise((_resolve) => {
                resolve = _resolve;
              });
              this.#notReady = { promise: promise, resolve: resolve };
            }
            const staticNetwork = this._getOption("staticNetwork");
            if (typeof staticNetwork === "boolean") {
              assertArgument(
                !staticNetwork || network !== "any",
                "staticNetwork cannot be used on special network 'any'",
                "options",
                options
              );
              if (staticNetwork && network != null) {
                this.#network = Network.from(network);
              }
            } else if (staticNetwork) {
              assertArgument(
                network == null || staticNetwork.matches(network),
                "staticNetwork MUST match network object",
                "options",
                options
              );
              this.#network = staticNetwork;
            }
          }
          _getOption(key) {
            return this.#options[key];
          }
          get _network() {
            assert(
              this.#network,
              "network is not available yet",
              "NETWORK_ERROR"
            );
            return this.#network;
          }
          async _perform(req) {
            if (req.method === "call" || req.method === "estimateGas") {
              let tx = req.transaction;
              if (tx && tx.type != null && getBigInt(tx.type)) {
                if (
                  tx.maxFeePerGas == null &&
                  tx.maxPriorityFeePerGas == null
                ) {
                  const feeData = await this.getFeeData();
                  if (
                    feeData.maxFeePerGas == null &&
                    feeData.maxPriorityFeePerGas == null
                  ) {
                    req = Object.assign({}, req, {
                      transaction: Object.assign({}, tx, { type: undefined }),
                    });
                  }
                }
              }
            }
            const request = this.getRpcRequest(req);
            if (request != null) {
              return await this.send(request.method, request.args);
            }
            return super._perform(req);
          }
          async _detectNetwork() {
            const network = this._getOption("staticNetwork");
            if (network) {
              if (network === true) {
                if (this.#network) {
                  return this.#network;
                }
              } else {
                return network;
              }
            }
            if (this.#pendingDetectNetwork) {
              return await this.#pendingDetectNetwork;
            }
            if (this.ready) {
              this.#pendingDetectNetwork = (async () => {
                try {
                  const result = Network.from(
                    getBigInt(await this.send("eth_chainId", []))
                  );
                  this.#pendingDetectNetwork = null;
                  return result;
                } catch (error) {
                  this.#pendingDetectNetwork = null;
                  throw error;
                }
              })();
              return await this.#pendingDetectNetwork;
            }
            this.#pendingDetectNetwork = (async () => {
              const payload = {
                id: this.#nextId++,
                method: "eth_chainId",
                params: [],
                jsonrpc: "2.0",
              };
              this.emit("debug", {
                action: "sendRpcPayload",
                payload: payload,
              });
              let result;
              try {
                result = (await this._send(payload))[0];
                this.#pendingDetectNetwork = null;
              } catch (error) {
                this.#pendingDetectNetwork = null;
                this.emit("debug", { action: "receiveRpcError", error: error });
                throw error;
              }
              this.emit("debug", {
                action: "receiveRpcResult",
                result: result,
              });
              if ("result" in result) {
                return Network.from(getBigInt(result.result));
              }
              throw this.getRpcError(payload, result);
            })();
            return await this.#pendingDetectNetwork;
          }
          _start() {
            if (this.#notReady == null || this.#notReady.resolve == null) {
              return;
            }
            this.#notReady.resolve();
            this.#notReady = null;
            (async () => {
              while (this.#network == null && !this.destroyed) {
                try {
                  this.#network = await this._detectNetwork();
                } catch (error) {
                  if (this.destroyed) {
                    break;
                  }
                  console.log(
                    "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
                  );
                  this.emit(
                    "error",
                    makeError(
                      "failed to bootstrap network detection",
                      "NETWORK_ERROR",
                      {
                        event: "initial-network-discovery",
                        info: { error: error },
                      }
                    )
                  );
                  await stall$3(1e3);
                }
              }
              this.#scheduleDrain();
            })();
          }
          async _waitUntilReady() {
            if (this.#notReady == null) {
              return;
            }
            return await this.#notReady.promise;
          }
          _getSubscriber(sub) {
            if (sub.type === "pending") {
              return new FilterIdPendingSubscriber(this);
            }
            if (sub.type === "event") {
              if (this._getOption("polling")) {
                return new PollingEventSubscriber(this, sub.filter);
              }
              return new FilterIdEventSubscriber(this, sub.filter);
            }
            if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
              return new UnmanagedSubscriber("orphan");
            }
            return super._getSubscriber(sub);
          }
          get ready() {
            return this.#notReady == null;
          }
          getRpcTransaction(tx) {
            const result = {};
            [
              "chainId",
              "gasLimit",
              "gasPrice",
              "type",
              "maxFeePerGas",
              "maxPriorityFeePerGas",
              "nonce",
              "value",
            ].forEach((key) => {
              if (tx[key] == null) {
                return;
              }
              let dstKey = key;
              if (key === "gasLimit") {
                dstKey = "gas";
              }
              result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
            });
            ["from", "to", "data"].forEach((key) => {
              if (tx[key] == null) {
                return;
              }
              result[key] = hexlify(tx[key]);
            });
            if (tx.accessList) {
              result["accessList"] = accessListify(tx.accessList);
            }
            return result;
          }
          getRpcRequest(req) {
            switch (req.method) {
              case "chainId":
                return { method: "eth_chainId", args: [] };
              case "getBlockNumber":
                return { method: "eth_blockNumber", args: [] };
              case "getGasPrice":
                return { method: "eth_gasPrice", args: [] };
              case "getPriorityFee":
                return { method: "eth_maxPriorityFeePerGas", args: [] };
              case "getBalance":
                return {
                  method: "eth_getBalance",
                  args: [getLowerCase(req.address), req.blockTag],
                };
              case "getTransactionCount":
                return {
                  method: "eth_getTransactionCount",
                  args: [getLowerCase(req.address), req.blockTag],
                };
              case "getCode":
                return {
                  method: "eth_getCode",
                  args: [getLowerCase(req.address), req.blockTag],
                };
              case "getStorage":
                return {
                  method: "eth_getStorageAt",
                  args: [
                    getLowerCase(req.address),
                    "0x" + req.position.toString(16),
                    req.blockTag,
                  ],
                };
              case "broadcastTransaction":
                return {
                  method: "eth_sendRawTransaction",
                  args: [req.signedTransaction],
                };
              case "getBlock":
                if ("blockTag" in req) {
                  return {
                    method: "eth_getBlockByNumber",
                    args: [req.blockTag, !!req.includeTransactions],
                  };
                } else if ("blockHash" in req) {
                  return {
                    method: "eth_getBlockByHash",
                    args: [req.blockHash, !!req.includeTransactions],
                  };
                }
                break;
              case "getTransaction":
                return { method: "eth_getTransactionByHash", args: [req.hash] };
              case "getTransactionReceipt":
                return {
                  method: "eth_getTransactionReceipt",
                  args: [req.hash],
                };
              case "call":
                return {
                  method: "eth_call",
                  args: [this.getRpcTransaction(req.transaction), req.blockTag],
                };
              case "estimateGas": {
                return {
                  method: "eth_estimateGas",
                  args: [this.getRpcTransaction(req.transaction)],
                };
              }
              case "getLogs":
                if (req.filter && req.filter.address != null) {
                  if (Array.isArray(req.filter.address)) {
                    req.filter.address = req.filter.address.map(getLowerCase);
                  } else {
                    req.filter.address = getLowerCase(req.filter.address);
                  }
                }
                return { method: "eth_getLogs", args: [req.filter] };
            }
            return null;
          }
          getRpcError(payload, _error) {
            const { method } = payload;
            const { error } = _error;
            if (method === "eth_estimateGas" && error.message) {
              const msg = error.message;
              if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
                return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
                  transaction: payload.params[0],
                  info: { payload: payload, error: error },
                });
              }
            }
            if (method === "eth_call" || method === "eth_estimateGas") {
              const result = spelunkData(error);
              const e = AbiCoder.getBuiltinCallException(
                method === "eth_call" ? "call" : "estimateGas",
                payload.params[0],
                result ? result.data : null
              );
              e.info = { error: error, payload: payload };
              return e;
            }
            const message = JSON.stringify(spelunkMessage(error));
            if (
              typeof error.message === "string" &&
              error.message.match(/user denied|ethers-user-denied/i)
            ) {
              const actionMap = {
                eth_sign: "signMessage",
                personal_sign: "signMessage",
                eth_signTypedData_v4: "signTypedData",
                eth_signTransaction: "signTransaction",
                eth_sendTransaction: "sendTransaction",
                eth_requestAccounts: "requestAccess",
                wallet_requestAccounts: "requestAccess",
              };
              return makeError(`user rejected action`, "ACTION_REJECTED", {
                action: actionMap[method] || "unknown",
                reason: "rejected",
                info: { payload: payload, error: error },
              });
            }
            if (
              method === "eth_sendRawTransaction" ||
              method === "eth_sendTransaction"
            ) {
              const transaction = payload.params[0];
              if (
                message.match(/insufficient funds|base fee exceeds gas limit/i)
              ) {
                return makeError(
                  "insufficient funds for intrinsic transaction cost",
                  "INSUFFICIENT_FUNDS",
                  { transaction: transaction, info: { error: error } }
                );
              }
              if (message.match(/nonce/i) && message.match(/too low/i)) {
                return makeError(
                  "nonce has already been used",
                  "NONCE_EXPIRED",
                  { transaction: transaction, info: { error: error } }
                );
              }
              if (
                message.match(/replacement transaction/i) &&
                message.match(/underpriced/i)
              ) {
                return makeError(
                  "replacement fee too low",
                  "REPLACEMENT_UNDERPRICED",
                  { transaction: transaction, info: { error: error } }
                );
              }
              if (message.match(/only replay-protected/i)) {
                return makeError(
                  "legacy pre-eip-155 transactions not supported",
                  "UNSUPPORTED_OPERATION",
                  {
                    operation: method,
                    info: { transaction: transaction, info: { error: error } },
                  }
                );
              }
            }
            let unsupported = !!message.match(/the method .* does not exist/i);
            if (!unsupported) {
              if (
                error &&
                error.details &&
                error.details.startsWith("Unauthorized method:")
              ) {
                unsupported = true;
              }
            }
            if (unsupported) {
              return makeError(
                "unsupported operation",
                "UNSUPPORTED_OPERATION",
                {
                  operation: payload.method,
                  info: { error: error, payload: payload },
                }
              );
            }
            return makeError("could not coalesce error", "UNKNOWN_ERROR", {
              error: error,
              payload: payload,
            });
          }
          send(method, params) {
            if (this.destroyed) {
              return Promise.reject(
                makeError(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: method }
                )
              );
            }
            const id = this.#nextId++;
            const promise = new Promise((resolve, reject) => {
              this.#payloads.push({
                resolve: resolve,
                reject: reject,
                payload: {
                  method: method,
                  params: params,
                  id: id,
                  jsonrpc: "2.0",
                },
              });
            });
            this.#scheduleDrain();
            return promise;
          }
          async getSigner(address) {
            if (address == null) {
              address = 0;
            }
            const accountsPromise = this.send("eth_accounts", []);
            if (typeof address === "number") {
              const accounts = await accountsPromise;
              if (address >= accounts.length) {
                throw new Error("no such account");
              }
              return new JsonRpcSigner(this, accounts[address]);
            }
            const { accounts } = await resolveProperties({
              network: this.getNetwork(),
              accounts: accountsPromise,
            });
            address = getAddress(address);
            for (const account of accounts) {
              if (getAddress(account) === address) {
                return new JsonRpcSigner(this, address);
              }
            }
            throw new Error("invalid account");
          }
          async listAccounts() {
            const accounts = await this.send("eth_accounts", []);
            return accounts.map((a) => new JsonRpcSigner(this, a));
          }
          destroy() {
            if (this.#drainTimer) {
              clearTimeout(this.#drainTimer);
              this.#drainTimer = null;
            }
            for (const { payload, reject } of this.#payloads) {
              reject(
                makeError(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: payload.method }
                )
              );
            }
            this.#payloads = [];
            super.destroy();
          }
        }
        class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
          #pollingInterval;
          constructor(network, options) {
            super(network, options);
            this.#pollingInterval = 4e3;
          }
          _getSubscriber(sub) {
            const subscriber = super._getSubscriber(sub);
            if (isPollable(subscriber)) {
              subscriber.pollingInterval = this.#pollingInterval;
            }
            return subscriber;
          }
          get pollingInterval() {
            return this.#pollingInterval;
          }
          set pollingInterval(value) {
            if (!Number.isInteger(value) || value < 0) {
              throw new Error("invalid interval");
            }
            this.#pollingInterval = value;
            this._forEachSubscriber((sub) => {
              if (isPollable(sub)) {
                sub.pollingInterval = this.#pollingInterval;
              }
            });
          }
        }
        class JsonRpcProvider extends JsonRpcApiPollingProvider {
          #connect;
          constructor(url, network, options) {
            if (url == null) {
              url = "http://localhost:8545";
            }
            super(network, options);
            if (typeof url === "string") {
              this.#connect = new FetchRequest(url);
            } else {
              this.#connect = url.clone();
            }
          }
          _getConnection() {
            return this.#connect.clone();
          }
          async send(method, params) {
            await this._start();
            return await super.send(method, params);
          }
          async _send(payload) {
            const request = this._getConnection();
            request.body = JSON.stringify(payload);
            request.setHeader("content-type", "application/json");
            const response = await request.send();
            response.assertOk();
            let resp = response.bodyJson;
            if (!Array.isArray(resp)) {
              resp = [resp];
            }
            return resp;
          }
        }
        function spelunkData(value) {
          if (value == null) {
            return null;
          }
          if (
            typeof value.message === "string" &&
            value.message.match(/revert/i) &&
            isHexString(value.data)
          ) {
            return { message: value.message, data: value.data };
          }
          if (typeof value === "object") {
            for (const key in value) {
              const result = spelunkData(value[key]);
              if (result) {
                return result;
              }
            }
            return null;
          }
          if (typeof value === "string") {
            try {
              return spelunkData(JSON.parse(value));
            } catch (error) {}
          }
          return null;
        }
        function _spelunkMessage(value, result) {
          if (value == null) {
            return;
          }
          if (typeof value.message === "string") {
            result.push(value.message);
          }
          if (typeof value === "object") {
            for (const key in value) {
              _spelunkMessage(value[key], result);
            }
          }
          if (typeof value === "string") {
            try {
              return _spelunkMessage(JSON.parse(value), result);
            } catch (error) {}
          }
        }
        function spelunkMessage(value) {
          const result = [];
          _spelunkMessage(value, result);
          return result;
        }
        const defaultApiKey$1 =
          "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
        function getHost$4(name) {
          switch (name) {
            case "mainnet":
              return "rpc.ankr.com/eth";
            case "goerli":
              return "rpc.ankr.com/eth_goerli";
            case "sepolia":
              return "rpc.ankr.com/eth_sepolia";
            case "arbitrum":
              return "rpc.ankr.com/arbitrum";
            case "base":
              return "rpc.ankr.com/base";
            case "base-goerli":
              return "rpc.ankr.com/base_goerli";
            case "base-sepolia":
              return "rpc.ankr.com/base_sepolia";
            case "bnb":
              return "rpc.ankr.com/bsc";
            case "bnbt":
              return "rpc.ankr.com/bsc_testnet_chapel";
            case "matic":
              return "rpc.ankr.com/polygon";
            case "matic-mumbai":
              return "rpc.ankr.com/polygon_mumbai";
            case "optimism":
              return "rpc.ankr.com/optimism";
            case "optimism-goerli":
              return "rpc.ankr.com/optimism_testnet";
            case "optimism-sepolia":
              return "rpc.ankr.com/optimism_sepolia";
          }
          assertArgument(false, "unsupported network", "network", name);
        }
        class AnkrProvider extends JsonRpcProvider {
          apiKey;
          constructor(_network, apiKey) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            if (apiKey == null) {
              apiKey = defaultApiKey$1;
            }
            const options = { polling: true, staticNetwork: network };
            const request = AnkrProvider.getRequest(network, apiKey);
            super(request, network, options);
            defineProperties(this, { apiKey: apiKey });
          }
          _getProvider(chainId) {
            try {
              return new AnkrProvider(chainId, this.apiKey);
            } catch (error) {}
            return super._getProvider(chainId);
          }
          static getRequest(network, apiKey) {
            if (apiKey == null) {
              apiKey = defaultApiKey$1;
            }
            const request = new FetchRequest(
              `https:/\/${getHost$4(network.name)}/${apiKey}`
            );
            request.allowGzip = true;
            if (apiKey === defaultApiKey$1) {
              request.retryFunc = async (request, response, attempt) => {
                showThrottleMessage("AnkrProvider");
                return true;
              };
            }
            return request;
          }
          getRpcError(payload, error) {
            if (payload.method === "eth_sendRawTransaction") {
              if (
                error &&
                error.error &&
                error.error.message ===
                  "INTERNAL_ERROR: could not replace existing tx"
              ) {
                error.error.message = "replacement transaction underpriced";
              }
            }
            return super.getRpcError(payload, error);
          }
          isCommunityResource() {
            return this.apiKey === defaultApiKey$1;
          }
        }
        const defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
        function getHost$3(name) {
          switch (name) {
            case "mainnet":
              return "eth-mainnet.alchemyapi.io";
            case "goerli":
              return "eth-goerli.g.alchemy.com";
            case "sepolia":
              return "eth-sepolia.g.alchemy.com";
            case "arbitrum":
              return "arb-mainnet.g.alchemy.com";
            case "arbitrum-goerli":
              return "arb-goerli.g.alchemy.com";
            case "arbitrum-sepolia":
              return "arb-sepolia.g.alchemy.com";
            case "base":
              return "base-mainnet.g.alchemy.com";
            case "base-goerli":
              return "base-goerli.g.alchemy.com";
            case "base-sepolia":
              return "base-sepolia.g.alchemy.com";
            case "matic":
              return "polygon-mainnet.g.alchemy.com";
            case "matic-mumbai":
              return "polygon-mumbai.g.alchemy.com";
            case "optimism":
              return "opt-mainnet.g.alchemy.com";
            case "optimism-goerli":
              return "opt-goerli.g.alchemy.com";
            case "optimism-sepolia":
              return "opt-sepolia.g.alchemy.com";
          }
          assertArgument(false, "unsupported network", "network", name);
        }
        class AlchemyProvider extends JsonRpcProvider {
          apiKey;
          constructor(_network, apiKey) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            if (apiKey == null) {
              apiKey = defaultApiKey;
            }
            const request = AlchemyProvider.getRequest(network, apiKey);
            super(request, network, { staticNetwork: network });
            defineProperties(this, { apiKey: apiKey });
          }
          _getProvider(chainId) {
            try {
              return new AlchemyProvider(chainId, this.apiKey);
            } catch (error) {}
            return super._getProvider(chainId);
          }
          async _perform(req) {
            if (req.method === "getTransactionResult") {
              const { trace, tx } = await resolveProperties({
                trace: this.send("trace_transaction", [req.hash]),
                tx: this.getTransaction(req.hash),
              });
              if (trace == null || tx == null) {
                return null;
              }
              let data;
              let error = false;
              try {
                data = trace[0].result.output;
                error = trace[0].error === "Reverted";
              } catch (error) {}
              if (data) {
                assert(
                  !error,
                  "an error occurred during transaction executions",
                  "CALL_EXCEPTION",
                  {
                    action: "getTransactionResult",
                    data: data,
                    reason: null,
                    transaction: tx,
                    invocation: null,
                    revert: null,
                  }
                );
                return data;
              }
              assert(false, "could not parse trace result", "BAD_DATA", {
                value: trace,
              });
            }
            return await super._perform(req);
          }
          isCommunityResource() {
            return this.apiKey === defaultApiKey;
          }
          static getRequest(network, apiKey) {
            if (apiKey == null) {
              apiKey = defaultApiKey;
            }
            const request = new FetchRequest(
              `https:/\/${getHost$3(network.name)}/v2/${apiKey}`
            );
            request.allowGzip = true;
            if (apiKey === defaultApiKey) {
              request.retryFunc = async (request, response, attempt) => {
                showThrottleMessage("alchemy");
                return true;
              };
            }
            return request;
          }
        }
        class CloudflareProvider extends JsonRpcProvider {
          constructor(_network) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            assertArgument(
              network.name === "mainnet",
              "unsupported network",
              "network",
              _network
            );
            super("https://cloudflare-eth.com/", network, {
              staticNetwork: network,
            });
          }
        }
        const THROTTLE = 2e3;
        function isPromise(value) {
          return value && typeof value.then === "function";
        }
        const EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
        class EtherscanPlugin extends NetworkPlugin {
          baseUrl;
          constructor(baseUrl) {
            super(EtherscanPluginId);
            defineProperties(this, { baseUrl: baseUrl });
          }
          clone() {
            return new EtherscanPlugin(this.baseUrl);
          }
        }
        const skipKeys = ["enableCcipRead"];
        let nextId = 1;
        class EtherscanProvider extends AbstractProvider {
          network;
          apiKey;
          #plugin;
          constructor(_network, _apiKey) {
            const apiKey = _apiKey != null ? _apiKey : null;
            super();
            const network = Network.from(_network);
            this.#plugin = network.getPlugin(EtherscanPluginId);
            defineProperties(this, { apiKey: apiKey, network: network });
            this.getBaseUrl();
          }
          getBaseUrl() {
            if (this.#plugin) {
              return this.#plugin.baseUrl;
            }
            switch (this.network.name) {
              case "mainnet":
                return "https://api.etherscan.io";
              case "goerli":
                return "https://api-goerli.etherscan.io";
              case "sepolia":
                return "https://api-sepolia.etherscan.io";
              case "holesky":
                return "https://api-holesky.etherscan.io";
              case "arbitrum":
                return "https://api.arbiscan.io";
              case "arbitrum-goerli":
                return "https://api-goerli.arbiscan.io";
              case "bnb":
                return "https://api.bscscan.com";
              case "bnbt":
                return "https://api-testnet.bscscan.com";
              case "matic":
                return "https://api.polygonscan.com";
              case "matic-mumbai":
                return "https://api-testnet.polygonscan.com";
              case "optimism":
                return "https://api-optimistic.etherscan.io";
              case "optimism-goerli":
                return "https://api-goerli-optimistic.etherscan.io";
            }
            assertArgument(
              false,
              "unsupported network",
              "network",
              this.network
            );
          }
          getUrl(module, params) {
            const query = Object.keys(params).reduce((accum, key) => {
              const value = params[key];
              if (value != null) {
                accum += `&${key}=${value}`;
              }
              return accum;
            }, "");
            const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
            return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;
          }
          getPostUrl() {
            return `${this.getBaseUrl()}/api`;
          }
          getPostData(module, params) {
            params.module = module;
            params.apikey = this.apiKey;
            return params;
          }
          async detectNetwork() {
            return this.network;
          }
          async fetch(module, params, post) {
            const id = nextId++;
            const url = post ? this.getPostUrl() : this.getUrl(module, params);
            const payload = post ? this.getPostData(module, params) : null;
            this.emit("debug", {
              action: "sendRequest",
              id: id,
              url: url,
              payload: payload,
            });
            const request = new FetchRequest(url);
            request.setThrottleParams({ slotInterval: 1e3 });
            request.retryFunc = (req, resp, attempt) => {
              if (this.isCommunityResource()) {
                showThrottleMessage("Etherscan");
              }
              return Promise.resolve(true);
            };
            request.processFunc = async (request, response) => {
              const result = response.hasBody()
                ? JSON.parse(toUtf8String(response.body))
                : {};
              const throttle =
                (typeof result.result === "string" ? result.result : "")
                  .toLowerCase()
                  .indexOf("rate limit") >= 0;
              if (module === "proxy") {
                if (
                  result &&
                  result.status == 0 &&
                  result.message == "NOTOK" &&
                  throttle
                ) {
                  this.emit("debug", {
                    action: "receiveError",
                    id: id,
                    reason: "proxy-NOTOK",
                    error: result,
                  });
                  response.throwThrottleError(result.result, THROTTLE);
                }
              } else {
                if (throttle) {
                  this.emit("debug", {
                    action: "receiveError",
                    id: id,
                    reason: "null result",
                    error: result.result,
                  });
                  response.throwThrottleError(result.result, THROTTLE);
                }
              }
              return response;
            };
            if (payload) {
              request.setHeader(
                "content-type",
                "application/x-www-form-urlencoded; charset=UTF-8"
              );
              request.body = Object.keys(payload)
                .map((k) => `${k}=${payload[k]}`)
                .join("&");
            }
            const response = await request.send();
            try {
              response.assertOk();
            } catch (error) {
              this.emit("debug", {
                action: "receiveError",
                id: id,
                error: error,
                reason: "assertOk",
              });
              assert(false, "response error", "SERVER_ERROR", {
                request: request,
                response: response,
              });
            }
            if (!response.hasBody()) {
              this.emit("debug", {
                action: "receiveError",
                id: id,
                error: "missing body",
                reason: "null body",
              });
              assert(false, "missing response", "SERVER_ERROR", {
                request: request,
                response: response,
              });
            }
            const result = JSON.parse(toUtf8String(response.body));
            if (module === "proxy") {
              if (result.jsonrpc != "2.0") {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result,
                  reason: "invalid JSON-RPC",
                });
                assert(
                  false,
                  "invalid JSON-RPC response (missing jsonrpc='2.0')",
                  "SERVER_ERROR",
                  {
                    request: request,
                    response: response,
                    info: { result: result },
                  }
                );
              }
              if (result.error) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result,
                  reason: "JSON-RPC error",
                });
                assert(false, "error response", "SERVER_ERROR", {
                  request: request,
                  response: response,
                  info: { result: result },
                });
              }
              this.emit("debug", {
                action: "receiveRequest",
                id: id,
                result: result,
              });
              return result.result;
            } else {
              if (
                result.status == 0 &&
                (result.message === "No records found" ||
                  result.message === "No transactions found")
              ) {
                this.emit("debug", {
                  action: "receiveRequest",
                  id: id,
                  result: result,
                });
                return result.result;
              }
              if (
                result.status != 1 ||
                (typeof result.message === "string" &&
                  !result.message.match(/^OK/))
              ) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result,
                });
                assert(false, "error response", "SERVER_ERROR", {
                  request: request,
                  response: response,
                  info: { result: result },
                });
              }
              this.emit("debug", {
                action: "receiveRequest",
                id: id,
                result: result,
              });
              return result.result;
            }
          }
          _getTransactionPostData(transaction) {
            const result = {};
            for (let key in transaction) {
              if (skipKeys.indexOf(key) >= 0) {
                continue;
              }
              if (transaction[key] == null) {
                continue;
              }
              let value = transaction[key];
              if (key === "type" && value === 0) {
                continue;
              }
              if (key === "blockTag" && value === "latest") {
                continue;
              }
              if (
                {
                  type: true,
                  gasLimit: true,
                  gasPrice: true,
                  maxFeePerGs: true,
                  maxPriorityFeePerGas: true,
                  nonce: true,
                  value: true,
                }[key]
              ) {
                value = toQuantity(value);
              } else if (key === "accessList") {
                value =
                  "[" +
                  accessListify(value)
                    .map((set) => {
                      return `{address:"${
                        set.address
                      }",storageKeys:["${set.storageKeys.join('","')}"]}`;
                    })
                    .join(",") +
                  "]";
              } else {
                value = hexlify(value);
              }
              result[key] = value;
            }
            return result;
          }
          _checkError(req, error, transaction) {
            let message = "";
            if (isError(error, "SERVER_ERROR")) {
              try {
                message = error.info.result.error.message;
              } catch (e) {}
              if (!message) {
                try {
                  message = error.info.message;
                } catch (e) {}
              }
            }
            if (req.method === "estimateGas") {
              if (
                !message.match(/revert/i) &&
                message.match(/insufficient funds/i)
              ) {
                assert(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
                  transaction: req.transaction,
                });
              }
            }
            if (req.method === "call" || req.method === "estimateGas") {
              if (message.match(/execution reverted/i)) {
                let data = "";
                try {
                  data = error.info.result.error.data;
                } catch (error) {}
                const e = AbiCoder.getBuiltinCallException(
                  req.method,
                  req.transaction,
                  data
                );
                e.info = { request: req, error: error };
                throw e;
              }
            }
            if (message) {
              if (req.method === "broadcastTransaction") {
                const transaction = Transaction.from(req.signedTransaction);
                if (
                  message.match(/replacement/i) &&
                  message.match(/underpriced/i)
                ) {
                  assert(
                    false,
                    "replacement fee too low",
                    "REPLACEMENT_UNDERPRICED",
                    { transaction: transaction }
                  );
                }
                if (message.match(/insufficient funds/)) {
                  assert(
                    false,
                    "insufficient funds for intrinsic transaction cost",
                    "INSUFFICIENT_FUNDS",
                    { transaction: transaction }
                  );
                }
                if (
                  message.match(
                    /same hash was already imported|transaction nonce is too low|nonce too low/
                  )
                ) {
                  assert(
                    false,
                    "nonce has already been used",
                    "NONCE_EXPIRED",
                    { transaction: transaction }
                  );
                }
              }
            }
            throw error;
          }
          async _detectNetwork() {
            return this.network;
          }
          async _perform(req) {
            switch (req.method) {
              case "chainId":
                return this.network.chainId;
              case "getBlockNumber":
                return this.fetch("proxy", { action: "eth_blockNumber" });
              case "getGasPrice":
                return this.fetch("proxy", { action: "eth_gasPrice" });
              case "getPriorityFee":
                if (this.network.name === "mainnet") {
                  return "1000000000";
                } else if (this.network.name === "optimism") {
                  return "1000000";
                } else {
                  throw new Error("fallback onto the AbstractProvider default");
                }
              case "getBalance":
                return this.fetch("account", {
                  action: "balance",
                  address: req.address,
                  tag: req.blockTag,
                });
              case "getTransactionCount":
                return this.fetch("proxy", {
                  action: "eth_getTransactionCount",
                  address: req.address,
                  tag: req.blockTag,
                });
              case "getCode":
                return this.fetch("proxy", {
                  action: "eth_getCode",
                  address: req.address,
                  tag: req.blockTag,
                });
              case "getStorage":
                return this.fetch("proxy", {
                  action: "eth_getStorageAt",
                  address: req.address,
                  position: req.position,
                  tag: req.blockTag,
                });
              case "broadcastTransaction":
                return this.fetch(
                  "proxy",
                  {
                    action: "eth_sendRawTransaction",
                    hex: req.signedTransaction,
                  },
                  true
                ).catch((error) => {
                  return this._checkError(req, error, req.signedTransaction);
                });
              case "getBlock":
                if ("blockTag" in req) {
                  return this.fetch("proxy", {
                    action: "eth_getBlockByNumber",
                    tag: req.blockTag,
                    boolean: req.includeTransactions ? "true" : "false",
                  });
                }
                assert(
                  false,
                  "getBlock by blockHash not supported by Etherscan",
                  "UNSUPPORTED_OPERATION",
                  { operation: "getBlock(blockHash)" }
                );
              case "getTransaction":
                return this.fetch("proxy", {
                  action: "eth_getTransactionByHash",
                  txhash: req.hash,
                });
              case "getTransactionReceipt":
                return this.fetch("proxy", {
                  action: "eth_getTransactionReceipt",
                  txhash: req.hash,
                });
              case "call": {
                if (req.blockTag !== "latest") {
                  throw new Error(
                    "EtherscanProvider does not support blockTag for call"
                  );
                }
                const postData = this._getTransactionPostData(req.transaction);
                postData.module = "proxy";
                postData.action = "eth_call";
                try {
                  return await this.fetch("proxy", postData, true);
                } catch (error) {
                  return this._checkError(req, error, req.transaction);
                }
              }
              case "estimateGas": {
                const postData = this._getTransactionPostData(req.transaction);
                postData.module = "proxy";
                postData.action = "eth_estimateGas";
                try {
                  return await this.fetch("proxy", postData, true);
                } catch (error) {
                  return this._checkError(req, error, req.transaction);
                }
              }
            }
            return super._perform(req);
          }
          async getNetwork() {
            return this.network;
          }
          async getEtherPrice() {
            if (this.network.name !== "mainnet") {
              return 0;
            }
            return parseFloat(
              (await this.fetch("stats", { action: "ethprice" })).ethusd
            );
          }
          async getContract(_address) {
            let address = this._getAddress(_address);
            if (isPromise(address)) {
              address = await address;
            }
            try {
              const resp = await this.fetch("contract", {
                action: "getabi",
                address: address,
              });
              const abi = JSON.parse(resp);
              return new Contract(address, abi, this);
            } catch (error) {
              return null;
            }
          }
          isCommunityResource() {
            return this.apiKey == null;
          }
        }
        function getGlobal() {
          if (typeof self !== "undefined") {
            return self;
          }
          if (typeof window !== "undefined") {
            return window;
          }
          if (typeof global !== "undefined") {
            return global;
          }
          throw new Error("unable to locate global object");
        }
        const _WebSocket = getGlobal().WebSocket;
        class SocketSubscriber {
          #provider;
          #filter;
          get filter() {
            return JSON.parse(this.#filter);
          }
          #filterId;
          #paused;
          #emitPromise;
          constructor(provider, filter) {
            this.#provider = provider;
            this.#filter = JSON.stringify(filter);
            this.#filterId = null;
            this.#paused = null;
            this.#emitPromise = null;
          }
          start() {
            this.#filterId = this.#provider
              .send("eth_subscribe", this.filter)
              .then((filterId) => {
                this.#provider._register(filterId, this);
                return filterId;
              });
          }
          stop() {
            this.#filterId.then((filterId) => {
              this.#provider.send("eth_unsubscribe", [filterId]);
            });
            this.#filterId = null;
          }
          pause(dropWhilePaused) {
            assert(
              dropWhilePaused,
              "preserve logs while paused not supported by SocketSubscriber yet",
              "UNSUPPORTED_OPERATION",
              { operation: "pause(false)" }
            );
            this.#paused = !!dropWhilePaused;
          }
          resume() {
            this.#paused = null;
          }
          _handleMessage(message) {
            if (this.#filterId == null) {
              return;
            }
            if (this.#paused === null) {
              let emitPromise = this.#emitPromise;
              if (emitPromise == null) {
                emitPromise = this._emit(this.#provider, message);
              } else {
                emitPromise = emitPromise.then(async () => {
                  await this._emit(this.#provider, message);
                });
              }
              this.#emitPromise = emitPromise.then(() => {
                if (this.#emitPromise === emitPromise) {
                  this.#emitPromise = null;
                }
              });
            }
          }
          async _emit(provider, message) {
            throw new Error("sub-classes must implemente this; _emit");
          }
        }
        class SocketBlockSubscriber extends SocketSubscriber {
          constructor(provider) {
            super(provider, ["newHeads"]);
          }
          async _emit(provider, message) {
            provider.emit("block", parseInt(message.number));
          }
        }
        class SocketPendingSubscriber extends SocketSubscriber {
          constructor(provider) {
            super(provider, ["newPendingTransactions"]);
          }
          async _emit(provider, message) {
            provider.emit("pending", message);
          }
        }
        class SocketEventSubscriber extends SocketSubscriber {
          #logFilter;
          get logFilter() {
            return JSON.parse(this.#logFilter);
          }
          constructor(provider, filter) {
            super(provider, ["logs", filter]);
            this.#logFilter = JSON.stringify(filter);
          }
          async _emit(provider, message) {
            provider.emit(
              this.logFilter,
              provider._wrapLog(message, provider._network)
            );
          }
        }
        class SocketProvider extends JsonRpcApiProvider {
          #callbacks;
          #subs;
          #pending;
          constructor(network, _options) {
            const options = Object.assign({}, _options != null ? _options : {});
            assertArgument(
              options.batchMaxCount == null || options.batchMaxCount === 1,
              "sockets-based providers do not support batches",
              "options.batchMaxCount",
              _options
            );
            options.batchMaxCount = 1;
            if (options.staticNetwork == null) {
              options.staticNetwork = true;
            }
            super(network, options);
            this.#callbacks = new Map();
            this.#subs = new Map();
            this.#pending = new Map();
          }
          _getSubscriber(sub) {
            switch (sub.type) {
              case "close":
                return new UnmanagedSubscriber("close");
              case "block":
                return new SocketBlockSubscriber(this);
              case "pending":
                return new SocketPendingSubscriber(this);
              case "event":
                return new SocketEventSubscriber(this, sub.filter);
              case "orphan":
                if (sub.filter.orphan === "drop-log") {
                  return new UnmanagedSubscriber("drop-log");
                }
            }
            return super._getSubscriber(sub);
          }
          _register(filterId, subscriber) {
            this.#subs.set(filterId, subscriber);
            const pending = this.#pending.get(filterId);
            if (pending) {
              for (const message of pending) {
                subscriber._handleMessage(message);
              }
              this.#pending.delete(filterId);
            }
          }
          async _send(payload) {
            assertArgument(
              !Array.isArray(payload),
              "WebSocket does not support batch send",
              "payload",
              payload
            );
            const promise = new Promise((resolve, reject) => {
              this.#callbacks.set(payload.id, {
                payload: payload,
                resolve: resolve,
                reject: reject,
              });
            });
            await this._waitUntilReady();
            await this._write(JSON.stringify(payload));
            return [await promise];
          }
          async _processMessage(message) {
            const result = JSON.parse(message);
            if (result && typeof result === "object" && "id" in result) {
              const callback = this.#callbacks.get(result.id);
              if (callback == null) {
                this.emit(
                  "error",
                  makeError("received result for unknown id", "UNKNOWN_ERROR", {
                    reasonCode: "UNKNOWN_ID",
                    result: result,
                  })
                );
                return;
              }
              this.#callbacks.delete(result.id);
              callback.resolve(result);
            } else if (result && result.method === "eth_subscription") {
              const filterId = result.params.subscription;
              const subscriber = this.#subs.get(filterId);
              if (subscriber) {
                subscriber._handleMessage(result.params.result);
              } else {
                let pending = this.#pending.get(filterId);
                if (pending == null) {
                  pending = [];
                  this.#pending.set(filterId, pending);
                }
                pending.push(result.params.result);
              }
            } else {
              this.emit(
                "error",
                makeError("received unexpected message", "UNKNOWN_ERROR", {
                  reasonCode: "UNEXPECTED_MESSAGE",
                  result: result,
                })
              );
              return;
            }
          }
          async _write(message) {
            throw new Error("sub-classes must override this");
          }
        }
        class WebSocketProvider extends SocketProvider {
          #connect;
          #websocket;
          get websocket() {
            if (this.#websocket == null) {
              throw new Error("websocket closed");
            }
            return this.#websocket;
          }
          constructor(url, network, options) {
            super(network, options);
            if (typeof url === "string") {
              this.#connect = () => {
                return new _WebSocket(url);
              };
              this.#websocket = this.#connect();
            } else if (typeof url === "function") {
              this.#connect = url;
              this.#websocket = url();
            } else {
              this.#connect = null;
              this.#websocket = url;
            }
            this.websocket.onopen = async () => {
              try {
                await this._start();
                this.resume();
              } catch (error) {
                console.log("failed to start WebsocketProvider", error);
              }
            };
            this.websocket.onmessage = (message) => {
              this._processMessage(message.data);
            };
          }
          async _write(message) {
            this.websocket.send(message);
          }
          async destroy() {
            if (this.#websocket != null) {
              this.#websocket.close();
              this.#websocket = null;
            }
            super.destroy();
          }
        }
        const defaultProjectId = "84842078b09946638c03157f83405213";
        function getHost$2(name) {
          switch (name) {
            case "mainnet":
              return "mainnet.infura.io";
            case "goerli":
              return "goerli.infura.io";
            case "sepolia":
              return "sepolia.infura.io";
            case "arbitrum":
              return "arbitrum-mainnet.infura.io";
            case "arbitrum-goerli":
              return "arbitrum-goerli.infura.io";
            case "arbitrum-sepolia":
              return "arbitrum-sepolia.infura.io";
            case "base":
              return "base-mainnet.infura.io";
            case "base-goerlia":
              return "base-goerli.infura.io";
            case "base-sepolia":
              return "base-sepolia.infura.io";
            case "bnb":
              return "bnbsmartchain-mainnet.infura.io";
            case "bnbt":
              return "bnbsmartchain-testnet.infura.io";
            case "linea":
              return "linea-mainnet.infura.io";
            case "linea-goerli":
              return "linea-goerli.infura.io";
            case "matic":
              return "polygon-mainnet.infura.io";
            case "matic-mumbai":
              return "polygon-mumbai.infura.io";
            case "optimism":
              return "optimism-mainnet.infura.io";
            case "optimism-goerli":
              return "optimism-goerli.infura.io";
            case "optimism-sepolia":
              return "optimism-sepolia.infura.io";
          }
          assertArgument(false, "unsupported network", "network", name);
        }
        class InfuraWebSocketProvider extends WebSocketProvider {
          projectId;
          projectSecret;
          constructor(network, projectId) {
            const provider = new InfuraProvider(network, projectId);
            const req = provider._getConnection();
            assert(
              !req.credentials,
              "INFURA WebSocket project secrets unsupported",
              "UNSUPPORTED_OPERATION",
              { operation: "InfuraProvider.getWebSocketProvider()" }
            );
            const url = req.url
              .replace(/^http/i, "ws")
              .replace("/v3/", "/ws/v3/");
            super(url, network);
            defineProperties(this, {
              projectId: provider.projectId,
              projectSecret: provider.projectSecret,
            });
          }
          isCommunityResource() {
            return this.projectId === defaultProjectId;
          }
        }
        class InfuraProvider extends JsonRpcProvider {
          projectId;
          projectSecret;
          constructor(_network, projectId, projectSecret) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            if (projectId == null) {
              projectId = defaultProjectId;
            }
            if (projectSecret == null) {
              projectSecret = null;
            }
            const request = InfuraProvider.getRequest(
              network,
              projectId,
              projectSecret
            );
            super(request, network, { staticNetwork: network });
            defineProperties(this, {
              projectId: projectId,
              projectSecret: projectSecret,
            });
          }
          _getProvider(chainId) {
            try {
              return new InfuraProvider(
                chainId,
                this.projectId,
                this.projectSecret
              );
            } catch (error) {}
            return super._getProvider(chainId);
          }
          isCommunityResource() {
            return this.projectId === defaultProjectId;
          }
          static getWebSocketProvider(network, projectId) {
            return new InfuraWebSocketProvider(network, projectId);
          }
          static getRequest(network, projectId, projectSecret) {
            if (projectId == null) {
              projectId = defaultProjectId;
            }
            if (projectSecret == null) {
              projectSecret = null;
            }
            const request = new FetchRequest(
              `https:/\/${getHost$2(network.name)}/v3/${projectId}`
            );
            request.allowGzip = true;
            if (projectSecret) {
              request.setCredentials("", projectSecret);
            }
            if (projectId === defaultProjectId) {
              request.retryFunc = async (request, response, attempt) => {
                showThrottleMessage("InfuraProvider");
                return true;
              };
            }
            return request;
          }
        }
        const defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
        function getHost$1(name) {
          switch (name) {
            case "mainnet":
              return "ethers.quiknode.pro";
            case "goerli":
              return "ethers.ethereum-goerli.quiknode.pro";
            case "sepolia":
              return "ethers.ethereum-sepolia.quiknode.pro";
            case "holesky":
              return "ethers.ethereum-holesky.quiknode.pro";
            case "arbitrum":
              return "ethers.arbitrum-mainnet.quiknode.pro";
            case "arbitrum-goerli":
              return "ethers.arbitrum-goerli.quiknode.pro";
            case "arbitrum-sepolia":
              return "ethers.arbitrum-sepolia.quiknode.pro";
            case "base":
              return "ethers.base-mainnet.quiknode.pro";
            case "base-goerli":
              return "ethers.base-goerli.quiknode.pro";
            case "base-spolia":
              return "ethers.base-sepolia.quiknode.pro";
            case "bnb":
              return "ethers.bsc.quiknode.pro";
            case "bnbt":
              return "ethers.bsc-testnet.quiknode.pro";
            case "matic":
              return "ethers.matic.quiknode.pro";
            case "matic-mumbai":
              return "ethers.matic-testnet.quiknode.pro";
            case "optimism":
              return "ethers.optimism.quiknode.pro";
            case "optimism-goerli":
              return "ethers.optimism-goerli.quiknode.pro";
            case "optimism-sepolia":
              return "ethers.optimism-sepolia.quiknode.pro";
            case "xdai":
              return "ethers.xdai.quiknode.pro";
          }
          assertArgument(false, "unsupported network", "network", name);
        }
        class QuickNodeProvider extends JsonRpcProvider {
          token;
          constructor(_network, token) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            if (token == null) {
              token = defaultToken;
            }
            const request = QuickNodeProvider.getRequest(network, token);
            super(request, network, { staticNetwork: network });
            defineProperties(this, { token: token });
          }
          _getProvider(chainId) {
            try {
              return new QuickNodeProvider(chainId, this.token);
            } catch (error) {}
            return super._getProvider(chainId);
          }
          isCommunityResource() {
            return this.token === defaultToken;
          }
          static getRequest(network, token) {
            if (token == null) {
              token = defaultToken;
            }
            const request = new FetchRequest(
              `https:/\/${getHost$1(network.name)}/${token}`
            );
            request.allowGzip = true;
            if (token === defaultToken) {
              request.retryFunc = async (request, response, attempt) => {
                showThrottleMessage("QuickNodeProvider");
                return true;
              };
            }
            return request;
          }
        }
        const BN_1 = BigInt("1");
        const BN_2 = BigInt("2");
        function shuffle(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
          }
        }
        function stall$2(duration) {
          return new Promise((resolve) => {
            setTimeout(resolve, duration);
          });
        }
        function getTime() {
          return new Date().getTime();
        }
        function stringify(value) {
          return JSON.stringify(value, (key, value) => {
            if (typeof value === "bigint") {
              return { type: "bigint", value: value.toString() };
            }
            return value;
          });
        }
        const defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
        const defaultState = {
          blockNumber: -2,
          requests: 0,
          lateResponses: 0,
          errorResponses: 0,
          outOfSync: -1,
          unsupportedEvents: 0,
          rollingDuration: 0,
          score: 0,
          _network: null,
          _updateNumber: null,
          _totalTime: 0,
          _lastFatalError: null,
          _lastFatalErrorTimestamp: 0,
        };
        async function waitForSync(config, blockNumber) {
          while (config.blockNumber < 0 || config.blockNumber < blockNumber) {
            if (!config._updateNumber) {
              config._updateNumber = (async () => {
                try {
                  const blockNumber = await config.provider.getBlockNumber();
                  if (blockNumber > config.blockNumber) {
                    config.blockNumber = blockNumber;
                  }
                } catch (error) {
                  config.blockNumber = -2;
                  config._lastFatalError = error;
                  config._lastFatalErrorTimestamp = getTime();
                }
                config._updateNumber = null;
              })();
            }
            await config._updateNumber;
            config.outOfSync++;
            if (config._lastFatalError) {
              break;
            }
          }
        }
        function _normalize(value) {
          if (value == null) {
            return "null";
          }
          if (Array.isArray(value)) {
            return "[" + value.map(_normalize).join(",") + "]";
          }
          if (typeof value === "object" && typeof value.toJSON === "function") {
            return _normalize(value.toJSON());
          }
          switch (typeof value) {
            case "boolean":
            case "symbol":
              return value.toString();
            case "bigint":
            case "number":
              return BigInt(value).toString();
            case "string":
              return JSON.stringify(value);
            case "object": {
              const keys = Object.keys(value);
              keys.sort();
              return (
                "{" +
                keys
                  .map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`)
                  .join(",") +
                "}"
              );
            }
          }
          console.log("Could not serialize", value);
          throw new Error("Hmm...");
        }
        function normalizeResult(value) {
          if ("error" in value) {
            const error = value.error;
            return { tag: _normalize(error), value: error };
          }
          const result = value.result;
          return { tag: _normalize(result), value: result };
        }
        function checkQuorum(quorum, results) {
          const tally = new Map();
          for (const { value, tag, weight } of results) {
            const t = tally.get(tag) || { value: value, weight: 0 };
            t.weight += weight;
            tally.set(tag, t);
          }
          let best = null;
          for (const r of tally.values()) {
            if (r.weight >= quorum && (!best || r.weight > best.weight)) {
              best = r;
            }
          }
          if (best) {
            return best.value;
          }
          return undefined;
        }
        function getMedian(quorum, results) {
          let resultWeight = 0;
          const errorMap = new Map();
          let bestError = null;
          const values = [];
          for (const { value, tag, weight } of results) {
            if (value instanceof Error) {
              const e = errorMap.get(tag) || { value: value, weight: 0 };
              e.weight += weight;
              errorMap.set(tag, e);
              if (bestError == null || e.weight > bestError.weight) {
                bestError = e;
              }
            } else {
              values.push(BigInt(value));
              resultWeight += weight;
            }
          }
          if (resultWeight < quorum) {
            if (bestError && bestError.weight >= quorum) {
              return bestError.value;
            }
            return undefined;
          }
          values.sort((a, b) => (a < b ? -1 : b > a ? 1 : 0));
          const mid = Math.floor(values.length / 2);
          if (values.length % 2) {
            return values[mid];
          }
          return (values[mid - 1] + values[mid] + BN_1) / BN_2;
        }
        function getAnyResult(quorum, results) {
          const result = checkQuorum(quorum, results);
          if (result !== undefined) {
            return result;
          }
          for (const r of results) {
            if (r.value) {
              return r.value;
            }
          }
          return undefined;
        }
        function getFuzzyMode(quorum, results) {
          if (quorum === 1) {
            return getNumber(getMedian(quorum, results), "%internal");
          }
          const tally = new Map();
          const add = (result, weight) => {
            const t = tally.get(result) || { result: result, weight: 0 };
            t.weight += weight;
            tally.set(result, t);
          };
          for (const { weight, value } of results) {
            const r = getNumber(value);
            add(r - 1, weight);
            add(r, weight);
            add(r + 1, weight);
          }
          let bestWeight = 0;
          let bestResult = undefined;
          for (const { weight, result } of tally.values()) {
            if (
              weight >= quorum &&
              (weight > bestWeight ||
                (bestResult != null &&
                  weight === bestWeight &&
                  result > bestResult))
            ) {
              bestWeight = weight;
              bestResult = result;
            }
          }
          return bestResult;
        }
        class FallbackProvider extends AbstractProvider {
          quorum;
          eventQuorum;
          eventWorkers;
          #configs;
          #height;
          #initialSyncPromise;
          constructor(providers, network, options) {
            super(network, options);
            this.#configs = providers.map((p) => {
              if (p instanceof AbstractProvider) {
                return Object.assign(
                  { provider: p },
                  defaultConfig,
                  defaultState
                );
              } else {
                return Object.assign({}, defaultConfig, p, defaultState);
              }
            });
            this.#height = -2;
            this.#initialSyncPromise = null;
            if (options && options.quorum != null) {
              this.quorum = options.quorum;
            } else {
              this.quorum = Math.ceil(
                this.#configs.reduce((accum, config) => {
                  accum += config.weight;
                  return accum;
                }, 0) / 2
              );
            }
            this.eventQuorum = 1;
            this.eventWorkers = 1;
            assertArgument(
              this.quorum <= this.#configs.reduce((a, c) => a + c.weight, 0),
              "quorum exceed provider wieght",
              "quorum",
              this.quorum
            );
          }
          get providerConfigs() {
            return this.#configs.map((c) => {
              const result = Object.assign({}, c);
              for (const key in result) {
                if (key[0] === "_") {
                  delete result[key];
                }
              }
              return result;
            });
          }
          async _detectNetwork() {
            return Network.from(
              getBigInt(await this._perform({ method: "chainId" }))
            );
          }
          async _translatePerform(provider, req) {
            switch (req.method) {
              case "broadcastTransaction":
                return await provider.broadcastTransaction(
                  req.signedTransaction
                );
              case "call":
                return await provider.call(
                  Object.assign({}, req.transaction, { blockTag: req.blockTag })
                );
              case "chainId":
                return (await provider.getNetwork()).chainId;
              case "estimateGas":
                return await provider.estimateGas(req.transaction);
              case "getBalance":
                return await provider.getBalance(req.address, req.blockTag);
              case "getBlock": {
                const block = "blockHash" in req ? req.blockHash : req.blockTag;
                return await provider.getBlock(block, req.includeTransactions);
              }
              case "getBlockNumber":
                return await provider.getBlockNumber();
              case "getCode":
                return await provider.getCode(req.address, req.blockTag);
              case "getGasPrice":
                return (await provider.getFeeData()).gasPrice;
              case "getPriorityFee":
                return (await provider.getFeeData()).maxPriorityFeePerGas;
              case "getLogs":
                return await provider.getLogs(req.filter);
              case "getStorage":
                return await provider.getStorage(
                  req.address,
                  req.position,
                  req.blockTag
                );
              case "getTransaction":
                return await provider.getTransaction(req.hash);
              case "getTransactionCount":
                return await provider.getTransactionCount(
                  req.address,
                  req.blockTag
                );
              case "getTransactionReceipt":
                return await provider.getTransactionReceipt(req.hash);
              case "getTransactionResult":
                return await provider.getTransactionResult(req.hash);
            }
          }
          #getNextConfig(running) {
            const configs = Array.from(running).map((r) => r.config);
            const allConfigs = this.#configs.slice();
            shuffle(allConfigs);
            allConfigs.sort((a, b) => a.priority - b.priority);
            for (const config of allConfigs) {
              if (config._lastFatalError) {
                continue;
              }
              if (configs.indexOf(config) === -1) {
                return config;
              }
            }
            return null;
          }
          #addRunner(running, req) {
            const config = this.#getNextConfig(running);
            if (config == null) {
              return null;
            }
            const runner = {
              config: config,
              result: null,
              didBump: false,
              perform: null,
              staller: null,
            };
            const now = getTime();
            runner.perform = (async () => {
              try {
                config.requests++;
                const result = await this._translatePerform(
                  config.provider,
                  req
                );
                runner.result = { result: result };
              } catch (error) {
                config.errorResponses++;
                runner.result = { error: error };
              }
              const dt = getTime() - now;
              config._totalTime += dt;
              config.rollingDuration =
                0.95 * config.rollingDuration + 0.05 * dt;
              runner.perform = null;
            })();
            runner.staller = (async () => {
              await stall$2(config.stallTimeout);
              runner.staller = null;
            })();
            running.add(runner);
            return runner;
          }
          async #initialSync() {
            let initialSync = this.#initialSyncPromise;
            if (!initialSync) {
              const promises = [];
              this.#configs.forEach((config) => {
                promises.push(
                  (async () => {
                    await waitForSync(config, 0);
                    if (!config._lastFatalError) {
                      config._network = await config.provider.getNetwork();
                    }
                  })()
                );
              });
              this.#initialSyncPromise = initialSync = (async () => {
                await Promise.all(promises);
                let chainId = null;
                for (const config of this.#configs) {
                  if (config._lastFatalError) {
                    continue;
                  }
                  const network = config._network;
                  if (chainId == null) {
                    chainId = network.chainId;
                  } else if (network.chainId !== chainId) {
                    assert(
                      false,
                      "cannot mix providers on different networks",
                      "UNSUPPORTED_OPERATION",
                      { operation: "new FallbackProvider" }
                    );
                  }
                }
              })();
            }
            await initialSync;
          }
          async #checkQuorum(running, req) {
            const results = [];
            for (const runner of running) {
              if (runner.result != null) {
                const { tag, value } = normalizeResult(runner.result);
                results.push({
                  tag: tag,
                  value: value,
                  weight: runner.config.weight,
                });
              }
            }
            if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {
              return undefined;
            }
            switch (req.method) {
              case "getBlockNumber": {
                if (this.#height === -2) {
                  this.#height = Math.ceil(
                    getNumber(
                      getMedian(
                        this.quorum,
                        this.#configs
                          .filter((c) => !c._lastFatalError)
                          .map((c) => ({
                            value: c.blockNumber,
                            tag: getNumber(c.blockNumber).toString(),
                            weight: c.weight,
                          }))
                      )
                    )
                  );
                }
                const mode = getFuzzyMode(this.quorum, results);
                if (mode === undefined) {
                  return undefined;
                }
                if (mode > this.#height) {
                  this.#height = mode;
                }
                return this.#height;
              }
              case "getGasPrice":
              case "getPriorityFee":
              case "estimateGas":
                return getMedian(this.quorum, results);
              case "getBlock":
                if ("blockTag" in req && req.blockTag === "pending") {
                  return getAnyResult(this.quorum, results);
                }
                return checkQuorum(this.quorum, results);
              case "call":
              case "chainId":
              case "getBalance":
              case "getTransactionCount":
              case "getCode":
              case "getStorage":
              case "getTransaction":
              case "getTransactionReceipt":
              case "getLogs":
                return checkQuorum(this.quorum, results);
              case "broadcastTransaction":
                return getAnyResult(this.quorum, results);
            }
            assert(false, "unsupported method", "UNSUPPORTED_OPERATION", {
              operation: `_perform(${stringify(req.method)})`,
            });
          }
          async #waitForQuorum(running, req) {
            if (running.size === 0) {
              throw new Error("no runners?!");
            }
            const interesting = [];
            let newRunners = 0;
            for (const runner of running) {
              if (runner.perform) {
                interesting.push(runner.perform);
              }
              if (runner.staller) {
                interesting.push(runner.staller);
                continue;
              }
              if (runner.didBump) {
                continue;
              }
              runner.didBump = true;
              newRunners++;
            }
            const value = await this.#checkQuorum(running, req);
            if (value !== undefined) {
              if (value instanceof Error) {
                throw value;
              }
              return value;
            }
            for (let i = 0; i < newRunners; i++) {
              this.#addRunner(running, req);
            }
            assert(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
              request: "%sub-requests",
              info: {
                request: req,
                results: Array.from(running).map((r) => stringify(r.result)),
              },
            });
            await Promise.race(interesting);
            return await this.#waitForQuorum(running, req);
          }
          async _perform(req) {
            if (req.method === "broadcastTransaction") {
              const results = this.#configs.map((c) => null);
              const broadcasts = this.#configs.map(
                async ({ provider, weight }, index) => {
                  try {
                    const result = await provider._perform(req);
                    results[index] = Object.assign(
                      normalizeResult({ result: result }),
                      { weight: weight }
                    );
                  } catch (error) {
                    results[index] = Object.assign(
                      normalizeResult({ error: error }),
                      { weight: weight }
                    );
                  }
                }
              );
              while (true) {
                const done = results.filter((r) => r != null);
                for (const { value } of done) {
                  if (!(value instanceof Error)) {
                    return value;
                  }
                }
                const result = checkQuorum(
                  this.quorum,
                  results.filter((r) => r != null)
                );
                if (isError(result, "INSUFFICIENT_FUNDS")) {
                  throw result;
                }
                const waiting = broadcasts.filter((b, i) => results[i] == null);
                if (waiting.length === 0) {
                  break;
                }
                await Promise.race(waiting);
              }
              const result = getAnyResult(this.quorum, results);
              assert(
                result !== undefined,
                "problem multi-broadcasting",
                "SERVER_ERROR",
                {
                  request: "%sub-requests",
                  info: { request: req, results: results.map(stringify) },
                }
              );
              if (result instanceof Error) {
                throw result;
              }
              return result;
            }
            await this.#initialSync();
            const running = new Set();
            let inflightQuorum = 0;
            while (true) {
              const runner = this.#addRunner(running, req);
              if (runner == null) {
                break;
              }
              inflightQuorum += runner.config.weight;
              if (inflightQuorum >= this.quorum) {
                break;
              }
            }
            const result = await this.#waitForQuorum(running, req);
            for (const runner of running) {
              if (runner.perform && runner.result == null) {
                runner.config.lateResponses++;
              }
            }
            return result;
          }
          async destroy() {
            for (const { provider } of this.#configs) {
              provider.destroy();
            }
            super.destroy();
          }
        }
        function isWebSocketLike(value) {
          return (
            value &&
            typeof value.send === "function" &&
            typeof value.close === "function"
          );
        }
        const Testnets =
          "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(
            " "
          );
        function getDefaultProvider(network, options) {
          if (options == null) {
            options = {};
          }
          const allowService = (name) => {
            if (options[name] === "-") {
              return false;
            }
            if (typeof options.exclusive === "string") {
              return name === options.exclusive;
            }
            if (Array.isArray(options.exclusive)) {
              return options.exclusive.indexOf(name) !== -1;
            }
            return true;
          };
          if (typeof network === "string" && network.match(/^https?:/)) {
            return new JsonRpcProvider(network);
          }
          if (
            (typeof network === "string" && network.match(/^wss?:/)) ||
            isWebSocketLike(network)
          ) {
            return new WebSocketProvider(network);
          }
          let staticNetwork = null;
          try {
            staticNetwork = Network.from(network);
          } catch (error) {}
          const providers = [];
          if (allowService("publicPolygon") && staticNetwork) {
            if (staticNetwork.name === "matic") {
              providers.push(
                new JsonRpcProvider("https://polygon-rpc.com/", staticNetwork, {
                  staticNetwork: staticNetwork,
                })
              );
            }
          }
          if (allowService("alchemy")) {
            try {
              providers.push(new AlchemyProvider(network, options.alchemy));
            } catch (error) {}
          }
          if (allowService("ankr") && options.ankr != null) {
            try {
              providers.push(new AnkrProvider(network, options.ankr));
            } catch (error) {}
          }
          if (allowService("cloudflare")) {
            try {
              providers.push(new CloudflareProvider(network));
            } catch (error) {}
          }
          if (allowService("etherscan")) {
            try {
              providers.push(new EtherscanProvider(network, options.etherscan));
            } catch (error) {}
          }
          if (allowService("infura")) {
            try {
              let projectId = options.infura;
              let projectSecret = undefined;
              if (typeof projectId === "object") {
                projectSecret = projectId.projectSecret;
                projectId = projectId.projectId;
              }
              providers.push(
                new InfuraProvider(network, projectId, projectSecret)
              );
            } catch (error) {}
          }
          if (allowService("quicknode")) {
            try {
              let token = options.quicknode;
              providers.push(new QuickNodeProvider(network, token));
            } catch (error) {}
          }
          assert(
            providers.length,
            "unsupported default network",
            "UNSUPPORTED_OPERATION",
            { operation: "getDefaultProvider" }
          );
          if (providers.length === 1) {
            return providers[0];
          }
          let quorum = Math.floor(providers.length / 2);
          if (quorum > 2) {
            quorum = 2;
          }
          if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
            quorum = 1;
          }
          if (options && options.quorum) {
            quorum = options.quorum;
          }
          return new FallbackProvider(providers, undefined, { quorum: quorum });
        }
        class NonceManager extends AbstractSigner {
          signer;
          #noncePromise;
          #delta;
          constructor(signer) {
            super(signer.provider);
            defineProperties(this, { signer: signer });
            this.#noncePromise = null;
            this.#delta = 0;
          }
          async getAddress() {
            return this.signer.getAddress();
          }
          connect(provider) {
            return new NonceManager(this.signer.connect(provider));
          }
          async getNonce(blockTag) {
            if (blockTag === "pending") {
              if (this.#noncePromise == null) {
                this.#noncePromise = super.getNonce("pending");
              }
              const delta = this.#delta;
              return (await this.#noncePromise) + delta;
            }
            return super.getNonce(blockTag);
          }
          increment() {
            this.#delta++;
          }
          reset() {
            this.#delta = 0;
            this.#noncePromise = null;
          }
          async sendTransaction(tx) {
            const noncePromise = this.getNonce("pending");
            this.increment();
            tx = await this.signer.populateTransaction(tx);
            tx.nonce = await noncePromise;
            return await this.signer.sendTransaction(tx);
          }
          signTransaction(tx) {
            return this.signer.signTransaction(tx);
          }
          signMessage(message) {
            return this.signer.signMessage(message);
          }
          signTypedData(domain, types, value) {
            return this.signer.signTypedData(domain, types, value);
          }
        }
        class BrowserProvider extends JsonRpcApiPollingProvider {
          #request;
          constructor(ethereum, network) {
            assertArgument(
              ethereum && ethereum.request,
              "invalid EIP-1193 provider",
              "ethereum",
              ethereum
            );
            super(network, { batchMaxCount: 1 });
            this.#request = async (method, params) => {
              const payload = { method: method, params: params };
              this.emit("debug", {
                action: "sendEip1193Request",
                payload: payload,
              });
              try {
                const result = await ethereum.request(payload);
                this.emit("debug", {
                  action: "receiveEip1193Result",
                  result: result,
                });
                return result;
              } catch (e) {
                const error = new Error(e.message);
                error.code = e.code;
                error.data = e.data;
                error.payload = payload;
                this.emit("debug", {
                  action: "receiveEip1193Error",
                  error: error,
                });
                throw error;
              }
            };
          }
          async send(method, params) {
            await this._start();
            return await super.send(method, params);
          }
          async _send(payload) {
            assertArgument(
              !Array.isArray(payload),
              "EIP-1193 does not support batch request",
              "payload",
              payload
            );
            try {
              const result = await this.#request(
                payload.method,
                payload.params || []
              );
              return [{ id: payload.id, result: result }];
            } catch (e) {
              return [
                {
                  id: payload.id,
                  error: { code: e.code, data: e.data, message: e.message },
                },
              ];
            }
          }
          getRpcError(payload, error) {
            error = JSON.parse(JSON.stringify(error));
            switch (error.error.code || -1) {
              case 4001:
                error.error.message = `ethers-user-denied: ${error.error.message}`;
                break;
              case 4200:
                error.error.message = `ethers-unsupported: ${error.error.message}`;
                break;
            }
            return super.getRpcError(payload, error);
          }
          async hasSigner(address) {
            if (address == null) {
              address = 0;
            }
            const accounts = await this.send("eth_accounts", []);
            if (typeof address === "number") {
              return accounts.length > address;
            }
            address = address.toLowerCase();
            return (
              accounts.filter((a) => a.toLowerCase() === address).length !== 0
            );
          }
          async getSigner(address) {
            if (address == null) {
              address = 0;
            }
            if (!(await this.hasSigner(address))) {
              try {
                await this.#request("eth_requestAccounts", []);
              } catch (error) {
                const payload = error.payload;
                throw this.getRpcError(payload, {
                  id: payload.id,
                  error: error,
                });
              }
            }
            return await super.getSigner(address);
          }
        }
        const defaultApplicationId = "62e1ad51b37b8e00394bda3b";
        function getHost(name) {
          switch (name) {
            case "mainnet":
              return "eth-mainnet.gateway.pokt.network";
            case "goerli":
              return "eth-goerli.gateway.pokt.network";
            case "matic":
              return "poly-mainnet.gateway.pokt.network";
            case "matic-mumbai":
              return "polygon-mumbai-rpc.gateway.pokt.network";
          }
          assertArgument(false, "unsupported network", "network", name);
        }
        class PocketProvider extends JsonRpcProvider {
          applicationId;
          applicationSecret;
          constructor(_network, applicationId, applicationSecret) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            if (applicationId == null) {
              applicationId = defaultApplicationId;
            }
            if (applicationSecret == null) {
              applicationSecret = null;
            }
            const options = { staticNetwork: network };
            const request = PocketProvider.getRequest(
              network,
              applicationId,
              applicationSecret
            );
            super(request, network, options);
            defineProperties(this, {
              applicationId: applicationId,
              applicationSecret: applicationSecret,
            });
          }
          _getProvider(chainId) {
            try {
              return new PocketProvider(
                chainId,
                this.applicationId,
                this.applicationSecret
              );
            } catch (error) {}
            return super._getProvider(chainId);
          }
          static getRequest(network, applicationId, applicationSecret) {
            if (applicationId == null) {
              applicationId = defaultApplicationId;
            }
            const request = new FetchRequest(
              `https:/\/${getHost(network.name)}/v1/lb/${applicationId}`
            );
            request.allowGzip = true;
            if (applicationSecret) {
              request.setCredentials("", applicationSecret);
            }
            if (applicationId === defaultApplicationId) {
              request.retryFunc = async (request, response, attempt) => {
                showThrottleMessage("PocketProvider");
                return true;
              };
            }
            return request;
          }
          isCommunityResource() {
            return this.applicationId === defaultApplicationId;
          }
        }
        const IpcSocketProvider = undefined;
        class BaseWallet extends AbstractSigner {
          address;
          #signingKey;
          constructor(privateKey, provider) {
            super(provider);
            assertArgument(
              privateKey && typeof privateKey.sign === "function",
              "invalid private key",
              "privateKey",
              "[ REDACTED ]"
            );
            this.#signingKey = privateKey;
            const address = computeAddress(this.signingKey.publicKey);
            defineProperties(this, { address: address });
          }
          get signingKey() {
            return this.#signingKey;
          }
          get privateKey() {
            return this.signingKey.privateKey;
          }
          async getAddress() {
            return this.address;
          }
          connect(provider) {
            return new BaseWallet(this.#signingKey, provider);
          }
          async signTransaction(tx) {
            const { to, from } = await resolveProperties({
              to: tx.to ? resolveAddress(tx.to, this.provider) : undefined,
              from: tx.from
                ? resolveAddress(tx.from, this.provider)
                : undefined,
            });
            if (to != null) {
              tx.to = to;
            }
            if (from != null) {
              tx.from = from;
            }
            if (tx.from != null) {
              assertArgument(
                getAddress(tx.from) === this.address,
                "transaction from address mismatch",
                "tx.from",
                tx.from
              );
              delete tx.from;
            }
            const btx = Transaction.from(tx);
            btx.signature = this.signingKey.sign(btx.unsignedHash);
            return btx.serialized;
          }
          async signMessage(message) {
            return this.signMessageSync(message);
          }
          signMessageSync(message) {
            return this.signingKey.sign(hashMessage(message)).serialized;
          }
          async signTypedData(domain, types, value) {
            const populated = await TypedDataEncoder.resolveNames(
              domain,
              types,
              value,
              async (name) => {
                assert(
                  this.provider != null,
                  "cannot resolve ENS names without a provider",
                  "UNSUPPORTED_OPERATION",
                  { operation: "resolveName", info: { name: name } }
                );
                const address = await this.provider.resolveName(name);
                assert(
                  address != null,
                  "unconfigured ENS name",
                  "UNCONFIGURED_NAME",
                  { value: name }
                );
                return address;
              }
            );
            return this.signingKey.sign(
              TypedDataEncoder.hash(populated.domain, types, populated.value)
            ).serialized;
          }
        }
        const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
        const Word = /^[a-z]*$/i;
        function unfold(words, sep) {
          let initial = 97;
          return words.reduce((accum, word) => {
            if (word === sep) {
              initial++;
            } else if (word.match(Word)) {
              accum.push(String.fromCharCode(initial) + word);
            } else {
              initial = 97;
              accum.push(word);
            }
            return accum;
          }, []);
        }
        function decode(data, subs) {
          for (let i = subsChrs.length - 1; i >= 0; i--) {
            data = data
              .split(subsChrs[i])
              .join(subs.substring(2 * i, 2 * i + 2));
          }
          const clumps = [];
          const leftover = data.replace(
            /(:|([0-9])|([A-Z][a-z]*))/g,
            (all, item, semi, word) => {
              if (semi) {
                for (let i = parseInt(semi); i >= 0; i--) {
                  clumps.push(";");
                }
              } else {
                clumps.push(item.toLowerCase());
              }
              return "";
            }
          );
          if (leftover) {
            throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
          }
          return unfold(unfold(clumps, ";"), ":");
        }
        function decodeOwl(data) {
          assertArgument(
            data[0] === "0",
            "unsupported auwl data",
            "data",
            data
          );
          return decode(
            data.substring(1 + 2 * subsChrs.length),
            data.substring(1, 1 + 2 * subsChrs.length)
          );
        }
        class Wordlist {
          locale;
          constructor(locale) {
            defineProperties(this, { locale: locale });
          }
          split(phrase) {
            return phrase.toLowerCase().split(/\s+/g);
          }
          join(words) {
            return words.join(" ");
          }
        }
        class WordlistOwl extends Wordlist {
          #data;
          #checksum;
          constructor(locale, data, checksum) {
            super(locale);
            this.#data = data;
            this.#checksum = checksum;
            this.#words = null;
          }
          get _data() {
            return this.#data;
          }
          _decodeWords() {
            return decodeOwl(this.#data);
          }
          #words;
          #loadWords() {
            if (this.#words == null) {
              const words = this._decodeWords();
              const checksum = id(words.join("\n") + "\n");
              if (checksum !== this.#checksum) {
                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
              }
              this.#words = words;
            }
            return this.#words;
          }
          getWord(index) {
            const words = this.#loadWords();
            assertArgument(
              index >= 0 && index < words.length,
              `invalid word index: ${index}`,
              "index",
              index
            );
            return words[index];
          }
          getWordIndex(word) {
            return this.#loadWords().indexOf(word);
          }
        }
        const words =
          "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
        const checksum =
          "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
        let wordlist = null;
        class LangEn extends WordlistOwl {
          constructor() {
            super("en", words, checksum);
          }
          static wordlist() {
            if (wordlist == null) {
              wordlist = new LangEn();
            }
            return wordlist;
          }
        }
        function getUpperMask(bits) {
          return (((1 << bits) - 1) << (8 - bits)) & 255;
        }
        function getLowerMask(bits) {
          return ((1 << bits) - 1) & 255;
        }
        function mnemonicToEntropy(mnemonic, wordlist) {
          assertNormalize("NFKD");
          if (wordlist == null) {
            wordlist = LangEn.wordlist();
          }
          const words = wordlist.split(mnemonic);
          assertArgument(
            words.length % 3 === 0 && words.length >= 12 && words.length <= 24,
            "invalid mnemonic length",
            "mnemonic",
            "[ REDACTED ]"
          );
          const entropy = new Uint8Array(Math.ceil((11 * words.length) / 8));
          let offset = 0;
          for (let i = 0; i < words.length; i++) {
            let index = wordlist.getWordIndex(words[i].normalize("NFKD"));
            assertArgument(
              index >= 0,
              `invalid mnemonic word at index ${i}`,
              "mnemonic",
              "[ REDACTED ]"
            );
            for (let bit = 0; bit < 11; bit++) {
              if (index & (1 << (10 - bit))) {
                entropy[offset >> 3] |= 1 << (7 - (offset % 8));
              }
              offset++;
            }
          }
          const entropyBits = (32 * words.length) / 3;
          const checksumBits = words.length / 3;
          const checksumMask = getUpperMask(checksumBits);
          const checksum =
            getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] &
            checksumMask;
          assertArgument(
            checksum === (entropy[entropy.length - 1] & checksumMask),
            "invalid mnemonic checksum",
            "mnemonic",
            "[ REDACTED ]"
          );
          return hexlify(entropy.slice(0, entropyBits / 8));
        }
        function entropyToMnemonic(entropy, wordlist) {
          assertArgument(
            entropy.length % 4 === 0 &&
              entropy.length >= 16 &&
              entropy.length <= 32,
            "invalid entropy size",
            "entropy",
            "[ REDACTED ]"
          );
          if (wordlist == null) {
            wordlist = LangEn.wordlist();
          }
          const indices = [0];
          let remainingBits = 11;
          for (let i = 0; i < entropy.length; i++) {
            if (remainingBits > 8) {
              indices[indices.length - 1] <<= 8;
              indices[indices.length - 1] |= entropy[i];
              remainingBits -= 8;
            } else {
              indices[indices.length - 1] <<= remainingBits;
              indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);
              indices.push(entropy[i] & getLowerMask(8 - remainingBits));
              remainingBits += 3;
            }
          }
          const checksumBits = entropy.length / 4;
          const checksum =
            parseInt(sha256(entropy).substring(2, 4), 16) &
            getUpperMask(checksumBits);
          indices[indices.length - 1] <<= checksumBits;
          indices[indices.length - 1] |= checksum >> (8 - checksumBits);
          return wordlist.join(indices.map((index) => wordlist.getWord(index)));
        }
        const _guard$1 = {};
        class Mnemonic {
          phrase;
          password;
          wordlist;
          entropy;
          constructor(guard, entropy, phrase, password, wordlist) {
            if (password == null) {
              password = "";
            }
            if (wordlist == null) {
              wordlist = LangEn.wordlist();
            }
            assertPrivate(guard, _guard$1, "Mnemonic");
            defineProperties(this, {
              phrase: phrase,
              password: password,
              wordlist: wordlist,
              entropy: entropy,
            });
          }
          computeSeed() {
            const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
            return pbkdf2(
              toUtf8Bytes(this.phrase, "NFKD"),
              salt,
              2048,
              64,
              "sha512"
            );
          }
          static fromPhrase(phrase, password, wordlist) {
            const entropy = mnemonicToEntropy(phrase, wordlist);
            phrase = entropyToMnemonic(getBytes(entropy), wordlist);
            return new Mnemonic(_guard$1, entropy, phrase, password, wordlist);
          }
          static fromEntropy(_entropy, password, wordlist) {
            const entropy = getBytes(_entropy, "entropy");
            const phrase = entropyToMnemonic(entropy, wordlist);
            return new Mnemonic(
              _guard$1,
              hexlify(entropy),
              phrase,
              password,
              wordlist
            );
          }
          static entropyToPhrase(_entropy, wordlist) {
            const entropy = getBytes(_entropy, "entropy");
            return entropyToMnemonic(entropy, wordlist);
          }
          static phraseToEntropy(phrase, wordlist) {
            return mnemonicToEntropy(phrase, wordlist);
          }
          static isValidMnemonic(phrase, wordlist) {
            try {
              mnemonicToEntropy(phrase, wordlist);
              return true;
            } catch (error) {}
            return false;
          }
        }
        var __classPrivateFieldGet$2 =
          (__$G && __$G.__classPrivateFieldGet) ||
          function (receiver, state, kind, f) {
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a getter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return kind === "m"
              ? f
              : kind === "a"
              ? f.call(receiver)
              : f
              ? f.value
              : state.get(receiver);
          };
        var __classPrivateFieldSet$2 =
          (__$G && __$G.__classPrivateFieldSet) ||
          function (receiver, state, value, kind, f) {
            if (kind === "m")
              throw new TypeError("Private method is not writable");
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a setter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              kind === "a"
                ? f.call(receiver, value)
                : f
                ? (f.value = value)
                : state.set(receiver, value),
              value
            );
          };
        var _AES_key, _AES_Kd, _AES_Ke;
        const numberOfRounds = { 16: 10, 24: 12, 32: 14 };
        const rcon = [
          1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94,
          188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145,
        ];
        const S = [
          99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171,
          118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156,
          164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241,
          113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226,
          235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179,
          41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190,
          57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2,
          127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182,
          218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196,
          167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136,
          70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92,
          194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213,
          78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28,
          166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181,
          102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248,
          152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140,
          161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22,
        ];
        const Si = [
          82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215,
          251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222,
          233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66,
          250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73,
          109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164,
          92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94,
          21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10,
          247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2,
          193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234,
          151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173,
          53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29,
          41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75,
          198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221,
          168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81,
          127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160,
          224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97,
          23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125,
        ];
        const T1 = [
          3328402341, 4168907908, 4000806809, 4135287693, 4294111757,
          3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241,
          1445669757, 3892248089, 3050821474, 1303096294, 3967186586,
          2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171,
          2387036105, 4226871307, 1101901292, 3017069671, 1604494077,
          1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402,
          3791519004, 1033081774, 1277568618, 1815492186, 2118074177,
          4126668546, 2211236943, 1748251740, 1369810420, 3521504564,
          4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908,
          2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135,
          798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438,
          1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972,
          874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614,
          1983593293, 3084310113, 2108928974, 1378429307, 3722699582,
          1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436,
          1075847264, 3825007647, 2041688520, 3059440621, 3563743934,
          2378943302, 1740553945, 1916352843, 2487896798, 2555137236,
          2958579944, 2244988746, 3151024235, 3320835882, 1336584933,
          3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663,
          3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106,
          1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413,
          563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573,
          1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300,
          403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436,
          773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572,
          3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905,
          2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882,
          3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493,
          2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571,
          201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935,
          3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010,
          2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682,
          1235855840, 3630984372, 2891339514, 4092916743, 3488279077,
          3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016,
          1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513,
          3421038627, 2715671932, 3899946140, 1042226977, 2521517021,
          1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956,
          3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891,
          1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535,
          664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707,
          2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602,
          3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671,
          1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982,
          3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163,
          2824099068, 1841019862, 739644986,
        ];
        const T2 = [
          2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027,
          2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147,
          434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938,
          1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592,
          3963727277, 1739838676, 4250903202, 3930435503, 3206782108,
          4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059,
          1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980,
          4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049,
          1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536,
          2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848,
          1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793,
          2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018,
          4217086112, 4137964114, 1299594043, 1639438038, 3464344499,
          2068982057, 1054729187, 1901997871, 2534638724, 4121318227,
          1757008337, 0, 750906861, 1614815264, 535035132, 3363418545,
          3988151131, 3201591914, 1183697867, 3647454910, 1265776953,
          3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087,
          3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261,
          3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428,
          3123027871, 3813386408, 4087501137, 4267549603, 3229630528,
          2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548,
          3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083,
          1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855,
          2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534,
          1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144,
          2551808385, 3516813135, 2141445340, 1715741218, 2119445034,
          2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540,
          2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026,
          1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516,
          1570751170, 1857934291, 4014189740, 2797888098, 2822345105,
          2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319,
          3084545389, 2348912013, 1689376213, 3533459022, 3762923945,
          3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810,
          3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758,
          607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877,
          2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234,
          2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067,
          33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753,
          2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800,
          3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444,
          3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045,
          2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245,
          3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313,
          2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766,
        ];
        const T3 = [
          1671808611, 2089089148, 2006576759, 2072901243, 4061003762,
          1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671,
          729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426,
          2191335298, 3376449993, 2106063485, 4195741690, 1508618841,
          1204391495, 4027317232, 2917941677, 3563566036, 2734514082,
          2951366063, 2629772188, 2767672228, 1922491506, 3227229120,
          3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767,
          4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329,
          1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279,
          593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466,
          118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711,
          2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610,
          455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283,
          3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444,
          1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412,
          2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753,
          1256100938, 1289001036, 1491644504, 3477767631, 3496721360,
          4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739,
          2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960,
          1011120188, 2679776671, 2833468328, 1374921297, 2751356323,
          1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005,
          3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895,
          4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324,
          1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711,
          2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699,
          1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154,
          2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740,
          3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546,
          978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276,
          3260915650, 3547250131, 2901361580, 1655096418, 2443721105,
          2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799,
          1840765549, 2374762893, 3580146133, 1322425422, 2850048425,
          1823791212, 1459268694, 4094161908, 3928346602, 1706019429,
          2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469,
          779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072,
          3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315,
          2323976074, 1888542832, 1044544574, 3049550261, 1722469478,
          1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557,
          1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430,
          3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385,
          2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169,
          3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649,
          2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440,
          1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308,
          3151392187, 372911126,
        ];
        const T4 = [
          1667474886, 2088535288, 2004326894, 2071694838, 4075949567,
          1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926,
          724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711,
          2189597983, 3385409673, 2105378810, 4210693615, 1499065266,
          1195886990, 4042263547, 2913856577, 3570689971, 2728590687,
          2947541573, 2627518243, 2762274643, 1920112356, 3233831835,
          3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142,
          4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529,
          1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789,
          589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191,
          117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286,
          2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380,
          454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198,
          3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939,
          1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667,
          2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178,
          1246420628, 1280103576, 1482221744, 3486468741, 3503319995,
          4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214,
          2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760,
          1010582648, 2678045221, 2829640523, 1364325282, 2745433693,
          1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505,
          3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645,
          4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699,
          1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621,
          2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854,
          1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924,
          2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440,
          3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716,
          976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736,
          3267517855, 3553849021, 2897014595, 1650632388, 2442242105,
          2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254,
          1835907034, 2374863873, 3587531953, 1313788572, 2846482505,
          1819063512, 1448540844, 4109633523, 3941213647, 1701162954,
          2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314,
          774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627,
          3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845,
          2324333839, 1886425312, 1044267644, 3048588401, 1718004428,
          1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282,
          1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215,
          3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025,
          2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609,
          3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649,
          2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520,
          1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848,
          3149649517, 370555436,
        ];
        const T5 = [
          1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753,
          2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485,
          1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703,
          1172967064, 1576976609, 3274667266, 2169303058, 2370213795,
          1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213,
          1484005843, 1239443753, 2395588676, 1975683434, 4102977912,
          2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444,
          1675577880, 3843699074, 2538681184, 1649639237, 2976151520,
          3144396420, 4269907996, 4178062228, 1883793496, 2403728665,
          2497604743, 1383856311, 2876494627, 1917518562, 3810496343,
          1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610,
          599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432,
          1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293,
          2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582,
          3178106961, 1042385657, 2531067453, 3711829422, 1306967366,
          2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327,
          2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483,
          2709260871, 2084704233, 4169408201, 0, 159417987, 841739592,
          504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415,
          168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535,
          3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374,
          3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893,
          766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109,
          4144047775, 1551037884, 1147550661, 1543208500, 2336434550,
          3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808,
          2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059,
          3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682,
          1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455,
          3644379585, 2362090238, 2564033334, 2801107407, 2776292904,
          3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698,
          4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924,
          1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923,
          3441850377, 1851332852, 3969562369, 2203032232, 3868552805,
          2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284,
          699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047,
          4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806,
          395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715,
          1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171,
          4211818798, 3009879386, 2463879762, 3910161971, 1842759443,
          2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029,
          3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775,
          1408749034, 1610459739, 3745345300, 2017778566, 3400528769,
          3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627,
          4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265,
          3576870512, 1215061108, 3501741890,
        ];
        const T6 = [
          1347548327, 1400783205, 3273267108, 2520393566, 3409685355,
          4045380933, 2880240216, 2471224067, 1428173050, 4138563181,
          2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155,
          1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728,
          2743944855, 3328955385, 3875770207, 2501218972, 3955191162,
          3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409,
          2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132,
          3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975,
          2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428,
          3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120,
          53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122,
          1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468,
          3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033,
          1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602,
          1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868,
          4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618,
          2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166,
          0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663,
          1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604,
          975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021,
          2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560,
          487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081,
          1286567175, 3152976349, 4255350624, 2683765030, 3160175349,
          3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617,
          3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061,
          296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347,
          1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879,
          3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419,
          3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554,
          2607439820, 1649704518, 3270937875, 3901806776, 1580087799,
          4118987695, 3198115200, 2087309459, 2842678573, 3016697106,
          1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472,
          32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392,
          3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259,
          818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840,
          1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904,
          1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889,
          77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242,
          870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476,
          4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235,
          2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891,
          2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253,
          2334669897, 1107234197, 1899603969, 3725069491, 2631447780,
          2422494913, 1635502980, 1893020342, 1950903388, 1120974935,
        ];
        const T7 = [
          2807058932, 1699970625, 2764249623, 1586903591, 1808481195,
          1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228,
          1277555970, 3623636965, 3419915562, 1149249077, 2744104290,
          1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588,
          2544078150, 4190530515, 1608975247, 2627016082, 2062270317,
          1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554,
          2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312,
          984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180,
          2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798,
          4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195,
          3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107,
          2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658,
          3201631749, 1646252340, 4270507174, 1402811438, 1436590835,
          3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366,
          2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892,
          3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497,
          1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938,
          516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170,
          4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260,
          1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075,
          3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128,
          3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854,
          428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354,
          1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452,
          3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051,
          840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177,
          376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744,
          752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444,
          2177869557, 3727205754, 2384911031, 3215212461, 2648976442,
          2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569,
          2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044,
          2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634,
          2594734927, 1852171925, 3867060991, 3473416636, 3907448597,
          2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639,
          2486224549, 1723872674, 3157750862, 3399941250, 3501252752,
          3625268135, 2555048196, 3673637356, 1343127501, 4130281361,
          3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410,
          532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963,
          492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225,
          344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695,
          3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069,
          1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571,
          3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716,
          3835484340, 3247465558, 2220981195, 3060847922, 1551124588,
          1463996600,
        ];
        const T8 = [
          4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623,
          4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885,
          3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053,
          3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835,
          2405426947, 2459735317, 1836772287, 1381620373, 3196267988,
          1948373848, 3764988233, 3385345166, 3263785589, 2390325492,
          1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789,
          3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355,
          2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426,
          1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895,
          3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221,
          3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454,
          878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212,
          2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718,
          1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912,
          2566595609, 3186202582, 1078185097, 3651041127, 3896688048,
          2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296,
          0, 2156299017, 736970802, 292596766, 1517440620, 251657213,
          2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339,
          908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416,
          3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620,
          454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591,
          1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156,
          4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431,
          1669664834, 2535604243, 3323011204, 1243905413, 3141400786,
          4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727,
          3004591147, 1891211689, 2487810577, 3915653703, 4237083816,
          4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628,
          3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092,
          2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814,
          3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464,
          410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844,
          1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714,
          1865862730, 2668221674, 2960971305, 2763173681, 1059270954,
          2777952454, 2724642869, 1320957812, 2194319100, 2429595872,
          2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550,
          4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417,
          1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011,
          3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729,
          322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828,
          4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015,
          1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990,
          3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240,
          1455525988, 3414450555, 850817237, 1817998408, 3092726480,
        ];
        const U1 = [
          0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554,
          708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108,
          1181045119, 1417561698, 1517767529, 3767586992, 4003061179,
          4236429990, 4069246893, 3635733660, 3602770327, 3299278474,
          3400528769, 2430122216, 2664543715, 2362090238, 2193862645,
          2835123396, 2801107407, 3035535058, 3135740889, 3678124923,
          3576870512, 3341394285, 3374361702, 3810496343, 3977675356,
          4279080257, 4043610186, 2876494627, 2776292904, 3076639029,
          3110650942, 2472011535, 2640243204, 2403728665, 2169303058,
          1001089995, 899835584, 666464733, 699432150, 59727847, 226906860,
          530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414,
          1942435775, 2110667444, 1876241833, 1641816226, 2910219766,
          2743034109, 2976151520, 3211623147, 2505202138, 2606453969,
          2302690252, 2269728455, 3711829422, 3543599269, 3240894392,
          3475313331, 3843699074, 3943906441, 4178062228, 4144047775,
          1306967366, 1139781709, 1374988112, 1610459739, 1975683434,
          2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896,
          800440835, 92987698, 193195065, 429456164, 395441711, 1984812685,
          2017778566, 1784663195, 1683407248, 1315562145, 1080094634,
          1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864,
          1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334,
          2328828971, 2227573024, 2935566865, 2700099354, 3001755655,
          3168937228, 3868552805, 3902563182, 4203181171, 4102977912,
          3736164937, 3501741890, 3265478751, 3433712980, 1106041591,
          1340463100, 1576976609, 1408749034, 2043211483, 2009195472,
          1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354,
          159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380,
          3178106961, 3009879386, 2572697195, 2538681184, 2236228733,
          2336434550, 3509871135, 3745345300, 3441850377, 3274667266,
          3910161971, 3877198648, 4110568485, 4211818798, 2597806476,
          2497604743, 2261089178, 2295101073, 2733856160, 2902087851,
          3202437046, 2968011453, 3936291284, 3835036895, 4136440770,
          4169408201, 3535486456, 3702665459, 3467192302, 3231722213,
          2051518780, 1951317047, 1716890410, 1750902305, 1113818384,
          1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330,
          404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369,
          3801332234, 4035489047, 4269907996, 3569255213, 3669462566,
          3366754619, 3332740144, 2631065433, 2463879762, 2160117071,
          2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497,
          33778362, 270040487, 504459436, 875451293, 975658646, 675039627,
          641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661,
          1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972,
          632953703, 260388950, 25965917, 328671808, 496906059, 1206477858,
          1239443753, 1543208500, 1441952575, 2144161806, 1908694277,
          1675577880, 1842759443, 3610369226, 3644379585, 3408119516,
          3307916247, 4011190502, 3776767469, 4077384432, 4245618683,
          2809771154, 2842737049, 3144396420, 3043140495, 2673705150,
          2438237621, 2203032232, 2370213795,
        ];
        const U2 = [
          0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694,
          824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388,
          2135319889, 1649704518, 1767536459, 2967507152, 3152976349,
          2801566410, 2918353863, 2631447780, 2547432937, 2328143614,
          2177544179, 3901806776, 3818836405, 4270639778, 4118987695,
          3299409036, 3483825537, 3535072918, 3652904859, 2077965243,
          1893020342, 1841768865, 1724457132, 1474502543, 1559041666,
          1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372,
          261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454,
          3710368113, 3593056380, 3875770207, 3960309330, 4045380933,
          4195456072, 2471224067, 2554718734, 2237133081, 2388260884,
          3212035895, 3028143674, 2842678573, 2724322336, 4138563181,
          4255350624, 3769721975, 3955191162, 3667219033, 3516619604,
          3431546947, 3347532110, 2933734917, 2782082824, 3099667487,
          3016697106, 2196052529, 2313884476, 2499348523, 2683765030,
          1179510461, 1296297904, 1347548327, 1533017514, 1786102409,
          1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751,
          53458370, 839224033, 957055980, 605657339, 790073846, 2373340630,
          2256028891, 2607439820, 2422494913, 2706270690, 2856345839,
          3075636216, 3160175349, 3573941694, 3725069491, 3273267108,
          3356761769, 4181598602, 4063242375, 4011996048, 3828103837,
          1033297158, 915985419, 730517276, 545572369, 296679730, 446754879,
          129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177,
          1239331162, 1120974935, 1606591296, 1422699085, 4148292826,
          4233094615, 3781033664, 3931371469, 3682191598, 3497509347,
          3446004468, 3328955385, 2939266226, 2755636671, 3106780840,
          2988687269, 2198438022, 2282195339, 2501218972, 2652609425,
          1201765386, 1286567175, 1371368976, 1521706781, 1805211710,
          1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672,
          46346101, 870912086, 954669403, 636813900, 788204353, 2358957921,
          2274680428, 2592523643, 2441661558, 2695033685, 2880240216,
          3065962831, 3182487618, 3572145929, 3756299780, 3270937875,
          3388507166, 4174560061, 4091327024, 4006521127, 3854606378,
          1014646705, 930369212, 711349675, 560487590, 272786309, 457992840,
          106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326,
          1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114,
          401639597, 486441376, 768917123, 651868046, 1003007129, 818324884,
          1503449823, 1385356242, 1333838021, 1150208456, 1973745387,
          2125135846, 1673061617, 1756818940, 2970356327, 3120694122,
          2802849917, 2887651696, 2637442643, 2520393566, 2334669897,
          2149987652, 3917234703, 3799141122, 4284502037, 4100872472,
          3309594171, 3460984630, 3545789473, 3629546796, 2050466060,
          1899603969, 1814803222, 1730525723, 1443857720, 1560382517,
          1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235,
          243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545,
          3704300486, 3620022987, 3874428392, 3990953189, 4042459122,
          4227665663, 2460449204, 2578018489, 2226875310, 2411029155,
          3198115200, 3046200461, 2827177882, 2743944855,
        ];
        const U3 = [
          0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294,
          590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588,
          1367295589, 1180849278, 1265195639, 3501252752, 3720081049,
          3399941250, 3350065803, 3835484340, 3919042237, 4270507174,
          4085369519, 3102249176, 3051593425, 2734591178, 2952102595,
          2361698556, 2177869557, 2530391278, 2614737639, 3145456443,
          3060847922, 2708326185, 2892417312, 2404901663, 2187128086,
          2504130317, 2555048196, 3542330227, 3727205754, 3375740769,
          3292445032, 3876557655, 3926170974, 4246310725, 4027744588,
          1808481195, 1723872674, 1910319033, 2094410160, 1608975247,
          1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201,
          344873464, 935293895, 984907214, 766078933, 547512796, 1844882806,
          1627235199, 2011214180, 2062270317, 1507497298, 1423022939,
          1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861,
          830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679,
          2807058932, 2858115069, 2305455554, 2220981195, 2474404304,
          2658625497, 3575528878, 3625268135, 3473416636, 3254988725,
          3778151818, 3963161475, 4213447064, 4130281361, 3599595085,
          3683022916, 3432737375, 3247465558, 3802222185, 4020912224,
          4172763771, 4122762354, 3201631749, 3017672716, 2764249623,
          2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613,
          188127444, 472615631, 287343814, 840019705, 1058709744, 671593195,
          621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577,
          1463996600, 1080017571, 1297403050, 3673637356, 3623636965,
          3235995134, 3454686199, 4007360968, 3822090177, 4107101658,
          4190530515, 2997825956, 3215212461, 2830708150, 2779915199,
          2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165,
          273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755,
          1646252340, 1863638845, 2013908262, 1963115311, 1446242576,
          1530455833, 1277555970, 1093597963, 1636604631, 1820824798,
          2073724613, 1989249228, 1436590835, 1487645946, 1337376481,
          1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051,
          821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645,
          2787207260, 2232435299, 2283490410, 2667994737, 2450346104,
          3647212047, 3564045318, 3279033885, 3464042516, 3980931627,
          3762502690, 4150144569, 4199882800, 3070356634, 3121275539,
          2904027272, 2686254721, 2200818878, 2384911031, 2570832044,
          2486224549, 3747192018, 3528626907, 3310321856, 3359936201,
          3950355702, 3867060991, 4049844452, 4234721005, 1739656202,
          1790575107, 2108100632, 1890328081, 1402811438, 1586903591,
          1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217,
          1002783846, 919489135, 567498868, 752375421, 209336225, 24197544,
          376187827, 459744698, 945164165, 895287692, 574624663, 793451934,
          1679968233, 1764313568, 2117360635, 1933530610, 1343127501,
          1560637892, 1243112415, 1192455638, 3704280881, 3519142200,
          3336358691, 3419915562, 3907448597, 3857572124, 4075877127,
          4294704398, 3029510009, 3113855344, 2927934315, 2744104290,
          2159976285, 2377486676, 2594734927, 2544078150,
        ];
        const U4 = [
          0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204,
          1059270954, 1214797936, 1097159550, 1517440620, 1400849762,
          1817998408, 1699839814, 2118541908, 2001430874, 2429595872,
          2581445614, 2194319100, 2345119218, 3034881240, 3186202582,
          2801699524, 2951971274, 3635996816, 3518358430, 3399679628,
          3283088770, 4237083816, 4118925222, 4002861748, 3885750714,
          1002142683, 850817237, 698445255, 548169417, 529487843, 377642221,
          227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577,
          1474760595, 1592394909, 1174215055, 1290801793, 2875968315,
          2724642869, 3111247143, 2960971305, 2405426947, 2253581325,
          2638606623, 2487810577, 3808662347, 3926825029, 4044981591,
          4162096729, 3342319475, 3459953789, 3576539503, 3693126241,
          1986918061, 2137062819, 1685577905, 1836772287, 1381620373,
          1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417,
          621982671, 439452389, 322734571, 137073913, 19308535, 3871163981,
          4021308739, 4104605777, 4255800159, 3263785589, 3414450555,
          3499326569, 3651041127, 2933202493, 2815956275, 3167684641,
          3049390895, 2330014213, 2213296395, 2566595609, 2448830231,
          1305906550, 1155237496, 1607244650, 1455525988, 1776460110,
          1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818,
          514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718,
          3557504664, 3474729866, 3323011204, 4180808110, 4030667424,
          3945269170, 3794078908, 2507040230, 2623762152, 2272556026,
          2390325492, 2975484382, 3092726480, 2738905026, 2857194700,
          3973773121, 3856137295, 4274053469, 4157467219, 3371096953,
          3252932727, 3673476453, 3556361835, 2763173681, 2915017791,
          3064510765, 3215307299, 2156299017, 2307622919, 2459735317,
          2610011675, 2081048481, 1963412655, 1846563261, 1729977011,
          1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015,
          645401037, 796197571, 274084841, 425408743, 38544885, 188821243,
          3613494426, 3731654548, 3313212038, 3430322568, 4082475170,
          4200115116, 3780097726, 3896688048, 2668221674, 2516901860,
          2366882550, 2216610296, 3141400786, 2989552604, 2837966542,
          2687165888, 1202797690, 1320957812, 1437280870, 1554391400,
          1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348,
          499347990, 349075736, 736970802, 585122620, 972512814, 821712160,
          2595684844, 2478443234, 2293045232, 2174754046, 3196267988,
          3079546586, 2895723464, 2777952454, 3537852828, 3687994002,
          3234156416, 3385345166, 4142626212, 4293295786, 3841024952,
          3992742070, 174567692, 57326082, 410887952, 292596766, 777231668,
          660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912,
          1494807662, 1715193156, 1865862730, 1948373848, 2100090966,
          2701949495, 2818666809, 3004591147, 3122358053, 2235061775,
          2352307457, 2535604243, 2653899549, 3915653703, 3764988233,
          4219352155, 4067639125, 3444575871, 3294430577, 3746175075,
          3594982253, 836553431, 953270745, 600235211, 718002117, 367585007,
          484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355,
          1654886325, 1568718495, 1418573201, 1335535747, 1184342925,
        ];
        function convertToInt32(bytes) {
          const result = [];
          for (let i = 0; i < bytes.length; i += 4) {
            result.push(
              (bytes[i] << 24) |
                (bytes[i + 1] << 16) |
                (bytes[i + 2] << 8) |
                bytes[i + 3]
            );
          }
          return result;
        }
        class AES {
          get key() {
            return __classPrivateFieldGet$2(this, _AES_key, "f").slice();
          }
          constructor(key) {
            _AES_key.set(this, void 0);
            _AES_Kd.set(this, void 0);
            _AES_Ke.set(this, void 0);
            if (!(this instanceof AES)) {
              throw Error("AES must be instanitated with `new`");
            }
            __classPrivateFieldSet$2(this, _AES_key, new Uint8Array(key), "f");
            const rounds = numberOfRounds[this.key.length];
            if (rounds == null) {
              throw new TypeError(
                "invalid key size (must be 16, 24 or 32 bytes)"
              );
            }
            __classPrivateFieldSet$2(this, _AES_Ke, [], "f");
            __classPrivateFieldSet$2(this, _AES_Kd, [], "f");
            for (let i = 0; i <= rounds; i++) {
              __classPrivateFieldGet$2(this, _AES_Ke, "f").push([0, 0, 0, 0]);
              __classPrivateFieldGet$2(this, _AES_Kd, "f").push([0, 0, 0, 0]);
            }
            const roundKeyCount = (rounds + 1) * 4;
            const KC = this.key.length / 4;
            const tk = convertToInt32(this.key);
            let index;
            for (let i = 0; i < KC; i++) {
              index = i >> 2;
              __classPrivateFieldGet$2(this, _AES_Ke, "f")[index][i % 4] =
                tk[i];
              __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - index][
                i % 4
              ] = tk[i];
            }
            let rconpointer = 0;
            let t = KC,
              tt;
            while (t < roundKeyCount) {
              tt = tk[KC - 1];
              tk[0] ^=
                (S[(tt >> 16) & 255] << 24) ^
                (S[(tt >> 8) & 255] << 16) ^
                (S[tt & 255] << 8) ^
                S[(tt >> 24) & 255] ^
                (rcon[rconpointer] << 24);
              rconpointer += 1;
              if (KC != 8) {
                for (let i = 1; i < KC; i++) {
                  tk[i] ^= tk[i - 1];
                }
              } else {
                for (let i = 1; i < KC / 2; i++) {
                  tk[i] ^= tk[i - 1];
                }
                tt = tk[KC / 2 - 1];
                tk[KC / 2] ^=
                  S[tt & 255] ^
                  (S[(tt >> 8) & 255] << 8) ^
                  (S[(tt >> 16) & 255] << 16) ^
                  (S[(tt >> 24) & 255] << 24);
                for (let i = KC / 2 + 1; i < KC; i++) {
                  tk[i] ^= tk[i - 1];
                }
              }
              let i = 0,
                r,
                c;
              while (i < KC && t < roundKeyCount) {
                r = t >> 2;
                c = t % 4;
                __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][c] = tk[i];
                __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - r][c] =
                  tk[i++];
                t++;
              }
            }
            for (let r = 1; r < rounds; r++) {
              for (let c = 0; c < 4; c++) {
                tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c];
                __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c] =
                  U1[(tt >> 24) & 255] ^
                  U2[(tt >> 16) & 255] ^
                  U3[(tt >> 8) & 255] ^
                  U4[tt & 255];
              }
            }
          }
          encrypt(plaintext) {
            if (plaintext.length != 16) {
              throw new TypeError("invalid plaintext size (must be 16 bytes)");
            }
            const rounds =
              __classPrivateFieldGet$2(this, _AES_Ke, "f").length - 1;
            const a = [0, 0, 0, 0];
            let t = convertToInt32(plaintext);
            for (let i = 0; i < 4; i++) {
              t[i] ^= __classPrivateFieldGet$2(this, _AES_Ke, "f")[0][i];
            }
            for (let r = 1; r < rounds; r++) {
              for (let i = 0; i < 4; i++) {
                a[i] =
                  T1[(t[i] >> 24) & 255] ^
                  T2[(t[(i + 1) % 4] >> 16) & 255] ^
                  T3[(t[(i + 2) % 4] >> 8) & 255] ^
                  T4[t[(i + 3) % 4] & 255] ^
                  __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][i];
              }
              t = a.slice();
            }
            const result = new Uint8Array(16);
            let tt = 0;
            for (let i = 0; i < 4; i++) {
              tt = __classPrivateFieldGet$2(this, _AES_Ke, "f")[rounds][i];
              result[4 * i] = (S[(t[i] >> 24) & 255] ^ (tt >> 24)) & 255;
              result[4 * i + 1] =
                (S[(t[(i + 1) % 4] >> 16) & 255] ^ (tt >> 16)) & 255;
              result[4 * i + 2] =
                (S[(t[(i + 2) % 4] >> 8) & 255] ^ (tt >> 8)) & 255;
              result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
            }
            return result;
          }
          decrypt(ciphertext) {
            if (ciphertext.length != 16) {
              throw new TypeError("invalid ciphertext size (must be 16 bytes)");
            }
            const rounds =
              __classPrivateFieldGet$2(this, _AES_Kd, "f").length - 1;
            const a = [0, 0, 0, 0];
            let t = convertToInt32(ciphertext);
            for (let i = 0; i < 4; i++) {
              t[i] ^= __classPrivateFieldGet$2(this, _AES_Kd, "f")[0][i];
            }
            for (let r = 1; r < rounds; r++) {
              for (let i = 0; i < 4; i++) {
                a[i] =
                  T5[(t[i] >> 24) & 255] ^
                  T6[(t[(i + 3) % 4] >> 16) & 255] ^
                  T7[(t[(i + 2) % 4] >> 8) & 255] ^
                  T8[t[(i + 1) % 4] & 255] ^
                  __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][i];
              }
              t = a.slice();
            }
            const result = new Uint8Array(16);
            let tt = 0;
            for (let i = 0; i < 4; i++) {
              tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds][i];
              result[4 * i] = (Si[(t[i] >> 24) & 255] ^ (tt >> 24)) & 255;
              result[4 * i + 1] =
                (Si[(t[(i + 3) % 4] >> 16) & 255] ^ (tt >> 16)) & 255;
              result[4 * i + 2] =
                (Si[(t[(i + 2) % 4] >> 8) & 255] ^ (tt >> 8)) & 255;
              result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
            }
            return result;
          }
        }
        (_AES_key = new WeakMap()),
          (_AES_Kd = new WeakMap()),
          (_AES_Ke = new WeakMap());
        class ModeOfOperation {
          constructor(name, key, cls) {
            if (cls && !(this instanceof cls)) {
              throw new Error(`${name} must be instantiated with "new"`);
            }
            Object.defineProperties(this, {
              aes: { enumerable: true, value: new AES(key) },
              name: { enumerable: true, value: name },
            });
          }
        }
        var __classPrivateFieldSet$1 =
          (__$G && __$G.__classPrivateFieldSet) ||
          function (receiver, state, value, kind, f) {
            if (kind === "m")
              throw new TypeError("Private method is not writable");
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a setter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              kind === "a"
                ? f.call(receiver, value)
                : f
                ? (f.value = value)
                : state.set(receiver, value),
              value
            );
          };
        var __classPrivateFieldGet$1 =
          (__$G && __$G.__classPrivateFieldGet) ||
          function (receiver, state, kind, f) {
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a getter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return kind === "m"
              ? f
              : kind === "a"
              ? f.call(receiver)
              : f
              ? f.value
              : state.get(receiver);
          };
        var _CBC_iv, _CBC_lastBlock;
        class CBC extends ModeOfOperation {
          constructor(key, iv) {
            super("ECC", key, CBC);
            _CBC_iv.set(this, void 0);
            _CBC_lastBlock.set(this, void 0);
            if (iv) {
              if (iv.length % 16) {
                throw new TypeError("invalid iv size (must be 16 bytes)");
              }
              __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(iv), "f");
            } else {
              __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(16), "f");
            }
            __classPrivateFieldSet$1(this, _CBC_lastBlock, this.iv, "f");
          }
          get iv() {
            return new Uint8Array(__classPrivateFieldGet$1(this, _CBC_iv, "f"));
          }
          encrypt(plaintext) {
            if (plaintext.length % 16) {
              throw new TypeError(
                "invalid plaintext size (must be multiple of 16 bytes)"
              );
            }
            const ciphertext = new Uint8Array(plaintext.length);
            for (let i = 0; i < plaintext.length; i += 16) {
              for (let j = 0; j < 16; j++) {
                __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] ^=
                  plaintext[i + j];
              }
              __classPrivateFieldSet$1(
                this,
                _CBC_lastBlock,
                this.aes.encrypt(
                  __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")
                ),
                "f"
              );
              ciphertext.set(
                __classPrivateFieldGet$1(this, _CBC_lastBlock, "f"),
                i
              );
            }
            return ciphertext;
          }
          decrypt(ciphertext) {
            if (ciphertext.length % 16) {
              throw new TypeError(
                "invalid ciphertext size (must be multiple of 16 bytes)"
              );
            }
            const plaintext = new Uint8Array(ciphertext.length);
            for (let i = 0; i < ciphertext.length; i += 16) {
              const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
              for (let j = 0; j < 16; j++) {
                plaintext[i + j] =
                  block[j] ^
                  __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j];
                __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] =
                  ciphertext[i + j];
              }
            }
            return plaintext;
          }
        }
        (_CBC_iv = new WeakMap()), (_CBC_lastBlock = new WeakMap());
        var __classPrivateFieldSet =
          (__$G && __$G.__classPrivateFieldSet) ||
          function (receiver, state, value, kind, f) {
            if (kind === "m")
              throw new TypeError("Private method is not writable");
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a setter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              kind === "a"
                ? f.call(receiver, value)
                : f
                ? (f.value = value)
                : state.set(receiver, value),
              value
            );
          };
        var __classPrivateFieldGet =
          (__$G && __$G.__classPrivateFieldGet) ||
          function (receiver, state, kind, f) {
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a getter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return kind === "m"
              ? f
              : kind === "a"
              ? f.call(receiver)
              : f
              ? f.value
              : state.get(receiver);
          };
        var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
        class CTR extends ModeOfOperation {
          constructor(key, initialValue) {
            super("CTR", key, CTR);
            _CTR_remaining.set(this, void 0);
            _CTR_remainingIndex.set(this, void 0);
            _CTR_counter.set(this, void 0);
            __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
            __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
            __classPrivateFieldSet(
              this,
              _CTR_remaining,
              __classPrivateFieldGet(this, _CTR_counter, "f"),
              "f"
            );
            __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
            if (initialValue == null) {
              initialValue = 1;
            }
            if (typeof initialValue === "number") {
              this.setCounterValue(initialValue);
            } else {
              this.setCounterBytes(initialValue);
            }
          }
          get counter() {
            return new Uint8Array(
              __classPrivateFieldGet(this, _CTR_counter, "f")
            );
          }
          setCounterValue(value) {
            if (
              !Number.isInteger(value) ||
              value < 0 ||
              value > Number.MAX_SAFE_INTEGER
            ) {
              throw new TypeError("invalid counter initial integer value");
            }
            for (let index = 15; index >= 0; --index) {
              __classPrivateFieldGet(this, _CTR_counter, "f")[index] =
                value % 256;
              value = Math.floor(value / 256);
            }
          }
          setCounterBytes(value) {
            if (value.length !== 16) {
              throw new TypeError(
                "invalid counter initial Uint8Array value length"
              );
            }
            __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
          }
          increment() {
            for (let i = 15; i >= 0; i--) {
              if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
                __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
              } else {
                __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
                break;
              }
            }
          }
          encrypt(plaintext) {
            var _a, _b;
            const crypttext = new Uint8Array(plaintext);
            for (let i = 0; i < crypttext.length; i++) {
              if (
                __classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16
              ) {
                __classPrivateFieldSet(
                  this,
                  _CTR_remaining,
                  this.aes.encrypt(
                    __classPrivateFieldGet(this, _CTR_counter, "f")
                  ),
                  "f"
                );
                __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
                this.increment();
              }
              crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[
                (__classPrivateFieldSet(
                  this,
                  _CTR_remainingIndex,
                  ((_b = __classPrivateFieldGet(
                    this,
                    _CTR_remainingIndex,
                    "f"
                  )),
                  (_a = _b++),
                  _b),
                  "f"
                ),
                _a)
              ];
            }
            return crypttext;
          }
          decrypt(ciphertext) {
            return this.encrypt(ciphertext);
          }
        }
        (_CTR_remaining = new WeakMap()),
          (_CTR_remainingIndex = new WeakMap()),
          (_CTR_counter = new WeakMap());
        function pkcs7Strip(data) {
          if (data.length < 16) {
            throw new TypeError("PKCS#7 invalid length");
          }
          const padder = data[data.length - 1];
          if (padder > 16) {
            throw new TypeError("PKCS#7 padding byte out of range");
          }
          const length = data.length - padder;
          for (let i = 0; i < padder; i++) {
            if (data[length + i] !== padder) {
              throw new TypeError("PKCS#7 invalid padding byte");
            }
          }
          return new Uint8Array(data.subarray(0, length));
        }
        function looseArrayify(hexString) {
          if (typeof hexString === "string" && !hexString.startsWith("0x")) {
            hexString = "0x" + hexString;
          }
          return getBytesCopy(hexString);
        }
        function zpad$1(value, length) {
          value = String(value);
          while (value.length < length) {
            value = "0" + value;
          }
          return value;
        }
        function getPassword(password) {
          if (typeof password === "string") {
            return toUtf8Bytes(password, "NFKC");
          }
          return getBytesCopy(password);
        }
        function spelunk(object, _path) {
          const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
          assertArgument(match != null, "invalid path", "path", _path);
          const path = match[1];
          const type = match[3];
          const reqd = match[4] === "!";
          let cur = object;
          for (const comp of path.toLowerCase().split(".")) {
            if (Array.isArray(cur)) {
              if (!comp.match(/^[0-9]+$/)) {
                break;
              }
              cur = cur[parseInt(comp)];
            } else if (typeof cur === "object") {
              let found = null;
              for (const key in cur) {
                if (key.toLowerCase() === comp) {
                  found = cur[key];
                  break;
                }
              }
              cur = found;
            } else {
              cur = null;
            }
            if (cur == null) {
              break;
            }
          }
          assertArgument(
            !reqd || cur != null,
            "missing required value",
            "path",
            path
          );
          if (type && cur != null) {
            if (type === "int") {
              if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
                return parseInt(cur);
              } else if (Number.isSafeInteger(cur)) {
                return cur;
              }
            }
            if (type === "number") {
              if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
                return parseFloat(cur);
              }
            }
            if (type === "data") {
              if (typeof cur === "string") {
                return looseArrayify(cur);
              }
            }
            if (type === "array" && Array.isArray(cur)) {
              return cur;
            }
            if (type === typeof cur) {
              return cur;
            }
            assertArgument(
              false,
              `wrong type found for ${type} `,
              "path",
              path
            );
          }
          return cur;
        }
        const defaultPath$1 = "m/44'/60'/0'/0/0";
        function isKeystoreJson(json) {
          try {
            const data = JSON.parse(json);
            const version = data.version != null ? parseInt(data.version) : 0;
            if (version === 3) {
              return true;
            }
          } catch (error) {}
          return false;
        }
        function decrypt(data, key, ciphertext) {
          const cipher = spelunk(data, "crypto.cipher:string");
          if (cipher === "aes-128-ctr") {
            const iv = spelunk(data, "crypto.cipherparams.iv:data!");
            const aesCtr = new CTR(key, iv);
            return hexlify(aesCtr.decrypt(ciphertext));
          }
          assert(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
            operation: "decrypt",
          });
        }
        function getAccount(data, _key) {
          const key = getBytes(_key);
          const ciphertext = spelunk(data, "crypto.ciphertext:data!");
          const computedMAC = hexlify(
            keccak256(concat([key.slice(16, 32), ciphertext]))
          ).substring(2);
          assertArgument(
            computedMAC === spelunk(data, "crypto.mac:string!").toLowerCase(),
            "incorrect password",
            "password",
            "[ REDACTED ]"
          );
          const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
          const address = computeAddress(privateKey);
          if (data.address) {
            let check = data.address.toLowerCase();
            if (!check.startsWith("0x")) {
              check = "0x" + check;
            }
            assertArgument(
              getAddress(check) === address,
              "keystore address/privateKey mismatch",
              "address",
              data.address
            );
          }
          const account = { address: address, privateKey: privateKey };
          const version = spelunk(data, "x-ethers.version:string");
          if (version === "0.1") {
            const mnemonicKey = key.slice(32, 64);
            const mnemonicCiphertext = spelunk(
              data,
              "x-ethers.mnemonicCiphertext:data!"
            );
            const mnemonicIv = spelunk(data, "x-ethers.mnemonicCounter:data!");
            const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
            account.mnemonic = {
              path: spelunk(data, "x-ethers.path:string") || defaultPath$1,
              locale: spelunk(data, "x-ethers.locale:string") || "en",
              entropy: hexlify(
                getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext))
              ),
            };
          }
          return account;
        }
        function getDecryptKdfParams(data) {
          const kdf = spelunk(data, "crypto.kdf:string");
          if (kdf && typeof kdf === "string") {
            if (kdf.toLowerCase() === "scrypt") {
              const salt = spelunk(data, "crypto.kdfparams.salt:data!");
              const N = spelunk(data, "crypto.kdfparams.n:int!");
              const r = spelunk(data, "crypto.kdfparams.r:int!");
              const p = spelunk(data, "crypto.kdfparams.p:int!");
              assertArgument(
                N > 0 && (N & (N - 1)) === 0,
                "invalid kdf.N",
                "kdf.N",
                N
              );
              assertArgument(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
              const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
              assertArgument(
                dkLen === 32,
                "invalid kdf.dklen",
                "kdf.dflen",
                dkLen
              );
              return {
                name: "scrypt",
                salt: salt,
                N: N,
                r: r,
                p: p,
                dkLen: 64,
              };
            } else if (kdf.toLowerCase() === "pbkdf2") {
              const salt = spelunk(data, "crypto.kdfparams.salt:data!");
              const prf = spelunk(data, "crypto.kdfparams.prf:string!");
              const algorithm = prf.split("-").pop();
              assertArgument(
                algorithm === "sha256" || algorithm === "sha512",
                "invalid kdf.pdf",
                "kdf.pdf",
                prf
              );
              const count = spelunk(data, "crypto.kdfparams.c:int!");
              const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
              assertArgument(
                dkLen === 32,
                "invalid kdf.dklen",
                "kdf.dklen",
                dkLen
              );
              return {
                name: "pbkdf2",
                salt: salt,
                count: count,
                dkLen: dkLen,
                algorithm: algorithm,
              };
            }
          }
          assertArgument(
            false,
            "unsupported key-derivation function",
            "kdf",
            kdf
          );
        }
        function decryptKeystoreJsonSync(json, _password) {
          const data = JSON.parse(json);
          const password = getPassword(_password);
          const params = getDecryptKdfParams(data);
          if (params.name === "pbkdf2") {
            const { salt, count, dkLen, algorithm } = params;
            const key = pbkdf2(password, salt, count, dkLen, algorithm);
            return getAccount(data, key);
          }
          assert(
            params.name === "scrypt",
            "cannot be reached",
            "UNKNOWN_ERROR",
            { params: params }
          );
          const { salt, N, r, p, dkLen } = params;
          const key = scryptSync(password, salt, N, r, p, dkLen);
          return getAccount(data, key);
        }
        function stall$1(duration) {
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve();
            }, duration);
          });
        }
        async function decryptKeystoreJson(json, _password, progress) {
          const data = JSON.parse(json);
          const password = getPassword(_password);
          const params = getDecryptKdfParams(data);
          if (params.name === "pbkdf2") {
            if (progress) {
              progress(0);
              await stall$1(0);
            }
            const { salt, count, dkLen, algorithm } = params;
            const key = pbkdf2(password, salt, count, dkLen, algorithm);
            if (progress) {
              progress(1);
              await stall$1(0);
            }
            return getAccount(data, key);
          }
          assert(
            params.name === "scrypt",
            "cannot be reached",
            "UNKNOWN_ERROR",
            { params: params }
          );
          const { salt, N, r, p, dkLen } = params;
          const key = await scrypt(password, salt, N, r, p, dkLen, progress);
          return getAccount(data, key);
        }
        function getEncryptKdfParams(options) {
          const salt =
            options.salt != null
              ? getBytes(options.salt, "options.salt")
              : randomBytes(32);
          let N = 1 << 17,
            r = 8,
            p = 1;
          if (options.scrypt) {
            if (options.scrypt.N) {
              N = options.scrypt.N;
            }
            if (options.scrypt.r) {
              r = options.scrypt.r;
            }
            if (options.scrypt.p) {
              p = options.scrypt.p;
            }
          }
          assertArgument(
            typeof N === "number" &&
              N > 0 &&
              Number.isSafeInteger(N) &&
              (BigInt(N) & BigInt(N - 1)) === BigInt(0),
            "invalid scrypt N parameter",
            "options.N",
            N
          );
          assertArgument(
            typeof r === "number" && r > 0 && Number.isSafeInteger(r),
            "invalid scrypt r parameter",
            "options.r",
            r
          );
          assertArgument(
            typeof p === "number" && p > 0 && Number.isSafeInteger(p),
            "invalid scrypt p parameter",
            "options.p",
            p
          );
          return { name: "scrypt", dkLen: 32, salt: salt, N: N, r: r, p: p };
        }
        function _encryptKeystore(key, kdf, account, options) {
          const privateKey = getBytes(account.privateKey, "privateKey");
          const iv =
            options.iv != null
              ? getBytes(options.iv, "options.iv")
              : randomBytes(16);
          assertArgument(
            iv.length === 16,
            "invalid options.iv length",
            "options.iv",
            options.iv
          );
          const uuidRandom =
            options.uuid != null
              ? getBytes(options.uuid, "options.uuid")
              : randomBytes(16);
          assertArgument(
            uuidRandom.length === 16,
            "invalid options.uuid length",
            "options.uuid",
            options.iv
          );
          const derivedKey = key.slice(0, 16);
          const macPrefix = key.slice(16, 32);
          const aesCtr = new CTR(derivedKey, iv);
          const ciphertext = getBytes(aesCtr.encrypt(privateKey));
          const mac = keccak256(concat([macPrefix, ciphertext]));
          const data = {
            address: account.address.substring(2).toLowerCase(),
            id: uuidV4(uuidRandom),
            version: 3,
            Crypto: {
              cipher: "aes-128-ctr",
              cipherparams: { iv: hexlify(iv).substring(2) },
              ciphertext: hexlify(ciphertext).substring(2),
              kdf: "scrypt",
              kdfparams: {
                salt: hexlify(kdf.salt).substring(2),
                n: kdf.N,
                dklen: 32,
                p: kdf.p,
                r: kdf.r,
              },
              mac: mac.substring(2),
            },
          };
          if (account.mnemonic) {
            const client =
              options.client != null ? options.client : `ethers/${version}`;
            const path = account.mnemonic.path || defaultPath$1;
            const locale = account.mnemonic.locale || "en";
            const mnemonicKey = key.slice(32, 64);
            const entropy = getBytes(
              account.mnemonic.entropy,
              "account.mnemonic.entropy"
            );
            const mnemonicIv = randomBytes(16);
            const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
            const mnemonicCiphertext = getBytes(
              mnemonicAesCtr.encrypt(entropy)
            );
            const now = new Date();
            const timestamp =
              now.getUTCFullYear() +
              "-" +
              zpad$1(now.getUTCMonth() + 1, 2) +
              "-" +
              zpad$1(now.getUTCDate(), 2) +
              "T" +
              zpad$1(now.getUTCHours(), 2) +
              "-" +
              zpad$1(now.getUTCMinutes(), 2) +
              "-" +
              zpad$1(now.getUTCSeconds(), 2) +
              ".0Z";
            const gethFilename = "UTC--" + timestamp + "--" + data.address;
            data["x-ethers"] = {
              client: client,
              gethFilename: gethFilename,
              path: path,
              locale: locale,
              mnemonicCounter: hexlify(mnemonicIv).substring(2),
              mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
              version: "0.1",
            };
          }
          return JSON.stringify(data);
        }
        function encryptKeystoreJsonSync(account, password, options) {
          if (options == null) {
            options = {};
          }
          const passwordBytes = getPassword(password);
          const kdf = getEncryptKdfParams(options);
          const key = scryptSync(
            passwordBytes,
            kdf.salt,
            kdf.N,
            kdf.r,
            kdf.p,
            64
          );
          return _encryptKeystore(getBytes(key), kdf, account, options);
        }
        async function encryptKeystoreJson(account, password, options) {
          if (options == null) {
            options = {};
          }
          const passwordBytes = getPassword(password);
          const kdf = getEncryptKdfParams(options);
          const key = await scrypt(
            passwordBytes,
            kdf.salt,
            kdf.N,
            kdf.r,
            kdf.p,
            64,
            options.progressCallback
          );
          return _encryptKeystore(getBytes(key), kdf, account, options);
        }
        const defaultPath = "m/44'/60'/0'/0/0";
        const MasterSecret = new Uint8Array([
          66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100,
        ]);
        const HardenedBit = 2147483648;
        const N = BigInt(
          "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
        );
        const Nibbles = "0123456789abcdef";
        function zpad(value, length) {
          let result = "";
          while (value) {
            result = Nibbles[value % 16] + result;
            value = Math.trunc(value / 16);
          }
          while (result.length < length * 2) {
            result = "0" + result;
          }
          return "0x" + result;
        }
        function encodeBase58Check(_value) {
          const value = getBytes(_value);
          const check = dataSlice(sha256(sha256(value)), 0, 4);
          const bytes = concat([value, check]);
          return encodeBase58(bytes);
        }
        const _guard = {};
        function ser_I(index, chainCode, publicKey, privateKey) {
          const data = new Uint8Array(37);
          if (index & HardenedBit) {
            assert(
              privateKey != null,
              "cannot derive child of neutered node",
              "UNSUPPORTED_OPERATION",
              { operation: "deriveChild" }
            );
            data.set(getBytes(privateKey), 1);
          } else {
            data.set(getBytes(publicKey));
          }
          for (let i = 24; i >= 0; i -= 8) {
            data[33 + (i >> 3)] = (index >> (24 - i)) & 255;
          }
          const I = getBytes(computeHmac("sha512", chainCode, data));
          return { IL: I.slice(0, 32), IR: I.slice(32) };
        }
        function derivePath(node, path) {
          const components = path.split("/");
          assertArgument(components.length > 0, "invalid path", "path", path);
          if (components[0] === "m") {
            assertArgument(
              node.depth === 0,
              `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`,
              "path",
              path
            );
            components.shift();
          }
          let result = node;
          for (let i = 0; i < components.length; i++) {
            const component = components[i];
            if (component.match(/^[0-9]+'$/)) {
              const index = parseInt(
                component.substring(0, component.length - 1)
              );
              assertArgument(
                index < HardenedBit,
                "invalid path index",
                `path[${i}]`,
                component
              );
              result = result.deriveChild(HardenedBit + index);
            } else if (component.match(/^[0-9]+$/)) {
              const index = parseInt(component);
              assertArgument(
                index < HardenedBit,
                "invalid path index",
                `path[${i}]`,
                component
              );
              result = result.deriveChild(index);
            } else {
              assertArgument(
                false,
                "invalid path component",
                `path[${i}]`,
                component
              );
            }
          }
          return result;
        }
        class HDNodeWallet extends BaseWallet {
          publicKey;
          fingerprint;
          parentFingerprint;
          mnemonic;
          chainCode;
          path;
          index;
          depth;
          constructor(
            guard,
            signingKey,
            parentFingerprint,
            chainCode,
            path,
            index,
            depth,
            mnemonic,
            provider
          ) {
            super(signingKey, provider);
            assertPrivate(guard, _guard, "HDNodeWallet");
            defineProperties(this, {
              publicKey: signingKey.compressedPublicKey,
            });
            const fingerprint = dataSlice(
              ripemd160(sha256(this.publicKey)),
              0,
              4
            );
            defineProperties(this, {
              parentFingerprint: parentFingerprint,
              fingerprint: fingerprint,
              chainCode: chainCode,
              path: path,
              index: index,
              depth: depth,
            });
            defineProperties(this, { mnemonic: mnemonic });
          }
          connect(provider) {
            return new HDNodeWallet(
              _guard,
              this.signingKey,
              this.parentFingerprint,
              this.chainCode,
              this.path,
              this.index,
              this.depth,
              this.mnemonic,
              provider
            );
          }
          #account() {
            const account = {
              address: this.address,
              privateKey: this.privateKey,
            };
            const m = this.mnemonic;
            if (
              this.path &&
              m &&
              m.wordlist.locale === "en" &&
              m.password === ""
            ) {
              account.mnemonic = {
                path: this.path,
                locale: "en",
                entropy: m.entropy,
              };
            }
            return account;
          }
          async encrypt(password, progressCallback) {
            return await encryptKeystoreJson(this.#account(), password, {
              progressCallback: progressCallback,
            });
          }
          encryptSync(password) {
            return encryptKeystoreJsonSync(this.#account(), password);
          }
          get extendedKey() {
            assert(
              this.depth < 256,
              "Depth too deep",
              "UNSUPPORTED_OPERATION",
              { operation: "extendedKey" }
            );
            return encodeBase58Check(
              concat([
                "0x0488ADE4",
                zpad(this.depth, 1),
                this.parentFingerprint,
                zpad(this.index, 4),
                this.chainCode,
                concat(["0x00", this.privateKey]),
              ])
            );
          }
          hasPath() {
            return this.path != null;
          }
          neuter() {
            return new HDNodeVoidWallet(
              _guard,
              this.address,
              this.publicKey,
              this.parentFingerprint,
              this.chainCode,
              this.path,
              this.index,
              this.depth,
              this.provider
            );
          }
          deriveChild(_index) {
            const index = getNumber(_index, "index");
            assertArgument(
              index <= 4294967295,
              "invalid index",
              "index",
              index
            );
            let path = this.path;
            if (path) {
              path += "/" + (index & ~HardenedBit);
              if (index & HardenedBit) {
                path += "'";
              }
            }
            const { IR, IL } = ser_I(
              index,
              this.chainCode,
              this.publicKey,
              this.privateKey
            );
            const ki = new SigningKey(
              toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32)
            );
            return new HDNodeWallet(
              _guard,
              ki,
              this.fingerprint,
              hexlify(IR),
              path,
              index,
              this.depth + 1,
              this.mnemonic,
              this.provider
            );
          }
          derivePath(path) {
            return derivePath(this, path);
          }
          static #fromSeed(_seed, mnemonic) {
            assertArgument(
              isBytesLike(_seed),
              "invalid seed",
              "seed",
              "[REDACTED]"
            );
            const seed = getBytes(_seed, "seed");
            assertArgument(
              seed.length >= 16 && seed.length <= 64,
              "invalid seed",
              "seed",
              "[REDACTED]"
            );
            const I = getBytes(computeHmac("sha512", MasterSecret, seed));
            const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
            return new HDNodeWallet(
              _guard,
              signingKey,
              "0x00000000",
              hexlify(I.slice(32)),
              "m",
              0,
              0,
              mnemonic,
              null
            );
          }
          static fromExtendedKey(extendedKey) {
            const bytes = toBeArray(decodeBase58(extendedKey));
            assertArgument(
              bytes.length === 82 ||
                encodeBase58Check(bytes.slice(0, 78)) === extendedKey,
              "invalid extended key",
              "extendedKey",
              "[ REDACTED ]"
            );
            const depth = bytes[4];
            const parentFingerprint = hexlify(bytes.slice(5, 9));
            const index = parseInt(
              hexlify(bytes.slice(9, 13)).substring(2),
              16
            );
            const chainCode = hexlify(bytes.slice(13, 45));
            const key = bytes.slice(45, 78);
            switch (hexlify(bytes.slice(0, 4))) {
              case "0x0488b21e":
              case "0x043587cf": {
                const publicKey = hexlify(key);
                return new HDNodeVoidWallet(
                  _guard,
                  computeAddress(publicKey),
                  publicKey,
                  parentFingerprint,
                  chainCode,
                  null,
                  index,
                  depth,
                  null
                );
              }
              case "0x0488ade4":
              case "0x04358394 ":
                if (key[0] !== 0) {
                  break;
                }
                return new HDNodeWallet(
                  _guard,
                  new SigningKey(key.slice(1)),
                  parentFingerprint,
                  chainCode,
                  null,
                  index,
                  depth,
                  null,
                  null
                );
            }
            assertArgument(
              false,
              "invalid extended key prefix",
              "extendedKey",
              "[ REDACTED ]"
            );
          }
          static createRandom(password, path, wordlist) {
            if (password == null) {
              password = "";
            }
            if (path == null) {
              path = defaultPath;
            }
            if (wordlist == null) {
              wordlist = LangEn.wordlist();
            }
            const mnemonic = Mnemonic.fromEntropy(
              randomBytes(16),
              password,
              wordlist
            );
            return HDNodeWallet.#fromSeed(
              mnemonic.computeSeed(),
              mnemonic
            ).derivePath(path);
          }
          static fromMnemonic(mnemonic, path) {
            if (!path) {
              path = defaultPath;
            }
            return HDNodeWallet.#fromSeed(
              mnemonic.computeSeed(),
              mnemonic
            ).derivePath(path);
          }
          static fromPhrase(phrase, password, path, wordlist) {
            if (password == null) {
              password = "";
            }
            if (path == null) {
              path = defaultPath;
            }
            if (wordlist == null) {
              wordlist = LangEn.wordlist();
            }
            const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist);
            return HDNodeWallet.#fromSeed(
              mnemonic.computeSeed(),
              mnemonic
            ).derivePath(path);
          }
          static fromSeed(seed) {
            return HDNodeWallet.#fromSeed(seed, null);
          }
        }
        class HDNodeVoidWallet extends VoidSigner {
          publicKey;
          fingerprint;
          parentFingerprint;
          chainCode;
          path;
          index;
          depth;
          constructor(
            guard,
            address,
            publicKey,
            parentFingerprint,
            chainCode,
            path,
            index,
            depth,
            provider
          ) {
            super(address, provider);
            assertPrivate(guard, _guard, "HDNodeVoidWallet");
            defineProperties(this, { publicKey: publicKey });
            const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);
            defineProperties(this, {
              publicKey: publicKey,
              fingerprint: fingerprint,
              parentFingerprint: parentFingerprint,
              chainCode: chainCode,
              path: path,
              index: index,
              depth: depth,
            });
          }
          connect(provider) {
            return new HDNodeVoidWallet(
              _guard,
              this.address,
              this.publicKey,
              this.parentFingerprint,
              this.chainCode,
              this.path,
              this.index,
              this.depth,
              provider
            );
          }
          get extendedKey() {
            assert(
              this.depth < 256,
              "Depth too deep",
              "UNSUPPORTED_OPERATION",
              { operation: "extendedKey" }
            );
            return encodeBase58Check(
              concat([
                "0x0488B21E",
                zpad(this.depth, 1),
                this.parentFingerprint,
                zpad(this.index, 4),
                this.chainCode,
                this.publicKey,
              ])
            );
          }
          hasPath() {
            return this.path != null;
          }
          deriveChild(_index) {
            const index = getNumber(_index, "index");
            assertArgument(
              index <= 4294967295,
              "invalid index",
              "index",
              index
            );
            let path = this.path;
            if (path) {
              path += "/" + (index & ~HardenedBit);
              if (index & HardenedBit) {
                path += "'";
              }
            }
            const { IR, IL } = ser_I(
              index,
              this.chainCode,
              this.publicKey,
              null
            );
            const Ki = SigningKey.addPoints(IL, this.publicKey, true);
            const address = computeAddress(Ki);
            return new HDNodeVoidWallet(
              _guard,
              address,
              Ki,
              this.fingerprint,
              hexlify(IR),
              path,
              index,
              this.depth + 1,
              this.provider
            );
          }
          derivePath(path) {
            return derivePath(this, path);
          }
        }
        function getAccountPath(_index) {
          const index = getNumber(_index, "index");
          assertArgument(
            index >= 0 && index < HardenedBit,
            "invalid account index",
            "index",
            index
          );
          return `m/44'/60'/${index}'/0/0`;
        }
        function getIndexedAccountPath(_index) {
          const index = getNumber(_index, "index");
          assertArgument(
            index >= 0 && index < HardenedBit,
            "invalid account index",
            "index",
            index
          );
          return `m/44'/60'/0'/0/${index}`;
        }
        function isCrowdsaleJson(json) {
          try {
            const data = JSON.parse(json);
            if (data.encseed) {
              return true;
            }
          } catch (error) {}
          return false;
        }
        function decryptCrowdsaleJson(json, _password) {
          const data = JSON.parse(json);
          const password = getPassword(_password);
          const address = getAddress(spelunk(data, "ethaddr:string!"));
          const encseed = looseArrayify(spelunk(data, "encseed:string!"));
          assertArgument(
            encseed && encseed.length % 16 === 0,
            "invalid encseed",
            "json",
            json
          );
          const key = getBytes(
            pbkdf2(password, password, 2e3, 32, "sha256")
          ).slice(0, 16);
          const iv = encseed.slice(0, 16);
          const encryptedSeed = encseed.slice(16);
          const aesCbc = new CBC(key, iv);
          const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
          let seedHex = "";
          for (let i = 0; i < seed.length; i++) {
            seedHex += String.fromCharCode(seed[i]);
          }
          return { address: address, privateKey: id(seedHex) };
        }
        function stall(duration) {
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve();
            }, duration);
          });
        }
        class Wallet extends BaseWallet {
          constructor(key, provider) {
            if (typeof key === "string" && !key.startsWith("0x")) {
              key = "0x" + key;
            }
            let signingKey =
              typeof key === "string" ? new SigningKey(key) : key;
            super(signingKey, provider);
          }
          connect(provider) {
            return new Wallet(this.signingKey, provider);
          }
          async encrypt(password, progressCallback) {
            const account = {
              address: this.address,
              privateKey: this.privateKey,
            };
            return await encryptKeystoreJson(account, password, {
              progressCallback: progressCallback,
            });
          }
          encryptSync(password) {
            const account = {
              address: this.address,
              privateKey: this.privateKey,
            };
            return encryptKeystoreJsonSync(account, password);
          }
          static #fromAccount(account) {
            assertArgument(
              account,
              "invalid JSON wallet",
              "json",
              "[ REDACTED ]"
            );
            if (
              "mnemonic" in account &&
              account.mnemonic &&
              account.mnemonic.locale === "en"
            ) {
              const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
              const wallet = HDNodeWallet.fromMnemonic(
                mnemonic,
                account.mnemonic.path
              );
              if (
                wallet.address === account.address &&
                wallet.privateKey === account.privateKey
              ) {
                return wallet;
              }
              console.log(
                "WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key"
              );
            }
            const wallet = new Wallet(account.privateKey);
            assertArgument(
              wallet.address === account.address,
              "address/privateKey mismatch",
              "json",
              "[ REDACTED ]"
            );
            return wallet;
          }
          static async fromEncryptedJson(json, password, progress) {
            let account = null;
            if (isKeystoreJson(json)) {
              account = await decryptKeystoreJson(json, password, progress);
            } else if (isCrowdsaleJson(json)) {
              if (progress) {
                progress(0);
                await stall(0);
              }
              account = decryptCrowdsaleJson(json, password);
              if (progress) {
                progress(1);
                await stall(0);
              }
            }
            return Wallet.#fromAccount(account);
          }
          static fromEncryptedJsonSync(json, password) {
            let account = null;
            if (isKeystoreJson(json)) {
              account = decryptKeystoreJsonSync(json, password);
            } else if (isCrowdsaleJson(json)) {
              account = decryptCrowdsaleJson(json, password);
            } else {
              assertArgument(
                false,
                "invalid JSON wallet",
                "json",
                "[ REDACTED ]"
              );
            }
            return Wallet.#fromAccount(account);
          }
          static createRandom(provider) {
            const wallet = HDNodeWallet.createRandom();
            if (provider) {
              return wallet.connect(provider);
            }
            return wallet;
          }
          static fromPhrase(phrase, provider) {
            const wallet = HDNodeWallet.fromPhrase(phrase);
            if (provider) {
              return wallet.connect(provider);
            }
            return wallet;
          }
        }
        const Base64 =
          ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
        function decodeBits(width, data) {
          const maxValue = (1 << width) - 1;
          const result = [];
          let accum = 0,
            bits = 0,
            flood = 0;
          for (let i = 0; i < data.length; i++) {
            accum = (accum << 6) | Base64.indexOf(data[i]);
            bits += 6;
            while (bits >= width) {
              const value = accum >> (bits - width);
              accum &= (1 << (bits - width)) - 1;
              bits -= width;
              if (value === 0) {
                flood += maxValue;
              } else {
                result.push(value + flood);
                flood = 0;
              }
            }
          }
          return result;
        }
        function decodeOwlA(data, accents) {
          let words = decodeOwl(data).join(",");
          accents.split(/,/g).forEach((accent) => {
            const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
            assertArgument(
              match !== null,
              "internal error parsing accents",
              "accents",
              accents
            );
            let posOffset = 0;
            const positions = decodeBits(parseInt(match[3]), match[4]);
            const charCode = parseInt(match[2]);
            const regex = new RegExp(`([${match[1]}])`, "g");
            words = words.replace(regex, (all, letter) => {
              const rem = --positions[posOffset];
              if (rem === 0) {
                letter = String.fromCharCode(letter.charCodeAt(0), charCode);
                posOffset++;
              }
              return letter;
            });
          });
          return words.split(",");
        }
        class WordlistOwlA extends WordlistOwl {
          #accent;
          constructor(locale, data, accent, checksum) {
            super(locale, data, checksum);
            this.#accent = accent;
          }
          get _accent() {
            return this.#accent;
          }
          _decodeWords() {
            return decodeOwlA(this._data, this._accent);
          }
        }
        const wordlists = { en: LangEn.wordlist() };
        var ethers = Object.freeze({
          __proto__: null,
          AbiCoder: AbiCoder,
          AbstractProvider: AbstractProvider,
          AbstractSigner: AbstractSigner,
          AlchemyProvider: AlchemyProvider,
          AnkrProvider: AnkrProvider,
          BaseContract: BaseContract,
          BaseWallet: BaseWallet,
          Block: Block,
          BrowserProvider: BrowserProvider,
          CloudflareProvider: CloudflareProvider,
          ConstructorFragment: ConstructorFragment,
          Contract: Contract,
          ContractEventPayload: ContractEventPayload,
          ContractFactory: ContractFactory,
          ContractTransactionReceipt: ContractTransactionReceipt,
          ContractTransactionResponse: ContractTransactionResponse,
          ContractUnknownEventPayload: ContractUnknownEventPayload,
          EnsPlugin: EnsPlugin,
          EnsResolver: EnsResolver,
          ErrorDescription: ErrorDescription,
          ErrorFragment: ErrorFragment,
          EtherSymbol: EtherSymbol,
          EtherscanPlugin: EtherscanPlugin,
          EtherscanProvider: EtherscanProvider,
          EventFragment: EventFragment,
          EventLog: EventLog,
          EventPayload: EventPayload,
          FallbackFragment: FallbackFragment,
          FallbackProvider: FallbackProvider,
          FeeData: FeeData,
          FeeDataNetworkPlugin: FeeDataNetworkPlugin,
          FetchCancelSignal: FetchCancelSignal,
          FetchRequest: FetchRequest,
          FetchResponse: FetchResponse,
          FetchUrlFeeDataNetworkPlugin: FetchUrlFeeDataNetworkPlugin,
          FixedNumber: FixedNumber,
          Fragment: Fragment,
          FunctionFragment: FunctionFragment,
          GasCostPlugin: GasCostPlugin,
          HDNodeVoidWallet: HDNodeVoidWallet,
          HDNodeWallet: HDNodeWallet,
          Indexed: Indexed,
          InfuraProvider: InfuraProvider,
          InfuraWebSocketProvider: InfuraWebSocketProvider,
          Interface: Interface,
          IpcSocketProvider: IpcSocketProvider,
          JsonRpcApiProvider: JsonRpcApiProvider,
          JsonRpcProvider: JsonRpcProvider,
          JsonRpcSigner: JsonRpcSigner,
          LangEn: LangEn,
          Log: Log,
          LogDescription: LogDescription,
          MaxInt256: MaxInt256,
          MaxUint256: MaxUint256,
          MessagePrefix: MessagePrefix,
          MinInt256: MinInt256,
          Mnemonic: Mnemonic,
          MulticoinProviderPlugin: MulticoinProviderPlugin,
          N: N$1,
          NamedFragment: NamedFragment,
          Network: Network,
          NetworkPlugin: NetworkPlugin,
          NonceManager: NonceManager,
          ParamType: ParamType,
          PocketProvider: PocketProvider,
          QuickNodeProvider: QuickNodeProvider,
          Result: Result,
          Signature: Signature,
          SigningKey: SigningKey,
          SocketBlockSubscriber: SocketBlockSubscriber,
          SocketEventSubscriber: SocketEventSubscriber,
          SocketPendingSubscriber: SocketPendingSubscriber,
          SocketProvider: SocketProvider,
          SocketSubscriber: SocketSubscriber,
          StructFragment: StructFragment,
          Transaction: Transaction,
          TransactionDescription: TransactionDescription,
          TransactionReceipt: TransactionReceipt,
          TransactionResponse: TransactionResponse,
          Typed: Typed,
          TypedDataEncoder: TypedDataEncoder,
          UndecodedEventLog: UndecodedEventLog,
          UnmanagedSubscriber: UnmanagedSubscriber,
          Utf8ErrorFuncs: Utf8ErrorFuncs,
          VoidSigner: VoidSigner,
          Wallet: Wallet,
          WebSocketProvider: WebSocketProvider,
          WeiPerEther: WeiPerEther,
          Wordlist: Wordlist,
          WordlistOwl: WordlistOwl,
          WordlistOwlA: WordlistOwlA,
          ZeroAddress: ZeroAddress,
          ZeroHash: ZeroHash,
          accessListify: accessListify,
          assert: assert,
          assertArgument: assertArgument,
          assertArgumentCount: assertArgumentCount,
          assertNormalize: assertNormalize,
          assertPrivate: assertPrivate,
          checkResultErrors: checkResultErrors,
          computeAddress: computeAddress,
          computeHmac: computeHmac,
          concat: concat,
          copyRequest: copyRequest,
          dataLength: dataLength,
          dataSlice: dataSlice,
          decodeBase58: decodeBase58,
          decodeBase64: decodeBase64,
          decodeBytes32String: decodeBytes32String,
          decodeRlp: decodeRlp,
          decryptCrowdsaleJson: decryptCrowdsaleJson,
          decryptKeystoreJson: decryptKeystoreJson,
          decryptKeystoreJsonSync: decryptKeystoreJsonSync,
          defaultPath: defaultPath,
          defineProperties: defineProperties,
          dnsEncode: dnsEncode,
          encodeBase58: encodeBase58,
          encodeBase64: encodeBase64,
          encodeBytes32String: encodeBytes32String,
          encodeRlp: encodeRlp,
          encryptKeystoreJson: encryptKeystoreJson,
          encryptKeystoreJsonSync: encryptKeystoreJsonSync,
          ensNormalize: ensNormalize,
          formatEther: formatEther,
          formatUnits: formatUnits,
          fromTwos: fromTwos,
          getAccountPath: getAccountPath,
          getAddress: getAddress,
          getBigInt: getBigInt,
          getBytes: getBytes,
          getBytesCopy: getBytesCopy,
          getCreate2Address: getCreate2Address,
          getCreateAddress: getCreateAddress,
          getDefaultProvider: getDefaultProvider,
          getIcapAddress: getIcapAddress,
          getIndexedAccountPath: getIndexedAccountPath,
          getNumber: getNumber,
          getUint: getUint,
          hashMessage: hashMessage,
          hexlify: hexlify,
          id: id,
          isAddress: isAddress,
          isAddressable: isAddressable,
          isBytesLike: isBytesLike,
          isCallException: isCallException,
          isCrowdsaleJson: isCrowdsaleJson,
          isError: isError,
          isHexString: isHexString,
          isKeystoreJson: isKeystoreJson,
          isValidName: isValidName,
          keccak256: keccak256,
          lock: lock,
          makeError: makeError,
          mask: mask,
          namehash: namehash,
          parseEther: parseEther,
          parseUnits: parseUnits$1,
          pbkdf2: pbkdf2,
          randomBytes: randomBytes,
          recoverAddress: recoverAddress,
          resolveAddress: resolveAddress,
          resolveProperties: resolveProperties,
          ripemd160: ripemd160,
          scrypt: scrypt,
          scryptSync: scryptSync,
          sha256: sha256,
          sha512: sha512,
          showThrottleMessage: showThrottleMessage,
          solidityPacked: solidityPacked,
          solidityPackedKeccak256: solidityPackedKeccak256,
          solidityPackedSha256: solidityPackedSha256,
          stripZerosLeft: stripZerosLeft,
          toBeArray: toBeArray,
          toBeHex: toBeHex,
          toBigInt: toBigInt,
          toNumber: toNumber,
          toQuantity: toQuantity,
          toTwos: toTwos,
          toUtf8Bytes: toUtf8Bytes,
          toUtf8CodePoints: toUtf8CodePoints,
          toUtf8String: toUtf8String,
          uuidV4: uuidV4,
          verifyMessage: verifyMessage,
          verifyTypedData: verifyTypedData,
          version: version,
          wordlists: wordlists,
          zeroPadBytes: zeroPadBytes,
          zeroPadValue: zeroPadValue,
        });
        exports.AbiCoder = AbiCoder;
        exports.AbstractProvider = AbstractProvider;
        exports.AbstractSigner = AbstractSigner;
        exports.AlchemyProvider = AlchemyProvider;
        exports.AnkrProvider = AnkrProvider;
        exports.BaseContract = BaseContract;
        exports.BaseWallet = BaseWallet;
        exports.Block = Block;
        exports.BrowserProvider = BrowserProvider;
        exports.CloudflareProvider = CloudflareProvider;
        exports.ConstructorFragment = ConstructorFragment;
        exports.Contract = Contract;
        exports.ContractEventPayload = ContractEventPayload;
        exports.ContractFactory = ContractFactory;
        exports.ContractTransactionReceipt = ContractTransactionReceipt;
        exports.ContractTransactionResponse = ContractTransactionResponse;
        exports.ContractUnknownEventPayload = ContractUnknownEventPayload;
        exports.EnsPlugin = EnsPlugin;
        exports.EnsResolver = EnsResolver;
        exports.ErrorDescription = ErrorDescription;
        exports.ErrorFragment = ErrorFragment;
        exports.EtherSymbol = EtherSymbol;
        exports.EtherscanPlugin = EtherscanPlugin;
        exports.EtherscanProvider = EtherscanProvider;
        exports.EventFragment = EventFragment;
        exports.EventLog = EventLog;
        exports.EventPayload = EventPayload;
        exports.FallbackFragment = FallbackFragment;
        exports.FallbackProvider = FallbackProvider;
        exports.FeeData = FeeData;
        exports.FeeDataNetworkPlugin = FeeDataNetworkPlugin;
        exports.FetchCancelSignal = FetchCancelSignal;
        exports.FetchRequest = FetchRequest;
        exports.FetchResponse = FetchResponse;
        exports.FetchUrlFeeDataNetworkPlugin = FetchUrlFeeDataNetworkPlugin;
        exports.FixedNumber = FixedNumber;
        exports.Fragment = Fragment;
        exports.FunctionFragment = FunctionFragment;
        exports.GasCostPlugin = GasCostPlugin;
        exports.HDNodeVoidWallet = HDNodeVoidWallet;
        exports.HDNodeWallet = HDNodeWallet;
        exports.Indexed = Indexed;
        exports.InfuraProvider = InfuraProvider;
        exports.InfuraWebSocketProvider = InfuraWebSocketProvider;
        exports.Interface = Interface;
        exports.IpcSocketProvider = IpcSocketProvider;
        exports.JsonRpcApiProvider = JsonRpcApiProvider;
        exports.JsonRpcProvider = JsonRpcProvider;
        exports.JsonRpcSigner = JsonRpcSigner;
        exports.LangEn = LangEn;
        exports.Log = Log;
        exports.LogDescription = LogDescription;
        exports.MaxInt256 = MaxInt256;
        exports.MaxUint256 = MaxUint256;
        exports.MessagePrefix = MessagePrefix;
        exports.MinInt256 = MinInt256;
        exports.Mnemonic = Mnemonic;
        exports.MulticoinProviderPlugin = MulticoinProviderPlugin;
        exports.N = N$1;
        exports.NamedFragment = NamedFragment;
        exports.Network = Network;
        exports.NetworkPlugin = NetworkPlugin;
        exports.NonceManager = NonceManager;
        exports.ParamType = ParamType;
        exports.PocketProvider = PocketProvider;
        exports.QuickNodeProvider = QuickNodeProvider;
        exports.Result = Result;
        exports.Signature = Signature;
        exports.SigningKey = SigningKey;
        exports.SocketBlockSubscriber = SocketBlockSubscriber;
        exports.SocketEventSubscriber = SocketEventSubscriber;
        exports.SocketPendingSubscriber = SocketPendingSubscriber;
        exports.SocketProvider = SocketProvider;
        exports.SocketSubscriber = SocketSubscriber;
        exports.StructFragment = StructFragment;
        exports.Transaction = Transaction;
        exports.TransactionDescription = TransactionDescription;
        exports.TransactionReceipt = TransactionReceipt;
        exports.TransactionResponse = TransactionResponse;
        exports.Typed = Typed;
        exports.TypedDataEncoder = TypedDataEncoder;
        exports.UndecodedEventLog = UndecodedEventLog;
        exports.UnmanagedSubscriber = UnmanagedSubscriber;
        exports.Utf8ErrorFuncs = Utf8ErrorFuncs;
        exports.VoidSigner = VoidSigner;
        exports.Wallet = Wallet;
        exports.WebSocketProvider = WebSocketProvider;
        exports.WeiPerEther = WeiPerEther;
        exports.Wordlist = Wordlist;
        exports.WordlistOwl = WordlistOwl;
        exports.WordlistOwlA = WordlistOwlA;
        exports.ZeroAddress = ZeroAddress;
        exports.ZeroHash = ZeroHash;
        exports.accessListify = accessListify;
        exports.assert = assert;
        exports.assertArgument = assertArgument;
        exports.assertArgumentCount = assertArgumentCount;
        exports.assertNormalize = assertNormalize;
        exports.assertPrivate = assertPrivate;
        exports.checkResultErrors = checkResultErrors;
        exports.computeAddress = computeAddress;
        exports.computeHmac = computeHmac;
        exports.concat = concat;
        exports.copyRequest = copyRequest;
        exports.dataLength = dataLength;
        exports.dataSlice = dataSlice;
        exports.decodeBase58 = decodeBase58;
        exports.decodeBase64 = decodeBase64;
        exports.decodeBytes32String = decodeBytes32String;
        exports.decodeRlp = decodeRlp;
        exports.decryptCrowdsaleJson = decryptCrowdsaleJson;
        exports.decryptKeystoreJson = decryptKeystoreJson;
        exports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;
        exports.defaultPath = defaultPath;
        exports.defineProperties = defineProperties;
        exports.dnsEncode = dnsEncode;
        exports.encodeBase58 = encodeBase58;
        exports.encodeBase64 = encodeBase64;
        exports.encodeBytes32String = encodeBytes32String;
        exports.encodeRlp = encodeRlp;
        exports.encryptKeystoreJson = encryptKeystoreJson;
        exports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;
        exports.ensNormalize = ensNormalize;
        exports.ethers = ethers;
        exports.formatEther = formatEther;
        exports.formatUnits = formatUnits;
        exports.fromTwos = fromTwos;
        exports.getAccountPath = getAccountPath;
        exports.getAddress = getAddress;
        exports.getBigInt = getBigInt;
        exports.getBytes = getBytes;
        exports.getBytesCopy = getBytesCopy;
        exports.getCreate2Address = getCreate2Address;
        exports.getCreateAddress = getCreateAddress;
        exports.getDefaultProvider = getDefaultProvider;
        exports.getIcapAddress = getIcapAddress;
        exports.getIndexedAccountPath = getIndexedAccountPath;
        exports.getNumber = getNumber;
        exports.getUint = getUint;
        exports.hashMessage = hashMessage;
        exports.hexlify = hexlify;
        exports.id = id;
        exports.isAddress = isAddress;
        exports.isAddressable = isAddressable;
        exports.isBytesLike = isBytesLike;
        exports.isCallException = isCallException;
        exports.isCrowdsaleJson = isCrowdsaleJson;
        exports.isError = isError;
        exports.isHexString = isHexString;
        exports.isKeystoreJson = isKeystoreJson;
        exports.isValidName = isValidName;
        exports.keccak256 = keccak256;
        exports.lock = lock;
        exports.makeError = makeError;
        exports.mask = mask;
        exports.namehash = namehash;
        exports.parseEther = parseEther;
        exports.parseUnits = parseUnits$1;
        exports.pbkdf2 = pbkdf2;
        exports.randomBytes = randomBytes;
        exports.recoverAddress = recoverAddress;
        exports.resolveAddress = resolveAddress;
        exports.resolveProperties = resolveProperties;
        exports.ripemd160 = ripemd160;
        exports.scrypt = scrypt;
        exports.scryptSync = scryptSync;
        exports.sha256 = sha256;
        exports.sha512 = sha512;
        exports.showThrottleMessage = showThrottleMessage;
        exports.solidityPacked = solidityPacked;
        exports.solidityPackedKeccak256 = solidityPackedKeccak256;
        exports.solidityPackedSha256 = solidityPackedSha256;
        exports.stripZerosLeft = stripZerosLeft;
        exports.toBeArray = toBeArray;
        exports.toBeHex = toBeHex;
        exports.toBigInt = toBigInt;
        exports.toNumber = toNumber;
        exports.toQuantity = toQuantity;
        exports.toTwos = toTwos;
        exports.toUtf8Bytes = toUtf8Bytes;
        exports.toUtf8CodePoints = toUtf8CodePoints;
        exports.toUtf8String = toUtf8String;
        exports.uuidV4 = uuidV4;
        exports.verifyMessage = verifyMessage;
        exports.verifyTypedData = verifyTypedData;
        exports.version = version;
        exports.wordlists = wordlists;
        exports.zeroPadBytes = zeroPadBytes;
        exports.zeroPadValue = zeroPadValue;
      });
    </script>
    <script>
      const html2pdf_base64 = `
            LyohIEZvciBsaWNlbnNlIGluZm9ybWF0aW9uIHBsZWFzZSBzZWUgaHRtbDJwZGYuYnVuZGxlLm1pbi5qcy5MSUNFTlNFLnR4dCAqLwohZnVuY3Rpb24oZSx0KXsib2JqZWN0Ij09dHlwZW9mIGV4cG9ydHMmJiJvYmplY3QiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSgiaHRtbDJwZGYiLFtdLHQpOiJvYmplY3QiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLmh0bWwycGRmPXQoKTplLmh0bWwycGRmPXQoKX0oc2VsZixmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlLHQsQT17Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQpeyhudWxsPT10fHx0PmUubGVuZ3RoKSYmKHQ9ZS5sZW5ndGgpO2Zvcih2YXIgQT0wLHI9QXJyYXkodCk7QTx0O0ErKylyW0FdPWVbQV07cmV0dXJuIHJ9QS5yKHQpLEEuZCh0LHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSl9LCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9QS5yKHQpLEEuZCh0LHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9fSl9LCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSx0LEEscixuLHMsaSl7dHJ5e3ZhciBvPWVbc10oaSksYT1vLnZhbHVlfWNhdGNoKGUpe3JldHVybiB2b2lkIEEoZSl9by5kb25lP3QoYSk6UHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4ocixuKX1mdW5jdGlvbiBuKGUpe3JldHVybiBmdW5jdGlvbigpe3ZhciB0PXRoaXMsQT1hcmd1bWVudHM7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4scyl7dmFyIGk9ZS5hcHBseSh0LEEpO2Z1bmN0aW9uIG8oZSl7cihpLG4scyxvLGEsIm5leHQiLGUpfWZ1bmN0aW9uIGEoZSl7cihpLG4scyxvLGEsInRocm93IixlKX1vKHZvaWQgMCl9KX19QS5yKHQpLEEuZCh0LHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIG59fSl9LCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtBLnIodCksQS5kKHQse2RlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbn19KTt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzIik7ZnVuY3Rpb24gbihlLHQsQSl7cmV0dXJuKHQ9KDAsci5kZWZhdWx0KSh0KSlpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOkEsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPUEsZX19LCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKGUsdCl7dmFyIEE9bnVsbD09ZT9udWxsOiJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZlW1N5bWJvbC5pdGVyYXRvcl18fGVbIkBAaXRlcmF0b3IiXTtpZihudWxsIT1BKXt2YXIgcixuLHMsaSxvPVtdLGE9ITAsbD0hMTt0cnl7aWYocz0oQT1BLmNhbGwoZSkpLm5leHQsMD09PXQpe2lmKE9iamVjdChBKSE9PUEpcmV0dXJuO2E9ITF9ZWxzZSBmb3IoOyEoYT0ocj1zLmNhbGwoQSkpLmRvbmUpJiYoby5wdXNoKHIudmFsdWUpLG8ubGVuZ3RoIT09dCk7YT0hMCk7fWNhdGNoKGUpe2w9ITAsbj1lfWZpbmFsbHl7dHJ5e2lmKCFhJiZudWxsIT1BLnJldHVybiYmKGk9QS5yZXR1cm4oKSxPYmplY3QoaSkhPT1pKSlyZXR1cm59ZmluYWxseXtpZihsKXRocm93IG59fXJldHVybiBvfX1BLnIodCksQS5kKHQse2RlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlUmVzdC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKCl7dGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC4iKX1BLnIodCksQS5kKHQse2RlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QS5yKHQpLEEuZCh0LHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIG99fSk7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIik7ZnVuY3Rpb24gbyhlLHQpe3JldHVybigwLHIuZGVmYXVsdCkoZSl8fCgwLG4uZGVmYXVsdCkoZSx0KXx8KDAscy5kZWZhdWx0KShlLHQpfHwoMCxpLmRlZmF1bHQpKCl9fSwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9QcmltaXRpdmUuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QS5yKHQpLEEuZCh0LHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIG59fSk7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIik7ZnVuY3Rpb24gbihlLHQpe2lmKCJvYmplY3QiIT0oMCxyLmRlZmF1bHQpKGUpfHwhZSlyZXR1cm4gZTt2YXIgQT1lW1N5bWJvbC50b1ByaW1pdGl2ZV07aWYodm9pZCAwIT09QSl7dmFyIG49QS5jYWxsKGUsdHx8ImRlZmF1bHQiKTtpZigib2JqZWN0IiE9KDAsci5kZWZhdWx0KShuKSlyZXR1cm4gbjt0aHJvdyBuZXcgVHlwZUVycm9yKCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLiIpfXJldHVybigic3RyaW5nIj09PXQ/U3RyaW5nOk51bWJlcikoZSl9fSwiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Qcm9wZXJ0eUtleS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtBLnIodCksQS5kKHQse2RlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gc319KTt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvUHJpbWl0aXZlLmpzIik7ZnVuY3Rpb24gcyhlKXt2YXIgdD0oMCxuLmRlZmF1bHQpKGUsInN0cmluZyIpO3JldHVybiJzeW1ib2wiPT0oMCxyLmRlZmF1bHQpKHQpP3Q6dCsiIn19LCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gcj0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgZX0scihlKX1BLnIodCksQS5kKHQse2RlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0Eucih0KSxBLmQodCx7ZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiBufX0pO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanMiKTtmdW5jdGlvbiBuKGUsdCl7aWYoZSl7aWYoInN0cmluZyI9PXR5cGVvZiBlKXJldHVybigwLHIuZGVmYXVsdCkoZSx0KTt2YXIgQT17fS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVybiJPYmplY3QiPT09QSYmZS5jb25zdHJ1Y3RvciYmKEE9ZS5jb25zdHJ1Y3Rvci5uYW1lKSwiTWFwIj09PUF8fCJTZXQiPT09QT9BcnJheS5mcm9tKGUpOiJBcmd1bWVudHMiPT09QXx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QoQSk/KDAsci5kZWZhdWx0KShlLHQpOnZvaWQgMH19fSwiLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmVzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0Eucih0KSxBLmQodCx7QUVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gVGV9LEFuaW1hdGVDb2xvckVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gTGV9LEFuaW1hdGVFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIFNlfSxBbmltYXRlVHJhbnNmb3JtRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBJZX0sQm91bmRpbmdCb3g6ZnVuY3Rpb24oKXtyZXR1cm4gYWV9LENCMTpmdW5jdGlvbigpe3JldHVybiBTfSxDQjI6ZnVuY3Rpb24oKXtyZXR1cm4gTH0sQ0IzOmZ1bmN0aW9uKCl7cmV0dXJuIEl9LENCNDpmdW5jdGlvbigpe3JldHVybiBOfSxDYW52ZzpmdW5jdGlvbigpe3JldHVybiBwdH0sQ2lyY2xlRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB3ZX0sQ2xpcFBhdGhFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHR0fSxEZWZzRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBqZX0sRGVzY0VsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gYXR9LERvY3VtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIGh0fSxFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIEFlfSxFbGxpcHNlRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBCZX0sRmVDb2xvck1hdHJpeEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gWmV9LEZlQ29tcG9zaXRlRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBzdH0sRmVEcm9wU2hhZG93RWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBydH0sRmVHYXVzc2lhbkJsdXJFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIGl0fSxGZU1vcnBob2xvZ3lFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIG50fSxGaWx0ZXJFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIEF0fSxGb250OmZ1bmN0aW9uKCl7cmV0dXJuIG9lfSxGb250RWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBOZX0sRm9udEZhY2VFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIGtlfSxHRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB4ZX0sR2x5cGhFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIGhlfSxHcmFkaWVudEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gRmV9LEltYWdlRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBLZX0sTGluZUVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4geWV9LExpbmVhckdyYWRpZW50RWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBRZX0sTWFya2VyRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBfZX0sTWFza0VsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gJGV9LE1hdHJpeDpmdW5jdGlvbigpe3JldHVybiBKfSxNaXNzaW5nR2x5cGhFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIEhlfSxNb3VzZTpmdW5jdGlvbigpe3JldHVybiBEfSxQU0VVRE9fWkVSTzpmdW5jdGlvbigpe3JldHVybiBGfSxQYXJzZXI6ZnVuY3Rpb24oKXtyZXR1cm4gcX0sUGF0aEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdWV9LFBhdGhQYXJzZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbGV9LFBhdHRlcm5FbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIENlfSxQb2ludDpmdW5jdGlvbigpe3JldHVybiBNfSxQb2x5Z29uRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBiZX0sUG9seWxpbmVFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHZlfSxQcm9wZXJ0eTpmdW5jdGlvbigpe3JldHVybiBUfSxRQjE6ZnVuY3Rpb24oKXtyZXR1cm4ga30sUUIyOmZ1bmN0aW9uKCl7cmV0dXJuIEh9LFFCMzpmdW5jdGlvbigpe3JldHVybiBQfSxSYWRpYWxHcmFkaWVudEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gVWV9LFJlY3RFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIG1lfSxSZW5kZXJlZEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gY2V9LFJvdGF0ZTpmdW5jdGlvbigpe3JldHVybiBYfSxTVkdFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIGdlfSxTVkdGb250TG9hZGVyOmZ1bmN0aW9uKCl7cmV0dXJuIEdlfSxTY2FsZTpmdW5jdGlvbigpe3JldHVybiBZfSxTY3JlZW46ZnVuY3Rpb24oKXtyZXR1cm4gVn0sU2tldzpmdW5jdGlvbigpe3JldHVybiBafSxTa2V3WDpmdW5jdGlvbigpe3JldHVybiAkfSxTa2V3WTpmdW5jdGlvbigpe3JldHVybiBlZX0sU3RvcEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gRWV9LFN0eWxlRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB6ZX0sU3ltYm9sRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBWZX0sVFJlZkVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gUGV9LFRTcGFuRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBmZX0sVGV4dEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gZGV9LFRleHRQYXRoRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBEZX0sVGl0bGVFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIG90fSxUcmFuc2Zvcm06ZnVuY3Rpb24oKXtyZXR1cm4gdGV9LFRyYW5zbGF0ZTpmdW5jdGlvbigpe3JldHVybiBXfSxVbmtub3duRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiByZX0sVXNlRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiBxZX0sVmlld1BvcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gT30sY29tcHJlc3NTcGFjZXM6ZnVuY3Rpb24oKXtyZXR1cm4gY30sZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiBwdH0sZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eTpmdW5jdGlvbigpe3JldHVybiB4fSxub3JtYWxpemVBdHRyaWJ1dGVOYW1lOmZ1bmN0aW9uKCl7cmV0dXJuIHB9LG5vcm1hbGl6ZUNvbG9yOmZ1bmN0aW9uKCl7cmV0dXJuIG19LHBhcnNlRXh0ZXJuYWxVcmw6ZnVuY3Rpb24oKXtyZXR1cm4gZ30scHJlc2V0czpmdW5jdGlvbigpe3JldHVybiBsfSx0b051bWJlcnM6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sdHJpbUxlZnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX0sdHJpbVJpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIGh9LHZlY3Rvck1hZ25pdHVkZTpmdW5jdGlvbigpe3JldHVybiBRfSx2ZWN0b3JzQW5nbGU6ZnVuY3Rpb24oKXtyZXR1cm4gRX0sdmVjdG9yc1JhdGlvOmZ1bmN0aW9uKCl7cmV0dXJuIFV9fSksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanMiKTt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzIiksbj0oQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGguanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzIikpLHM9KEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmVuZHMtd2l0aC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9yYWYvaW5kZXguanMiKSksaT0oQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvcmdiY29sb3IvaW5kZXguanMiKSksbz0oQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcy5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZXZlcnNlLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvc3ZnLXBhdGhkYXRhL2xpYi9TVkdQYXRoRGF0YS5tb2R1bGUuanMiKSksYT0oQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9zdGFja2JsdXItY2FudmFzL2Rpc3Qvc3RhY2tibHVyLWVzLmpzIikpLGw9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsb2Zmc2NyZWVuOmZ1bmN0aW9uKCl7dmFye0RPTVBhcnNlcjplfT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sdD17d2luZG93Om51bGwsaWdub3JlQW5pbWF0aW9uOiEwLGlnbm9yZU1vdXNlOiEwLERPTVBhcnNlcjplLGNyZWF0ZUNhbnZhcyhlLHQpe3JldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKGUsdCl9LGNyZWF0ZUltYWdlKGUpe3JldHVybigwLHIuZGVmYXVsdCkoZnVuY3Rpb24qKCl7dmFyIHQ9eWllbGQgZmV0Y2goZSksQT15aWVsZCB0LmJsb2IoKTtyZXR1cm4geWllbGQgY3JlYXRlSW1hZ2VCaXRtYXAoQSl9KSgpfX07cmV0dXJuInVuZGVmaW5lZCI9PXR5cGVvZiBET01QYXJzZXImJnZvaWQgMCE9PWV8fFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodCwiRE9NUGFyc2VyIiksdH0sbm9kZTpmdW5jdGlvbihlKXt2YXJ7RE9NUGFyc2VyOnQsY2FudmFzOkEsZmV0Y2g6cn09ZTtyZXR1cm57d2luZG93Om51bGwsaWdub3JlQW5pbWF0aW9uOiEwLGlnbm9yZU1vdXNlOiEwLERPTVBhcnNlcjp0LGZldGNoOnIsY3JlYXRlQ2FudmFzOkEuY3JlYXRlQ2FudmFzLGNyZWF0ZUltYWdlOkEubG9hZEltYWdlfX19KTtmdW5jdGlvbiBjKGUpe3JldHVybiBlLnJlcGxhY2UoLyg/IVx1MzAwMClccysvZ20sIiAiKX1mdW5jdGlvbiB1KGUpe3JldHVybiBlLnJlcGxhY2UoL15bXG4gXHRdKy8sIiIpfWZ1bmN0aW9uIGgoZSl7cmV0dXJuIGUucmVwbGFjZSgvW1xuIFx0XSskLywiIil9ZnVuY3Rpb24gZChlKXtyZXR1cm4oKGV8fCIiKS5tYXRjaCgvLT8oXGQrKD86XC5cZCooPzpbZUVdWystXT9cZCspPyk/fFwuXGQrKSg/PVxEfCQpL2dtKXx8W10pLm1hcChwYXJzZUZsb2F0KX12YXIgZj0vXltBLVotXSskLztmdW5jdGlvbiBwKGUpe3JldHVybiBmLnRlc3QoZSk/ZS50b0xvd2VyQ2FzZSgpOmV9ZnVuY3Rpb24gZyhlKXt2YXIgdD0vdXJsXCgoJyhbXiddKyknfCIoW14iXSspInwoW14nIildKykpXCkvLmV4ZWMoZSl8fFtdO3JldHVybiB0WzJdfHx0WzNdfHx0WzRdfWZ1bmN0aW9uIG0oZSl7aWYoIWUuc3RhcnRzV2l0aCgicmdiIikpcmV0dXJuIGU7dmFyIHQ9MztyZXR1cm4gZS5yZXBsYWNlKC9cZCsoXC5cZCspPy9nLChlLEEpPT50LS0mJkE/U3RyaW5nKE1hdGgucm91bmQocGFyc2VGbG9hdChlKSkpOmUpfXZhciB3PS8oXFtbXlxdXStcXSkvZyxCPS8oI1teXHMrPn4uWzpdKykvZyx5PS8oXC5bXlxzKz5+Lls6XSspL2csdj0vKDo6W15ccys+fi5bOl0rfDpmaXJzdC1saW5lfDpmaXJzdC1sZXR0ZXJ8OmJlZm9yZXw6YWZ0ZXIpL2dpLGI9Lyg6W1x3LV0rXChbXildKlwpKS9naSxDPS8oOlteXHMrPn4uWzpdKykvZyxfPS8oW15ccys+fi5bOl0rKS9nO2Z1bmN0aW9uIGooZSx0KXt2YXIgQT10LmV4ZWMoZSk7cmV0dXJuIEE/W2UucmVwbGFjZSh0LCIgIiksQS5sZW5ndGhdOltlLDBdfWZ1bmN0aW9uIHgoZSl7dmFyIHQ9WzAsMCwwXSxBPWUucmVwbGFjZSgvOm5vdFwoKFteKV0qKVwpL2csIiAgICAgJDEgIikucmVwbGFjZSgve1tcc1xTXSovZ20sIiAiKSxyPTA7cmV0dXJuW0Escl09aihBLHcpLHRbMV0rPXIsW0Escl09aihBLEIpLHRbMF0rPXIsW0Escl09aihBLHkpLHRbMV0rPXIsW0Escl09aihBLHYpLHRbMl0rPXIsW0Escl09aihBLGIpLHRbMV0rPXIsW0Escl09aihBLEMpLHRbMV0rPXIsQT1BLnJlcGxhY2UoL1sqXHMrPn5dL2csIiAiKS5yZXBsYWNlKC9bIy5dL2csIiAiKSxbQSxyXT1qKEEsXyksdFsyXSs9cix0LmpvaW4oIiIpfXZhciBGPTFlLTg7ZnVuY3Rpb24gUShlKXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGVbMF0sMikrTWF0aC5wb3coZVsxXSwyKSl9ZnVuY3Rpb24gVShlLHQpe3JldHVybihlWzBdKnRbMF0rZVsxXSp0WzFdKS8oUShlKSpRKHQpKX1mdW5jdGlvbiBFKGUsdCl7cmV0dXJuKGVbMF0qdFsxXTxlWzFdKnRbMF0/LTE6MSkqTWF0aC5hY29zKFUoZSx0KSl9ZnVuY3Rpb24gUyhlKXtyZXR1cm4gZSplKmV9ZnVuY3Rpb24gTChlKXtyZXR1cm4gMyplKmUqKDEtZSl9ZnVuY3Rpb24gSShlKXtyZXR1cm4gMyplKigxLWUpKigxLWUpfWZ1bmN0aW9uIE4oZSl7cmV0dXJuKDEtZSkqKDEtZSkqKDEtZSl9ZnVuY3Rpb24gayhlKXtyZXR1cm4gZSplfWZ1bmN0aW9uIEgoZSl7cmV0dXJuIDIqZSooMS1lKX1mdW5jdGlvbiBQKGUpe3JldHVybigxLWUpKigxLWUpfWNsYXNzIFR7Y29uc3RydWN0b3IoZSx0LEEpe3RoaXMuZG9jdW1lbnQ9ZSx0aGlzLm5hbWU9dCx0aGlzLnZhbHVlPUEsdGhpcy5pc05vcm1hbGl6ZWRDb2xvcj0hMX1zdGF0aWMgZW1wdHkoZSl7cmV0dXJuIG5ldyBUKGUsIkVNUFRZIiwiIil9c3BsaXQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06IiAiLHtkb2N1bWVudDp0LG5hbWU6QX09dGhpcztyZXR1cm4gYyh0aGlzLmdldFN0cmluZygpKS50cmltKCkuc3BsaXQoZSkubWFwKGU9Pm5ldyBUKHQsQSxlKSl9aGFzVmFsdWUoZSl7dmFye3ZhbHVlOnR9PXRoaXM7cmV0dXJuIG51bGwhPT10JiYiIiE9PXQmJihlfHwwIT09dCkmJnZvaWQgMCE9PXR9aXNTdHJpbmcoZSl7dmFye3ZhbHVlOnR9PXRoaXMsQT0ic3RyaW5nIj09dHlwZW9mIHQ7cmV0dXJuIEEmJmU/ZS50ZXN0KHQpOkF9aXNVcmxEZWZpbml0aW9uKCl7cmV0dXJuIHRoaXMuaXNTdHJpbmcoL151cmxcKC8pfWlzUGl4ZWxzKCl7aWYoIXRoaXMuaGFzVmFsdWUoKSlyZXR1cm4hMTt2YXIgZT10aGlzLmdldFN0cmluZygpO3N3aXRjaCghMCl7Y2FzZSBlLmVuZHNXaXRoKCJweCIpOmNhc2UvXlswLTldKyQvLnRlc3QoZSk6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19c2V0VmFsdWUoZSl7cmV0dXJuIHRoaXMudmFsdWU9ZSx0aGlzfWdldFZhbHVlKGUpe3JldHVybiB2b2lkIDA9PT1lfHx0aGlzLmhhc1ZhbHVlKCk/dGhpcy52YWx1ZTplfWdldE51bWJlcihlKXtpZighdGhpcy5oYXNWYWx1ZSgpKXJldHVybiB2b2lkIDA9PT1lPzA6cGFyc2VGbG9hdChlKTt2YXJ7dmFsdWU6dH09dGhpcyxBPXBhcnNlRmxvYXQodCk7cmV0dXJuIHRoaXMuaXNTdHJpbmcoLyUkLykmJihBLz0xMDApLEF9Z2V0U3RyaW5nKGUpe3JldHVybiB2b2lkIDA9PT1lfHx0aGlzLmhhc1ZhbHVlKCk/dm9pZCAwPT09dGhpcy52YWx1ZT8iIjpTdHJpbmcodGhpcy52YWx1ZSk6U3RyaW5nKGUpfWdldENvbG9yKGUpe3ZhciB0PXRoaXMuZ2V0U3RyaW5nKGUpO3JldHVybiB0aGlzLmlzTm9ybWFsaXplZENvbG9yfHwodGhpcy5pc05vcm1hbGl6ZWRDb2xvcj0hMCx0PW0odCksdGhpcy52YWx1ZT10KSx0fWdldERwaSgpe3JldHVybiA5Nn1nZXRSZW0oKXtyZXR1cm4gdGhpcy5kb2N1bWVudC5yb290RW1TaXplfWdldEVtKCl7cmV0dXJuIHRoaXMuZG9jdW1lbnQuZW1TaXplfWdldFVuaXRzKCl7cmV0dXJuIHRoaXMuZ2V0U3RyaW5nKCkucmVwbGFjZSgvWzAtOS4tXS9nLCIiKX1nZXRQaXhlbHMoZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTtpZighdGhpcy5oYXNWYWx1ZSgpKXJldHVybiAwO3ZhcltBLHJdPSJib29sZWFuIj09dHlwZW9mIGU/W3ZvaWQgMCxlXTpbZV0se3ZpZXdQb3J0Om59PXRoaXMuZG9jdW1lbnQuc2NyZWVuO3N3aXRjaCghMCl7Y2FzZSB0aGlzLmlzU3RyaW5nKC92bWluJC8pOnJldHVybiB0aGlzLmdldE51bWJlcigpLzEwMCpNYXRoLm1pbihuLmNvbXB1dGVTaXplKCJ4Iiksbi5jb21wdXRlU2l6ZSgieSIpKTtjYXNlIHRoaXMuaXNTdHJpbmcoL3ZtYXgkLyk6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkvMTAwKk1hdGgubWF4KG4uY29tcHV0ZVNpemUoIngiKSxuLmNvbXB1dGVTaXplKCJ5IikpO2Nhc2UgdGhpcy5pc1N0cmluZygvdnckLyk6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkvMTAwKm4uY29tcHV0ZVNpemUoIngiKTtjYXNlIHRoaXMuaXNTdHJpbmcoL3ZoJC8pOnJldHVybiB0aGlzLmdldE51bWJlcigpLzEwMCpuLmNvbXB1dGVTaXplKCJ5Iik7Y2FzZSB0aGlzLmlzU3RyaW5nKC9yZW0kLyk6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkqdGhpcy5nZXRSZW0oKTtjYXNlIHRoaXMuaXNTdHJpbmcoL2VtJC8pOnJldHVybiB0aGlzLmdldE51bWJlcigpKnRoaXMuZ2V0RW0oKTtjYXNlIHRoaXMuaXNTdHJpbmcoL2V4JC8pOnJldHVybiB0aGlzLmdldE51bWJlcigpKnRoaXMuZ2V0RW0oKS8yO2Nhc2UgdGhpcy5pc1N0cmluZygvcHgkLyk6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7Y2FzZSB0aGlzLmlzU3RyaW5nKC9wdCQvKTpyZXR1cm4gdGhpcy5nZXROdW1iZXIoKSp0aGlzLmdldERwaSgpKigxLzcyKTtjYXNlIHRoaXMuaXNTdHJpbmcoL3BjJC8pOnJldHVybiAxNSp0aGlzLmdldE51bWJlcigpO2Nhc2UgdGhpcy5pc1N0cmluZygvY20kLyk6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkqdGhpcy5nZXREcGkoKS8yLjU0O2Nhc2UgdGhpcy5pc1N0cmluZygvbW0kLyk6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkqdGhpcy5nZXREcGkoKS8yNS40O2Nhc2UgdGhpcy5pc1N0cmluZygvaW4kLyk6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkqdGhpcy5nZXREcGkoKTtjYXNlIHRoaXMuaXNTdHJpbmcoLyUkLykmJnI6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkqdGhpcy5nZXRFbSgpO2Nhc2UgdGhpcy5pc1N0cmluZygvJSQvKTpyZXR1cm4gdGhpcy5nZXROdW1iZXIoKSpuLmNvbXB1dGVTaXplKEEpO2RlZmF1bHQ6dmFyIHM9dGhpcy5nZXROdW1iZXIoKTtyZXR1cm4gdCYmczwxP3Mqbi5jb21wdXRlU2l6ZShBKTpzfX1nZXRNaWxsaXNlY29uZHMoKXtyZXR1cm4gdGhpcy5oYXNWYWx1ZSgpP3RoaXMuaXNTdHJpbmcoL21zJC8pP3RoaXMuZ2V0TnVtYmVyKCk6MWUzKnRoaXMuZ2V0TnVtYmVyKCk6MH1nZXRSYWRpYW5zKCl7aWYoIXRoaXMuaGFzVmFsdWUoKSlyZXR1cm4gMDtzd2l0Y2goITApe2Nhc2UgdGhpcy5pc1N0cmluZygvZGVnJC8pOnJldHVybiB0aGlzLmdldE51bWJlcigpKihNYXRoLlBJLzE4MCk7Y2FzZSB0aGlzLmlzU3RyaW5nKC9ncmFkJC8pOnJldHVybiB0aGlzLmdldE51bWJlcigpKihNYXRoLlBJLzIwMCk7Y2FzZSB0aGlzLmlzU3RyaW5nKC9yYWQkLyk6cmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5nZXROdW1iZXIoKSooTWF0aC5QSS8xODApfX1nZXREZWZpbml0aW9uKCl7dmFyIGU9dGhpcy5nZXRTdHJpbmcoKSx0PS8jKFteKSciXSspLy5leGVjKGUpO3JldHVybiB0JiYodD10WzFdKSx0fHwodD1lKSx0aGlzLmRvY3VtZW50LmRlZmluaXRpb25zW3RdfWdldEZpbGxTdHlsZURlZmluaXRpb24oZSx0KXt2YXIgQT10aGlzLmdldERlZmluaXRpb24oKTtpZighQSlyZXR1cm4gbnVsbDtpZigiZnVuY3Rpb24iPT10eXBlb2YgQS5jcmVhdGVHcmFkaWVudClyZXR1cm4gQS5jcmVhdGVHcmFkaWVudCh0aGlzLmRvY3VtZW50LmN0eCxlLHQpO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBBLmNyZWF0ZVBhdHRlcm4pe2lmKEEuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpe3ZhciByPUEuZ2V0QXR0cmlidXRlKCJwYXR0ZXJuVHJhbnNmb3JtIik7QT1BLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCksci5oYXNWYWx1ZSgpJiZBLmdldEF0dHJpYnV0ZSgicGF0dGVyblRyYW5zZm9ybSIsITApLnNldFZhbHVlKHIudmFsdWUpfXJldHVybiBBLmNyZWF0ZVBhdHRlcm4odGhpcy5kb2N1bWVudC5jdHgsZSx0KX1yZXR1cm4gbnVsbH1nZXRUZXh0QmFzZWxpbmUoKXtyZXR1cm4gdGhpcy5oYXNWYWx1ZSgpP1QudGV4dEJhc2VsaW5lTWFwcGluZ1t0aGlzLmdldFN0cmluZygpXTpudWxsfWFkZE9wYWNpdHkoZSl7Zm9yKHZhciB0PXRoaXMuZ2V0Q29sb3IoKSxBPXQubGVuZ3RoLHI9MCxuPTA7bjxBJiYoIiwiPT09dFtuXSYmcisrLDMhPT1yKTtuKyspO2lmKGUuaGFzVmFsdWUoKSYmdGhpcy5pc1N0cmluZygpJiYzIT09cil7dmFyIHM9bmV3IGkodCk7cy5vayYmKHMuYWxwaGE9ZS5nZXROdW1iZXIoKSx0PXMudG9SR0JBKCkpfXJldHVybiBuZXcgVCh0aGlzLmRvY3VtZW50LHRoaXMubmFtZSx0KX19VC50ZXh0QmFzZWxpbmVNYXBwaW5nPXtiYXNlbGluZToiYWxwaGFiZXRpYyIsImJlZm9yZS1lZGdlIjoidG9wIiwidGV4dC1iZWZvcmUtZWRnZSI6InRvcCIsbWlkZGxlOiJtaWRkbGUiLGNlbnRyYWw6Im1pZGRsZSIsImFmdGVyLWVkZ2UiOiJib3R0b20iLCJ0ZXh0LWFmdGVyLWVkZ2UiOiJib3R0b20iLGlkZW9ncmFwaGljOiJpZGVvZ3JhcGhpYyIsYWxwaGFiZXRpYzoiYWxwaGFiZXRpYyIsaGFuZ2luZzoiaGFuZ2luZyIsbWF0aGVtYXRpY2FsOiJhbHBoYWJldGljIn07Y2xhc3MgT3tjb25zdHJ1Y3Rvcigpe3RoaXMudmlld1BvcnRzPVtdfWNsZWFyKCl7dGhpcy52aWV3UG9ydHM9W119c2V0Q3VycmVudChlLHQpe3RoaXMudmlld1BvcnRzLnB1c2goe3dpZHRoOmUsaGVpZ2h0OnR9KX1yZW1vdmVDdXJyZW50KCl7dGhpcy52aWV3UG9ydHMucG9wKCl9Z2V0Q3VycmVudCgpe3Zhcnt2aWV3UG9ydHM6ZX09dGhpcztyZXR1cm4gZVtlLmxlbmd0aC0xXX1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpcy5nZXRDdXJyZW50KCkud2lkdGh9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLmdldEN1cnJlbnQoKS5oZWlnaHR9Y29tcHV0ZVNpemUoZSl7cmV0dXJuIm51bWJlciI9PXR5cGVvZiBlP2U6IngiPT09ZT90aGlzLndpZHRoOiJ5Ij09PWU/dGhpcy5oZWlnaHQ6TWF0aC5zcXJ0KE1hdGgucG93KHRoaXMud2lkdGgsMikrTWF0aC5wb3codGhpcy5oZWlnaHQsMikpL01hdGguc3FydCgyKX19Y2xhc3MgTXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMueD1lLHRoaXMueT10fXN0YXRpYyBwYXJzZShlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MCxbQT10LHI9dF09ZChlKTtyZXR1cm4gbmV3IE0oQSxyKX1zdGF0aWMgcGFyc2VTY2FsZShlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MSxbQT10LHI9QV09ZChlKTtyZXR1cm4gbmV3IE0oQSxyKX1zdGF0aWMgcGFyc2VQYXRoKGUpe2Zvcih2YXIgdD1kKGUpLEE9dC5sZW5ndGgscj1bXSxuPTA7bjxBO24rPTIpci5wdXNoKG5ldyBNKHRbbl0sdFtuKzFdKSk7cmV0dXJuIHJ9YW5nbGVUbyhlKXtyZXR1cm4gTWF0aC5hdGFuMihlLnktdGhpcy55LGUueC10aGlzLngpfWFwcGx5VHJhbnNmb3JtKGUpe3Zhcnt4OnQseTpBfT10aGlzLHI9dCplWzBdK0EqZVsyXStlWzRdLG49dCplWzFdK0EqZVszXStlWzVdO3RoaXMueD1yLHRoaXMueT1ufX1jbGFzcyBEe2NvbnN0cnVjdG9yKGUpe3RoaXMuc2NyZWVuPWUsdGhpcy53b3JraW5nPSExLHRoaXMuZXZlbnRzPVtdLHRoaXMuZXZlbnRFbGVtZW50cz1bXSx0aGlzLm9uQ2xpY2s9dGhpcy5vbkNsaWNrLmJpbmQodGhpcyksdGhpcy5vbk1vdXNlTW92ZT10aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyl9aXNXb3JraW5nKCl7cmV0dXJuIHRoaXMud29ya2luZ31zdGFydCgpe2lmKCF0aGlzLndvcmtpbmcpe3ZhcntzY3JlZW46ZSxvbkNsaWNrOnQsb25Nb3VzZU1vdmU6QX09dGhpcyxyPWUuY3R4LmNhbnZhcztyLm9uY2xpY2s9dCxyLm9ubW91c2Vtb3ZlPUEsdGhpcy53b3JraW5nPSEwfX1zdG9wKCl7aWYodGhpcy53b3JraW5nKXt2YXIgZT10aGlzLnNjcmVlbi5jdHguY2FudmFzO3RoaXMud29ya2luZz0hMSxlLm9uY2xpY2s9bnVsbCxlLm9ubW91c2Vtb3ZlPW51bGx9fWhhc0V2ZW50cygpe3JldHVybiB0aGlzLndvcmtpbmcmJnRoaXMuZXZlbnRzLmxlbmd0aD4wfXJ1bkV2ZW50cygpe2lmKHRoaXMud29ya2luZyl7dmFye3NjcmVlbjplLGV2ZW50czp0LGV2ZW50RWxlbWVudHM6QX09dGhpcyx7c3R5bGU6cn09ZS5jdHguY2FudmFzO3ImJihyLmN1cnNvcj0iIiksdC5mb3JFYWNoKChlLHQpPT57Zm9yKHZhcntydW46cn09ZSxuPUFbdF07bjspcihuKSxuPW4ucGFyZW50fSksdGhpcy5ldmVudHM9W10sdGhpcy5ldmVudEVsZW1lbnRzPVtdfX1jaGVja1BhdGgoZSx0KXtpZih0aGlzLndvcmtpbmcmJnQpe3ZhcntldmVudHM6QSxldmVudEVsZW1lbnRzOnJ9PXRoaXM7QS5mb3JFYWNoKChBLG4pPT57dmFye3g6cyx5Oml9PUE7IXJbbl0mJnQuaXNQb2ludEluUGF0aCYmdC5pc1BvaW50SW5QYXRoKHMsaSkmJihyW25dPWUpfSl9fWNoZWNrQm91bmRpbmdCb3goZSx0KXtpZih0aGlzLndvcmtpbmcmJnQpe3ZhcntldmVudHM6QSxldmVudEVsZW1lbnRzOnJ9PXRoaXM7QS5mb3JFYWNoKChBLG4pPT57dmFye3g6cyx5Oml9PUE7IXJbbl0mJnQuaXNQb2ludEluQm94KHMsaSkmJihyW25dPWUpfSl9fW1hcFhZKGUsdCl7Zm9yKHZhcnt3aW5kb3c6QSxjdHg6cn09dGhpcy5zY3JlZW4sbj1uZXcgTShlLHQpLHM9ci5jYW52YXM7czspbi54LT1zLm9mZnNldExlZnQsbi55LT1zLm9mZnNldFRvcCxzPXMub2Zmc2V0UGFyZW50O3JldHVybiBBLnNjcm9sbFgmJihuLngrPUEuc2Nyb2xsWCksQS5zY3JvbGxZJiYobi55Kz1BLnNjcm9sbFkpLG59b25DbGljayhlKXt2YXJ7eDp0LHk6QX09dGhpcy5tYXBYWShlLmNsaWVudFgsZS5jbGllbnRZKTt0aGlzLmV2ZW50cy5wdXNoKHt0eXBlOiJvbmNsaWNrIix4OnQseTpBLHJ1bihlKXtlLm9uQ2xpY2smJmUub25DbGljaygpfX0pfW9uTW91c2VNb3ZlKGUpe3Zhcnt4OnQseTpBfT10aGlzLm1hcFhZKGUuY2xpZW50WCxlLmNsaWVudFkpO3RoaXMuZXZlbnRzLnB1c2goe3R5cGU6Im9ubW91c2Vtb3ZlIix4OnQseTpBLHJ1bihlKXtlLm9uTW91c2VNb3ZlJiZlLm9uTW91c2VNb3ZlKCl9fSl9fXZhciBSPSJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpudWxsLEs9InVuZGVmaW5lZCIhPXR5cGVvZiBmZXRjaD9mZXRjaC5iaW5kKHZvaWQgMCk6bnVsbDtjbGFzcyBWe2NvbnN0cnVjdG9yKGUpe3ZhcntmZXRjaDp0PUssd2luZG93OkE9Un09YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O3RoaXMuY3R4PWUsdGhpcy5GUkFNRVJBVEU9MzAsdGhpcy5NQVhfVklSVFVBTF9QSVhFTFM9M2U0LHRoaXMuQ0xJRU5UX1dJRFRIPTgwMCx0aGlzLkNMSUVOVF9IRUlHSFQ9NjAwLHRoaXMudmlld1BvcnQ9bmV3IE8sdGhpcy5tb3VzZT1uZXcgRCh0aGlzKSx0aGlzLmFuaW1hdGlvbnM9W10sdGhpcy53YWl0cz1bXSx0aGlzLmZyYW1lRHVyYXRpb249MCx0aGlzLmlzUmVhZHlMb2NrPSExLHRoaXMuaXNGaXJzdFJlbmRlcj0hMCx0aGlzLmludGVydmFsSWQ9bnVsbCx0aGlzLndpbmRvdz1BLHRoaXMuZmV0Y2g9dH13YWl0KGUpe3RoaXMud2FpdHMucHVzaChlKX1yZWFkeSgpe3JldHVybiB0aGlzLnJlYWR5UHJvbWlzZT90aGlzLnJlYWR5UHJvbWlzZTpQcm9taXNlLnJlc29sdmUoKX1pc1JlYWR5KCl7aWYodGhpcy5pc1JlYWR5TG9jaylyZXR1cm4hMDt2YXIgZT10aGlzLndhaXRzLmV2ZXJ5KGU9PmUoKSk7cmV0dXJuIGUmJih0aGlzLndhaXRzPVtdLHRoaXMucmVzb2x2ZVJlYWR5JiZ0aGlzLnJlc29sdmVSZWFkeSgpKSx0aGlzLmlzUmVhZHlMb2NrPWUsZX1zZXREZWZhdWx0cyhlKXtlLnN0cm9rZVN0eWxlPSJyZ2JhKDAsMCwwLDApIixlLmxpbmVDYXA9ImJ1dHQiLGUubGluZUpvaW49Im1pdGVyIixlLm1pdGVyTGltaXQ9NH1zZXRWaWV3Qm94KGUpe3Zhcntkb2N1bWVudDp0LGN0eDpBLGFzcGVjdFJhdGlvOnIsd2lkdGg6bixkZXNpcmVkV2lkdGg6cyxoZWlnaHQ6aSxkZXNpcmVkSGVpZ2h0Om8sbWluWDphPTAsbWluWTpsPTAscmVmWDp1LHJlZlk6aCxjbGlwOmQ9ITEsY2xpcFg6Zj0wLGNsaXBZOnA9MH09ZSxnPWMocikucmVwbGFjZSgvXmRlZmVyXHMvLCIiKSxbbSx3XT1nLnNwbGl0KCIgIiksQj1tfHwieE1pZFlNaWQiLHk9d3x8Im1lZXQiLHY9bi9zLGI9aS9vLEM9TWF0aC5taW4odixiKSxfPU1hdGgubWF4KHYsYiksaj1zLHg9bzsibWVldCI9PT15JiYoaio9Qyx4Kj1DKSwic2xpY2UiPT09eSYmKGoqPV8seCo9Xyk7dmFyIEY9bmV3IFQodCwicmVmWCIsdSksUT1uZXcgVCh0LCJyZWZZIixoKSxVPUYuaGFzVmFsdWUoKSYmUS5oYXNWYWx1ZSgpO2lmKFUmJkEudHJhbnNsYXRlKC1DKkYuZ2V0UGl4ZWxzKCJ4IiksLUMqUS5nZXRQaXhlbHMoInkiKSksZCl7dmFyIEU9QypmLFM9QypwO0EuYmVnaW5QYXRoKCksQS5tb3ZlVG8oRSxTKSxBLmxpbmVUbyhuLFMpLEEubGluZVRvKG4saSksQS5saW5lVG8oRSxpKSxBLmNsb3NlUGF0aCgpLEEuY2xpcCgpfWlmKCFVKXt2YXIgTD0ibWVldCI9PT15JiZDPT09YixJPSJzbGljZSI9PT15JiZfPT09YixOPSJtZWV0Ij09PXkmJkM9PT12LGs9InNsaWNlIj09PXkmJl89PT12O0Iuc3RhcnRzV2l0aCgieE1pZCIpJiYoTHx8SSkmJkEudHJhbnNsYXRlKG4vMi1qLzIsMCksQi5lbmRzV2l0aCgiWU1pZCIpJiYoTnx8aykmJkEudHJhbnNsYXRlKDAsaS8yLXgvMiksQi5zdGFydHNXaXRoKCJ4TWF4IikmJihMfHxJKSYmQS50cmFuc2xhdGUobi1qLDApLEIuZW5kc1dpdGgoIllNYXgiKSYmKE58fGspJiZBLnRyYW5zbGF0ZSgwLGkteCl9c3dpdGNoKCEwKXtjYXNlIm5vbmUiPT09QjpBLnNjYWxlKHYsYik7YnJlYWs7Y2FzZSJtZWV0Ij09PXk6QS5zY2FsZShDLEMpO2JyZWFrO2Nhc2Uic2xpY2UiPT09eTpBLnNjYWxlKF8sXyl9QS50cmFuc2xhdGUoLWEsLWwpfXN0YXJ0KGUpe3ZhcntlbmFibGVSZWRyYXc6dD0hMSxpZ25vcmVNb3VzZTpBPSExLGlnbm9yZUFuaW1hdGlvbjpyPSExLGlnbm9yZURpbWVuc2lvbnM6bj0hMSxpZ25vcmVDbGVhcjppPSExLGZvcmNlUmVkcmF3Om8sc2NhbGVXaWR0aDphLHNjYWxlSGVpZ2h0Omwsb2Zmc2V0WDpjLG9mZnNldFk6dX09YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LHtGUkFNRVJBVEU6aCxtb3VzZTpkfT10aGlzLGY9MWUzL2g7aWYodGhpcy5mcmFtZUR1cmF0aW9uPWYsdGhpcy5yZWFkeVByb21pc2U9bmV3IFByb21pc2UoZT0+e3RoaXMucmVzb2x2ZVJlYWR5PWV9KSx0aGlzLmlzUmVhZHkoKSYmdGhpcy5yZW5kZXIoZSxuLGksYSxsLGMsdSksdCl7dmFyIHA9RGF0ZS5ub3coKSxnPXAsbT0wLHc9KCk9PntwPURhdGUubm93KCksKG09cC1nKT49ZiYmKGc9cC1tJWYsdGhpcy5zaG91bGRVcGRhdGUocixvKSYmKHRoaXMucmVuZGVyKGUsbixpLGEsbCxjLHUpLGQucnVuRXZlbnRzKCkpKSx0aGlzLmludGVydmFsSWQ9cyh3KX07QXx8ZC5zdGFydCgpLHRoaXMuaW50ZXJ2YWxJZD1zKHcpfX1zdG9wKCl7dGhpcy5pbnRlcnZhbElkJiYocy5jYW5jZWwodGhpcy5pbnRlcnZhbElkKSx0aGlzLmludGVydmFsSWQ9bnVsbCksdGhpcy5tb3VzZS5zdG9wKCl9c2hvdWxkVXBkYXRlKGUsdCl7aWYoIWUpe3ZhcntmcmFtZUR1cmF0aW9uOkF9PXRoaXM7aWYodGhpcy5hbmltYXRpb25zLnJlZHVjZSgoZSx0KT0+dC51cGRhdGUoQSl8fGUsITEpKXJldHVybiEwfXJldHVybiEoImZ1bmN0aW9uIiE9dHlwZW9mIHR8fCF0KCkpfHwhKHRoaXMuaXNSZWFkeUxvY2t8fCF0aGlzLmlzUmVhZHkoKSl8fCEhdGhpcy5tb3VzZS5oYXNFdmVudHMoKX1yZW5kZXIoZSx0LEEscixuLHMsaSl7dmFye0NMSUVOVF9XSURUSDpvLENMSUVOVF9IRUlHSFQ6YSx2aWV3UG9ydDpsLGN0eDpjLGlzRmlyc3RSZW5kZXI6dX09dGhpcyxoPWMuY2FudmFzO2wuY2xlYXIoKSxoLndpZHRoJiZoLmhlaWdodD9sLnNldEN1cnJlbnQoaC53aWR0aCxoLmhlaWdodCk6bC5zZXRDdXJyZW50KG8sYSk7dmFyIGY9ZS5nZXRTdHlsZSgid2lkdGgiKSxwPWUuZ2V0U3R5bGUoImhlaWdodCIpOyF0JiYodXx8Im51bWJlciIhPXR5cGVvZiByJiYibnVtYmVyIiE9dHlwZW9mIG4pJiYoZi5oYXNWYWx1ZSgpJiYoaC53aWR0aD1mLmdldFBpeGVscygieCIpLGguc3R5bGUmJihoLnN0eWxlLndpZHRoPSIiLmNvbmNhdChoLndpZHRoLCJweCIpKSkscC5oYXNWYWx1ZSgpJiYoaC5oZWlnaHQ9cC5nZXRQaXhlbHMoInkiKSxoLnN0eWxlJiYoaC5zdHlsZS5oZWlnaHQ9IiIuY29uY2F0KGguaGVpZ2h0LCJweCIpKSkpO3ZhciBnPWguY2xpZW50V2lkdGh8fGgud2lkdGgsbT1oLmNsaWVudEhlaWdodHx8aC5oZWlnaHQ7aWYodCYmZi5oYXNWYWx1ZSgpJiZwLmhhc1ZhbHVlKCkmJihnPWYuZ2V0UGl4ZWxzKCJ4IiksbT1wLmdldFBpeGVscygieSIpKSxsLnNldEN1cnJlbnQoZyxtKSwibnVtYmVyIj09dHlwZW9mIHMmJmUuZ2V0QXR0cmlidXRlKCJ4IiwhMCkuc2V0VmFsdWUocyksIm51bWJlciI9PXR5cGVvZiBpJiZlLmdldEF0dHJpYnV0ZSgieSIsITApLnNldFZhbHVlKGkpLCJudW1iZXIiPT10eXBlb2Ygcnx8Im51bWJlciI9PXR5cGVvZiBuKXt2YXIgdz1kKGUuZ2V0QXR0cmlidXRlKCJ2aWV3Qm94IikuZ2V0U3RyaW5nKCkpLEI9MCx5PTA7aWYoIm51bWJlciI9PXR5cGVvZiByKXt2YXIgdj1lLmdldFN0eWxlKCJ3aWR0aCIpO3YuaGFzVmFsdWUoKT9CPXYuZ2V0UGl4ZWxzKCJ4Iikvcjppc05hTih3WzJdKXx8KEI9d1syXS9yKX1pZigibnVtYmVyIj09dHlwZW9mIG4pe3ZhciBiPWUuZ2V0U3R5bGUoImhlaWdodCIpO2IuaGFzVmFsdWUoKT95PWIuZ2V0UGl4ZWxzKCJ5Iikvbjppc05hTih3WzNdKXx8KHk9d1szXS9uKX1CfHwoQj15KSx5fHwoeT1CKSxlLmdldEF0dHJpYnV0ZSgid2lkdGgiLCEwKS5zZXRWYWx1ZShyKSxlLmdldEF0dHJpYnV0ZSgiaGVpZ2h0IiwhMCkuc2V0VmFsdWUobik7dmFyIEM9ZS5nZXRTdHlsZSgidHJhbnNmb3JtIiwhMCwhMCk7Qy5zZXRWYWx1ZSgiIi5jb25jYXQoQy5nZXRTdHJpbmcoKSwiIHNjYWxlKCIpLmNvbmNhdCgxL0IsIiwgIikuY29uY2F0KDEveSwiKSIpKX1BfHxjLmNsZWFyUmVjdCgwLDAsZyxtKSxlLnJlbmRlcihjKSx1JiYodGhpcy5pc0ZpcnN0UmVuZGVyPSExKX19Vi5kZWZhdWx0V2luZG93PVIsVi5kZWZhdWx0RmV0Y2g9Szt2YXJ7ZGVmYXVsdEZldGNoOkd9PVYsej0idW5kZWZpbmVkIiE9dHlwZW9mIERPTVBhcnNlcj9ET01QYXJzZXI6bnVsbDtjbGFzcyBxe2NvbnN0cnVjdG9yKCl7dmFye2ZldGNoOmU9RyxET01QYXJzZXI6dD16fT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e307dGhpcy5mZXRjaD1lLHRoaXMuRE9NUGFyc2VyPXR9cGFyc2UoZSl7dmFyIHQ9dGhpcztyZXR1cm4oMCxyLmRlZmF1bHQpKGZ1bmN0aW9uKigpe3JldHVybiBlLnN0YXJ0c1dpdGgoIjwiKT90LnBhcnNlRnJvbVN0cmluZyhlKTp0LmxvYWQoZSl9KSgpfXBhcnNlRnJvbVN0cmluZyhlKXt2YXIgdD1uZXcgdGhpcy5ET01QYXJzZXI7dHJ5e3JldHVybiB0aGlzLmNoZWNrRG9jdW1lbnQodC5wYXJzZUZyb21TdHJpbmcoZSwiaW1hZ2Uvc3ZnK3htbCIpKX1jYXRjaChBKXtyZXR1cm4gdGhpcy5jaGVja0RvY3VtZW50KHQucGFyc2VGcm9tU3RyaW5nKGUsInRleHQveG1sIikpfX1jaGVja0RvY3VtZW50KGUpe3ZhciB0PWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInBhcnNlcmVycm9yIilbMF07aWYodCl0aHJvdyBuZXcgRXJyb3IodC50ZXh0Q29udGVudCk7cmV0dXJuIGV9bG9hZChlKXt2YXIgdD10aGlzO3JldHVybigwLHIuZGVmYXVsdCkoZnVuY3Rpb24qKCl7dmFyIEE9eWllbGQgdC5mZXRjaChlKSxyPXlpZWxkIEEudGV4dCgpO3JldHVybiB0LnBhcnNlRnJvbVN0cmluZyhyKX0pKCl9fWNsYXNzIFd7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnR5cGU9InRyYW5zbGF0ZSIsdGhpcy5wb2ludD1udWxsLHRoaXMucG9pbnQ9TS5wYXJzZSh0KX1hcHBseShlKXt2YXJ7eDp0LHk6QX09dGhpcy5wb2ludDtlLnRyYW5zbGF0ZSh0fHwwLEF8fDApfXVuYXBwbHkoZSl7dmFye3g6dCx5OkF9PXRoaXMucG9pbnQ7ZS50cmFuc2xhdGUoLTEqdHx8MCwtMSpBfHwwKX1hcHBseVRvUG9pbnQoZSl7dmFye3g6dCx5OkF9PXRoaXMucG9pbnQ7ZS5hcHBseVRyYW5zZm9ybShbMSwwLDAsMSx0fHwwLEF8fDBdKX19Y2xhc3MgWHtjb25zdHJ1Y3RvcihlLHQsQSl7dGhpcy50eXBlPSJyb3RhdGUiLHRoaXMuYW5nbGU9bnVsbCx0aGlzLm9yaWdpblg9bnVsbCx0aGlzLm9yaWdpblk9bnVsbCx0aGlzLmN4PTAsdGhpcy5jeT0wO3ZhciByPWQodCk7dGhpcy5hbmdsZT1uZXcgVChlLCJhbmdsZSIsclswXSksdGhpcy5vcmlnaW5YPUFbMF0sdGhpcy5vcmlnaW5ZPUFbMV0sdGhpcy5jeD1yWzFdfHwwLHRoaXMuY3k9clsyXXx8MH1hcHBseShlKXt2YXJ7Y3g6dCxjeTpBLG9yaWdpblg6cixvcmlnaW5ZOm4sYW5nbGU6c309dGhpcyxpPXQrci5nZXRQaXhlbHMoIngiKSxvPUErbi5nZXRQaXhlbHMoInkiKTtlLnRyYW5zbGF0ZShpLG8pLGUucm90YXRlKHMuZ2V0UmFkaWFucygpKSxlLnRyYW5zbGF0ZSgtaSwtbyl9dW5hcHBseShlKXt2YXJ7Y3g6dCxjeTpBLG9yaWdpblg6cixvcmlnaW5ZOm4sYW5nbGU6c309dGhpcyxpPXQrci5nZXRQaXhlbHMoIngiKSxvPUErbi5nZXRQaXhlbHMoInkiKTtlLnRyYW5zbGF0ZShpLG8pLGUucm90YXRlKC0xKnMuZ2V0UmFkaWFucygpKSxlLnRyYW5zbGF0ZSgtaSwtbyl9YXBwbHlUb1BvaW50KGUpe3ZhcntjeDp0LGN5OkEsYW5nbGU6cn09dGhpcyxuPXIuZ2V0UmFkaWFucygpO2UuYXBwbHlUcmFuc2Zvcm0oWzEsMCwwLDEsdHx8MCxBfHwwXSksZS5hcHBseVRyYW5zZm9ybShbTWF0aC5jb3MobiksTWF0aC5zaW4obiksLU1hdGguc2luKG4pLE1hdGguY29zKG4pLDAsMF0pLGUuYXBwbHlUcmFuc2Zvcm0oWzEsMCwwLDEsLXR8fDAsLUF8fDBdKX19Y2xhc3MgWXtjb25zdHJ1Y3RvcihlLHQsQSl7dGhpcy50eXBlPSJzY2FsZSIsdGhpcy5zY2FsZT1udWxsLHRoaXMub3JpZ2luWD1udWxsLHRoaXMub3JpZ2luWT1udWxsO3ZhciByPU0ucGFyc2VTY2FsZSh0KTswIT09ci54JiYwIT09ci55fHwoci54PUYsci55PUYpLHRoaXMuc2NhbGU9cix0aGlzLm9yaWdpblg9QVswXSx0aGlzLm9yaWdpblk9QVsxXX1hcHBseShlKXt2YXJ7c2NhbGU6e3g6dCx5OkF9LG9yaWdpblg6cixvcmlnaW5ZOm59PXRoaXMscz1yLmdldFBpeGVscygieCIpLGk9bi5nZXRQaXhlbHMoInkiKTtlLnRyYW5zbGF0ZShzLGkpLGUuc2NhbGUodCxBfHx0KSxlLnRyYW5zbGF0ZSgtcywtaSl9dW5hcHBseShlKXt2YXJ7c2NhbGU6e3g6dCx5OkF9LG9yaWdpblg6cixvcmlnaW5ZOm59PXRoaXMscz1yLmdldFBpeGVscygieCIpLGk9bi5nZXRQaXhlbHMoInkiKTtlLnRyYW5zbGF0ZShzLGkpLGUuc2NhbGUoMS90LDEvQXx8dCksZS50cmFuc2xhdGUoLXMsLWkpfWFwcGx5VG9Qb2ludChlKXt2YXJ7eDp0LHk6QX09dGhpcy5zY2FsZTtlLmFwcGx5VHJhbnNmb3JtKFt0fHwwLDAsMCxBfHwwLDAsMF0pfX1jbGFzcyBKe2NvbnN0cnVjdG9yKGUsdCxBKXt0aGlzLnR5cGU9Im1hdHJpeCIsdGhpcy5tYXRyaXg9W10sdGhpcy5vcmlnaW5YPW51bGwsdGhpcy5vcmlnaW5ZPW51bGwsdGhpcy5tYXRyaXg9ZCh0KSx0aGlzLm9yaWdpblg9QVswXSx0aGlzLm9yaWdpblk9QVsxXX1hcHBseShlKXt2YXJ7b3JpZ2luWDp0LG9yaWdpblk6QSxtYXRyaXg6cn09dGhpcyxuPXQuZ2V0UGl4ZWxzKCJ4Iikscz1BLmdldFBpeGVscygieSIpO2UudHJhbnNsYXRlKG4scyksZS50cmFuc2Zvcm0oclswXSxyWzFdLHJbMl0sclszXSxyWzRdLHJbNV0pLGUudHJhbnNsYXRlKC1uLC1zKX11bmFwcGx5KGUpe3ZhcntvcmlnaW5YOnQsb3JpZ2luWTpBLG1hdHJpeDpyfT10aGlzLG49clswXSxzPXJbMl0saT1yWzRdLG89clsxXSxhPXJbM10sbD1yWzVdLGM9MS8obiooMSphLTAqbCktcyooMSpvLTAqbCkraSooMCpvLTAqYSkpLHU9dC5nZXRQaXhlbHMoIngiKSxoPUEuZ2V0UGl4ZWxzKCJ5Iik7ZS50cmFuc2xhdGUodSxoKSxlLnRyYW5zZm9ybShjKigxKmEtMCpsKSxjKigwKmwtMSpvKSxjKigwKmktMSpzKSxjKigxKm4tMCppKSxjKihzKmwtaSphKSxjKihpKm8tbipsKSksZS50cmFuc2xhdGUoLXUsLWgpfWFwcGx5VG9Qb2ludChlKXtlLmFwcGx5VHJhbnNmb3JtKHRoaXMubWF0cml4KX19Y2xhc3MgWiBleHRlbmRzIEp7Y29uc3RydWN0b3IoZSx0LEEpe3N1cGVyKGUsdCxBKSx0aGlzLnR5cGU9InNrZXciLHRoaXMuYW5nbGU9bnVsbCx0aGlzLmFuZ2xlPW5ldyBUKGUsImFuZ2xlIix0KX19Y2xhc3MgJCBleHRlbmRzIFp7Y29uc3RydWN0b3IoZSx0LEEpe3N1cGVyKGUsdCxBKSx0aGlzLnR5cGU9InNrZXdYIix0aGlzLm1hdHJpeD1bMSwwLE1hdGgudGFuKHRoaXMuYW5nbGUuZ2V0UmFkaWFucygpKSwxLDAsMF19fWNsYXNzIGVlIGV4dGVuZHMgWntjb25zdHJ1Y3RvcihlLHQsQSl7c3VwZXIoZSx0LEEpLHRoaXMudHlwZT0ic2tld1kiLHRoaXMubWF0cml4PVsxLE1hdGgudGFuKHRoaXMuYW5nbGUuZ2V0UmFkaWFucygpKSwwLDEsMCwwXX19Y2xhc3MgdGV7Y29uc3RydWN0b3IoZSx0LEEpe3RoaXMuZG9jdW1lbnQ9ZSx0aGlzLnRyYW5zZm9ybXM9W107dmFyIHI9ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZSkudHJpbSgpLnJlcGxhY2UoL1wpKFthLXpBLVpdKS9nLCIpICQxIikucmVwbGFjZSgvXCkoXHM/LFxzPykvZywiKSAiKS5zcGxpdCgvXHMoPz1bYS16XSkvKX0odCk7ci5mb3JFYWNoKGU9PntpZigibm9uZSIhPT1lKXt2YXJbdCxyXT1mdW5jdGlvbihlKXt2YXJbdCxBXT1lLnNwbGl0KCIoIik7cmV0dXJuW3QudHJpbSgpLEEudHJpbSgpLnJlcGxhY2UoIikiLCIiKV19KGUpLG49dGUudHJhbnNmb3JtVHlwZXNbdF07dm9pZCAwIT09biYmdGhpcy50cmFuc2Zvcm1zLnB1c2gobmV3IG4odGhpcy5kb2N1bWVudCxyLEEpKX19KX1zdGF0aWMgZnJvbUVsZW1lbnQoZSx0KXt2YXIgQT10LmdldFN0eWxlKCJ0cmFuc2Zvcm0iLCExLCEwKSxbcixuPXJdPXQuZ2V0U3R5bGUoInRyYW5zZm9ybS1vcmlnaW4iLCExLCEwKS5zcGxpdCgpLHM9W3Isbl07cmV0dXJuIEEuaGFzVmFsdWUoKT9uZXcgdGUoZSxBLmdldFN0cmluZygpLHMpOm51bGx9YXBwbHkoZSl7Zm9yKHZhcnt0cmFuc2Zvcm1zOnR9PXRoaXMsQT10Lmxlbmd0aCxyPTA7cjxBO3IrKyl0W3JdLmFwcGx5KGUpfXVuYXBwbHkoZSl7Zm9yKHZhcnt0cmFuc2Zvcm1zOnR9PXRoaXMsQT10Lmxlbmd0aC0xO0E+PTA7QS0tKXRbQV0udW5hcHBseShlKX1hcHBseVRvUG9pbnQoZSl7Zm9yKHZhcnt0cmFuc2Zvcm1zOnR9PXRoaXMsQT10Lmxlbmd0aCxyPTA7cjxBO3IrKyl0W3JdLmFwcGx5VG9Qb2ludChlKX19dGUudHJhbnNmb3JtVHlwZXM9e3RyYW5zbGF0ZTpXLHJvdGF0ZTpYLHNjYWxlOlksbWF0cml4Okosc2tld1g6JCxza2V3WTplZX07Y2xhc3MgQWV7Y29uc3RydWN0b3IoZSx0KXt2YXIgQT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdO2lmKHRoaXMuZG9jdW1lbnQ9ZSx0aGlzLm5vZGU9dCx0aGlzLmNhcHR1cmVUZXh0Tm9kZXM9QSx0aGlzLmF0dHJpYnV0ZXM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLnN0eWxlcz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuc3R5bGVzU3BlY2lmaWNpdHk9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLmFuaW1hdGlvbkZyb3plbj0hMSx0aGlzLmFuaW1hdGlvbkZyb3plblZhbHVlPSIiLHRoaXMucGFyZW50PW51bGwsdGhpcy5jaGlsZHJlbj1bXSx0JiYxPT09dC5ub2RlVHlwZSl7QXJyYXkuZnJvbSh0LmF0dHJpYnV0ZXMpLmZvckVhY2godD0+e3ZhciBBPXAodC5ub2RlTmFtZSk7dGhpcy5hdHRyaWJ1dGVzW0FdPW5ldyBUKGUsQSx0LnZhbHVlKX0pLHRoaXMuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpLHRoaXMuZ2V0QXR0cmlidXRlKCJzdHlsZSIpLmhhc1ZhbHVlKCkmJnRoaXMuZ2V0QXR0cmlidXRlKCJzdHlsZSIpLmdldFN0cmluZygpLnNwbGl0KCI7IikubWFwKGU9PmUudHJpbSgpKS5mb3JFYWNoKHQ9PntpZih0KXt2YXJbQSxyXT10LnNwbGl0KCI6IikubWFwKGU9PmUudHJpbSgpKTt0aGlzLnN0eWxlc1tBXT1uZXcgVChlLEEscil9fSk7dmFye2RlZmluaXRpb25zOnJ9PWUsbj10aGlzLmdldEF0dHJpYnV0ZSgiaWQiKTtuLmhhc1ZhbHVlKCkmJihyW24uZ2V0U3RyaW5nKCldfHwocltuLmdldFN0cmluZygpXT10aGlzKSksQXJyYXkuZnJvbSh0LmNoaWxkTm9kZXMpLmZvckVhY2godD0+e2lmKDE9PT10Lm5vZGVUeXBlKXRoaXMuYWRkQ2hpbGQodCk7ZWxzZSBpZihBJiYoMz09PXQubm9kZVR5cGV8fDQ9PT10Lm5vZGVUeXBlKSl7dmFyIHI9ZS5jcmVhdGVUZXh0Tm9kZSh0KTtyLmdldFRleHQoKS5sZW5ndGg+MCYmdGhpcy5hZGRDaGlsZChyKX19KX19Z2V0QXR0cmlidXRlKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0sQT10aGlzLmF0dHJpYnV0ZXNbZV07aWYoIUEmJnQpe3ZhciByPW5ldyBUKHRoaXMuZG9jdW1lbnQsZSwiIik7cmV0dXJuIHRoaXMuYXR0cmlidXRlc1tlXT1yLHJ9cmV0dXJuIEF8fFQuZW1wdHkodGhpcy5kb2N1bWVudCl9Z2V0SHJlZkF0dHJpYnV0ZSgpe2Zvcih2YXIgZSBpbiB0aGlzLmF0dHJpYnV0ZXMpaWYoImhyZWYiPT09ZXx8ZS5lbmRzV2l0aCgiOmhyZWYiKSlyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2VdO3JldHVybiBULmVtcHR5KHRoaXMuZG9jdW1lbnQpfWdldFN0eWxlKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0sQT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLHI9dGhpcy5zdHlsZXNbZV07aWYocilyZXR1cm4gcjt2YXIgbj10aGlzLmdldEF0dHJpYnV0ZShlKTtpZihudWxsIT1uJiZuLmhhc1ZhbHVlKCkpcmV0dXJuIHRoaXMuc3R5bGVzW2VdPW4sbjtpZighQSl7dmFye3BhcmVudDpzfT10aGlzO2lmKHMpe3ZhciBpPXMuZ2V0U3R5bGUoZSk7aWYobnVsbCE9aSYmaS5oYXNWYWx1ZSgpKXJldHVybiBpfX1pZih0KXt2YXIgbz1uZXcgVCh0aGlzLmRvY3VtZW50LGUsIiIpO3JldHVybiB0aGlzLnN0eWxlc1tlXT1vLG99cmV0dXJuIHJ8fFQuZW1wdHkodGhpcy5kb2N1bWVudCl9cmVuZGVyKGUpe2lmKCJub25lIiE9PXRoaXMuZ2V0U3R5bGUoImRpc3BsYXkiKS5nZXRTdHJpbmcoKSYmImhpZGRlbiIhPT10aGlzLmdldFN0eWxlKCJ2aXNpYmlsaXR5IikuZ2V0U3RyaW5nKCkpe2lmKGUuc2F2ZSgpLHRoaXMuZ2V0U3R5bGUoIm1hc2siKS5oYXNWYWx1ZSgpKXt2YXIgdD10aGlzLmdldFN0eWxlKCJtYXNrIikuZ2V0RGVmaW5pdGlvbigpO3QmJih0aGlzLmFwcGx5RWZmZWN0cyhlKSx0LmFwcGx5KGUsdGhpcykpfWVsc2UgaWYoIm5vbmUiIT09dGhpcy5nZXRTdHlsZSgiZmlsdGVyIikuZ2V0VmFsdWUoIm5vbmUiKSl7dmFyIEE9dGhpcy5nZXRTdHlsZSgiZmlsdGVyIikuZ2V0RGVmaW5pdGlvbigpO0EmJih0aGlzLmFwcGx5RWZmZWN0cyhlKSxBLmFwcGx5KGUsdGhpcykpfWVsc2UgdGhpcy5zZXRDb250ZXh0KGUpLHRoaXMucmVuZGVyQ2hpbGRyZW4oZSksdGhpcy5jbGVhckNvbnRleHQoZSk7ZS5yZXN0b3JlKCl9fXNldENvbnRleHQoZSl7fWFwcGx5RWZmZWN0cyhlKXt2YXIgdD10ZS5mcm9tRWxlbWVudCh0aGlzLmRvY3VtZW50LHRoaXMpO3QmJnQuYXBwbHkoZSk7dmFyIEE9dGhpcy5nZXRTdHlsZSgiY2xpcC1wYXRoIiwhMSwhMCk7aWYoQS5oYXNWYWx1ZSgpKXt2YXIgcj1BLmdldERlZmluaXRpb24oKTtyJiZyLmFwcGx5KGUpfX1jbGVhckNvbnRleHQoZSl7fXJlbmRlckNoaWxkcmVuKGUpe3RoaXMuY2hpbGRyZW4uZm9yRWFjaCh0PT57dC5yZW5kZXIoZSl9KX1hZGRDaGlsZChlKXt2YXIgdD1lIGluc3RhbmNlb2YgQWU/ZTp0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSk7dC5wYXJlbnQ9dGhpcyxBZS5pZ25vcmVDaGlsZFR5cGVzLmluY2x1ZGVzKHQudHlwZSl8fHRoaXMuY2hpbGRyZW4ucHVzaCh0KX1tYXRjaGVzU2VsZWN0b3IoZSl7dmFyIHQse25vZGU6QX09dGhpcztpZigiZnVuY3Rpb24iPT10eXBlb2YgQS5tYXRjaGVzKXJldHVybiBBLm1hdGNoZXMoZSk7dmFyIHI9bnVsbD09PSh0PUEuZ2V0QXR0cmlidXRlKXx8dm9pZCAwPT09dD92b2lkIDA6dC5jYWxsKEEsImNsYXNzIik7cmV0dXJuISghcnx8IiI9PT1yKSYmci5zcGxpdCgiICIpLnNvbWUodD0+Ii4iLmNvbmNhdCh0KT09PWUpfWFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKXt2YXJ7c3R5bGVzOmUsc3R5bGVzU3BlY2lmaWNpdHk6dH09dGhpcy5kb2N1bWVudDtmb3IodmFyIEEgaW4gZSlpZighQS5zdGFydHNXaXRoKCJAIikmJnRoaXMubWF0Y2hlc1NlbGVjdG9yKEEpKXt2YXIgcj1lW0FdLG49dFtBXTtpZihyKWZvcih2YXIgcyBpbiByKXt2YXIgaT10aGlzLnN0eWxlc1NwZWNpZmljaXR5W3NdO3ZvaWQgMD09PWkmJihpPSIwMDAiKSxuPj1pJiYodGhpcy5zdHlsZXNbc109cltzXSx0aGlzLnN0eWxlc1NwZWNpZmljaXR5W3NdPW4pfX19cmVtb3ZlU3R5bGVzKGUsdCl7cmV0dXJuIHQucmVkdWNlKCh0LEEpPT57dmFyIHI9ZS5nZXRTdHlsZShBKTtpZighci5oYXNWYWx1ZSgpKXJldHVybiB0O3ZhciBuPXIuZ2V0U3RyaW5nKCk7cmV0dXJuIHIuc2V0VmFsdWUoIiIpLFsuLi50LFtBLG5dXX0sW10pfXJlc3RvcmVTdHlsZXMoZSx0KXt0LmZvckVhY2godD0+e3ZhcltBLHJdPXQ7ZS5nZXRTdHlsZShBLCEwKS5zZXRWYWx1ZShyKX0pfWlzRmlyc3RDaGlsZCgpe3ZhciBlO3JldHVybiAwPT09KG51bGw9PT0oZT10aGlzLnBhcmVudCl8fHZvaWQgMD09PWU/dm9pZCAwOmUuY2hpbGRyZW4uaW5kZXhPZih0aGlzKSl9fUFlLmlnbm9yZUNoaWxkVHlwZXM9WyJ0aXRsZSJdO2NsYXNzIHJlIGV4dGVuZHMgQWV7Y29uc3RydWN0b3IoZSx0LEEpe3N1cGVyKGUsdCxBKX19ZnVuY3Rpb24gbmUoZSl7dmFyIHQ9ZS50cmltKCk7cmV0dXJuL14oJ3wiKS8udGVzdCh0KT90OiciJy5jb25jYXQodCwnIicpfWZ1bmN0aW9uIHNlKGUpe2lmKCFlKXJldHVybiIiO3ZhciB0PWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7c3dpdGNoKHQpe2Nhc2Uibm9ybWFsIjpjYXNlIml0YWxpYyI6Y2FzZSJvYmxpcXVlIjpjYXNlImluaGVyaXQiOmNhc2UiaW5pdGlhbCI6Y2FzZSJ1bnNldCI6cmV0dXJuIHQ7ZGVmYXVsdDpyZXR1cm4vXm9ibGlxdWVccysoLXwpXGQrZGVnJC8udGVzdCh0KT90OiIifX1mdW5jdGlvbiBpZShlKXtpZighZSlyZXR1cm4iIjt2YXIgdD1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO3N3aXRjaCh0KXtjYXNlIm5vcm1hbCI6Y2FzZSJib2xkIjpjYXNlImxpZ2h0ZXIiOmNhc2UiYm9sZGVyIjpjYXNlImluaGVyaXQiOmNhc2UiaW5pdGlhbCI6Y2FzZSJ1bnNldCI6cmV0dXJuIHQ7ZGVmYXVsdDpyZXR1cm4vXltcZC5dKyQvLnRlc3QodCk/dDoiIn19Y2xhc3Mgb2V7Y29uc3RydWN0b3IoZSx0LEEscixuLHMpe3ZhciBpPXM/InN0cmluZyI9PXR5cGVvZiBzP29lLnBhcnNlKHMpOnM6e307dGhpcy5mb250RmFtaWx5PW58fGkuZm9udEZhbWlseSx0aGlzLmZvbnRTaXplPXJ8fGkuZm9udFNpemUsdGhpcy5mb250U3R5bGU9ZXx8aS5mb250U3R5bGUsdGhpcy5mb250V2VpZ2h0PUF8fGkuZm9udFdlaWdodCx0aGlzLmZvbnRWYXJpYW50PXR8fGkuZm9udFZhcmlhbnR9c3RhdGljIHBhcnNlKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsdD0iIixBPSIiLHI9IiIsbj0iIixzPSIiLGk9Yyhhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06IiIpLnRyaW0oKS5zcGxpdCgiICIpLG89e2ZvbnRTaXplOiExLGZvbnRTdHlsZTohMSxmb250V2VpZ2h0OiExLGZvbnRWYXJpYW50OiExfTtyZXR1cm4gaS5mb3JFYWNoKGU9Pntzd2l0Y2goITApe2Nhc2Uhby5mb250U3R5bGUmJm9lLnN0eWxlcy5pbmNsdWRlcyhlKToiaW5oZXJpdCIhPT1lJiYodD1lKSxvLmZvbnRTdHlsZT0hMDticmVhaztjYXNlIW8uZm9udFZhcmlhbnQmJm9lLnZhcmlhbnRzLmluY2x1ZGVzKGUpOiJpbmhlcml0IiE9PWUmJihBPWUpLG8uZm9udFN0eWxlPSEwLG8uZm9udFZhcmlhbnQ9ITA7YnJlYWs7Y2FzZSFvLmZvbnRXZWlnaHQmJm9lLndlaWdodHMuaW5jbHVkZXMoZSk6ImluaGVyaXQiIT09ZSYmKHI9ZSksby5mb250U3R5bGU9ITAsby5mb250VmFyaWFudD0hMCxvLmZvbnRXZWlnaHQ9ITA7YnJlYWs7Y2FzZSFvLmZvbnRTaXplOiJpbmhlcml0IiE9PWUmJihbbl09ZS5zcGxpdCgiLyIpKSxvLmZvbnRTdHlsZT0hMCxvLmZvbnRWYXJpYW50PSEwLG8uZm9udFdlaWdodD0hMCxvLmZvbnRTaXplPSEwO2JyZWFrO2RlZmF1bHQ6ImluaGVyaXQiIT09ZSYmKHMrPWUpfX0pLG5ldyBvZSh0LEEscixuLHMsZSl9dG9TdHJpbmcoKXtyZXR1cm5bc2UodGhpcy5mb250U3R5bGUpLHRoaXMuZm9udFZhcmlhbnQsaWUodGhpcy5mb250V2VpZ2h0KSx0aGlzLmZvbnRTaXplLChlPXRoaXMuZm9udEZhbWlseSwidW5kZWZpbmVkIj09dHlwZW9mIHByb2Nlc3M/ZTplLnRyaW0oKS5zcGxpdCgiLCIpLm1hcChuZSkuam9pbigiLCIpKV0uam9pbigiICIpLnRyaW0oKTt2YXIgZX19b2Uuc3R5bGVzPSJub3JtYWx8aXRhbGljfG9ibGlxdWV8aW5oZXJpdCIsb2UudmFyaWFudHM9Im5vcm1hbHxzbWFsbC1jYXBzfGluaGVyaXQiLG9lLndlaWdodHM9Im5vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwfGluaGVyaXQiO2NsYXNzIGFle2NvbnN0cnVjdG9yKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOk51bWJlci5OYU4sdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06TnVtYmVyLk5hTixBPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpOdW1iZXIuTmFOLHI9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOk51bWJlci5OYU47dGhpcy54MT1lLHRoaXMueTE9dCx0aGlzLngyPUEsdGhpcy55Mj1yLHRoaXMuYWRkUG9pbnQoZSx0KSx0aGlzLmFkZFBvaW50KEEscil9Z2V0IHgoKXtyZXR1cm4gdGhpcy54MX1nZXQgeSgpe3JldHVybiB0aGlzLnkxfWdldCB3aWR0aCgpe3JldHVybiB0aGlzLngyLXRoaXMueDF9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLnkyLXRoaXMueTF9YWRkUG9pbnQoZSx0KXt2b2lkIDAhPT1lJiYoKGlzTmFOKHRoaXMueDEpfHxpc05hTih0aGlzLngyKSkmJih0aGlzLngxPWUsdGhpcy54Mj1lKSxlPHRoaXMueDEmJih0aGlzLngxPWUpLGU+dGhpcy54MiYmKHRoaXMueDI9ZSkpLHZvaWQgMCE9PXQmJigoaXNOYU4odGhpcy55MSl8fGlzTmFOKHRoaXMueTIpKSYmKHRoaXMueTE9dCx0aGlzLnkyPXQpLHQ8dGhpcy55MSYmKHRoaXMueTE9dCksdD50aGlzLnkyJiYodGhpcy55Mj10KSl9YWRkWChlKXt0aGlzLmFkZFBvaW50KGUsbnVsbCl9YWRkWShlKXt0aGlzLmFkZFBvaW50KG51bGwsZSl9YWRkQm91bmRpbmdCb3goZSl7aWYoZSl7dmFye3gxOnQseTE6QSx4MjpyLHkyOm59PWU7dGhpcy5hZGRQb2ludCh0LEEpLHRoaXMuYWRkUG9pbnQocixuKX19c3VtQ3ViaWMoZSx0LEEscixuKXtyZXR1cm4gTWF0aC5wb3coMS1lLDMpKnQrMypNYXRoLnBvdygxLWUsMikqZSpBKzMqKDEtZSkqTWF0aC5wb3coZSwyKSpyK01hdGgucG93KGUsMykqbn1iZXppZXJDdXJ2ZUFkZChlLHQsQSxyLG4pe3ZhciBzPTYqdC0xMipBKzYqcixpPS0zKnQrOSpBLTkqciszKm4sbz0zKkEtMyp0O2lmKDAhPT1pKXt2YXIgYT1NYXRoLnBvdyhzLDIpLTQqbyppO2lmKCEoYTwwKSl7dmFyIGw9KC1zK01hdGguc3FydChhKSkvKDIqaSk7MDxsJiZsPDEmJihlP3RoaXMuYWRkWCh0aGlzLnN1bUN1YmljKGwsdCxBLHIsbikpOnRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKGwsdCxBLHIsbikpKTt2YXIgYz0oLXMtTWF0aC5zcXJ0KGEpKS8oMippKTswPGMmJmM8MSYmKGU/dGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWMoYyx0LEEscixuKSk6dGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWMoYyx0LEEscixuKSkpfX1lbHNle2lmKDA9PT1zKXJldHVybjt2YXIgdT0tby9zOzA8dSYmdTwxJiYoZT90aGlzLmFkZFgodGhpcy5zdW1DdWJpYyh1LHQsQSxyLG4pKTp0aGlzLmFkZFkodGhpcy5zdW1DdWJpYyh1LHQsQSxyLG4pKSl9fWFkZEJlemllckN1cnZlKGUsdCxBLHIsbixzLGksbyl7dGhpcy5hZGRQb2ludChlLHQpLHRoaXMuYWRkUG9pbnQoaSxvKSx0aGlzLmJlemllckN1cnZlQWRkKCEwLGUsQSxuLGkpLHRoaXMuYmV6aWVyQ3VydmVBZGQoITEsdCxyLHMsbyl9YWRkUXVhZHJhdGljQ3VydmUoZSx0LEEscixuLHMpe3ZhciBpPWUrMi8zKihBLWUpLG89dCsyLzMqKHItdCksYT1pKzEvMyoobi1lKSxsPW8rMS8zKihzLXQpO3RoaXMuYWRkQmV6aWVyQ3VydmUoZSx0LGksYSxvLGwsbixzKX1pc1BvaW50SW5Cb3goZSx0KXt2YXJ7eDE6QSx5MTpyLHgyOm4seTI6c309dGhpcztyZXR1cm4gQTw9ZSYmZTw9biYmcjw9dCYmdDw9c319Y2xhc3MgbGUgZXh0ZW5kcyBvLlNWR1BhdGhEYXRhe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUucmVwbGFjZSgvKFsrXC0uXSlccysvZ20sIiQxIikucmVwbGFjZSgvW15NbVp6TGxIaFZ2Q2NTc1FxVHRBYWVcZFxzLiwrLV0uKi9nLCIiKSksdGhpcy5jb250cm9sPW51bGwsdGhpcy5zdGFydD1udWxsLHRoaXMuY3VycmVudD1udWxsLHRoaXMuY29tbWFuZD1udWxsLHRoaXMuY29tbWFuZHM9dGhpcy5jb21tYW5kcyx0aGlzLmk9LTEsdGhpcy5wcmV2aW91c0NvbW1hbmQ9bnVsbCx0aGlzLnBvaW50cz1bXSx0aGlzLmFuZ2xlcz1bXX1yZXNldCgpe3RoaXMuaT0tMSx0aGlzLmNvbW1hbmQ9bnVsbCx0aGlzLnByZXZpb3VzQ29tbWFuZD1udWxsLHRoaXMuc3RhcnQ9bmV3IE0oMCwwKSx0aGlzLmNvbnRyb2w9bmV3IE0oMCwwKSx0aGlzLmN1cnJlbnQ9bmV3IE0oMCwwKSx0aGlzLnBvaW50cz1bXSx0aGlzLmFuZ2xlcz1bXX1pc0VuZCgpe3ZhcntpOmUsY29tbWFuZHM6dH09dGhpcztyZXR1cm4gZT49dC5sZW5ndGgtMX1uZXh0KCl7dmFyIGU9dGhpcy5jb21tYW5kc1srK3RoaXMuaV07cmV0dXJuIHRoaXMucHJldmlvdXNDb21tYW5kPXRoaXMuY29tbWFuZCx0aGlzLmNvbW1hbmQ9ZSxlfWdldFBvaW50KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOiJ4Iix0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToieSIsQT1uZXcgTSh0aGlzLmNvbW1hbmRbZV0sdGhpcy5jb21tYW5kW3RdKTtyZXR1cm4gdGhpcy5tYWtlQWJzb2x1dGUoQSl9Z2V0QXNDb250cm9sUG9pbnQoZSx0KXt2YXIgQT10aGlzLmdldFBvaW50KGUsdCk7cmV0dXJuIHRoaXMuY29udHJvbD1BLEF9Z2V0QXNDdXJyZW50UG9pbnQoZSx0KXt2YXIgQT10aGlzLmdldFBvaW50KGUsdCk7cmV0dXJuIHRoaXMuY3VycmVudD1BLEF9Z2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCl7dmFyIGU9dGhpcy5wcmV2aW91c0NvbW1hbmQudHlwZTtpZihlIT09by5TVkdQYXRoRGF0YS5DVVJWRV9UTyYmZSE9PW8uU1ZHUGF0aERhdGEuU01PT1RIX0NVUlZFX1RPJiZlIT09by5TVkdQYXRoRGF0YS5RVUFEX1RPJiZlIT09by5TVkdQYXRoRGF0YS5TTU9PVEhfUVVBRF9UTylyZXR1cm4gdGhpcy5jdXJyZW50O3ZhcntjdXJyZW50Ont4OnQseTpBfSxjb250cm9sOnt4OnIseTpufX09dGhpcztyZXR1cm4gbmV3IE0oMip0LXIsMipBLW4pfW1ha2VBYnNvbHV0ZShlKXtpZih0aGlzLmNvbW1hbmQucmVsYXRpdmUpe3Zhcnt4OnQseTpBfT10aGlzLmN1cnJlbnQ7ZS54Kz10LGUueSs9QX1yZXR1cm4gZX1hZGRNYXJrZXIoZSx0LEEpe3Zhcntwb2ludHM6cixhbmdsZXM6bn09dGhpcztBJiZuLmxlbmd0aD4wJiYhbltuLmxlbmd0aC0xXSYmKG5bbi5sZW5ndGgtMV09cltyLmxlbmd0aC0xXS5hbmdsZVRvKEEpKSx0aGlzLmFkZE1hcmtlckFuZ2xlKGUsdD90LmFuZ2xlVG8oZSk6bnVsbCl9YWRkTWFya2VyQW5nbGUoZSx0KXt0aGlzLnBvaW50cy5wdXNoKGUpLHRoaXMuYW5nbGVzLnB1c2godCl9Z2V0TWFya2VyUG9pbnRzKCl7cmV0dXJuIHRoaXMucG9pbnRzfWdldE1hcmtlckFuZ2xlcygpe2Zvcih2YXJ7YW5nbGVzOmV9PXRoaXMsdD1lLmxlbmd0aCxBPTA7QTx0O0ErKylpZighZVtBXSlmb3IodmFyIHI9QSsxO3I8dDtyKyspaWYoZVtyXSl7ZVtBXT1lW3JdO2JyZWFrfXJldHVybiBlfX1jbGFzcyBjZSBleHRlbmRzIEFle2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2s9ITF9Y2FsY3VsYXRlT3BhY2l0eSgpe2Zvcih2YXIgZT0xLHQ9dGhpczt0Oyl7dmFyIEE9dC5nZXRTdHlsZSgib3BhY2l0eSIsITEsITApO0EuaGFzVmFsdWUoITApJiYoZSo9QS5nZXROdW1iZXIoKSksdD10LnBhcmVudH1yZXR1cm4gZX1zZXRDb250ZXh0KGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV07aWYoIXQpe3ZhciBBPXRoaXMuZ2V0U3R5bGUoImZpbGwiKSxyPXRoaXMuZ2V0U3R5bGUoImZpbGwtb3BhY2l0eSIpLG49dGhpcy5nZXRTdHlsZSgic3Ryb2tlIikscz10aGlzLmdldFN0eWxlKCJzdHJva2Utb3BhY2l0eSIpO2lmKEEuaXNVcmxEZWZpbml0aW9uKCkpe3ZhciBpPUEuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLHIpO2kmJihlLmZpbGxTdHlsZT1pKX1lbHNlIGlmKEEuaGFzVmFsdWUoKSl7ImN1cnJlbnRDb2xvciI9PT1BLmdldFN0cmluZygpJiZBLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoImNvbG9yIikuZ2V0Q29sb3IoKSk7dmFyIG89QS5nZXRDb2xvcigpOyJpbmhlcml0IiE9PW8mJihlLmZpbGxTdHlsZT0ibm9uZSI9PT1vPyJyZ2JhKDAsMCwwLDApIjpvKX1pZihyLmhhc1ZhbHVlKCkpe3ZhciBhPW5ldyBUKHRoaXMuZG9jdW1lbnQsImZpbGwiLGUuZmlsbFN0eWxlKS5hZGRPcGFjaXR5KHIpLmdldENvbG9yKCk7ZS5maWxsU3R5bGU9YX1pZihuLmlzVXJsRGVmaW5pdGlvbigpKXt2YXIgbD1uLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcyxzKTtsJiYoZS5zdHJva2VTdHlsZT1sKX1lbHNlIGlmKG4uaGFzVmFsdWUoKSl7ImN1cnJlbnRDb2xvciI9PT1uLmdldFN0cmluZygpJiZuLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoImNvbG9yIikuZ2V0Q29sb3IoKSk7dmFyIGM9bi5nZXRTdHJpbmcoKTsiaW5oZXJpdCIhPT1jJiYoZS5zdHJva2VTdHlsZT0ibm9uZSI9PT1jPyJyZ2JhKDAsMCwwLDApIjpjKX1pZihzLmhhc1ZhbHVlKCkpe3ZhciB1PW5ldyBUKHRoaXMuZG9jdW1lbnQsInN0cm9rZSIsZS5zdHJva2VTdHlsZSkuYWRkT3BhY2l0eShzKS5nZXRTdHJpbmcoKTtlLnN0cm9rZVN0eWxlPXV9dmFyIGg9dGhpcy5nZXRTdHlsZSgic3Ryb2tlLXdpZHRoIik7aWYoaC5oYXNWYWx1ZSgpKXt2YXIgZj1oLmdldFBpeGVscygpO2UubGluZVdpZHRoPWZ8fEZ9dmFyIHA9dGhpcy5nZXRTdHlsZSgic3Ryb2tlLWxpbmVjYXAiKSxnPXRoaXMuZ2V0U3R5bGUoInN0cm9rZS1saW5lam9pbiIpLG09dGhpcy5nZXRTdHlsZSgic3Ryb2tlLW1pdGVybGltaXQiKSx3PXRoaXMuZ2V0U3R5bGUoInN0cm9rZS1kYXNoYXJyYXkiKSxCPXRoaXMuZ2V0U3R5bGUoInN0cm9rZS1kYXNob2Zmc2V0Iik7aWYocC5oYXNWYWx1ZSgpJiYoZS5saW5lQ2FwPXAuZ2V0U3RyaW5nKCkpLGcuaGFzVmFsdWUoKSYmKGUubGluZUpvaW49Zy5nZXRTdHJpbmcoKSksbS5oYXNWYWx1ZSgpJiYoZS5taXRlckxpbWl0PW0uZ2V0TnVtYmVyKCkpLHcuaGFzVmFsdWUoKSYmIm5vbmUiIT09dy5nZXRTdHJpbmcoKSl7dmFyIHk9ZCh3LmdldFN0cmluZygpKTt2b2lkIDAhPT1lLnNldExpbmVEYXNoP2Uuc2V0TGluZURhc2goeSk6dm9pZCAwIT09ZS53ZWJraXRMaW5lRGFzaD9lLndlYmtpdExpbmVEYXNoPXk6dm9pZCAwPT09ZS5tb3pEYXNofHwxPT09eS5sZW5ndGgmJjA9PT15WzBdfHwoZS5tb3pEYXNoPXkpO3ZhciB2PUIuZ2V0UGl4ZWxzKCk7dm9pZCAwIT09ZS5saW5lRGFzaE9mZnNldD9lLmxpbmVEYXNoT2Zmc2V0PXY6dm9pZCAwIT09ZS53ZWJraXRMaW5lRGFzaE9mZnNldD9lLndlYmtpdExpbmVEYXNoT2Zmc2V0PXY6dm9pZCAwIT09ZS5tb3pEYXNoT2Zmc2V0JiYoZS5tb3pEYXNoT2Zmc2V0PXYpfX1pZih0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2s9ITEsdm9pZCAwIT09ZS5mb250KXt2YXIgYj10aGlzLmdldFN0eWxlKCJmb250IiksQz10aGlzLmdldFN0eWxlKCJmb250LXN0eWxlIiksXz10aGlzLmdldFN0eWxlKCJmb250LXZhcmlhbnQiKSxqPXRoaXMuZ2V0U3R5bGUoImZvbnQtd2VpZ2h0IikseD10aGlzLmdldFN0eWxlKCJmb250LXNpemUiKSxRPXRoaXMuZ2V0U3R5bGUoImZvbnQtZmFtaWx5IiksVT1uZXcgb2UoQy5nZXRTdHJpbmcoKSxfLmdldFN0cmluZygpLGouZ2V0U3RyaW5nKCkseC5oYXNWYWx1ZSgpPyIiLmNvbmNhdCh4LmdldFBpeGVscyghMCksInB4Iik6IiIsUS5nZXRTdHJpbmcoKSxvZS5wYXJzZShiLmdldFN0cmluZygpLGUuZm9udCkpO0Muc2V0VmFsdWUoVS5mb250U3R5bGUpLF8uc2V0VmFsdWUoVS5mb250VmFyaWFudCksai5zZXRWYWx1ZShVLmZvbnRXZWlnaHQpLHguc2V0VmFsdWUoVS5mb250U2l6ZSksUS5zZXRWYWx1ZShVLmZvbnRGYW1pbHkpLGUuZm9udD1VLnRvU3RyaW5nKCkseC5pc1BpeGVscygpJiYodGhpcy5kb2N1bWVudC5lbVNpemU9eC5nZXRQaXhlbHMoKSx0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2s9ITApfXR8fCh0aGlzLmFwcGx5RWZmZWN0cyhlKSxlLmdsb2JhbEFscGhhPXRoaXMuY2FsY3VsYXRlT3BhY2l0eSgpKX1jbGVhckNvbnRleHQoZSl7c3VwZXIuY2xlYXJDb250ZXh0KGUpLHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayYmdGhpcy5kb2N1bWVudC5wb3BFbVNpemUoKX19Y2xhc3MgdWUgZXh0ZW5kcyBjZXtjb25zdHJ1Y3RvcihlLHQsQSl7c3VwZXIoZSx0LEEpLHRoaXMudHlwZT0icGF0aCIsdGhpcy5wYXRoUGFyc2VyPW51bGwsdGhpcy5wYXRoUGFyc2VyPW5ldyBsZSh0aGlzLmdldEF0dHJpYnV0ZSgiZCIpLmdldFN0cmluZygpKX1wYXRoKGUpe3ZhcntwYXRoUGFyc2VyOnR9PXRoaXMsQT1uZXcgYWU7Zm9yKHQucmVzZXQoKSxlJiZlLmJlZ2luUGF0aCgpOyF0LmlzRW5kKCk7KXN3aXRjaCh0Lm5leHQoKS50eXBlKXtjYXNlIGxlLk1PVkVfVE86dGhpcy5wYXRoTShlLEEpO2JyZWFrO2Nhc2UgbGUuTElORV9UTzp0aGlzLnBhdGhMKGUsQSk7YnJlYWs7Y2FzZSBsZS5IT1JJWl9MSU5FX1RPOnRoaXMucGF0aEgoZSxBKTticmVhaztjYXNlIGxlLlZFUlRfTElORV9UTzp0aGlzLnBhdGhWKGUsQSk7YnJlYWs7Y2FzZSBsZS5DVVJWRV9UTzp0aGlzLnBhdGhDKGUsQSk7YnJlYWs7Y2FzZSBsZS5TTU9PVEhfQ1VSVkVfVE86dGhpcy5wYXRoUyhlLEEpO2JyZWFrO2Nhc2UgbGUuUVVBRF9UTzp0aGlzLnBhdGhRKGUsQSk7YnJlYWs7Y2FzZSBsZS5TTU9PVEhfUVVBRF9UTzp0aGlzLnBhdGhUKGUsQSk7YnJlYWs7Y2FzZSBsZS5BUkM6dGhpcy5wYXRoQShlLEEpO2JyZWFrO2Nhc2UgbGUuQ0xPU0VfUEFUSDp0aGlzLnBhdGhaKGUsQSl9cmV0dXJuIEF9Z2V0Qm91bmRpbmdCb3goZSl7cmV0dXJuIHRoaXMucGF0aCgpfWdldE1hcmtlcnMoKXt2YXJ7cGF0aFBhcnNlcjplfT10aGlzLHQ9ZS5nZXRNYXJrZXJQb2ludHMoKSxBPWUuZ2V0TWFya2VyQW5nbGVzKCk7cmV0dXJuIHQubWFwKChlLHQpPT5bZSxBW3RdXSl9cmVuZGVyQ2hpbGRyZW4oZSl7dGhpcy5wYXRoKGUpLHRoaXMuZG9jdW1lbnQuc2NyZWVuLm1vdXNlLmNoZWNrUGF0aCh0aGlzLGUpO3ZhciB0PXRoaXMuZ2V0U3R5bGUoImZpbGwtcnVsZSIpOyIiIT09ZS5maWxsU3R5bGUmJigiaW5oZXJpdCIhPT10LmdldFN0cmluZygiaW5oZXJpdCIpP2UuZmlsbCh0LmdldFN0cmluZygpKTplLmZpbGwoKSksIiIhPT1lLnN0cm9rZVN0eWxlJiYoIm5vbi1zY2FsaW5nLXN0cm9rZSI9PT10aGlzLmdldEF0dHJpYnV0ZSgidmVjdG9yLWVmZmVjdCIpLmdldFN0cmluZygpPyhlLnNhdmUoKSxlLnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCksZS5zdHJva2UoKSxlLnJlc3RvcmUoKSk6ZS5zdHJva2UoKSk7dmFyIEE9dGhpcy5nZXRNYXJrZXJzKCk7aWYoQSl7dmFyIHI9QS5sZW5ndGgtMSxuPXRoaXMuZ2V0U3R5bGUoIm1hcmtlci1zdGFydCIpLHM9dGhpcy5nZXRTdHlsZSgibWFya2VyLW1pZCIpLGk9dGhpcy5nZXRTdHlsZSgibWFya2VyLWVuZCIpO2lmKG4uaXNVcmxEZWZpbml0aW9uKCkpe3ZhciBvPW4uZ2V0RGVmaW5pdGlvbigpLFthLGxdPUFbMF07by5yZW5kZXIoZSxhLGwpfWlmKHMuaXNVcmxEZWZpbml0aW9uKCkpZm9yKHZhciBjPXMuZ2V0RGVmaW5pdGlvbigpLHU9MTt1PHI7dSsrKXt2YXJbaCxkXT1BW3VdO2MucmVuZGVyKGUsaCxkKX1pZihpLmlzVXJsRGVmaW5pdGlvbigpKXt2YXIgZj1pLmdldERlZmluaXRpb24oKSxbcCxnXT1BW3JdO2YucmVuZGVyKGUscCxnKX19fXN0YXRpYyBwYXRoTShlKXt2YXIgdD1lLmdldEFzQ3VycmVudFBvaW50KCk7cmV0dXJuIGUuc3RhcnQ9ZS5jdXJyZW50LHtwb2ludDp0fX1wYXRoTShlLHQpe3ZhcntwYXRoUGFyc2VyOkF9PXRoaXMse3BvaW50OnJ9PXVlLnBhdGhNKEEpLHt4Om4seTpzfT1yO0EuYWRkTWFya2VyKHIpLHQuYWRkUG9pbnQobixzKSxlJiZlLm1vdmVUbyhuLHMpfXN0YXRpYyBwYXRoTChlKXt2YXJ7Y3VycmVudDp0fT1lO3JldHVybntjdXJyZW50OnQscG9pbnQ6ZS5nZXRBc0N1cnJlbnRQb2ludCgpfX1wYXRoTChlLHQpe3ZhcntwYXRoUGFyc2VyOkF9PXRoaXMse2N1cnJlbnQ6cixwb2ludDpufT11ZS5wYXRoTChBKSx7eDpzLHk6aX09bjtBLmFkZE1hcmtlcihuLHIpLHQuYWRkUG9pbnQocyxpKSxlJiZlLmxpbmVUbyhzLGkpfXN0YXRpYyBwYXRoSChlKXt2YXJ7Y3VycmVudDp0LGNvbW1hbmQ6QX09ZSxyPW5ldyBNKChBLnJlbGF0aXZlP3QueDowKStBLngsdC55KTtyZXR1cm4gZS5jdXJyZW50PXIse2N1cnJlbnQ6dCxwb2ludDpyfX1wYXRoSChlLHQpe3ZhcntwYXRoUGFyc2VyOkF9PXRoaXMse2N1cnJlbnQ6cixwb2ludDpufT11ZS5wYXRoSChBKSx7eDpzLHk6aX09bjtBLmFkZE1hcmtlcihuLHIpLHQuYWRkUG9pbnQocyxpKSxlJiZlLmxpbmVUbyhzLGkpfXN0YXRpYyBwYXRoVihlKXt2YXJ7Y3VycmVudDp0LGNvbW1hbmQ6QX09ZSxyPW5ldyBNKHQueCwoQS5yZWxhdGl2ZT90Lnk6MCkrQS55KTtyZXR1cm4gZS5jdXJyZW50PXIse2N1cnJlbnQ6dCxwb2ludDpyfX1wYXRoVihlLHQpe3ZhcntwYXRoUGFyc2VyOkF9PXRoaXMse2N1cnJlbnQ6cixwb2ludDpufT11ZS5wYXRoVihBKSx7eDpzLHk6aX09bjtBLmFkZE1hcmtlcihuLHIpLHQuYWRkUG9pbnQocyxpKSxlJiZlLmxpbmVUbyhzLGkpfXN0YXRpYyBwYXRoQyhlKXt2YXJ7Y3VycmVudDp0fT1lO3JldHVybntjdXJyZW50OnQscG9pbnQ6ZS5nZXRQb2ludCgieDEiLCJ5MSIpLGNvbnRyb2xQb2ludDplLmdldEFzQ29udHJvbFBvaW50KCJ4MiIsInkyIiksY3VycmVudFBvaW50OmUuZ2V0QXNDdXJyZW50UG9pbnQoKX19cGF0aEMoZSx0KXt2YXJ7cGF0aFBhcnNlcjpBfT10aGlzLHtjdXJyZW50OnIscG9pbnQ6bixjb250cm9sUG9pbnQ6cyxjdXJyZW50UG9pbnQ6aX09dWUucGF0aEMoQSk7QS5hZGRNYXJrZXIoaSxzLG4pLHQuYWRkQmV6aWVyQ3VydmUoci54LHIueSxuLngsbi55LHMueCxzLnksaS54LGkueSksZSYmZS5iZXppZXJDdXJ2ZVRvKG4ueCxuLnkscy54LHMueSxpLngsaS55KX1zdGF0aWMgcGF0aFMoZSl7dmFye2N1cnJlbnQ6dH09ZTtyZXR1cm57Y3VycmVudDp0LHBvaW50OmUuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCksY29udHJvbFBvaW50OmUuZ2V0QXNDb250cm9sUG9pbnQoIngyIiwieTIiKSxjdXJyZW50UG9pbnQ6ZS5nZXRBc0N1cnJlbnRQb2ludCgpfX1wYXRoUyhlLHQpe3ZhcntwYXRoUGFyc2VyOkF9PXRoaXMse2N1cnJlbnQ6cixwb2ludDpuLGNvbnRyb2xQb2ludDpzLGN1cnJlbnRQb2ludDppfT11ZS5wYXRoUyhBKTtBLmFkZE1hcmtlcihpLHMsbiksdC5hZGRCZXppZXJDdXJ2ZShyLngsci55LG4ueCxuLnkscy54LHMueSxpLngsaS55KSxlJiZlLmJlemllckN1cnZlVG8obi54LG4ueSxzLngscy55LGkueCxpLnkpfXN0YXRpYyBwYXRoUShlKXt2YXJ7Y3VycmVudDp0fT1lO3JldHVybntjdXJyZW50OnQsY29udHJvbFBvaW50OmUuZ2V0QXNDb250cm9sUG9pbnQoIngxIiwieTEiKSxjdXJyZW50UG9pbnQ6ZS5nZXRBc0N1cnJlbnRQb2ludCgpfX1wYXRoUShlLHQpe3ZhcntwYXRoUGFyc2VyOkF9PXRoaXMse2N1cnJlbnQ6cixjb250cm9sUG9pbnQ6bixjdXJyZW50UG9pbnQ6c309dWUucGF0aFEoQSk7QS5hZGRNYXJrZXIocyxuLG4pLHQuYWRkUXVhZHJhdGljQ3VydmUoci54LHIueSxuLngsbi55LHMueCxzLnkpLGUmJmUucXVhZHJhdGljQ3VydmVUbyhuLngsbi55LHMueCxzLnkpfXN0YXRpYyBwYXRoVChlKXt2YXJ7Y3VycmVudDp0fT1lLEE9ZS5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKTtyZXR1cm4gZS5jb250cm9sPUEse2N1cnJlbnQ6dCxjb250cm9sUG9pbnQ6QSxjdXJyZW50UG9pbnQ6ZS5nZXRBc0N1cnJlbnRQb2ludCgpfX1wYXRoVChlLHQpe3ZhcntwYXRoUGFyc2VyOkF9PXRoaXMse2N1cnJlbnQ6cixjb250cm9sUG9pbnQ6bixjdXJyZW50UG9pbnQ6c309dWUucGF0aFQoQSk7QS5hZGRNYXJrZXIocyxuLG4pLHQuYWRkUXVhZHJhdGljQ3VydmUoci54LHIueSxuLngsbi55LHMueCxzLnkpLGUmJmUucXVhZHJhdGljQ3VydmVUbyhuLngsbi55LHMueCxzLnkpfXN0YXRpYyBwYXRoQShlKXt2YXJ7Y3VycmVudDp0LGNvbW1hbmQ6QX09ZSx7clg6cixyWTpuLHhSb3Q6cyxsQXJjRmxhZzppLHN3ZWVwRmxhZzpvfT1BLGE9cyooTWF0aC5QSS8xODApLGw9ZS5nZXRBc0N1cnJlbnRQb2ludCgpLGM9bmV3IE0oTWF0aC5jb3MoYSkqKHQueC1sLngpLzIrTWF0aC5zaW4oYSkqKHQueS1sLnkpLzIsLU1hdGguc2luKGEpKih0LngtbC54KS8yK01hdGguY29zKGEpKih0LnktbC55KS8yKSx1PU1hdGgucG93KGMueCwyKS9NYXRoLnBvdyhyLDIpK01hdGgucG93KGMueSwyKS9NYXRoLnBvdyhuLDIpO3U+MSYmKHIqPU1hdGguc3FydCh1KSxuKj1NYXRoLnNxcnQodSkpO3ZhciBoPShpPT09bz8tMToxKSpNYXRoLnNxcnQoKE1hdGgucG93KHIsMikqTWF0aC5wb3cobiwyKS1NYXRoLnBvdyhyLDIpKk1hdGgucG93KGMueSwyKS1NYXRoLnBvdyhuLDIpKk1hdGgucG93KGMueCwyKSkvKE1hdGgucG93KHIsMikqTWF0aC5wb3coYy55LDIpK01hdGgucG93KG4sMikqTWF0aC5wb3coYy54LDIpKSk7aXNOYU4oaCkmJihoPTApO3ZhciBkPW5ldyBNKGgqcipjLnkvbixoKi1uKmMueC9yKSxmPW5ldyBNKCh0LngrbC54KS8yK01hdGguY29zKGEpKmQueC1NYXRoLnNpbihhKSpkLnksKHQueStsLnkpLzIrTWF0aC5zaW4oYSkqZC54K01hdGguY29zKGEpKmQueSkscD1FKFsxLDBdLFsoYy54LWQueCkvciwoYy55LWQueSkvbl0pLGc9WyhjLngtZC54KS9yLChjLnktZC55KS9uXSxtPVsoLWMueC1kLngpL3IsKC1jLnktZC55KS9uXSx3PUUoZyxtKTtyZXR1cm4gVShnLG0pPD0tMSYmKHc9TWF0aC5QSSksVShnLG0pPj0xJiYodz0wKSx7Y3VycmVudFBvaW50Omwsclg6cixyWTpuLHN3ZWVwRmxhZzpvLHhBeGlzUm90YXRpb246YSxjZW50cDpmLGExOnAsYWQ6d319cGF0aEEoZSx0KXt2YXJ7cGF0aFBhcnNlcjpBfT10aGlzLHtjdXJyZW50UG9pbnQ6cixyWDpuLHJZOnMsc3dlZXBGbGFnOmkseEF4aXNSb3RhdGlvbjpvLGNlbnRwOmEsYTE6bCxhZDpjfT11ZS5wYXRoQShBKSx1PTEtaT8xOi0xLGg9bCt1KihjLzIpLGQ9bmV3IE0oYS54K24qTWF0aC5jb3MoaCksYS55K3MqTWF0aC5zaW4oaCkpO2lmKEEuYWRkTWFya2VyQW5nbGUoZCxoLXUqTWF0aC5QSS8yKSxBLmFkZE1hcmtlckFuZ2xlKHIsaC11Kk1hdGguUEkpLHQuYWRkUG9pbnQoci54LHIueSksZSYmIWlzTmFOKGwpJiYhaXNOYU4oYykpe3ZhciBmPW4+cz9uOnMscD1uPnM/MTpuL3MsZz1uPnM/cy9uOjE7ZS50cmFuc2xhdGUoYS54LGEueSksZS5yb3RhdGUobyksZS5zY2FsZShwLGcpLGUuYXJjKDAsMCxmLGwsbCtjLEJvb2xlYW4oMS1pKSksZS5zY2FsZSgxL3AsMS9nKSxlLnJvdGF0ZSgtbyksZS50cmFuc2xhdGUoLWEueCwtYS55KX19c3RhdGljIHBhdGhaKGUpe2UuY3VycmVudD1lLnN0YXJ0fXBhdGhaKGUsdCl7dWUucGF0aFoodGhpcy5wYXRoUGFyc2VyKSxlJiZ0LngxIT09dC54MiYmdC55MSE9PXQueTImJmUuY2xvc2VQYXRoKCl9fWNsYXNzIGhlIGV4dGVuZHMgdWV7Y29uc3RydWN0b3IoZSx0LEEpe3N1cGVyKGUsdCxBKSx0aGlzLnR5cGU9ImdseXBoIix0aGlzLmhvcml6QWR2WD10aGlzLmdldEF0dHJpYnV0ZSgiaG9yaXotYWR2LXgiKS5nZXROdW1iZXIoKSx0aGlzLnVuaWNvZGU9dGhpcy5nZXRBdHRyaWJ1dGUoInVuaWNvZGUiKS5nZXRTdHJpbmcoKSx0aGlzLmFyYWJpY0Zvcm09dGhpcy5nZXRBdHRyaWJ1dGUoImFyYWJpYy1mb3JtIikuZ2V0U3RyaW5nKCl9fWNsYXNzIGRlIGV4dGVuZHMgY2V7Y29uc3RydWN0b3IoZSx0LEEpe3N1cGVyKGUsdCxuZXcudGFyZ2V0PT09ZGV8fEEpLHRoaXMudHlwZT0idGV4dCIsdGhpcy54PTAsdGhpcy55PTAsdGhpcy5tZWFzdXJlQ2FjaGU9LTF9c2V0Q29udGV4dChlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdO3N1cGVyLnNldENvbnRleHQoZSx0KTt2YXIgQT10aGlzLmdldFN0eWxlKCJkb21pbmFudC1iYXNlbGluZSIpLmdldFRleHRCYXNlbGluZSgpfHx0aGlzLmdldFN0eWxlKCJhbGlnbm1lbnQtYmFzZWxpbmUiKS5nZXRUZXh0QmFzZWxpbmUoKTtBJiYoZS50ZXh0QmFzZWxpbmU9QSl9aW5pdGlhbGl6ZUNvb3JkaW5hdGVzKCl7dGhpcy54PTAsdGhpcy55PTAsdGhpcy5sZWFmVGV4dHM9W10sdGhpcy50ZXh0Q2h1bmtTdGFydD0wLHRoaXMubWluWD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5tYXhYPU51bWJlci5ORUdBVElWRV9JTkZJTklUWX1nZXRCb3VuZGluZ0JveChlKXtpZigidGV4dCIhPT10aGlzLnR5cGUpcmV0dXJuIHRoaXMuZ2V0VEVsZW1lbnRCb3VuZGluZ0JveChlKTt0aGlzLmluaXRpYWxpemVDb29yZGluYXRlcygpLHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShlKTt2YXIgdD1udWxsO3JldHVybiB0aGlzLmNoaWxkcmVuLmZvckVhY2goKEEscik9Pnt2YXIgbj10aGlzLmdldENoaWxkQm91bmRpbmdCb3goZSx0aGlzLHRoaXMscik7dD90LmFkZEJvdW5kaW5nQm94KG4pOnQ9bn0pLHR9Z2V0Rm9udFNpemUoKXt2YXJ7ZG9jdW1lbnQ6ZSxwYXJlbnQ6dH09dGhpcyxBPW9lLnBhcnNlKGUuY3R4LmZvbnQpLmZvbnRTaXplO3JldHVybiB0LmdldFN0eWxlKCJmb250LXNpemUiKS5nZXROdW1iZXIoQSl9Z2V0VEVsZW1lbnRCb3VuZGluZ0JveChlKXt2YXIgdD10aGlzLmdldEZvbnRTaXplKCk7cmV0dXJuIG5ldyBhZSh0aGlzLngsdGhpcy55LXQsdGhpcy54K3RoaXMubWVhc3VyZVRleHQoZSksdGhpcy55KX1nZXRHbHlwaChlLHQsQSl7dmFyIHI9dFtBXSxuPW51bGw7aWYoZS5pc0FyYWJpYyl7dmFyIHM9dC5sZW5ndGgsaT10W0EtMV0sbz10W0ErMV0sYT0iaXNvbGF0ZWQiO2lmKCgwPT09QXx8IiAiPT09aSkmJkE8cy0xJiYiICIhPT1vJiYoYT0idGVybWluYWwiKSxBPjAmJiIgIiE9PWkmJkE8cy0xJiYiICIhPT1vJiYoYT0ibWVkaWFsIiksQT4wJiYiICIhPT1pJiYoQT09PXMtMXx8IiAiPT09bykmJihhPSJpbml0aWFsIiksdm9pZCAwIT09ZS5nbHlwaHNbcl0pe3ZhciBsPWUuZ2x5cGhzW3JdO249bCBpbnN0YW5jZW9mIGhlP2w6bFthXX19ZWxzZSBuPWUuZ2x5cGhzW3JdO3JldHVybiBufHwobj1lLm1pc3NpbmdHbHlwaCksbn1nZXRUZXh0KCl7cmV0dXJuIiJ9Z2V0VGV4dEZyb21Ob2RlKGUpe3ZhciB0PWV8fHRoaXMubm9kZSxBPUFycmF5LmZyb20odC5wYXJlbnROb2RlLmNoaWxkTm9kZXMpLHI9QS5pbmRleE9mKHQpLG49QS5sZW5ndGgtMSxzPWModC50ZXh0Q29udGVudHx8IiIpO3JldHVybiAwPT09ciYmKHM9dShzKSkscj09PW4mJihzPWgocykpLHN9cmVuZGVyQ2hpbGRyZW4oZSl7aWYoInRleHQiPT09dGhpcy50eXBlKXt0aGlzLmluaXRpYWxpemVDb29yZGluYXRlcygpLHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShlKSx0aGlzLmNoaWxkcmVuLmZvckVhY2goKHQsQSk9Pnt0aGlzLnJlbmRlckNoaWxkKGUsdGhpcyx0aGlzLEEpfSk7dmFye21vdXNlOnR9PXRoaXMuZG9jdW1lbnQuc2NyZWVuO3QuaXNXb3JraW5nKCkmJnQuY2hlY2tCb3VuZGluZ0JveCh0aGlzLHRoaXMuZ2V0Qm91bmRpbmdCb3goZSkpfWVsc2UgdGhpcy5yZW5kZXJURWxlbWVudENoaWxkcmVuKGUpfXJlbmRlclRFbGVtZW50Q2hpbGRyZW4oZSl7dmFye2RvY3VtZW50OnQscGFyZW50OkF9PXRoaXMscj10aGlzLmdldFRleHQoKSxuPUEuZ2V0U3R5bGUoImZvbnQtZmFtaWx5IikuZ2V0RGVmaW5pdGlvbigpO2lmKG4pZm9yKHZhcnt1bml0c1BlckVtOnN9PW4uZm9udEZhY2UsaT1vZS5wYXJzZSh0LmN0eC5mb250KSxvPUEuZ2V0U3R5bGUoImZvbnQtc2l6ZSIpLmdldE51bWJlcihpLmZvbnRTaXplKSxhPUEuZ2V0U3R5bGUoImZvbnQtc3R5bGUiKS5nZXRTdHJpbmcoaS5mb250U3R5bGUpLGw9by9zLGM9bi5pc1JUTD9yLnNwbGl0KCIiKS5yZXZlcnNlKCkuam9pbigiIik6cix1PWQoQS5nZXRBdHRyaWJ1dGUoImR4IikuZ2V0U3RyaW5nKCkpLGg9Yy5sZW5ndGgsZj0wO2Y8aDtmKyspe3ZhciBwPXRoaXMuZ2V0R2x5cGgobixjLGYpO2UudHJhbnNsYXRlKHRoaXMueCx0aGlzLnkpLGUuc2NhbGUobCwtbCk7dmFyIGc9ZS5saW5lV2lkdGg7ZS5saW5lV2lkdGg9ZS5saW5lV2lkdGgqcy9vLCJpdGFsaWMiPT09YSYmZS50cmFuc2Zvcm0oMSwwLC40LDEsMCwwKSxwLnJlbmRlcihlKSwiaXRhbGljIj09PWEmJmUudHJhbnNmb3JtKDEsMCwtLjQsMSwwLDApLGUubGluZVdpZHRoPWcsZS5zY2FsZSgxL2wsLTEvbCksZS50cmFuc2xhdGUoLXRoaXMueCwtdGhpcy55KSx0aGlzLngrPW8qKHAuaG9yaXpBZHZYfHxuLmhvcml6QWR2WCkvcyx2b2lkIDA9PT11W2ZdfHxpc05hTih1W2ZdKXx8KHRoaXMueCs9dVtmXSl9ZWxzZXt2YXJ7eDptLHk6d309dGhpcztlLmZpbGxTdHlsZSYmZS5maWxsVGV4dChyLG0sdyksZS5zdHJva2VTdHlsZSYmZS5zdHJva2VUZXh0KHIsbSx3KX19YXBwbHlBbmNob3JpbmcoKXtpZighKHRoaXMudGV4dENodW5rU3RhcnQ+PXRoaXMubGVhZlRleHRzLmxlbmd0aCkpe3ZhciBlLHQ9dGhpcy5sZWFmVGV4dHNbdGhpcy50ZXh0Q2h1bmtTdGFydF0sQT10LmdldFN0eWxlKCJ0ZXh0LWFuY2hvciIpLmdldFN0cmluZygic3RhcnQiKTtlPSJzdGFydCI9PT1BP3QueC10aGlzLm1pblg6ImVuZCI9PT1BP3QueC10aGlzLm1heFg6dC54LSh0aGlzLm1pblgrdGhpcy5tYXhYKS8yO2Zvcih2YXIgcj10aGlzLnRleHRDaHVua1N0YXJ0O3I8dGhpcy5sZWFmVGV4dHMubGVuZ3RoO3IrKyl0aGlzLmxlYWZUZXh0c1tyXS54Kz1lO3RoaXMubWluWD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5tYXhYPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSx0aGlzLnRleHRDaHVua1N0YXJ0PXRoaXMubGVhZlRleHRzLmxlbmd0aH19YWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShlKXt0aGlzLmNoaWxkcmVuLmZvckVhY2goKHQsQSk9Pnt0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGUsdGhpcyx0aGlzLEEpfSksdGhpcy5hcHBseUFuY2hvcmluZygpfWFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGUsdCxBLHIpe3ZhciBuPUEuY2hpbGRyZW5bcl07bi5jaGlsZHJlbi5sZW5ndGg+MD9uLmNoaWxkcmVuLmZvckVhY2goKEEscik9Pnt0LmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGUsdCxuLHIpfSk6dGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzKGUsdCxBLHIpfWFkanVzdENoaWxkQ29vcmRpbmF0ZXMoZSx0LEEscil7dmFyIG49QS5jaGlsZHJlbltyXTtpZigiZnVuY3Rpb24iIT10eXBlb2Ygbi5tZWFzdXJlVGV4dClyZXR1cm4gbjtlLnNhdmUoKSxuLnNldENvbnRleHQoZSwhMCk7dmFyIHM9bi5nZXRBdHRyaWJ1dGUoIngiKSxpPW4uZ2V0QXR0cmlidXRlKCJ5Iiksbz1uLmdldEF0dHJpYnV0ZSgiZHgiKSxhPW4uZ2V0QXR0cmlidXRlKCJkeSIpLGw9bi5nZXRTdHlsZSgiZm9udC1mYW1pbHkiKS5nZXREZWZpbml0aW9uKCksYz1Cb29sZWFuKGwpJiZsLmlzUlRMOzA9PT1yJiYocy5oYXNWYWx1ZSgpfHxzLnNldFZhbHVlKG4uZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCJ4IikpLGkuaGFzVmFsdWUoKXx8aS5zZXRWYWx1ZShuLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgieSIpKSxvLmhhc1ZhbHVlKCl8fG8uc2V0VmFsdWUobi5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoImR4IikpLGEuaGFzVmFsdWUoKXx8YS5zZXRWYWx1ZShuLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgiZHkiKSkpO3ZhciB1PW4ubWVhc3VyZVRleHQoZSk7cmV0dXJuIGMmJih0LngtPXUpLHMuaGFzVmFsdWUoKT8odC5hcHBseUFuY2hvcmluZygpLG4ueD1zLmdldFBpeGVscygieCIpLG8uaGFzVmFsdWUoKSYmKG4ueCs9by5nZXRQaXhlbHMoIngiKSkpOihvLmhhc1ZhbHVlKCkmJih0LngrPW8uZ2V0UGl4ZWxzKCJ4IikpLG4ueD10LngpLHQueD1uLngsY3x8KHQueCs9dSksaS5oYXNWYWx1ZSgpPyhuLnk9aS5nZXRQaXhlbHMoInkiKSxhLmhhc1ZhbHVlKCkmJihuLnkrPWEuZ2V0UGl4ZWxzKCJ5IikpKTooYS5oYXNWYWx1ZSgpJiYodC55Kz1hLmdldFBpeGVscygieSIpKSxuLnk9dC55KSx0Lnk9bi55LHQubGVhZlRleHRzLnB1c2gobiksdC5taW5YPU1hdGgubWluKHQubWluWCxuLngsbi54K3UpLHQubWF4WD1NYXRoLm1heCh0Lm1heFgsbi54LG4ueCt1KSxuLmNsZWFyQ29udGV4dChlKSxlLnJlc3RvcmUoKSxufWdldENoaWxkQm91bmRpbmdCb3goZSx0LEEscil7dmFyIG49QS5jaGlsZHJlbltyXTtpZigiZnVuY3Rpb24iIT10eXBlb2Ygbi5nZXRCb3VuZGluZ0JveClyZXR1cm4gbnVsbDt2YXIgcz1uLmdldEJvdW5kaW5nQm94KGUpO3JldHVybiBzPyhuLmNoaWxkcmVuLmZvckVhY2goKEEscik9Pnt2YXIgaT10LmdldENoaWxkQm91bmRpbmdCb3goZSx0LG4scik7cy5hZGRCb3VuZGluZ0JveChpKX0pLHMpOm51bGx9cmVuZGVyQ2hpbGQoZSx0LEEscil7dmFyIG49QS5jaGlsZHJlbltyXTtuLnJlbmRlcihlKSxuLmNoaWxkcmVuLmZvckVhY2goKEEscik9Pnt0LnJlbmRlckNoaWxkKGUsdCxuLHIpfSl9bWVhc3VyZVRleHQoZSl7dmFye21lYXN1cmVDYWNoZTp0fT10aGlzO2lmKH50KXJldHVybiB0O3ZhciBBPXRoaXMuZ2V0VGV4dCgpLHI9dGhpcy5tZWFzdXJlVGFyZ2V0VGV4dChlLEEpO3JldHVybiB0aGlzLm1lYXN1cmVDYWNoZT1yLHJ9bWVhc3VyZVRhcmdldFRleHQoZSx0KXtpZighdC5sZW5ndGgpcmV0dXJuIDA7dmFye3BhcmVudDpBfT10aGlzLHI9QS5nZXRTdHlsZSgiZm9udC1mYW1pbHkiKS5nZXREZWZpbml0aW9uKCk7aWYocil7Zm9yKHZhciBuPXRoaXMuZ2V0Rm9udFNpemUoKSxzPXIuaXNSVEw/dC5zcGxpdCgiIikucmV2ZXJzZSgpLmpvaW4oIiIpOnQsaT1kKEEuZ2V0QXR0cmlidXRlKCJkeCIpLmdldFN0cmluZygpKSxvPXMubGVuZ3RoLGE9MCxsPTA7bDxvO2wrKylhKz0odGhpcy5nZXRHbHlwaChyLHMsbCkuaG9yaXpBZHZYfHxyLmhvcml6QWR2WCkqbi9yLmZvbnRGYWNlLnVuaXRzUGVyRW0sdm9pZCAwPT09aVtsXXx8aXNOYU4oaVtsXSl8fChhKz1pW2xdKTtyZXR1cm4gYX1pZighZS5tZWFzdXJlVGV4dClyZXR1cm4gMTAqdC5sZW5ndGg7ZS5zYXZlKCksdGhpcy5zZXRDb250ZXh0KGUsITApO3Zhcnt3aWR0aDpjfT1lLm1lYXN1cmVUZXh0KHQpO3JldHVybiB0aGlzLmNsZWFyQ29udGV4dChlKSxlLnJlc3RvcmUoKSxjfWdldEluaGVyaXRlZEF0dHJpYnV0ZShlKXtmb3IodmFyIHQ9dGhpczt0IGluc3RhbmNlb2YgZGUmJnQuaXNGaXJzdENoaWxkKCk7KXt2YXIgQT10LnBhcmVudC5nZXRBdHRyaWJ1dGUoZSk7aWYoQS5oYXNWYWx1ZSghMCkpcmV0dXJuIEEuZ2V0VmFsdWUoIjAiKTt0PXQucGFyZW50fXJldHVybiBudWxsfX1jbGFzcyBmZSBleHRlbmRzIGRle2NvbnN0cnVjdG9yKGUsdCxBKXtzdXBlcihlLHQsbmV3LnRhcmdldD09PWZlfHxBKSx0aGlzLnR5cGU9InRzcGFuIix0aGlzLnRleHQ9dGhpcy5jaGlsZHJlbi5sZW5ndGg+MD8iIjp0aGlzLmdldFRleHRGcm9tTm9kZSgpfWdldFRleHQoKXtyZXR1cm4gdGhpcy50ZXh0fX1jbGFzcyBwZSBleHRlbmRzIGZle2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9InRleHROb2RlIn19Y2xhc3MgZ2UgZXh0ZW5kcyBjZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJzdmciLHRoaXMucm9vdD0hMX1zZXRDb250ZXh0KGUpe3ZhciB0LHtkb2N1bWVudDpBfT10aGlzLHtzY3JlZW46cix3aW5kb3c6bn09QSxzPWUuY2FudmFzO2lmKHIuc2V0RGVmYXVsdHMoZSkscy5zdHlsZSYmdm9pZCAwIT09ZS5mb250JiZuJiZ2b2lkIDAhPT1uLmdldENvbXB1dGVkU3R5bGUpe2UuZm9udD1uLmdldENvbXB1dGVkU3R5bGUocykuZ2V0UHJvcGVydHlWYWx1ZSgiZm9udCIpO3ZhciBpPW5ldyBUKEEsImZvbnRTaXplIixvZS5wYXJzZShlLmZvbnQpLmZvbnRTaXplKTtpLmhhc1ZhbHVlKCkmJihBLnJvb3RFbVNpemU9aS5nZXRQaXhlbHMoInkiKSxBLmVtU2l6ZT1BLnJvb3RFbVNpemUpfXRoaXMuZ2V0QXR0cmlidXRlKCJ4IikuaGFzVmFsdWUoKXx8dGhpcy5nZXRBdHRyaWJ1dGUoIngiLCEwKS5zZXRWYWx1ZSgwKSx0aGlzLmdldEF0dHJpYnV0ZSgieSIpLmhhc1ZhbHVlKCl8fHRoaXMuZ2V0QXR0cmlidXRlKCJ5IiwhMCkuc2V0VmFsdWUoMCk7dmFye3dpZHRoOm8saGVpZ2h0OmF9PXIudmlld1BvcnQ7dGhpcy5nZXRTdHlsZSgid2lkdGgiKS5oYXNWYWx1ZSgpfHx0aGlzLmdldFN0eWxlKCJ3aWR0aCIsITApLnNldFZhbHVlKCIxMDAlIiksdGhpcy5nZXRTdHlsZSgiaGVpZ2h0IikuaGFzVmFsdWUoKXx8dGhpcy5nZXRTdHlsZSgiaGVpZ2h0IiwhMCkuc2V0VmFsdWUoIjEwMCUiKSx0aGlzLmdldFN0eWxlKCJjb2xvciIpLmhhc1ZhbHVlKCl8fHRoaXMuZ2V0U3R5bGUoImNvbG9yIiwhMCkuc2V0VmFsdWUoImJsYWNrIik7dmFyIGw9dGhpcy5nZXRBdHRyaWJ1dGUoInJlZlgiKSxjPXRoaXMuZ2V0QXR0cmlidXRlKCJyZWZZIiksdT10aGlzLmdldEF0dHJpYnV0ZSgidmlld0JveCIpLGg9dS5oYXNWYWx1ZSgpP2QodS5nZXRTdHJpbmcoKSk6bnVsbCxmPSF0aGlzLnJvb3QmJiJ2aXNpYmxlIiE9PXRoaXMuZ2V0U3R5bGUoIm92ZXJmbG93IikuZ2V0VmFsdWUoImhpZGRlbiIpLHA9MCxnPTAsbT0wLHc9MDtoJiYocD1oWzBdLGc9aFsxXSksdGhpcy5yb290fHwobz10aGlzLmdldFN0eWxlKCJ3aWR0aCIpLmdldFBpeGVscygieCIpLGE9dGhpcy5nZXRTdHlsZSgiaGVpZ2h0IikuZ2V0UGl4ZWxzKCJ5IiksIm1hcmtlciI9PT10aGlzLnR5cGUmJihtPXAsdz1nLHA9MCxnPTApKSxyLnZpZXdQb3J0LnNldEN1cnJlbnQobyxhKSwhdGhpcy5ub2RlfHx0aGlzLnBhcmVudCYmImZvcmVpZ25PYmplY3QiIT09KG51bGw9PT0odD10aGlzLm5vZGUucGFyZW50Tm9kZSl8fHZvaWQgMD09PXQ/dm9pZCAwOnQubm9kZU5hbWUpfHwhdGhpcy5nZXRTdHlsZSgidHJhbnNmb3JtIiwhMSwhMCkuaGFzVmFsdWUoKXx8dGhpcy5nZXRTdHlsZSgidHJhbnNmb3JtLW9yaWdpbiIsITEsITApLmhhc1ZhbHVlKCl8fHRoaXMuZ2V0U3R5bGUoInRyYW5zZm9ybS1vcmlnaW4iLCEwLCEwKS5zZXRWYWx1ZSgiNTAlIDUwJSIpLHN1cGVyLnNldENvbnRleHQoZSksZS50cmFuc2xhdGUodGhpcy5nZXRBdHRyaWJ1dGUoIngiKS5nZXRQaXhlbHMoIngiKSx0aGlzLmdldEF0dHJpYnV0ZSgieSIpLmdldFBpeGVscygieSIpKSxoJiYobz1oWzJdLGE9aFszXSksQS5zZXRWaWV3Qm94KHtjdHg6ZSxhc3BlY3RSYXRpbzp0aGlzLmdldEF0dHJpYnV0ZSgicHJlc2VydmVBc3BlY3RSYXRpbyIpLmdldFN0cmluZygpLHdpZHRoOnIudmlld1BvcnQud2lkdGgsZGVzaXJlZFdpZHRoOm8saGVpZ2h0OnIudmlld1BvcnQuaGVpZ2h0LGRlc2lyZWRIZWlnaHQ6YSxtaW5YOnAsbWluWTpnLHJlZlg6bC5nZXRWYWx1ZSgpLHJlZlk6Yy5nZXRWYWx1ZSgpLGNsaXA6ZixjbGlwWDptLGNsaXBZOnd9KSxoJiYoci52aWV3UG9ydC5yZW1vdmVDdXJyZW50KCksci52aWV3UG9ydC5zZXRDdXJyZW50KG8sYSkpfWNsZWFyQ29udGV4dChlKXtzdXBlci5jbGVhckNvbnRleHQoZSksdGhpcy5kb2N1bWVudC5zY3JlZW4udmlld1BvcnQucmVtb3ZlQ3VycmVudCgpfXJlc2l6ZShlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06ZSxBPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0scj10aGlzLmdldEF0dHJpYnV0ZSgid2lkdGgiLCEwKSxuPXRoaXMuZ2V0QXR0cmlidXRlKCJoZWlnaHQiLCEwKSxzPXRoaXMuZ2V0QXR0cmlidXRlKCJ2aWV3Qm94IiksaT10aGlzLmdldEF0dHJpYnV0ZSgic3R5bGUiKSxvPXIuZ2V0TnVtYmVyKDApLGE9bi5nZXROdW1iZXIoMCk7aWYoQSlpZigic3RyaW5nIj09dHlwZW9mIEEpdGhpcy5nZXRBdHRyaWJ1dGUoInByZXNlcnZlQXNwZWN0UmF0aW8iLCEwKS5zZXRWYWx1ZShBKTtlbHNle3ZhciBsPXRoaXMuZ2V0QXR0cmlidXRlKCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIik7bC5oYXNWYWx1ZSgpJiZsLnNldFZhbHVlKGwuZ2V0U3RyaW5nKCkucmVwbGFjZSgvXlxzKihcUy4qXFMpXHMqJC8sIiQxIikpfWlmKHIuc2V0VmFsdWUoZSksbi5zZXRWYWx1ZSh0KSxzLmhhc1ZhbHVlKCl8fHMuc2V0VmFsdWUoIjAgMCAiLmNvbmNhdChvfHxlLCIgIikuY29uY2F0KGF8fHQpKSxpLmhhc1ZhbHVlKCkpe3ZhciBjPXRoaXMuZ2V0U3R5bGUoIndpZHRoIiksdT10aGlzLmdldFN0eWxlKCJoZWlnaHQiKTtjLmhhc1ZhbHVlKCkmJmMuc2V0VmFsdWUoIiIuY29uY2F0KGUsInB4IikpLHUuaGFzVmFsdWUoKSYmdS5zZXRWYWx1ZSgiIi5jb25jYXQodCwicHgiKSl9fX1jbGFzcyBtZSBleHRlbmRzIHVle2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9InJlY3QifXBhdGgoZSl7dmFyIHQ9dGhpcy5nZXRBdHRyaWJ1dGUoIngiKS5nZXRQaXhlbHMoIngiKSxBPXRoaXMuZ2V0QXR0cmlidXRlKCJ5IikuZ2V0UGl4ZWxzKCJ5Iikscj10aGlzLmdldFN0eWxlKCJ3aWR0aCIsITEsITApLmdldFBpeGVscygieCIpLG49dGhpcy5nZXRTdHlsZSgiaGVpZ2h0IiwhMSwhMCkuZ2V0UGl4ZWxzKCJ5Iikscz10aGlzLmdldEF0dHJpYnV0ZSgicngiKSxpPXRoaXMuZ2V0QXR0cmlidXRlKCJyeSIpLG89cy5nZXRQaXhlbHMoIngiKSxhPWkuZ2V0UGl4ZWxzKCJ5Iik7aWYocy5oYXNWYWx1ZSgpJiYhaS5oYXNWYWx1ZSgpJiYoYT1vKSxpLmhhc1ZhbHVlKCkmJiFzLmhhc1ZhbHVlKCkmJihvPWEpLG89TWF0aC5taW4obyxyLzIpLGE9TWF0aC5taW4oYSxuLzIpLGUpe3ZhciBsPShNYXRoLnNxcnQoMiktMSkvMyo0O2UuYmVnaW5QYXRoKCksbj4wJiZyPjAmJihlLm1vdmVUbyh0K28sQSksZS5saW5lVG8odCtyLW8sQSksZS5iZXppZXJDdXJ2ZVRvKHQrci1vK2wqbyxBLHQrcixBK2EtbCphLHQrcixBK2EpLGUubGluZVRvKHQrcixBK24tYSksZS5iZXppZXJDdXJ2ZVRvKHQrcixBK24tYStsKmEsdCtyLW8rbCpvLEErbix0K3ItbyxBK24pLGUubGluZVRvKHQrbyxBK24pLGUuYmV6aWVyQ3VydmVUbyh0K28tbCpvLEErbix0LEErbi1hK2wqYSx0LEErbi1hKSxlLmxpbmVUbyh0LEErYSksZS5iZXppZXJDdXJ2ZVRvKHQsQSthLWwqYSx0K28tbCpvLEEsdCtvLEEpLGUuY2xvc2VQYXRoKCkpfXJldHVybiBuZXcgYWUodCxBLHQrcixBK24pfWdldE1hcmtlcnMoKXtyZXR1cm4gbnVsbH19Y2xhc3Mgd2UgZXh0ZW5kcyB1ZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJjaXJjbGUifXBhdGgoZSl7dmFyIHQ9dGhpcy5nZXRBdHRyaWJ1dGUoImN4IikuZ2V0UGl4ZWxzKCJ4IiksQT10aGlzLmdldEF0dHJpYnV0ZSgiY3kiKS5nZXRQaXhlbHMoInkiKSxyPXRoaXMuZ2V0QXR0cmlidXRlKCJyIikuZ2V0UGl4ZWxzKCk7cmV0dXJuIGUmJnI+MCYmKGUuYmVnaW5QYXRoKCksZS5hcmModCxBLHIsMCwyKk1hdGguUEksITEpLGUuY2xvc2VQYXRoKCkpLG5ldyBhZSh0LXIsQS1yLHQrcixBK3IpfWdldE1hcmtlcnMoKXtyZXR1cm4gbnVsbH19Y2xhc3MgQmUgZXh0ZW5kcyB1ZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJlbGxpcHNlIn1wYXRoKGUpe3ZhciB0PShNYXRoLnNxcnQoMiktMSkvMyo0LEE9dGhpcy5nZXRBdHRyaWJ1dGUoInJ4IikuZ2V0UGl4ZWxzKCJ4Iikscj10aGlzLmdldEF0dHJpYnV0ZSgicnkiKS5nZXRQaXhlbHMoInkiKSxuPXRoaXMuZ2V0QXR0cmlidXRlKCJjeCIpLmdldFBpeGVscygieCIpLHM9dGhpcy5nZXRBdHRyaWJ1dGUoImN5IikuZ2V0UGl4ZWxzKCJ5Iik7cmV0dXJuIGUmJkE+MCYmcj4wJiYoZS5iZWdpblBhdGgoKSxlLm1vdmVUbyhuK0EscyksZS5iZXppZXJDdXJ2ZVRvKG4rQSxzK3QqcixuK3QqQSxzK3IsbixzK3IpLGUuYmV6aWVyQ3VydmVUbyhuLXQqQSxzK3Isbi1BLHMrdCpyLG4tQSxzKSxlLmJlemllckN1cnZlVG8obi1BLHMtdCpyLG4tdCpBLHMtcixuLHMtciksZS5iZXppZXJDdXJ2ZVRvKG4rdCpBLHMtcixuK0Escy10KnIsbitBLHMpLGUuY2xvc2VQYXRoKCkpLG5ldyBhZShuLUEscy1yLG4rQSxzK3IpfWdldE1hcmtlcnMoKXtyZXR1cm4gbnVsbH19Y2xhc3MgeWUgZXh0ZW5kcyB1ZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJsaW5lIn1nZXRQb2ludHMoKXtyZXR1cm5bbmV3IE0odGhpcy5nZXRBdHRyaWJ1dGUoIngxIikuZ2V0UGl4ZWxzKCJ4IiksdGhpcy5nZXRBdHRyaWJ1dGUoInkxIikuZ2V0UGl4ZWxzKCJ5IikpLG5ldyBNKHRoaXMuZ2V0QXR0cmlidXRlKCJ4MiIpLmdldFBpeGVscygieCIpLHRoaXMuZ2V0QXR0cmlidXRlKCJ5MiIpLmdldFBpeGVscygieSIpKV19cGF0aChlKXt2YXJbe3g6dCx5OkF9LHt4OnIseTpufV09dGhpcy5nZXRQb2ludHMoKTtyZXR1cm4gZSYmKGUuYmVnaW5QYXRoKCksZS5tb3ZlVG8odCxBKSxlLmxpbmVUbyhyLG4pKSxuZXcgYWUodCxBLHIsbil9Z2V0TWFya2Vycygpe3ZhcltlLHRdPXRoaXMuZ2V0UG9pbnRzKCksQT1lLmFuZ2xlVG8odCk7cmV0dXJuW1tlLEFdLFt0LEFdXX19Y2xhc3MgdmUgZXh0ZW5kcyB1ZXtjb25zdHJ1Y3RvcihlLHQsQSl7c3VwZXIoZSx0LEEpLHRoaXMudHlwZT0icG9seWxpbmUiLHRoaXMucG9pbnRzPVtdLHRoaXMucG9pbnRzPU0ucGFyc2VQYXRoKHRoaXMuZ2V0QXR0cmlidXRlKCJwb2ludHMiKS5nZXRTdHJpbmcoKSl9cGF0aChlKXt2YXJ7cG9pbnRzOnR9PXRoaXMsW3t4OkEseTpyfV09dCxuPW5ldyBhZShBLHIpO3JldHVybiBlJiYoZS5iZWdpblBhdGgoKSxlLm1vdmVUbyhBLHIpKSx0LmZvckVhY2godD0+e3Zhcnt4OkEseTpyfT10O24uYWRkUG9pbnQoQSxyKSxlJiZlLmxpbmVUbyhBLHIpfSksbn1nZXRNYXJrZXJzKCl7dmFye3BvaW50czplfT10aGlzLHQ9ZS5sZW5ndGgtMSxBPVtdO3JldHVybiBlLmZvckVhY2goKHIsbik9PntuIT09dCYmQS5wdXNoKFtyLHIuYW5nbGVUbyhlW24rMV0pXSl9KSxBLmxlbmd0aD4wJiZBLnB1c2goW2VbZS5sZW5ndGgtMV0sQVtBLmxlbmd0aC0xXVsxXV0pLEF9fWNsYXNzIGJlIGV4dGVuZHMgdmV7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudHlwZT0icG9seWdvbiJ9cGF0aChlKXt2YXIgdD1zdXBlci5wYXRoKGUpLFt7eDpBLHk6cn1dPXRoaXMucG9pbnRzO3JldHVybiBlJiYoZS5saW5lVG8oQSxyKSxlLmNsb3NlUGF0aCgpKSx0fX1jbGFzcyBDZSBleHRlbmRzIEFle2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9InBhdHRlcm4ifWNyZWF0ZVBhdHRlcm4oZSx0LEEpe3ZhciByPXRoaXMuZ2V0U3R5bGUoIndpZHRoIikuZ2V0UGl4ZWxzKCJ4IiwhMCksbj10aGlzLmdldFN0eWxlKCJoZWlnaHQiKS5nZXRQaXhlbHMoInkiLCEwKSxzPW5ldyBnZSh0aGlzLmRvY3VtZW50LG51bGwpO3MuYXR0cmlidXRlcy52aWV3Qm94PW5ldyBUKHRoaXMuZG9jdW1lbnQsInZpZXdCb3giLHRoaXMuZ2V0QXR0cmlidXRlKCJ2aWV3Qm94IikuZ2V0VmFsdWUoKSkscy5hdHRyaWJ1dGVzLndpZHRoPW5ldyBUKHRoaXMuZG9jdW1lbnQsIndpZHRoIiwiIi5jb25jYXQociwicHgiKSkscy5hdHRyaWJ1dGVzLmhlaWdodD1uZXcgVCh0aGlzLmRvY3VtZW50LCJoZWlnaHQiLCIiLmNvbmNhdChuLCJweCIpKSxzLmF0dHJpYnV0ZXMudHJhbnNmb3JtPW5ldyBUKHRoaXMuZG9jdW1lbnQsInRyYW5zZm9ybSIsdGhpcy5nZXRBdHRyaWJ1dGUoInBhdHRlcm5UcmFuc2Zvcm0iKS5nZXRWYWx1ZSgpKSxzLmNoaWxkcmVuPXRoaXMuY2hpbGRyZW47dmFyIGk9dGhpcy5kb2N1bWVudC5jcmVhdGVDYW52YXMocixuKSxvPWkuZ2V0Q29udGV4dCgiMmQiKSxhPXRoaXMuZ2V0QXR0cmlidXRlKCJ4IiksbD10aGlzLmdldEF0dHJpYnV0ZSgieSIpO2EuaGFzVmFsdWUoKSYmbC5oYXNWYWx1ZSgpJiZvLnRyYW5zbGF0ZShhLmdldFBpeGVscygieCIsITApLGwuZ2V0UGl4ZWxzKCJ5IiwhMCkpLEEuaGFzVmFsdWUoKT90aGlzLnN0eWxlc1siZmlsbC1vcGFjaXR5Il09QTpSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRoaXMuc3R5bGVzLCJmaWxsLW9wYWNpdHkiKTtmb3IodmFyIGM9LTE7Yzw9MTtjKyspZm9yKHZhciB1PS0xO3U8PTE7dSsrKW8uc2F2ZSgpLHMuYXR0cmlidXRlcy54PW5ldyBUKHRoaXMuZG9jdW1lbnQsIngiLGMqaS53aWR0aCkscy5hdHRyaWJ1dGVzLnk9bmV3IFQodGhpcy5kb2N1bWVudCwieSIsdSppLmhlaWdodCkscy5yZW5kZXIobyksby5yZXN0b3JlKCk7cmV0dXJuIGUuY3JlYXRlUGF0dGVybihpLCJyZXBlYXQiKX19Y2xhc3MgX2UgZXh0ZW5kcyBBZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJtYXJrZXIifXJlbmRlcihlLHQsQSl7aWYodCl7dmFye3g6cix5Om59PXQscz10aGlzLmdldEF0dHJpYnV0ZSgib3JpZW50IikuZ2V0U3RyaW5nKCJhdXRvIiksaT10aGlzLmdldEF0dHJpYnV0ZSgibWFya2VyVW5pdHMiKS5nZXRTdHJpbmcoInN0cm9rZVdpZHRoIik7ZS50cmFuc2xhdGUocixuKSwiYXV0byI9PT1zJiZlLnJvdGF0ZShBKSwic3Ryb2tlV2lkdGgiPT09aSYmZS5zY2FsZShlLmxpbmVXaWR0aCxlLmxpbmVXaWR0aCksZS5zYXZlKCk7dmFyIG89bmV3IGdlKHRoaXMuZG9jdW1lbnQsbnVsbCk7by50eXBlPXRoaXMudHlwZSxvLmF0dHJpYnV0ZXMudmlld0JveD1uZXcgVCh0aGlzLmRvY3VtZW50LCJ2aWV3Qm94Iix0aGlzLmdldEF0dHJpYnV0ZSgidmlld0JveCIpLmdldFZhbHVlKCkpLG8uYXR0cmlidXRlcy5yZWZYPW5ldyBUKHRoaXMuZG9jdW1lbnQsInJlZlgiLHRoaXMuZ2V0QXR0cmlidXRlKCJyZWZYIikuZ2V0VmFsdWUoKSksby5hdHRyaWJ1dGVzLnJlZlk9bmV3IFQodGhpcy5kb2N1bWVudCwicmVmWSIsdGhpcy5nZXRBdHRyaWJ1dGUoInJlZlkiKS5nZXRWYWx1ZSgpKSxvLmF0dHJpYnV0ZXMud2lkdGg9bmV3IFQodGhpcy5kb2N1bWVudCwid2lkdGgiLHRoaXMuZ2V0QXR0cmlidXRlKCJtYXJrZXJXaWR0aCIpLmdldFZhbHVlKCkpLG8uYXR0cmlidXRlcy5oZWlnaHQ9bmV3IFQodGhpcy5kb2N1bWVudCwiaGVpZ2h0Iix0aGlzLmdldEF0dHJpYnV0ZSgibWFya2VySGVpZ2h0IikuZ2V0VmFsdWUoKSksby5hdHRyaWJ1dGVzLm92ZXJmbG93PW5ldyBUKHRoaXMuZG9jdW1lbnQsIm92ZXJmbG93Iix0aGlzLmdldEF0dHJpYnV0ZSgib3ZlcmZsb3ciKS5nZXRWYWx1ZSgpKSxvLmF0dHJpYnV0ZXMuZmlsbD1uZXcgVCh0aGlzLmRvY3VtZW50LCJmaWxsIix0aGlzLmdldEF0dHJpYnV0ZSgiZmlsbCIpLmdldENvbG9yKCJibGFjayIpKSxvLmF0dHJpYnV0ZXMuc3Ryb2tlPW5ldyBUKHRoaXMuZG9jdW1lbnQsInN0cm9rZSIsdGhpcy5nZXRBdHRyaWJ1dGUoInN0cm9rZSIpLmdldFZhbHVlKCJub25lIikpLG8uY2hpbGRyZW49dGhpcy5jaGlsZHJlbixvLnJlbmRlcihlKSxlLnJlc3RvcmUoKSwic3Ryb2tlV2lkdGgiPT09aSYmZS5zY2FsZSgxL2UubGluZVdpZHRoLDEvZS5saW5lV2lkdGgpLCJhdXRvIj09PXMmJmUucm90YXRlKC1BKSxlLnRyYW5zbGF0ZSgtciwtbil9fX1jbGFzcyBqZSBleHRlbmRzIEFle2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9ImRlZnMifXJlbmRlcigpe319Y2xhc3MgeGUgZXh0ZW5kcyBjZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJnIn1nZXRCb3VuZGluZ0JveChlKXt2YXIgdD1uZXcgYWU7cmV0dXJuIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChBPT57dC5hZGRCb3VuZGluZ0JveChBLmdldEJvdW5kaW5nQm94KGUpKX0pLHR9fWNsYXNzIEZlIGV4dGVuZHMgQWV7Y29uc3RydWN0b3IoZSx0LEEpe3N1cGVyKGUsdCxBKSx0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQ9WyJncmFkaWVudFVuaXRzIl0sdGhpcy5zdG9wcz1bXTt2YXJ7c3RvcHM6cixjaGlsZHJlbjpufT10aGlzO24uZm9yRWFjaChlPT57InN0b3AiPT09ZS50eXBlJiZyLnB1c2goZSl9KX1nZXRHcmFkaWVudFVuaXRzKCl7cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCJncmFkaWVudFVuaXRzIikuZ2V0U3RyaW5nKCJvYmplY3RCb3VuZGluZ0JveCIpfWNyZWF0ZUdyYWRpZW50KGUsdCxBKXt2YXIgcj10aGlzO3RoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkmJihyPXRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKSx0aGlzLmluaGVyaXRTdG9wQ29udGFpbmVyKHIpKTt2YXJ7c3RvcHM6bn09cixzPXRoaXMuZ2V0R3JhZGllbnQoZSx0KTtpZighcylyZXR1cm4gdGhpcy5hZGRQYXJlbnRPcGFjaXR5KEEsbltuLmxlbmd0aC0xXS5jb2xvcik7aWYobi5mb3JFYWNoKGU9PntzLmFkZENvbG9yU3RvcChlLm9mZnNldCx0aGlzLmFkZFBhcmVudE9wYWNpdHkoQSxlLmNvbG9yKSl9KSx0aGlzLmdldEF0dHJpYnV0ZSgiZ3JhZGllbnRUcmFuc2Zvcm0iKS5oYXNWYWx1ZSgpKXt2YXJ7ZG9jdW1lbnQ6aX09dGhpcyx7TUFYX1ZJUlRVQUxfUElYRUxTOm8sdmlld1BvcnQ6YX09aS5zY3JlZW4sW2xdPWEudmlld1BvcnRzLGM9bmV3IG1lKGksbnVsbCk7Yy5hdHRyaWJ1dGVzLng9bmV3IFQoaSwieCIsLW8vMyksYy5hdHRyaWJ1dGVzLnk9bmV3IFQoaSwieSIsLW8vMyksYy5hdHRyaWJ1dGVzLndpZHRoPW5ldyBUKGksIndpZHRoIixvKSxjLmF0dHJpYnV0ZXMuaGVpZ2h0PW5ldyBUKGksImhlaWdodCIsbyk7dmFyIHU9bmV3IHhlKGksbnVsbCk7dS5hdHRyaWJ1dGVzLnRyYW5zZm9ybT1uZXcgVChpLCJ0cmFuc2Zvcm0iLHRoaXMuZ2V0QXR0cmlidXRlKCJncmFkaWVudFRyYW5zZm9ybSIpLmdldFZhbHVlKCkpLHUuY2hpbGRyZW49W2NdO3ZhciBoPW5ldyBnZShpLG51bGwpO2guYXR0cmlidXRlcy54PW5ldyBUKGksIngiLDApLGguYXR0cmlidXRlcy55PW5ldyBUKGksInkiLDApLGguYXR0cmlidXRlcy53aWR0aD1uZXcgVChpLCJ3aWR0aCIsbC53aWR0aCksaC5hdHRyaWJ1dGVzLmhlaWdodD1uZXcgVChpLCJoZWlnaHQiLGwuaGVpZ2h0KSxoLmNoaWxkcmVuPVt1XTt2YXIgZD1pLmNyZWF0ZUNhbnZhcyhsLndpZHRoLGwuaGVpZ2h0KSxmPWQuZ2V0Q29udGV4dCgiMmQiKTtyZXR1cm4gZi5maWxsU3R5bGU9cyxoLnJlbmRlcihmKSxmLmNyZWF0ZVBhdHRlcm4oZCwibm8tcmVwZWF0Iil9cmV0dXJuIHN9aW5oZXJpdFN0b3BDb250YWluZXIoZSl7dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LmZvckVhY2godD0+eyF0aGlzLmdldEF0dHJpYnV0ZSh0KS5oYXNWYWx1ZSgpJiZlLmdldEF0dHJpYnV0ZSh0KS5oYXNWYWx1ZSgpJiZ0aGlzLmdldEF0dHJpYnV0ZSh0LCEwKS5zZXRWYWx1ZShlLmdldEF0dHJpYnV0ZSh0KS5nZXRWYWx1ZSgpKX0pfWFkZFBhcmVudE9wYWNpdHkoZSx0KXtyZXR1cm4gZS5oYXNWYWx1ZSgpP25ldyBUKHRoaXMuZG9jdW1lbnQsImNvbG9yIix0KS5hZGRPcGFjaXR5KGUpLmdldENvbG9yKCk6dH19Y2xhc3MgUWUgZXh0ZW5kcyBGZXtjb25zdHJ1Y3RvcihlLHQsQSl7c3VwZXIoZSx0LEEpLHRoaXMudHlwZT0ibGluZWFyR3JhZGllbnQiLHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCJ4MSIsInkxIiwieDIiLCJ5MiIpfWdldEdyYWRpZW50KGUsdCl7dmFyIEE9Im9iamVjdEJvdW5kaW5nQm94Ij09PXRoaXMuZ2V0R3JhZGllbnRVbml0cygpLHI9QT90LmdldEJvdW5kaW5nQm94KGUpOm51bGw7aWYoQSYmIXIpcmV0dXJuIG51bGw7dGhpcy5nZXRBdHRyaWJ1dGUoIngxIikuaGFzVmFsdWUoKXx8dGhpcy5nZXRBdHRyaWJ1dGUoInkxIikuaGFzVmFsdWUoKXx8dGhpcy5nZXRBdHRyaWJ1dGUoIngyIikuaGFzVmFsdWUoKXx8dGhpcy5nZXRBdHRyaWJ1dGUoInkyIikuaGFzVmFsdWUoKXx8KHRoaXMuZ2V0QXR0cmlidXRlKCJ4MSIsITApLnNldFZhbHVlKDApLHRoaXMuZ2V0QXR0cmlidXRlKCJ5MSIsITApLnNldFZhbHVlKDApLHRoaXMuZ2V0QXR0cmlidXRlKCJ4MiIsITApLnNldFZhbHVlKDEpLHRoaXMuZ2V0QXR0cmlidXRlKCJ5MiIsITApLnNldFZhbHVlKDApKTt2YXIgbj1BP3IueCtyLndpZHRoKnRoaXMuZ2V0QXR0cmlidXRlKCJ4MSIpLmdldE51bWJlcigpOnRoaXMuZ2V0QXR0cmlidXRlKCJ4MSIpLmdldFBpeGVscygieCIpLHM9QT9yLnkrci5oZWlnaHQqdGhpcy5nZXRBdHRyaWJ1dGUoInkxIikuZ2V0TnVtYmVyKCk6dGhpcy5nZXRBdHRyaWJ1dGUoInkxIikuZ2V0UGl4ZWxzKCJ5IiksaT1BP3IueCtyLndpZHRoKnRoaXMuZ2V0QXR0cmlidXRlKCJ4MiIpLmdldE51bWJlcigpOnRoaXMuZ2V0QXR0cmlidXRlKCJ4MiIpLmdldFBpeGVscygieCIpLG89QT9yLnkrci5oZWlnaHQqdGhpcy5nZXRBdHRyaWJ1dGUoInkyIikuZ2V0TnVtYmVyKCk6dGhpcy5nZXRBdHRyaWJ1dGUoInkyIikuZ2V0UGl4ZWxzKCJ5Iik7cmV0dXJuIG49PT1pJiZzPT09bz9udWxsOmUuY3JlYXRlTGluZWFyR3JhZGllbnQobixzLGksbyl9fWNsYXNzIFVlIGV4dGVuZHMgRmV7Y29uc3RydWN0b3IoZSx0LEEpe3N1cGVyKGUsdCxBKSx0aGlzLnR5cGU9InJhZGlhbEdyYWRpZW50Iix0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgiY3giLCJjeSIsInIiLCJmeCIsImZ5IiwiZnIiKX1nZXRHcmFkaWVudChlLHQpe3ZhciBBPSJvYmplY3RCb3VuZGluZ0JveCI9PT10aGlzLmdldEdyYWRpZW50VW5pdHMoKSxyPXQuZ2V0Qm91bmRpbmdCb3goZSk7aWYoQSYmIXIpcmV0dXJuIG51bGw7dGhpcy5nZXRBdHRyaWJ1dGUoImN4IikuaGFzVmFsdWUoKXx8dGhpcy5nZXRBdHRyaWJ1dGUoImN4IiwhMCkuc2V0VmFsdWUoIjUwJSIpLHRoaXMuZ2V0QXR0cmlidXRlKCJjeSIpLmhhc1ZhbHVlKCl8fHRoaXMuZ2V0QXR0cmlidXRlKCJjeSIsITApLnNldFZhbHVlKCI1MCUiKSx0aGlzLmdldEF0dHJpYnV0ZSgiciIpLmhhc1ZhbHVlKCl8fHRoaXMuZ2V0QXR0cmlidXRlKCJyIiwhMCkuc2V0VmFsdWUoIjUwJSIpO3ZhciBuPUE/ci54K3Iud2lkdGgqdGhpcy5nZXRBdHRyaWJ1dGUoImN4IikuZ2V0TnVtYmVyKCk6dGhpcy5nZXRBdHRyaWJ1dGUoImN4IikuZ2V0UGl4ZWxzKCJ4Iikscz1BP3IueStyLmhlaWdodCp0aGlzLmdldEF0dHJpYnV0ZSgiY3kiKS5nZXROdW1iZXIoKTp0aGlzLmdldEF0dHJpYnV0ZSgiY3kiKS5nZXRQaXhlbHMoInkiKSxpPW4sbz1zO3RoaXMuZ2V0QXR0cmlidXRlKCJmeCIpLmhhc1ZhbHVlKCkmJihpPUE/ci54K3Iud2lkdGgqdGhpcy5nZXRBdHRyaWJ1dGUoImZ4IikuZ2V0TnVtYmVyKCk6dGhpcy5nZXRBdHRyaWJ1dGUoImZ4IikuZ2V0UGl4ZWxzKCJ4IikpLHRoaXMuZ2V0QXR0cmlidXRlKCJmeSIpLmhhc1ZhbHVlKCkmJihvPUE/ci55K3IuaGVpZ2h0KnRoaXMuZ2V0QXR0cmlidXRlKCJmeSIpLmdldE51bWJlcigpOnRoaXMuZ2V0QXR0cmlidXRlKCJmeSIpLmdldFBpeGVscygieSIpKTt2YXIgYT1BPyhyLndpZHRoK3IuaGVpZ2h0KS8yKnRoaXMuZ2V0QXR0cmlidXRlKCJyIikuZ2V0TnVtYmVyKCk6dGhpcy5nZXRBdHRyaWJ1dGUoInIiKS5nZXRQaXhlbHMoKSxsPXRoaXMuZ2V0QXR0cmlidXRlKCJmciIpLmdldFBpeGVscygpO3JldHVybiBlLmNyZWF0ZVJhZGlhbEdyYWRpZW50KGksbyxsLG4scyxhKX19Y2xhc3MgRWUgZXh0ZW5kcyBBZXtjb25zdHJ1Y3RvcihlLHQsQSl7c3VwZXIoZSx0LEEpLHRoaXMudHlwZT0ic3RvcCI7dmFyIHI9TWF0aC5tYXgoMCxNYXRoLm1pbigxLHRoaXMuZ2V0QXR0cmlidXRlKCJvZmZzZXQiKS5nZXROdW1iZXIoKSkpLG49dGhpcy5nZXRTdHlsZSgic3RvcC1vcGFjaXR5Iikscz10aGlzLmdldFN0eWxlKCJzdG9wLWNvbG9yIiwhMCk7IiI9PT1zLmdldFN0cmluZygpJiZzLnNldFZhbHVlKCIjMDAwIiksbi5oYXNWYWx1ZSgpJiYocz1zLmFkZE9wYWNpdHkobikpLHRoaXMub2Zmc2V0PXIsdGhpcy5jb2xvcj1zLmdldENvbG9yKCl9fWNsYXNzIFNlIGV4dGVuZHMgQWV7Y29uc3RydWN0b3IoZSx0LEEpe3N1cGVyKGUsdCxBKSx0aGlzLnR5cGU9ImFuaW1hdGUiLHRoaXMuZHVyYXRpb249MCx0aGlzLmluaXRpYWxWYWx1ZT1udWxsLHRoaXMuaW5pdGlhbFVuaXRzPSIiLHRoaXMucmVtb3ZlZD0hMSx0aGlzLmZyb3plbj0hMSxlLnNjcmVlbi5hbmltYXRpb25zLnB1c2godGhpcyksdGhpcy5iZWdpbj10aGlzLmdldEF0dHJpYnV0ZSgiYmVnaW4iKS5nZXRNaWxsaXNlY29uZHMoKSx0aGlzLm1heER1cmF0aW9uPXRoaXMuYmVnaW4rdGhpcy5nZXRBdHRyaWJ1dGUoImR1ciIpLmdldE1pbGxpc2Vjb25kcygpLHRoaXMuZnJvbT10aGlzLmdldEF0dHJpYnV0ZSgiZnJvbSIpLHRoaXMudG89dGhpcy5nZXRBdHRyaWJ1dGUoInRvIiksdGhpcy52YWx1ZXM9bmV3IFQoZSwidmFsdWVzIixudWxsKTt2YXIgcj10aGlzLmdldEF0dHJpYnV0ZSgidmFsdWVzIik7ci5oYXNWYWx1ZSgpJiZ0aGlzLnZhbHVlcy5zZXRWYWx1ZShyLmdldFN0cmluZygpLnNwbGl0KCI7IikpfWdldFByb3BlcnR5KCl7dmFyIGU9dGhpcy5nZXRBdHRyaWJ1dGUoImF0dHJpYnV0ZVR5cGUiKS5nZXRTdHJpbmcoKSx0PXRoaXMuZ2V0QXR0cmlidXRlKCJhdHRyaWJ1dGVOYW1lIikuZ2V0U3RyaW5nKCk7cmV0dXJuIkNTUyI9PT1lP3RoaXMucGFyZW50LmdldFN0eWxlKHQsITApOnRoaXMucGFyZW50LmdldEF0dHJpYnV0ZSh0LCEwKX1jYWxjVmFsdWUoKXt2YXJ7aW5pdGlhbFVuaXRzOmV9PXRoaXMse3Byb2dyZXNzOnQsZnJvbTpBLHRvOnJ9PXRoaXMuZ2V0UHJvZ3Jlc3MoKSxuPUEuZ2V0TnVtYmVyKCkrKHIuZ2V0TnVtYmVyKCktQS5nZXROdW1iZXIoKSkqdDtyZXR1cm4iJSI9PT1lJiYobio9MTAwKSwiIi5jb25jYXQobikuY29uY2F0KGUpfXVwZGF0ZShlKXt2YXJ7cGFyZW50OnR9PXRoaXMsQT10aGlzLmdldFByb3BlcnR5KCk7aWYodGhpcy5pbml0aWFsVmFsdWV8fCh0aGlzLmluaXRpYWxWYWx1ZT1BLmdldFN0cmluZygpLHRoaXMuaW5pdGlhbFVuaXRzPUEuZ2V0VW5pdHMoKSksdGhpcy5kdXJhdGlvbj50aGlzLm1heER1cmF0aW9uKXt2YXIgcj10aGlzLmdldEF0dHJpYnV0ZSgiZmlsbCIpLmdldFN0cmluZygicmVtb3ZlIik7aWYoImluZGVmaW5pdGUiPT09dGhpcy5nZXRBdHRyaWJ1dGUoInJlcGVhdENvdW50IikuZ2V0U3RyaW5nKCl8fCJpbmRlZmluaXRlIj09PXRoaXMuZ2V0QXR0cmlidXRlKCJyZXBlYXREdXIiKS5nZXRTdHJpbmcoKSl0aGlzLmR1cmF0aW9uPTA7ZWxzZSBpZigiZnJlZXplIiE9PXJ8fHRoaXMuZnJvemVuKXtpZigicmVtb3ZlIj09PXImJiF0aGlzLnJlbW92ZWQpcmV0dXJuIHRoaXMucmVtb3ZlZD0hMCxBLnNldFZhbHVlKHQuYW5pbWF0aW9uRnJvemVuP3QuYW5pbWF0aW9uRnJvemVuVmFsdWU6dGhpcy5pbml0aWFsVmFsdWUpLCEwfWVsc2UgdGhpcy5mcm96ZW49ITAsdC5hbmltYXRpb25Gcm96ZW49ITAsdC5hbmltYXRpb25Gcm96ZW5WYWx1ZT1BLmdldFN0cmluZygpO3JldHVybiExfXRoaXMuZHVyYXRpb24rPWU7dmFyIG49ITE7aWYodGhpcy5iZWdpbjx0aGlzLmR1cmF0aW9uKXt2YXIgcz10aGlzLmNhbGNWYWx1ZSgpLGk9dGhpcy5nZXRBdHRyaWJ1dGUoInR5cGUiKTtpZihpLmhhc1ZhbHVlKCkpe3ZhciBvPWkuZ2V0U3RyaW5nKCk7cz0iIi5jb25jYXQobywiKCIpLmNvbmNhdChzLCIpIil9QS5zZXRWYWx1ZShzKSxuPSEwfXJldHVybiBufWdldFByb2dyZXNzKCl7dmFye2RvY3VtZW50OmUsdmFsdWVzOnR9PXRoaXMsQT17cHJvZ3Jlc3M6KHRoaXMuZHVyYXRpb24tdGhpcy5iZWdpbikvKHRoaXMubWF4RHVyYXRpb24tdGhpcy5iZWdpbil9O2lmKHQuaGFzVmFsdWUoKSl7dmFyIHI9QS5wcm9ncmVzcyoodC5nZXRWYWx1ZSgpLmxlbmd0aC0xKSxuPU1hdGguZmxvb3Iocikscz1NYXRoLmNlaWwocik7QS5mcm9tPW5ldyBUKGUsImZyb20iLHBhcnNlRmxvYXQodC5nZXRWYWx1ZSgpW25dKSksQS50bz1uZXcgVChlLCJ0byIscGFyc2VGbG9hdCh0LmdldFZhbHVlKClbc10pKSxBLnByb2dyZXNzPShyLW4pLyhzLW4pfWVsc2UgQS5mcm9tPXRoaXMuZnJvbSxBLnRvPXRoaXMudG87cmV0dXJuIEF9fWNsYXNzIExlIGV4dGVuZHMgU2V7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudHlwZT0iYW5pbWF0ZUNvbG9yIn1jYWxjVmFsdWUoKXt2YXJ7cHJvZ3Jlc3M6ZSxmcm9tOnQsdG86QX09dGhpcy5nZXRQcm9ncmVzcygpLHI9bmV3IGkodC5nZXRDb2xvcigpKSxuPW5ldyBpKEEuZ2V0Q29sb3IoKSk7aWYoci5vayYmbi5vayl7dmFyIHM9ci5yKyhuLnItci5yKSplLG89ci5nKyhuLmctci5nKSplLGE9ci5iKyhuLmItci5iKSplO3JldHVybiJyZ2IoIi5jb25jYXQoTWF0aC5mbG9vcihzKSwiLCAiKS5jb25jYXQoTWF0aC5mbG9vcihvKSwiLCAiKS5jb25jYXQoTWF0aC5mbG9vcihhKSwiKSIpfXJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgiZnJvbSIpLmdldENvbG9yKCl9fWNsYXNzIEllIGV4dGVuZHMgU2V7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudHlwZT0iYW5pbWF0ZVRyYW5zZm9ybSJ9Y2FsY1ZhbHVlKCl7dmFye3Byb2dyZXNzOmUsZnJvbTp0LHRvOkF9PXRoaXMuZ2V0UHJvZ3Jlc3MoKSxyPWQodC5nZXRTdHJpbmcoKSksbj1kKEEuZ2V0U3RyaW5nKCkpLHM9ci5tYXAoKHQsQSk9PnQrKG5bQV0tdCkqZSkuam9pbigiICIpO3JldHVybiBzfX1jbGFzcyBOZSBleHRlbmRzIEFle2NvbnN0cnVjdG9yKGUsdCxBKXtzdXBlcihlLHQsQSksdGhpcy50eXBlPSJmb250Iix0aGlzLmdseXBocz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuaG9yaXpBZHZYPXRoaXMuZ2V0QXR0cmlidXRlKCJob3Jpei1hZHYteCIpLmdldE51bWJlcigpO3ZhcntkZWZpbml0aW9uczpyfT1lLHtjaGlsZHJlbjpufT10aGlzO2Zvcih2YXIgcyBvZiBuKXN3aXRjaChzLnR5cGUpe2Nhc2UiZm9udC1mYWNlIjp0aGlzLmZvbnRGYWNlPXM7dmFyIGk9cy5nZXRTdHlsZSgiZm9udC1mYW1pbHkiKTtpLmhhc1ZhbHVlKCkmJihyW2kuZ2V0U3RyaW5nKCldPXRoaXMpO2JyZWFrO2Nhc2UibWlzc2luZy1nbHlwaCI6dGhpcy5taXNzaW5nR2x5cGg9czticmVhaztjYXNlImdseXBoIjp2YXIgbz1zO28uYXJhYmljRm9ybT8odGhpcy5pc1JUTD0hMCx0aGlzLmlzQXJhYmljPSEwLHZvaWQgMD09PXRoaXMuZ2x5cGhzW28udW5pY29kZV0mJih0aGlzLmdseXBoc1tvLnVuaWNvZGVdPU9iamVjdC5jcmVhdGUobnVsbCkpLHRoaXMuZ2x5cGhzW28udW5pY29kZV1bby5hcmFiaWNGb3JtXT1vKTp0aGlzLmdseXBoc1tvLnVuaWNvZGVdPW99fXJlbmRlcigpe319Y2xhc3Mga2UgZXh0ZW5kcyBBZXtjb25zdHJ1Y3RvcihlLHQsQSl7c3VwZXIoZSx0LEEpLHRoaXMudHlwZT0iZm9udC1mYWNlIix0aGlzLmFzY2VudD10aGlzLmdldEF0dHJpYnV0ZSgiYXNjZW50IikuZ2V0TnVtYmVyKCksdGhpcy5kZXNjZW50PXRoaXMuZ2V0QXR0cmlidXRlKCJkZXNjZW50IikuZ2V0TnVtYmVyKCksdGhpcy51bml0c1BlckVtPXRoaXMuZ2V0QXR0cmlidXRlKCJ1bml0cy1wZXItZW0iKS5nZXROdW1iZXIoKX19Y2xhc3MgSGUgZXh0ZW5kcyB1ZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJtaXNzaW5nLWdseXBoIix0aGlzLmhvcml6QWR2WD0wfX1jbGFzcyBQZSBleHRlbmRzIGRle2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9InRyZWYifWdldFRleHQoKXt2YXIgZT10aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7aWYoZSl7dmFyIHQ9ZS5jaGlsZHJlblswXTtpZih0KXJldHVybiB0LmdldFRleHQoKX1yZXR1cm4iIn19Y2xhc3MgVGUgZXh0ZW5kcyBkZXtjb25zdHJ1Y3RvcihlLHQsQSl7c3VwZXIoZSx0LEEpLHRoaXMudHlwZT0iYSI7dmFye2NoaWxkTm9kZXM6cn09dCxuPXJbMF0scz1yLmxlbmd0aD4wJiZBcnJheS5mcm9tKHIpLmV2ZXJ5KGU9PjM9PT1lLm5vZGVUeXBlKTt0aGlzLmhhc1RleHQ9cyx0aGlzLnRleHQ9cz90aGlzLmdldFRleHRGcm9tTm9kZShuKToiIn1nZXRUZXh0KCl7cmV0dXJuIHRoaXMudGV4dH1yZW5kZXJDaGlsZHJlbihlKXtpZih0aGlzLmhhc1RleHQpe3N1cGVyLnJlbmRlckNoaWxkcmVuKGUpO3Zhcntkb2N1bWVudDp0LHg6QSx5OnJ9PXRoaXMse21vdXNlOm59PXQuc2NyZWVuLHM9bmV3IFQodCwiZm9udFNpemUiLG9lLnBhcnNlKHQuY3R4LmZvbnQpLmZvbnRTaXplKTtuLmlzV29ya2luZygpJiZuLmNoZWNrQm91bmRpbmdCb3godGhpcyxuZXcgYWUoQSxyLXMuZ2V0UGl4ZWxzKCJ5IiksQSt0aGlzLm1lYXN1cmVUZXh0KGUpLHIpKX1lbHNlIGlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoPjApe3ZhciBpPW5ldyB4ZSh0aGlzLmRvY3VtZW50LG51bGwpO2kuY2hpbGRyZW49dGhpcy5jaGlsZHJlbixpLnBhcmVudD10aGlzLGkucmVuZGVyKGUpfX1vbkNsaWNrKCl7dmFye3dpbmRvdzplfT10aGlzLmRvY3VtZW50O2UmJmUub3Blbih0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXRTdHJpbmcoKSl9b25Nb3VzZU1vdmUoKXt0aGlzLmRvY3VtZW50LmN0eC5jYW52YXMuc3R5bGUuY3Vyc29yPSJwb2ludGVyIn19ZnVuY3Rpb24gT2UoZSx0KXt2YXIgQT1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihyPXIuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSxBLnB1c2guYXBwbHkoQSxyKX1yZXR1cm4gQX1mdW5jdGlvbiBNZShlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgQT1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9O3QlMj9PZShPYmplY3QoQSksITApLmZvckVhY2goZnVuY3Rpb24odCl7KDAsbi5kZWZhdWx0KShlLHQsQVt0XSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKEEpKTpPZShPYmplY3QoQSkpLmZvckVhY2goZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEEsdCkpfSl9cmV0dXJuIGV9Y2xhc3MgRGUgZXh0ZW5kcyBkZXtjb25zdHJ1Y3RvcihlLHQsQSl7c3VwZXIoZSx0LEEpLHRoaXMudHlwZT0idGV4dFBhdGgiLHRoaXMudGV4dFdpZHRoPTAsdGhpcy50ZXh0SGVpZ2h0PTAsdGhpcy5wYXRoTGVuZ3RoPS0xLHRoaXMuZ2x5cGhJbmZvPW51bGwsdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGU9W10sdGhpcy5tZWFzdXJlc0NhY2hlPW5ldyBNYXAoW1siIiwwXV0pO3ZhciByPXRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTt0aGlzLnRleHQ9dGhpcy5nZXRUZXh0RnJvbU5vZGUoKSx0aGlzLmRhdGFBcnJheT10aGlzLnBhcnNlUGF0aERhdGEocil9Z2V0VGV4dCgpe3JldHVybiB0aGlzLnRleHR9cGF0aChlKXt2YXJ7ZGF0YUFycmF5OnR9PXRoaXM7ZSYmZS5iZWdpblBhdGgoKSx0LmZvckVhY2godD0+e3Zhcnt0eXBlOkEscG9pbnRzOnJ9PXQ7c3dpdGNoKEEpe2Nhc2UgbGUuTElORV9UTzplJiZlLmxpbmVUbyhyWzBdLHJbMV0pO2JyZWFrO2Nhc2UgbGUuTU9WRV9UTzplJiZlLm1vdmVUbyhyWzBdLHJbMV0pO2JyZWFrO2Nhc2UgbGUuQ1VSVkVfVE86ZSYmZS5iZXppZXJDdXJ2ZVRvKHJbMF0sclsxXSxyWzJdLHJbM10scls0XSxyWzVdKTticmVhaztjYXNlIGxlLlFVQURfVE86ZSYmZS5xdWFkcmF0aWNDdXJ2ZVRvKHJbMF0sclsxXSxyWzJdLHJbM10pO2JyZWFrO2Nhc2UgbGUuQVJDOnZhcltuLHMsaSxvLGEsbCxjLHVdPXIsaD1pPm8/aTpvLGQ9aT5vPzE6aS9vLGY9aT5vP28vaToxO2UmJihlLnRyYW5zbGF0ZShuLHMpLGUucm90YXRlKGMpLGUuc2NhbGUoZCxmKSxlLmFyYygwLDAsaCxhLGErbCxCb29sZWFuKDEtdSkpLGUuc2NhbGUoMS9kLDEvZiksZS5yb3RhdGUoLWMpLGUudHJhbnNsYXRlKC1uLC1zKSk7YnJlYWs7Y2FzZSBsZS5DTE9TRV9QQVRIOmUmJmUuY2xvc2VQYXRoKCl9fSl9cmVuZGVyQ2hpbGRyZW4oZSl7dGhpcy5zZXRUZXh0RGF0YShlKSxlLnNhdmUoKTt2YXIgdD10aGlzLnBhcmVudC5nZXRTdHlsZSgidGV4dC1kZWNvcmF0aW9uIikuZ2V0U3RyaW5nKCksQT10aGlzLmdldEZvbnRTaXplKCkse2dseXBoSW5mbzpyfT10aGlzLG49ZS5maWxsU3R5bGU7InVuZGVybGluZSI9PT10JiZlLmJlZ2luUGF0aCgpLHIuZm9yRWFjaCgocixuKT0+e3ZhcntwMDpzLHAxOmkscm90YXRpb246byx0ZXh0OmF9PXI7ZS5zYXZlKCksZS50cmFuc2xhdGUocy54LHMueSksZS5yb3RhdGUobyksZS5maWxsU3R5bGUmJmUuZmlsbFRleHQoYSwwLDApLGUuc3Ryb2tlU3R5bGUmJmUuc3Ryb2tlVGV4dChhLDAsMCksZS5yZXN0b3JlKCksInVuZGVybGluZSI9PT10JiYoMD09PW4mJmUubW92ZVRvKHMueCxzLnkrQS84KSxlLmxpbmVUbyhpLngsaS55K0EvNSkpfSksInVuZGVybGluZSI9PT10JiYoZS5saW5lV2lkdGg9QS8yMCxlLnN0cm9rZVN0eWxlPW4sZS5zdHJva2UoKSxlLmNsb3NlUGF0aCgpKSxlLnJlc3RvcmUoKX1nZXRMZXR0ZXJTcGFjaW5nQXQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MDtyZXR1cm4gdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGVbZV18fDB9ZmluZFNlZ21lbnRUb0ZpdENoYXIoZSx0LEEscixuLHMsaSxvLGEpe3ZhciBsPXMsYz10aGlzLm1lYXN1cmVUZXh0KGUsbyk7IiAiPT09byYmImp1c3RpZnkiPT09dCYmQTxyJiYoYys9KHItQSkvbiksYT4tMSYmKGwrPXRoaXMuZ2V0TGV0dGVyU3BhY2luZ0F0KGEpKTt2YXIgdT10aGlzLnRleHRIZWlnaHQvMjAsaD10aGlzLmdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgobCx1LDApLGQ9dGhpcy5nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKGwrYyx1LDApLGY9e3AwOmgscDE6ZH0scD1oJiZkP01hdGguYXRhbjIoZC55LWgueSxkLngtaC54KTowO2lmKGkpe3ZhciBnPU1hdGguY29zKE1hdGguUEkvMitwKSppLG09TWF0aC5jb3MoLXApKmk7Zi5wMD1NZShNZSh7fSxoKSx7fSx7eDpoLngrZyx5OmgueSttfSksZi5wMT1NZShNZSh7fSxkKSx7fSx7eDpkLngrZyx5OmQueSttfSl9cmV0dXJue29mZnNldDpsKz1jLHNlZ21lbnQ6Zixyb3RhdGlvbjpwfX1tZWFzdXJlVGV4dChlLHQpe3ZhcnttZWFzdXJlc0NhY2hlOkF9PXRoaXMscj10fHx0aGlzLmdldFRleHQoKTtpZihBLmhhcyhyKSlyZXR1cm4gQS5nZXQocik7dmFyIG49dGhpcy5tZWFzdXJlVGFyZ2V0VGV4dChlLHIpO3JldHVybiBBLnNldChyLG4pLG59c2V0VGV4dERhdGEoZSl7aWYoIXRoaXMuZ2x5cGhJbmZvKXt2YXIgdD10aGlzLmdldFRleHQoKSxBPXQuc3BsaXQoIiIpLHI9dC5zcGxpdCgiICIpLmxlbmd0aC0xLG49dGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKCJkeCIpLnNwbGl0KCkubWFwKGU9PmUuZ2V0UGl4ZWxzKCJ4IikpLHM9dGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKCJkeSIpLmdldFBpeGVscygieSIpLGk9dGhpcy5wYXJlbnQuZ2V0U3R5bGUoInRleHQtYW5jaG9yIikuZ2V0U3RyaW5nKCJzdGFydCIpLG89dGhpcy5nZXRTdHlsZSgibGV0dGVyLXNwYWNpbmciKSxhPXRoaXMucGFyZW50LmdldFN0eWxlKCJsZXR0ZXItc3BhY2luZyIpLGw9MDtvLmhhc1ZhbHVlKCkmJiJpbmhlcml0IiE9PW8uZ2V0VmFsdWUoKT9vLmhhc1ZhbHVlKCkmJiJpbml0aWFsIiE9PW8uZ2V0VmFsdWUoKSYmInVuc2V0IiE9PW8uZ2V0VmFsdWUoKSYmKGw9by5nZXRQaXhlbHMoKSk6bD1hLmdldFBpeGVscygpO3ZhciBjPVtdLHU9dC5sZW5ndGg7dGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGU9Yztmb3IodmFyIGg9MDtoPHU7aCsrKWMucHVzaCh2b2lkIDAhPT1uW2hdP25baF06bCk7dmFyIGQ9Yy5yZWR1Y2UoKGUsdCxBKT0+MD09PUE/MDplK3R8fDAsMCksZj10aGlzLm1lYXN1cmVUZXh0KGUpLHA9TWF0aC5tYXgoZitkLDApO3RoaXMudGV4dFdpZHRoPWYsdGhpcy50ZXh0SGVpZ2h0PXRoaXMuZ2V0Rm9udFNpemUoKSx0aGlzLmdseXBoSW5mbz1bXTt2YXIgZz10aGlzLmdldFBhdGhMZW5ndGgoKSxtPXRoaXMuZ2V0U3R5bGUoInN0YXJ0T2Zmc2V0IikuZ2V0TnVtYmVyKDApKmcsdz0wOyJtaWRkbGUiIT09aSYmImNlbnRlciIhPT1pfHwodz0tcC8yKSwiZW5kIiE9PWkmJiJyaWdodCIhPT1pfHwodz0tcCksdys9bSxBLmZvckVhY2goKHQsbik9Pnt2YXJ7b2Zmc2V0Om8sc2VnbWVudDphLHJvdGF0aW9uOmx9PXRoaXMuZmluZFNlZ21lbnRUb0ZpdENoYXIoZSxpLHAsZyxyLHcscyx0LG4pO3c9byxhLnAwJiZhLnAxJiZ0aGlzLmdseXBoSW5mby5wdXNoKHt0ZXh0OkFbbl0scDA6YS5wMCxwMTphLnAxLHJvdGF0aW9uOmx9KX0pfX1wYXJzZVBhdGhEYXRhKGUpe2lmKHRoaXMucGF0aExlbmd0aD0tMSwhZSlyZXR1cm5bXTt2YXIgdD1bXSx7cGF0aFBhcnNlcjpBfT1lO2ZvcihBLnJlc2V0KCk7IUEuaXNFbmQoKTspe3ZhcntjdXJyZW50OnJ9PUEsbj1yP3IueDowLHM9cj9yLnk6MCxpPUEubmV4dCgpLG89aS50eXBlLGE9W107c3dpdGNoKGkudHlwZSl7Y2FzZSBsZS5NT1ZFX1RPOnRoaXMucGF0aE0oQSxhKTticmVhaztjYXNlIGxlLkxJTkVfVE86bz10aGlzLnBhdGhMKEEsYSk7YnJlYWs7Y2FzZSBsZS5IT1JJWl9MSU5FX1RPOm89dGhpcy5wYXRoSChBLGEpO2JyZWFrO2Nhc2UgbGUuVkVSVF9MSU5FX1RPOm89dGhpcy5wYXRoVihBLGEpO2JyZWFrO2Nhc2UgbGUuQ1VSVkVfVE86dGhpcy5wYXRoQyhBLGEpO2JyZWFrO2Nhc2UgbGUuU01PT1RIX0NVUlZFX1RPOm89dGhpcy5wYXRoUyhBLGEpO2JyZWFrO2Nhc2UgbGUuUVVBRF9UTzp0aGlzLnBhdGhRKEEsYSk7YnJlYWs7Y2FzZSBsZS5TTU9PVEhfUVVBRF9UTzpvPXRoaXMucGF0aFQoQSxhKTticmVhaztjYXNlIGxlLkFSQzphPXRoaXMucGF0aEEoQSk7YnJlYWs7Y2FzZSBsZS5DTE9TRV9QQVRIOnVlLnBhdGhaKEEpfWkudHlwZSE9PWxlLkNMT1NFX1BBVEg/dC5wdXNoKHt0eXBlOm8scG9pbnRzOmEsc3RhcnQ6e3g6bix5OnN9LHBhdGhMZW5ndGg6dGhpcy5jYWxjTGVuZ3RoKG4scyxvLGEpfSk6dC5wdXNoKHt0eXBlOmxlLkNMT1NFX1BBVEgscG9pbnRzOltdLHBhdGhMZW5ndGg6MH0pfXJldHVybiB0fXBhdGhNKGUsdCl7dmFye3g6QSx5OnJ9PXVlLnBhdGhNKGUpLnBvaW50O3QucHVzaChBLHIpfXBhdGhMKGUsdCl7dmFye3g6QSx5OnJ9PXVlLnBhdGhMKGUpLnBvaW50O3JldHVybiB0LnB1c2goQSxyKSxsZS5MSU5FX1RPfXBhdGhIKGUsdCl7dmFye3g6QSx5OnJ9PXVlLnBhdGhIKGUpLnBvaW50O3JldHVybiB0LnB1c2goQSxyKSxsZS5MSU5FX1RPfXBhdGhWKGUsdCl7dmFye3g6QSx5OnJ9PXVlLnBhdGhWKGUpLnBvaW50O3JldHVybiB0LnB1c2goQSxyKSxsZS5MSU5FX1RPfXBhdGhDKGUsdCl7dmFye3BvaW50OkEsY29udHJvbFBvaW50OnIsY3VycmVudFBvaW50Om59PXVlLnBhdGhDKGUpO3QucHVzaChBLngsQS55LHIueCxyLnksbi54LG4ueSl9cGF0aFMoZSx0KXt2YXJ7cG9pbnQ6QSxjb250cm9sUG9pbnQ6cixjdXJyZW50UG9pbnQ6bn09dWUucGF0aFMoZSk7cmV0dXJuIHQucHVzaChBLngsQS55LHIueCxyLnksbi54LG4ueSksbGUuQ1VSVkVfVE99cGF0aFEoZSx0KXt2YXJ7Y29udHJvbFBvaW50OkEsY3VycmVudFBvaW50OnJ9PXVlLnBhdGhRKGUpO3QucHVzaChBLngsQS55LHIueCxyLnkpfXBhdGhUKGUsdCl7dmFye2NvbnRyb2xQb2ludDpBLGN1cnJlbnRQb2ludDpyfT11ZS5wYXRoVChlKTtyZXR1cm4gdC5wdXNoKEEueCxBLnksci54LHIueSksbGUuUVVBRF9UT31wYXRoQShlKXt2YXJ7clg6dCxyWTpBLHN3ZWVwRmxhZzpyLHhBeGlzUm90YXRpb246bixjZW50cDpzLGExOmksYWQ6b309dWUucGF0aEEoZSk7cmV0dXJuIDA9PT1yJiZvPjAmJihvLT0yKk1hdGguUEkpLDE9PT1yJiZvPDAmJihvKz0yKk1hdGguUEkpLFtzLngscy55LHQsQSxpLG8sbixyXX1jYWxjTGVuZ3RoKGUsdCxBLHIpe3ZhciBuPTAscz1udWxsLGk9bnVsbCxvPTA7c3dpdGNoKEEpe2Nhc2UgbGUuTElORV9UTzpyZXR1cm4gdGhpcy5nZXRMaW5lTGVuZ3RoKGUsdCxyWzBdLHJbMV0pO2Nhc2UgbGUuQ1VSVkVfVE86Zm9yKG49MCxzPXRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKDAsZSx0LHJbMF0sclsxXSxyWzJdLHJbM10scls0XSxyWzVdKSxvPS4wMTtvPD0xO28rPS4wMSlpPXRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKG8sZSx0LHJbMF0sclsxXSxyWzJdLHJbM10scls0XSxyWzVdKSxuKz10aGlzLmdldExpbmVMZW5ndGgocy54LHMueSxpLngsaS55KSxzPWk7cmV0dXJuIG47Y2FzZSBsZS5RVUFEX1RPOmZvcihuPTAscz10aGlzLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoMCxlLHQsclswXSxyWzFdLHJbMl0sclszXSksbz0uMDE7bzw9MTtvKz0uMDEpaT10aGlzLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIobyxlLHQsclswXSxyWzFdLHJbMl0sclszXSksbis9dGhpcy5nZXRMaW5lTGVuZ3RoKHMueCxzLnksaS54LGkueSkscz1pO3JldHVybiBuO2Nhc2UgbGUuQVJDOm49MDt2YXIgYT1yWzRdLGw9cls1XSxjPXJbNF0rbCx1PU1hdGguUEkvMTgwO2lmKE1hdGguYWJzKGEtYyk8dSYmKHU9TWF0aC5hYnMoYS1jKSkscz10aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHJbMF0sclsxXSxyWzJdLHJbM10sYSwwKSxsPDApZm9yKG89YS11O28+YztvLT11KWk9dGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhyWzBdLHJbMV0sclsyXSxyWzNdLG8sMCksbis9dGhpcy5nZXRMaW5lTGVuZ3RoKHMueCxzLnksaS54LGkueSkscz1pO2Vsc2UgZm9yKG89YSt1O288YztvKz11KWk9dGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhyWzBdLHJbMV0sclsyXSxyWzNdLG8sMCksbis9dGhpcy5nZXRMaW5lTGVuZ3RoKHMueCxzLnksaS54LGkueSkscz1pO3JldHVybiBpPXRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoclswXSxyWzFdLHJbMl0sclszXSxjLDApLG4rdGhpcy5nZXRMaW5lTGVuZ3RoKHMueCxzLnksaS54LGkueSl9cmV0dXJuIDB9Z2V0UG9pbnRPbkxpbmUoZSx0LEEscixuKXt2YXIgcz1hcmd1bWVudHMubGVuZ3RoPjUmJnZvaWQgMCE9PWFyZ3VtZW50c1s1XT9hcmd1bWVudHNbNV06dCxpPWFyZ3VtZW50cy5sZW5ndGg+NiYmdm9pZCAwIT09YXJndW1lbnRzWzZdP2FyZ3VtZW50c1s2XTpBLG89KG4tQSkvKHItdCtGKSxhPU1hdGguc3FydChlKmUvKDErbypvKSk7cjx0JiYoYSo9LTEpO3ZhciBsPW8qYSxjPW51bGw7aWYocj09PXQpYz17eDpzLHk6aStsfTtlbHNlIGlmKChpLUEpLyhzLXQrRik9PT1vKWM9e3g6cythLHk6aStsfTtlbHNle3ZhciB1LGgsZD10aGlzLmdldExpbmVMZW5ndGgodCxBLHIsbik7aWYoZDxGKXJldHVybiBudWxsO3ZhciBmPShzLXQpKihyLXQpKyhpLUEpKihuLUEpO3U9dCsoZi89ZCpkKSooci10KSxoPUErZioobi1BKTt2YXIgcD10aGlzLmdldExpbmVMZW5ndGgocyxpLHUsaCksZz1NYXRoLnNxcnQoZSplLXAqcCk7YT1NYXRoLnNxcnQoZypnLygxK28qbykpLHI8dCYmKGEqPS0xKSxjPXt4OnUrYSx5OmgrKGw9byphKX19cmV0dXJuIGN9Z2V0UG9pbnRPblBhdGgoZSl7dmFyIHQ9dGhpcy5nZXRQYXRoTGVuZ3RoKCksQT0wLHI9bnVsbDtpZihlPC01ZS01fHxlLTVlLTU+dClyZXR1cm4gbnVsbDt2YXJ7ZGF0YUFycmF5Om59PXRoaXM7Zm9yKHZhciBzIG9mIG4pe2lmKCFzfHwhKHMucGF0aExlbmd0aDw1ZS01fHxBK3MucGF0aExlbmd0aCs1ZS01PGUpKXt2YXIgaT1lLUEsbz0wO3N3aXRjaChzLnR5cGUpe2Nhc2UgbGUuTElORV9UTzpyPXRoaXMuZ2V0UG9pbnRPbkxpbmUoaSxzLnN0YXJ0Lngscy5zdGFydC55LHMucG9pbnRzWzBdLHMucG9pbnRzWzFdLHMuc3RhcnQueCxzLnN0YXJ0LnkpO2JyZWFrO2Nhc2UgbGUuQVJDOnZhciBhPXMucG9pbnRzWzRdLGw9cy5wb2ludHNbNV0sYz1zLnBvaW50c1s0XStsO2lmKG89YStpL3MucGF0aExlbmd0aCpsLGw8MCYmbzxjfHxsPj0wJiZvPmMpYnJlYWs7cj10aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHMucG9pbnRzWzBdLHMucG9pbnRzWzFdLHMucG9pbnRzWzJdLHMucG9pbnRzWzNdLG8scy5wb2ludHNbNl0pO2JyZWFrO2Nhc2UgbGUuQ1VSVkVfVE86KG89aS9zLnBhdGhMZW5ndGgpPjEmJihvPTEpLHI9dGhpcy5nZXRQb2ludE9uQ3ViaWNCZXppZXIobyxzLnN0YXJ0Lngscy5zdGFydC55LHMucG9pbnRzWzBdLHMucG9pbnRzWzFdLHMucG9pbnRzWzJdLHMucG9pbnRzWzNdLHMucG9pbnRzWzRdLHMucG9pbnRzWzVdKTticmVhaztjYXNlIGxlLlFVQURfVE86KG89aS9zLnBhdGhMZW5ndGgpPjEmJihvPTEpLHI9dGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKG8scy5zdGFydC54LHMuc3RhcnQueSxzLnBvaW50c1swXSxzLnBvaW50c1sxXSxzLnBvaW50c1syXSxzLnBvaW50c1szXSl9aWYocilyZXR1cm4gcjticmVha31BKz1zLnBhdGhMZW5ndGh9cmV0dXJuIG51bGx9Z2V0TGluZUxlbmd0aChlLHQsQSxyKXtyZXR1cm4gTWF0aC5zcXJ0KChBLWUpKihBLWUpKyhyLXQpKihyLXQpKX1nZXRQYXRoTGVuZ3RoKCl7cmV0dXJuLTE9PT10aGlzLnBhdGhMZW5ndGgmJih0aGlzLnBhdGhMZW5ndGg9dGhpcy5kYXRhQXJyYXkucmVkdWNlKChlLHQpPT50LnBhdGhMZW5ndGg+MD9lK3QucGF0aExlbmd0aDplLDApKSx0aGlzLnBhdGhMZW5ndGh9Z2V0UG9pbnRPbkN1YmljQmV6aWVyKGUsdCxBLHIsbixzLGksbyxhKXtyZXR1cm57eDpvKlMoZSkrcypMKGUpK3IqSShlKSt0Kk4oZSkseTphKlMoZSkraSpMKGUpK24qSShlKStBKk4oZSl9fWdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoZSx0LEEscixuLHMsaSl7cmV0dXJue3g6cyprKGUpK3IqSChlKSt0KlAoZSkseTppKmsoZSkrbipIKGUpK0EqUChlKX19Z2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoZSx0LEEscixuLHMpe3ZhciBpPU1hdGguY29zKHMpLG89TWF0aC5zaW4ocyksYT1BKk1hdGguY29zKG4pLGw9cipNYXRoLnNpbihuKTtyZXR1cm57eDplKyhhKmktbCpvKSx5OnQrKGEqbytsKmkpfX1idWlsZEVxdWlkaXN0YW50Q2FjaGUoZSx0KXt2YXIgQT10aGlzLmdldFBhdGhMZW5ndGgoKSxyPXR8fC4yNSxuPWV8fEEvMTAwO2lmKCF0aGlzLmVxdWlkaXN0YW50Q2FjaGV8fHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5zdGVwIT09bnx8dGhpcy5lcXVpZGlzdGFudENhY2hlLnByZWNpc2lvbiE9PXIpe3RoaXMuZXF1aWRpc3RhbnRDYWNoZT17c3RlcDpuLHByZWNpc2lvbjpyLHBvaW50czpbXX07Zm9yKHZhciBzPTAsaT0wO2k8PUE7aSs9cil7dmFyIG89dGhpcy5nZXRQb2ludE9uUGF0aChpKSxhPXRoaXMuZ2V0UG9pbnRPblBhdGgoaStyKTtvJiZhJiYocys9dGhpcy5nZXRMaW5lTGVuZ3RoKG8ueCxvLnksYS54LGEueSkpPj1uJiYodGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50cy5wdXNoKHt4Om8ueCx5Om8ueSxkaXN0YW5jZTppfSkscy09bil9fX1nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKGUsdCxBKXtpZih0aGlzLmJ1aWxkRXF1aWRpc3RhbnRDYWNoZSh0LEEpLGU8MHx8ZS10aGlzLmdldFBhdGhMZW5ndGgoKT41ZS01KXJldHVybiBudWxsO3ZhciByPU1hdGgucm91bmQoZS90aGlzLmdldFBhdGhMZW5ndGgoKSoodGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50cy5sZW5ndGgtMSkpO3JldHVybiB0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzW3JdfHxudWxsfX12YXIgUmU9L15ccypkYXRhOigoW14vLDtdK1wvW14vLDtdKykoPzo7KFteLDs9XSs9W14sOz1dKykpPyk/KD86OyhiYXNlNjQpKT8sKC4qKSQvaTtjbGFzcyBLZSBleHRlbmRzIGNle2NvbnN0cnVjdG9yKGUsdCxBKXtzdXBlcihlLHQsQSksdGhpcy50eXBlPSJpbWFnZSIsdGhpcy5sb2FkZWQ9ITE7dmFyIHI9dGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0U3RyaW5nKCk7aWYocil7dmFyIG49ci5lbmRzV2l0aCgiLnN2ZyIpfHwvXlxzKmRhdGE6aW1hZ2VcL3N2Z1wreG1sL2kudGVzdChyKTtlLmltYWdlcy5wdXNoKHRoaXMpLG4/dGhpcy5sb2FkU3ZnKHIpOnRoaXMubG9hZEltYWdlKHIpLHRoaXMuaXNTdmc9bn19bG9hZEltYWdlKGUpe3ZhciB0PXRoaXM7cmV0dXJuKDAsci5kZWZhdWx0KShmdW5jdGlvbiooKXt0cnl7dmFyIEE9eWllbGQgdC5kb2N1bWVudC5jcmVhdGVJbWFnZShlKTt0LmltYWdlPUF9Y2F0Y2godCl7Y29uc29sZS5lcnJvcignRXJyb3Igd2hpbGUgbG9hZGluZyBpbWFnZSAiJy5jb25jYXQoZSwnIjonKSx0KX10LmxvYWRlZD0hMH0pKCl9bG9hZFN2ZyhlKXt2YXIgdD10aGlzO3JldHVybigwLHIuZGVmYXVsdCkoZnVuY3Rpb24qKCl7dmFyIEE9UmUuZXhlYyhlKTtpZihBKXt2YXIgcj1BWzVdOyJiYXNlNjQiPT09QVs0XT90LmltYWdlPWF0b2Iocik6dC5pbWFnZT1kZWNvZGVVUklDb21wb25lbnQocil9ZWxzZSB0cnl7dmFyIG49eWllbGQgdC5kb2N1bWVudC5mZXRjaChlKSxzPXlpZWxkIG4udGV4dCgpO3QuaW1hZ2U9c31jYXRjaCh0KXtjb25zb2xlLmVycm9yKCdFcnJvciB3aGlsZSBsb2FkaW5nIGltYWdlICInLmNvbmNhdChlLCciOicpLHQpfXQubG9hZGVkPSEwfSkoKX1yZW5kZXJDaGlsZHJlbihlKXt2YXJ7ZG9jdW1lbnQ6dCxpbWFnZTpBLGxvYWRlZDpyfT10aGlzLG49dGhpcy5nZXRBdHRyaWJ1dGUoIngiKS5nZXRQaXhlbHMoIngiKSxzPXRoaXMuZ2V0QXR0cmlidXRlKCJ5IikuZ2V0UGl4ZWxzKCJ5IiksaT10aGlzLmdldFN0eWxlKCJ3aWR0aCIpLmdldFBpeGVscygieCIpLG89dGhpcy5nZXRTdHlsZSgiaGVpZ2h0IikuZ2V0UGl4ZWxzKCJ5Iik7aWYociYmQSYmaSYmbyl7aWYoZS5zYXZlKCksZS50cmFuc2xhdGUobixzKSx0aGlzLmlzU3ZnKXt2YXIgYT10LmNhbnZnLmZvcmtTdHJpbmcoZSx0aGlzLmltYWdlLHtpZ25vcmVNb3VzZTohMCxpZ25vcmVBbmltYXRpb246ITAsaWdub3JlRGltZW5zaW9uczohMCxpZ25vcmVDbGVhcjohMCxvZmZzZXRYOjAsb2Zmc2V0WTowLHNjYWxlV2lkdGg6aSxzY2FsZUhlaWdodDpvfSk7YS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucGFyZW50PXRoaXMsYS5yZW5kZXIoKX1lbHNle3ZhciBsPXRoaXMuaW1hZ2U7dC5zZXRWaWV3Qm94KHtjdHg6ZSxhc3BlY3RSYXRpbzp0aGlzLmdldEF0dHJpYnV0ZSgicHJlc2VydmVBc3BlY3RSYXRpbyIpLmdldFN0cmluZygpLHdpZHRoOmksZGVzaXJlZFdpZHRoOmwud2lkdGgsaGVpZ2h0Om8sZGVzaXJlZEhlaWdodDpsLmhlaWdodH0pLHRoaXMubG9hZGVkJiYodm9pZCAwPT09bC5jb21wbGV0ZXx8bC5jb21wbGV0ZSkmJmUuZHJhd0ltYWdlKGwsMCwwKX1lLnJlc3RvcmUoKX19Z2V0Qm91bmRpbmdCb3goKXt2YXIgZT10aGlzLmdldEF0dHJpYnV0ZSgieCIpLmdldFBpeGVscygieCIpLHQ9dGhpcy5nZXRBdHRyaWJ1dGUoInkiKS5nZXRQaXhlbHMoInkiKSxBPXRoaXMuZ2V0U3R5bGUoIndpZHRoIikuZ2V0UGl4ZWxzKCJ4Iikscj10aGlzLmdldFN0eWxlKCJoZWlnaHQiKS5nZXRQaXhlbHMoInkiKTtyZXR1cm4gbmV3IGFlKGUsdCxlK0EsdCtyKX19Y2xhc3MgVmUgZXh0ZW5kcyBjZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJzeW1ib2wifXJlbmRlcihlKXt9fWNsYXNzIEdle2NvbnN0cnVjdG9yKGUpe3RoaXMuZG9jdW1lbnQ9ZSx0aGlzLmxvYWRlZD0hMSxlLmZvbnRzLnB1c2godGhpcyl9bG9hZChlLHQpe3ZhciBBPXRoaXM7cmV0dXJuKDAsci5kZWZhdWx0KShmdW5jdGlvbiooKXt0cnl7dmFye2RvY3VtZW50OnJ9PUEsbj0oeWllbGQgci5jYW52Zy5wYXJzZXIubG9hZCh0KSkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImZvbnQiKTtBcnJheS5mcm9tKG4pLmZvckVhY2godD0+e3ZhciBBPXIuY3JlYXRlRWxlbWVudCh0KTtyLmRlZmluaXRpb25zW2VdPUF9KX1jYXRjaChlKXtjb25zb2xlLmVycm9yKCdFcnJvciB3aGlsZSBsb2FkaW5nIGZvbnQgIicuY29uY2F0KHQsJyI6JyksZSl9QS5sb2FkZWQ9ITB9KSgpfX1jbGFzcyB6ZSBleHRlbmRzIEFle2NvbnN0cnVjdG9yKGUsdCxBKXtzdXBlcihlLHQsQSksdGhpcy50eXBlPSJzdHlsZSIsYyhBcnJheS5mcm9tKHQuY2hpbGROb2RlcykubWFwKGU9PmUudGV4dENvbnRlbnQpLmpvaW4oIiIpLnJlcGxhY2UoLyhcL1wqKFteKl18W1xyXG5dfChcKisoW14qL118W1xyXG5dKSkpKlwqK1wvKXwoXltcc10qXC9cLy4qKS9nbSwiIikucmVwbGFjZSgvQGltcG9ydC4qOy9nLCIiKSkuc3BsaXQoIn0iKS5mb3JFYWNoKHQ9Pnt2YXIgQT10LnRyaW0oKTtpZihBKXt2YXIgcj1BLnNwbGl0KCJ7Iiksbj1yWzBdLnNwbGl0KCIsIikscz1yWzFdLnNwbGl0KCI7Iik7bi5mb3JFYWNoKHQ9Pnt2YXIgQT10LnRyaW0oKTtpZihBKXt2YXIgcj1lLnN0eWxlc1tBXXx8e307aWYocy5mb3JFYWNoKHQ9Pnt2YXIgQT10LmluZGV4T2YoIjoiKSxuPXQuc3Vic3RyKDAsQSkudHJpbSgpLHM9dC5zdWJzdHIoQSsxLHQubGVuZ3RoLUEpLnRyaW0oKTtuJiZzJiYocltuXT1uZXcgVChlLG4scykpfSksZS5zdHlsZXNbQV09cixlLnN0eWxlc1NwZWNpZmljaXR5W0FdPXgoQSksIkBmb250LWZhY2UiPT09QSl7dmFyIG49clsiZm9udC1mYW1pbHkiXS5nZXRTdHJpbmcoKS5yZXBsYWNlKC8ifCcvZywiIik7ci5zcmMuZ2V0U3RyaW5nKCkuc3BsaXQoIiwiKS5mb3JFYWNoKHQ9PntpZih0LmluZGV4T2YoJ2Zvcm1hdCgic3ZnIiknKT4wKXt2YXIgQT1nKHQpO0EmJm5ldyBHZShlKS5sb2FkKG4sQSl9fSl9fX0pfX0pfX16ZS5wYXJzZUV4dGVybmFsVXJsPWc7Y2xhc3MgcWUgZXh0ZW5kcyBjZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJ1c2UifXNldENvbnRleHQoZSl7c3VwZXIuc2V0Q29udGV4dChlKTt2YXIgdD10aGlzLmdldEF0dHJpYnV0ZSgieCIpLEE9dGhpcy5nZXRBdHRyaWJ1dGUoInkiKTt0Lmhhc1ZhbHVlKCkmJmUudHJhbnNsYXRlKHQuZ2V0UGl4ZWxzKCJ4IiksMCksQS5oYXNWYWx1ZSgpJiZlLnRyYW5zbGF0ZSgwLEEuZ2V0UGl4ZWxzKCJ5IikpfXBhdGgoZSl7dmFye2VsZW1lbnQ6dH09dGhpczt0JiZ0LnBhdGgoZSl9cmVuZGVyQ2hpbGRyZW4oZSl7dmFye2RvY3VtZW50OnQsZWxlbWVudDpBfT10aGlzO2lmKEEpe3ZhciByPUE7aWYoInN5bWJvbCI9PT1BLnR5cGUmJigocj1uZXcgZ2UodCxudWxsKSkuYXR0cmlidXRlcy52aWV3Qm94PW5ldyBUKHQsInZpZXdCb3giLEEuZ2V0QXR0cmlidXRlKCJ2aWV3Qm94IikuZ2V0U3RyaW5nKCkpLHIuYXR0cmlidXRlcy5wcmVzZXJ2ZUFzcGVjdFJhdGlvPW5ldyBUKHQsInByZXNlcnZlQXNwZWN0UmF0aW8iLEEuZ2V0QXR0cmlidXRlKCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIikuZ2V0U3RyaW5nKCkpLHIuYXR0cmlidXRlcy5vdmVyZmxvdz1uZXcgVCh0LCJvdmVyZmxvdyIsQS5nZXRBdHRyaWJ1dGUoIm92ZXJmbG93IikuZ2V0U3RyaW5nKCkpLHIuY2hpbGRyZW49QS5jaGlsZHJlbixBLnN0eWxlcy5vcGFjaXR5PW5ldyBUKHQsIm9wYWNpdHkiLHRoaXMuY2FsY3VsYXRlT3BhY2l0eSgpKSksInN2ZyI9PT1yLnR5cGUpe3ZhciBuPXRoaXMuZ2V0U3R5bGUoIndpZHRoIiwhMSwhMCkscz10aGlzLmdldFN0eWxlKCJoZWlnaHQiLCExLCEwKTtuLmhhc1ZhbHVlKCkmJihyLmF0dHJpYnV0ZXMud2lkdGg9bmV3IFQodCwid2lkdGgiLG4uZ2V0U3RyaW5nKCkpKSxzLmhhc1ZhbHVlKCkmJihyLmF0dHJpYnV0ZXMuaGVpZ2h0PW5ldyBUKHQsImhlaWdodCIscy5nZXRTdHJpbmcoKSkpfXZhciBpPXIucGFyZW50O3IucGFyZW50PXRoaXMsci5yZW5kZXIoZSksci5wYXJlbnQ9aX19Z2V0Qm91bmRpbmdCb3goZSl7dmFye2VsZW1lbnQ6dH09dGhpcztyZXR1cm4gdD90LmdldEJvdW5kaW5nQm94KGUpOm51bGx9ZWxlbWVudFRyYW5zZm9ybSgpe3Zhcntkb2N1bWVudDplLGVsZW1lbnQ6dH09dGhpcztyZXR1cm4gdGUuZnJvbUVsZW1lbnQoZSx0KX1nZXQgZWxlbWVudCgpe3JldHVybiB0aGlzLmNhY2hlZEVsZW1lbnR8fCh0aGlzLmNhY2hlZEVsZW1lbnQ9dGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpKSx0aGlzLmNhY2hlZEVsZW1lbnR9fWZ1bmN0aW9uIFdlKGUsdCxBLHIsbixzKXtyZXR1cm4gZVtBKnIqNCs0KnQrc119ZnVuY3Rpb24gWGUoZSx0LEEscixuLHMsaSl7ZVtBKnIqNCs0KnQrc109aX1mdW5jdGlvbiBZZShlLHQsQSl7cmV0dXJuIGVbdF0qQX1mdW5jdGlvbiBKZShlLHQsQSxyKXtyZXR1cm4gdCtNYXRoLmNvcyhlKSpBK01hdGguc2luKGUpKnJ9Y2xhc3MgWmUgZXh0ZW5kcyBBZXtjb25zdHJ1Y3RvcihlLHQsQSl7c3VwZXIoZSx0LEEpLHRoaXMudHlwZT0iZmVDb2xvck1hdHJpeCI7dmFyIHI9ZCh0aGlzLmdldEF0dHJpYnV0ZSgidmFsdWVzIikuZ2V0U3RyaW5nKCkpO3N3aXRjaCh0aGlzLmdldEF0dHJpYnV0ZSgidHlwZSIpLmdldFN0cmluZygibWF0cml4Iikpe2Nhc2Uic2F0dXJhdGUiOnZhciBuPXJbMF07cj1bLjIxMysuNzg3Km4sLjcxNS0uNzE1Km4sLjA3Mi0uMDcyKm4sMCwwLC4yMTMtLjIxMypuLC43MTUrLjI4NSpuLC4wNzItLjA3MipuLDAsMCwuMjEzLS4yMTMqbiwuNzE1LS43MTUqbiwuMDcyKy45MjgqbiwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMV07YnJlYWs7Y2FzZSJodWVSb3RhdGUiOnZhciBzPXJbMF0qTWF0aC5QSS8xODA7cj1bSmUocywuMjEzLC43ODcsLS4yMTMpLEplKHMsLjcxNSwtLjcxNSwtLjcxNSksSmUocywuMDcyLC0uMDcyLC45MjgpLDAsMCxKZShzLC4yMTMsLS4yMTMsLjE0MyksSmUocywuNzE1LC4yODUsLjE0KSxKZShzLC4wNzIsLS4wNzIsLS4yODMpLDAsMCxKZShzLC4yMTMsLS4yMTMsLS43ODcpLEplKHMsLjcxNSwtLjcxNSwuNzE1KSxKZShzLC4wNzIsLjkyOCwuMDcyKSwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMV07YnJlYWs7Y2FzZSJsdW1pbmFuY2VUb0FscGhhIjpyPVswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwuMjEyNSwuNzE1NCwuMDcyMSwwLDAsMCwwLDAsMCwxXX10aGlzLm1hdHJpeD1yLHRoaXMuaW5jbHVkZU9wYWNpdHk9dGhpcy5nZXRBdHRyaWJ1dGUoImluY2x1ZGVPcGFjaXR5IikuaGFzVmFsdWUoKX1hcHBseShlLHQsQSxyLG4pe2Zvcih2YXJ7aW5jbHVkZU9wYWNpdHk6cyxtYXRyaXg6aX09dGhpcyxvPWUuZ2V0SW1hZ2VEYXRhKDAsMCxyLG4pLGE9MDthPG47YSsrKWZvcih2YXIgbD0wO2w8cjtsKyspe3ZhciBjPVdlKG8uZGF0YSxsLGEsciwwLDApLHU9V2Uoby5kYXRhLGwsYSxyLDAsMSksaD1XZShvLmRhdGEsbCxhLHIsMCwyKSxkPVdlKG8uZGF0YSxsLGEsciwwLDMpLGY9WWUoaSwwLGMpK1llKGksMSx1KStZZShpLDIsaCkrWWUoaSwzLGQpK1llKGksNCwxKSxwPVllKGksNSxjKStZZShpLDYsdSkrWWUoaSw3LGgpK1llKGksOCxkKStZZShpLDksMSksZz1ZZShpLDEwLGMpK1llKGksMTEsdSkrWWUoaSwxMixoKStZZShpLDEzLGQpK1llKGksMTQsMSksbT1ZZShpLDE1LGMpK1llKGksMTYsdSkrWWUoaSwxNyxoKStZZShpLDE4LGQpK1llKGksMTksMSk7cyYmKGY9MCxwPTAsZz0wLG0qPWQvMjU1KSxYZShvLmRhdGEsbCxhLHIsMCwwLGYpLFhlKG8uZGF0YSxsLGEsciwwLDEscCksWGUoby5kYXRhLGwsYSxyLDAsMixnKSxYZShvLmRhdGEsbCxhLHIsMCwzLG0pfWUuY2xlYXJSZWN0KDAsMCxyLG4pLGUucHV0SW1hZ2VEYXRhKG8sMCwwKX19Y2xhc3MgJGUgZXh0ZW5kcyBBZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJtYXNrIn1hcHBseShlLHQpe3Zhcntkb2N1bWVudDpBfT10aGlzLHI9dGhpcy5nZXRBdHRyaWJ1dGUoIngiKS5nZXRQaXhlbHMoIngiKSxuPXRoaXMuZ2V0QXR0cmlidXRlKCJ5IikuZ2V0UGl4ZWxzKCJ5Iikscz10aGlzLmdldFN0eWxlKCJ3aWR0aCIpLmdldFBpeGVscygieCIpLGk9dGhpcy5nZXRTdHlsZSgiaGVpZ2h0IikuZ2V0UGl4ZWxzKCJ5Iik7aWYoIXMmJiFpKXt2YXIgbz1uZXcgYWU7dGhpcy5jaGlsZHJlbi5mb3JFYWNoKHQ9PntvLmFkZEJvdW5kaW5nQm94KHQuZ2V0Qm91bmRpbmdCb3goZSkpfSkscj1NYXRoLmZsb29yKG8ueDEpLG49TWF0aC5mbG9vcihvLnkxKSxzPU1hdGguZmxvb3Ioby53aWR0aCksaT1NYXRoLmZsb29yKG8uaGVpZ2h0KX12YXIgYT10aGlzLnJlbW92ZVN0eWxlcyh0LCRlLmlnbm9yZVN0eWxlcyksbD1BLmNyZWF0ZUNhbnZhcyhyK3MsbitpKSxjPWwuZ2V0Q29udGV4dCgiMmQiKTtBLnNjcmVlbi5zZXREZWZhdWx0cyhjKSx0aGlzLnJlbmRlckNoaWxkcmVuKGMpLG5ldyBaZShBLHtub2RlVHlwZToxLGNoaWxkTm9kZXM6W10sYXR0cmlidXRlczpbe25vZGVOYW1lOiJ0eXBlIix2YWx1ZToibHVtaW5hbmNlVG9BbHBoYSJ9LHtub2RlTmFtZToiaW5jbHVkZU9wYWNpdHkiLHZhbHVlOiJ0cnVlIn1dfSkuYXBwbHkoYywwLDAscitzLG4raSk7dmFyIHU9QS5jcmVhdGVDYW52YXMocitzLG4raSksaD11LmdldENvbnRleHQoIjJkIik7QS5zY3JlZW4uc2V0RGVmYXVsdHMoaCksdC5yZW5kZXIoaCksaC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249ImRlc3RpbmF0aW9uLWluIixoLmZpbGxTdHlsZT1jLmNyZWF0ZVBhdHRlcm4obCwibm8tcmVwZWF0IiksaC5maWxsUmVjdCgwLDAscitzLG4raSksZS5maWxsU3R5bGU9aC5jcmVhdGVQYXR0ZXJuKHUsIm5vLXJlcGVhdCIpLGUuZmlsbFJlY3QoMCwwLHIrcyxuK2kpLHRoaXMucmVzdG9yZVN0eWxlcyh0LGEpfXJlbmRlcihlKXt9fSRlLmlnbm9yZVN0eWxlcz1bIm1hc2siLCJ0cmFuc2Zvcm0iLCJjbGlwLXBhdGgiXTt2YXIgZXQ9KCk9Pnt9O2NsYXNzIHR0IGV4dGVuZHMgQWV7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudHlwZT0iY2xpcFBhdGgifWFwcGx5KGUpe3Zhcntkb2N1bWVudDp0fT10aGlzLEE9UmVmbGVjdC5nZXRQcm90b3R5cGVPZihlKSx7YmVnaW5QYXRoOnIsY2xvc2VQYXRoOm59PWU7QSYmKEEuYmVnaW5QYXRoPWV0LEEuY2xvc2VQYXRoPWV0KSxSZWZsZWN0LmFwcGx5KHIsZSxbXSksdGhpcy5jaGlsZHJlbi5mb3JFYWNoKHI9PntpZih2b2lkIDAhPT1yLnBhdGgpe3ZhciBzPXZvaWQgMCE9PXIuZWxlbWVudFRyYW5zZm9ybT9yLmVsZW1lbnRUcmFuc2Zvcm0oKTpudWxsO3N8fChzPXRlLmZyb21FbGVtZW50KHQscikpLHMmJnMuYXBwbHkoZSksci5wYXRoKGUpLEEmJihBLmNsb3NlUGF0aD1uKSxzJiZzLnVuYXBwbHkoZSl9fSksUmVmbGVjdC5hcHBseShuLGUsW10pLGUuY2xpcCgpLEEmJihBLmJlZ2luUGF0aD1yLEEuY2xvc2VQYXRoPW4pfXJlbmRlcihlKXt9fWNsYXNzIEF0IGV4dGVuZHMgQWV7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudHlwZT0iZmlsdGVyIn1hcHBseShlLHQpe3Zhcntkb2N1bWVudDpBLGNoaWxkcmVuOnJ9PXRoaXMsbj10LmdldEJvdW5kaW5nQm94KGUpO2lmKG4pe3ZhciBzPTAsaT0wO3IuZm9yRWFjaChlPT57dmFyIHQ9ZS5leHRyYUZpbHRlckRpc3RhbmNlfHwwO3M9TWF0aC5tYXgocyx0KSxpPU1hdGgubWF4KGksdCl9KTt2YXIgbz1NYXRoLmZsb29yKG4ud2lkdGgpLGE9TWF0aC5mbG9vcihuLmhlaWdodCksbD1vKzIqcyxjPWErMippO2lmKCEobDwxfHxjPDEpKXt2YXIgdT1NYXRoLmZsb29yKG4ueCksaD1NYXRoLmZsb29yKG4ueSksZD10aGlzLnJlbW92ZVN0eWxlcyh0LEF0Lmlnbm9yZVN0eWxlcyksZj1BLmNyZWF0ZUNhbnZhcyhsLGMpLHA9Zi5nZXRDb250ZXh0KCIyZCIpO0Euc2NyZWVuLnNldERlZmF1bHRzKHApLHAudHJhbnNsYXRlKC11K3MsLWgraSksdC5yZW5kZXIocCksci5mb3JFYWNoKGU9PnsiZnVuY3Rpb24iPT10eXBlb2YgZS5hcHBseSYmZS5hcHBseShwLDAsMCxsLGMpfSksZS5kcmF3SW1hZ2UoZiwwLDAsbCxjLHUtcyxoLWksbCxjKSx0aGlzLnJlc3RvcmVTdHlsZXModCxkKX19fXJlbmRlcihlKXt9fUF0Lmlnbm9yZVN0eWxlcz1bImZpbHRlciIsInRyYW5zZm9ybSIsImNsaXAtcGF0aCJdO2NsYXNzIHJ0IGV4dGVuZHMgQWV7Y29uc3RydWN0b3IoZSx0LEEpe3N1cGVyKGUsdCxBKSx0aGlzLnR5cGU9ImZlRHJvcFNoYWRvdyIsdGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCl9YXBwbHkoZSx0LEEscixuKXt9fWNsYXNzIG50IGV4dGVuZHMgQWV7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudHlwZT0iZmVNb3JwaG9sb2d5In1hcHBseShlLHQsQSxyLG4pe319Y2xhc3Mgc3QgZXh0ZW5kcyBBZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJmZUNvbXBvc2l0ZSJ9YXBwbHkoZSx0LEEscixuKXt9fWNsYXNzIGl0IGV4dGVuZHMgQWV7Y29uc3RydWN0b3IoZSx0LEEpe3N1cGVyKGUsdCxBKSx0aGlzLnR5cGU9ImZlR2F1c3NpYW5CbHVyIix0aGlzLmJsdXJSYWRpdXM9TWF0aC5mbG9vcih0aGlzLmdldEF0dHJpYnV0ZSgic3RkRGV2aWF0aW9uIikuZ2V0TnVtYmVyKCkpLHRoaXMuZXh0cmFGaWx0ZXJEaXN0YW5jZT10aGlzLmJsdXJSYWRpdXN9YXBwbHkoZSx0LEEscixuKXt2YXJ7ZG9jdW1lbnQ6cyxibHVyUmFkaXVzOml9PXRoaXMsbz1zLndpbmRvdz9zLndpbmRvdy5kb2N1bWVudC5ib2R5Om51bGwsbD1lLmNhbnZhcztsLmlkPXMuZ2V0VW5pcXVlSWQoKSxvJiYobC5zdHlsZS5kaXNwbGF5PSJub25lIixvLmFwcGVuZENoaWxkKGwpKSwoMCxhLmNhbnZhc1JHQkEpKGwsdCxBLHIsbixpKSxvJiZvLnJlbW92ZUNoaWxkKGwpfX1jbGFzcyBvdCBleHRlbmRzIEFle2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9InRpdGxlIn19Y2xhc3MgYXQgZXh0ZW5kcyBBZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50eXBlPSJkZXNjIn19dmFyIGx0PXtzdmc6Z2UscmVjdDptZSxjaXJjbGU6d2UsZWxsaXBzZTpCZSxsaW5lOnllLHBvbHlsaW5lOnZlLHBvbHlnb246YmUscGF0aDp1ZSxwYXR0ZXJuOkNlLG1hcmtlcjpfZSxkZWZzOmplLGxpbmVhckdyYWRpZW50OlFlLHJhZGlhbEdyYWRpZW50OlVlLHN0b3A6RWUsYW5pbWF0ZTpTZSxhbmltYXRlQ29sb3I6TGUsYW5pbWF0ZVRyYW5zZm9ybTpJZSxmb250Ok5lLCJmb250LWZhY2UiOmtlLCJtaXNzaW5nLWdseXBoIjpIZSxnbHlwaDpoZSx0ZXh0OmRlLHRzcGFuOmZlLHRyZWY6UGUsYTpUZSx0ZXh0UGF0aDpEZSxpbWFnZTpLZSxnOnhlLHN5bWJvbDpWZSxzdHlsZTp6ZSx1c2U6cWUsbWFzazokZSxjbGlwUGF0aDp0dCxmaWx0ZXI6QXQsZmVEcm9wU2hhZG93OnJ0LGZlTW9ycGhvbG9neTpudCxmZUNvbXBvc2l0ZTpzdCxmZUNvbG9yTWF0cml4OlplLGZlR2F1c3NpYW5CbHVyOml0LHRpdGxlOm90LGRlc2M6YXR9O2Z1bmN0aW9uIGN0KGUsdCl7dmFyIEE9T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYocj1yLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSksQS5wdXNoLmFwcGx5KEEscil9cmV0dXJuIEF9ZnVuY3Rpb24gdXQoKXtyZXR1cm4gdXQ9KDAsci5kZWZhdWx0KShmdW5jdGlvbiooZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxBPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO3JldHVybiB0JiYoQS5jcm9zc09yaWdpbj0iQW5vbnltb3VzIiksbmV3IFByb21pc2UoKHQscik9PntBLm9ubG9hZD0oKT0+e3QoQSl9LEEub25lcnJvcj0oZSx0LEEsbixzKT0+e3Iocyl9LEEuc3JjPWV9KX0pLHV0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jbGFzcyBodHtjb25zdHJ1Y3RvcihlKXt2YXJ7cm9vdEVtU2l6ZTp0PTEyLGVtU2l6ZTpBPTEyLGNyZWF0ZUNhbnZhczpyPWh0LmNyZWF0ZUNhbnZhcyxjcmVhdGVJbWFnZTpuPWh0LmNyZWF0ZUltYWdlLGFub255bW91c0Nyb3NzT3JpZ2luOnN9PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTt0aGlzLmNhbnZnPWUsdGhpcy5kZWZpbml0aW9ucz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuc3R5bGVzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5zdHlsZXNTcGVjaWZpY2l0eT1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuaW1hZ2VzPVtdLHRoaXMuZm9udHM9W10sdGhpcy5lbVNpemVTdGFjaz1bXSx0aGlzLnVuaXF1ZUlkPTAsdGhpcy5zY3JlZW49ZS5zY3JlZW4sdGhpcy5yb290RW1TaXplPXQsdGhpcy5lbVNpemU9QSx0aGlzLmNyZWF0ZUNhbnZhcz1yLHRoaXMuY3JlYXRlSW1hZ2U9dGhpcy5iaW5kQ3JlYXRlSW1hZ2UobixzKSx0aGlzLnNjcmVlbi53YWl0KHRoaXMuaXNJbWFnZXNMb2FkZWQuYmluZCh0aGlzKSksdGhpcy5zY3JlZW4ud2FpdCh0aGlzLmlzRm9udHNMb2FkZWQuYmluZCh0aGlzKSl9YmluZENyZWF0ZUltYWdlKGUsdCl7cmV0dXJuImJvb2xlYW4iPT10eXBlb2YgdD8oQSxyKT0+ZShBLCJib29sZWFuIj09dHlwZW9mIHI/cjp0KTplfWdldCB3aW5kb3coKXtyZXR1cm4gdGhpcy5zY3JlZW4ud2luZG93fWdldCBmZXRjaCgpe3JldHVybiB0aGlzLnNjcmVlbi5mZXRjaH1nZXQgY3R4KCl7cmV0dXJuIHRoaXMuc2NyZWVuLmN0eH1nZXQgZW1TaXplKCl7dmFye2VtU2l6ZVN0YWNrOmV9PXRoaXM7cmV0dXJuIGVbZS5sZW5ndGgtMV19c2V0IGVtU2l6ZShlKXt2YXJ7ZW1TaXplU3RhY2s6dH09dGhpczt0LnB1c2goZSl9cG9wRW1TaXplKCl7dmFye2VtU2l6ZVN0YWNrOmV9PXRoaXM7ZS5wb3AoKX1nZXRVbmlxdWVJZCgpe3JldHVybiJjYW52ZyIuY29uY2F0KCsrdGhpcy51bmlxdWVJZCl9aXNJbWFnZXNMb2FkZWQoKXtyZXR1cm4gdGhpcy5pbWFnZXMuZXZlcnkoZT0+ZS5sb2FkZWQpfWlzRm9udHNMb2FkZWQoKXtyZXR1cm4gdGhpcy5mb250cy5ldmVyeShlPT5lLmxvYWRlZCl9Y3JlYXRlRG9jdW1lbnRFbGVtZW50KGUpe3ZhciB0PXRoaXMuY3JlYXRlRWxlbWVudChlLmRvY3VtZW50RWxlbWVudCk7cmV0dXJuIHQucm9vdD0hMCx0LmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKSx0aGlzLmRvY3VtZW50RWxlbWVudD10LHR9Y3JlYXRlRWxlbWVudChlKXt2YXIgdD1lLm5vZGVOYW1lLnJlcGxhY2UoL15bXjpdKzovLCIiKSxBPWh0LmVsZW1lbnRUeXBlc1t0XTtyZXR1cm4gdm9pZCAwIT09QT9uZXcgQSh0aGlzLGUpOm5ldyByZSh0aGlzLGUpfWNyZWF0ZVRleHROb2RlKGUpe3JldHVybiBuZXcgcGUodGhpcyxlKX1zZXRWaWV3Qm94KGUpe3RoaXMuc2NyZWVuLnNldFZpZXdCb3goZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIEE9bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fTt0JTI/Y3QoT2JqZWN0KEEpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKHQpeygwLG4uZGVmYXVsdCkoZSx0LEFbdF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhBKSk6Y3QoT2JqZWN0KEEpKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihBLHQpKX0pfXJldHVybiBlfSh7ZG9jdW1lbnQ6dGhpc30sZSkpfX1mdW5jdGlvbiBkdChlLHQpe3ZhciBBPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciByPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKHI9ci5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpLEEucHVzaC5hcHBseShBLHIpfXJldHVybiBBfWZ1bmN0aW9uIGZ0KGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBBPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP2R0KE9iamVjdChBKSwhMCkuZm9yRWFjaChmdW5jdGlvbih0KXsoMCxuLmRlZmF1bHQpKGUsdCxBW3RdKX0pOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoQSkpOmR0KE9iamVjdChBKSkuZm9yRWFjaChmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQSx0KSl9KX1yZXR1cm4gZX1odC5jcmVhdGVDYW52YXM9ZnVuY3Rpb24oZSx0KXt2YXIgQT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKTtyZXR1cm4gQS53aWR0aD1lLEEuaGVpZ2h0PXQsQX0saHQuY3JlYXRlSW1hZ2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHV0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0saHQuZWxlbWVudFR5cGVzPWx0O2NsYXNzIHB0e2NvbnN0cnVjdG9yKGUsdCl7dmFyIEE9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9O3RoaXMucGFyc2VyPW5ldyBxKEEpLHRoaXMuc2NyZWVuPW5ldyBWKGUsQSksdGhpcy5vcHRpb25zPUE7dmFyIHI9bmV3IGh0KHRoaXMsQSksbj1yLmNyZWF0ZURvY3VtZW50RWxlbWVudCh0KTt0aGlzLmRvY3VtZW50PXIsdGhpcy5kb2N1bWVudEVsZW1lbnQ9bn1zdGF0aWMgZnJvbShlLHQpe3ZhciBBPWFyZ3VtZW50cztyZXR1cm4oMCxyLmRlZmF1bHQpKGZ1bmN0aW9uKigpe3ZhciByPUEubGVuZ3RoPjImJnZvaWQgMCE9PUFbMl0/QVsyXTp7fSxuPW5ldyBxKHIpLHM9eWllbGQgbi5wYXJzZSh0KTtyZXR1cm4gbmV3IHB0KGUscyxyKX0pKCl9c3RhdGljIGZyb21TdHJpbmcoZSx0KXt2YXIgQT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30scj1uZXcgcShBKS5wYXJzZUZyb21TdHJpbmcodCk7cmV0dXJuIG5ldyBwdChlLHIsQSl9Zm9yayhlLHQpe3ZhciBBPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fTtyZXR1cm4gcHQuZnJvbShlLHQsZnQoZnQoe30sdGhpcy5vcHRpb25zKSxBKSl9Zm9ya1N0cmluZyhlLHQpe3ZhciBBPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fTtyZXR1cm4gcHQuZnJvbVN0cmluZyhlLHQsZnQoZnQoe30sdGhpcy5vcHRpb25zKSxBKSl9cmVhZHkoKXtyZXR1cm4gdGhpcy5zY3JlZW4ucmVhZHkoKX1pc1JlYWR5KCl7cmV0dXJuIHRoaXMuc2NyZWVuLmlzUmVhZHkoKX1yZW5kZXIoKXt2YXIgZT1hcmd1bWVudHMsdD10aGlzO3JldHVybigwLHIuZGVmYXVsdCkoZnVuY3Rpb24qKCl7dmFyIEE9ZS5sZW5ndGg+MCYmdm9pZCAwIT09ZVswXT9lWzBdOnt9O3Quc3RhcnQoZnQoe2VuYWJsZVJlZHJhdzohMCxpZ25vcmVBbmltYXRpb246ITAsaWdub3JlTW91c2U6ITB9LEEpKSx5aWVsZCB0LnJlYWR5KCksdC5zdG9wKCl9KSgpfXN0YXJ0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LHtkb2N1bWVudEVsZW1lbnQ6dCxzY3JlZW46QSxvcHRpb25zOnJ9PXRoaXM7QS5zdGFydCh0LGZ0KGZ0KHtlbmFibGVSZWRyYXc6ITB9LHIpLGUpKX1zdG9wKCl7dGhpcy5zY3JlZW4uc3RvcCgpfXJlc2l6ZShlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06ZSxBPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07dGhpcy5kb2N1bWVudEVsZW1lbnQucmVzaXplKGUsdCxBKX19fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZy5qcyIpLHM9VHlwZUVycm9yO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtpZihyKGUpKXJldHVybiBlO3Rocm93IG5ldyBzKG4oZSkrIiBpcyBub3QgYSBmdW5jdGlvbiIpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY29uc3RydWN0b3IuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3IuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanMiKSxzPVR5cGVFcnJvcjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYocihlKSlyZXR1cm4gZTt0aHJvdyBuZXcgcyhuKGUpKyIgaXMgbm90IGEgY29uc3RydWN0b3IiKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wb3NzaWJsZS1wcm90b3R5cGUuanMiKSxuPVN0cmluZyxzPVR5cGVFcnJvcjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYocihlKSlyZXR1cm4gZTt0aHJvdyBuZXcgcygiQ2FuJ3Qgc2V0ICIrbihlKSsiIGFzIGEgcHJvdG90eXBlIil9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1zZXQuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWhlbHBlcnMuanMiKS5oYXM7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiByKGUpLGV9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIikuZixpPXIoInVuc2NvcGFibGVzIiksbz1BcnJheS5wcm90b3R5cGU7dm9pZCAwPT09b1tpXSYmcyhvLGkse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTpuKG51bGwpfSksZS5leHBvcnRzPWZ1bmN0aW9uKGUpe29baV1bZV09ITB9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXguanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyIpLmNoYXJBdDtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LEEpe3JldHVybiB0KyhBP3IoZSx0KS5sZW5ndGg6MSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4taW5zdGFuY2UuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qcyIpLG49VHlwZUVycm9yO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe2lmKHIodCxlKSlyZXR1cm4gZTt0aHJvdyBuZXcgbigiSW5jb3JyZWN0IGludm9jYXRpb24iKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiksbj1TdHJpbmcscz1UeXBlRXJyb3I7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2lmKHIoZSkpcmV0dXJuIGU7dGhyb3cgbmV3IHMobihlKSsiIGlzIG5vdCBhbiBvYmplY3QiKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1idWZmZXItbm9uLWV4dGVuc2libGUuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKTtlLmV4cG9ydHM9cihmdW5jdGlvbigpe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBBcnJheUJ1ZmZlcil7dmFyIGU9bmV3IEFycmF5QnVmZmVyKDgpO09iamVjdC5pc0V4dGVuc2libGUoZSkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJhIix7dmFsdWU6OH0pfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2guanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzIikuZm9yRWFjaCxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QuanMiKSgiZm9yRWFjaCIpO2UuZXhwb3J0cz1uP1tdLmZvckVhY2g6ZnVuY3Rpb24oZSl7cmV0dXJuIHIodGhpcyxlLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mcm9tLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZy5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcyIpLHU9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzIiksaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiksZD1BcnJheTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9cyhlKSxBPWEodGhpcyksZj1hcmd1bWVudHMubGVuZ3RoLHA9Zj4xP2FyZ3VtZW50c1sxXTp2b2lkIDAsZz12b2lkIDAhPT1wO2cmJihwPXIocCxmPjI/YXJndW1lbnRzWzJdOnZvaWQgMCkpO3ZhciBtLHcsQix5LHYsYixDPWgodCksXz0wO2lmKCFDfHx0aGlzPT09ZCYmbyhDKSlmb3IobT1sKHQpLHc9QT9uZXcgdGhpcyhtKTpkKG0pO20+XztfKyspYj1nP3AodFtfXSxfKTp0W19dLGModyxfLGIpO2Vsc2UgZm9yKHc9QT9uZXcgdGhpczpbXSx2PSh5PXUodCxDKSkubmV4dDshKEI9bih2LHkpKS5kb25lO18rKyliPWc/aSh5LHAsW0IudmFsdWUsX10sITApOkIudmFsdWUsYyh3LF8sYik7cmV0dXJuIHcubGVuZ3RoPV8sd319LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzIiksaT1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxBLGkpe3ZhciBvPXIodCksYT1zKG8pO2lmKDA9PT1hKXJldHVybiFlJiYtMTt2YXIgbCxjPW4oaSxhKTtpZihlJiZBIT1BKXtmb3IoO2E+YzspaWYoKGw9b1tjKytdKSE9bClyZXR1cm4hMH1lbHNlIGZvcig7YT5jO2MrKylpZigoZXx8YyBpbiBvKSYmb1tjXT09PUEpcmV0dXJuIGV8fGN8fDA7cmV0dXJuIWUmJi0xfX07ZS5leHBvcnRzPXtpbmNsdWRlczppKCEwKSxpbmRleE9mOmkoITEpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiksbD1uKFtdLnB1c2gpLGM9ZnVuY3Rpb24oZSl7dmFyIHQ9MT09PWUsQT0yPT09ZSxuPTM9PT1lLGM9ND09PWUsdT02PT09ZSxoPTc9PT1lLGQ9NT09PWV8fHU7cmV0dXJuIGZ1bmN0aW9uKGYscCxnLG0pe2Zvcih2YXIgdyxCLHk9aShmKSx2PXMoeSksYj1vKHYpLEM9cihwLGcpLF89MCxqPW18fGEseD10P2ooZixiKTpBfHxoP2ooZiwwKTp2b2lkIDA7Yj5fO18rKylpZigoZHx8XyBpbiB2KSYmKEI9Qyh3PXZbX10sXyx5KSxlKSlpZih0KXhbX109QjtlbHNlIGlmKEIpc3dpdGNoKGUpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIHc7Y2FzZSA2OnJldHVybiBfO2Nhc2UgMjpsKHgsdyl9ZWxzZSBzd2l0Y2goZSl7Y2FzZSA0OnJldHVybiExO2Nhc2UgNzpsKHgsdyl9cmV0dXJuIHU/LTE6bnx8Yz9jOnh9fTtlLmV4cG9ydHM9e2ZvckVhY2g6YygwKSxtYXA6YygxKSxmaWx0ZXI6YygyKSxzb21lOmMoMyksZXZlcnk6Yyg0KSxmaW5kOmMoNSksZmluZEluZGV4OmMoNiksZmlsdGVyUmVqZWN0OmMoNyl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uLmpzIiksaT1uKCJzcGVjaWVzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBzPj01MXx8IXIoZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4odC5jb25zdHJ1Y3Rvcj17fSlbaV09ZnVuY3Rpb24oKXtyZXR1cm57Zm9vOjF9fSwxIT09dFtlXShCb29sZWFuKS5mb299KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIEE9W11bZV07cmV0dXJuISFBJiZyKGZ1bmN0aW9uKCl7QS5jYWxsKG51bGwsdHx8ZnVuY3Rpb24oKXtyZXR1cm4gMX0sMSl9KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1yZWR1Y2UuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UuanMiKSxvPVR5cGVFcnJvcixhPSJSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlIixsPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LEEsbCxjKXt2YXIgdT1uKHQpLGg9cyh1KSxkPWkodSk7aWYocihBKSwwPT09ZCYmbDwyKXRocm93IG5ldyBvKGEpO3ZhciBmPWU/ZC0xOjAscD1lPy0xOjE7aWYobDwyKWZvcig7Oyl7aWYoZiBpbiBoKXtjPWhbZl0sZis9cDticmVha31pZihmKz1wLGU/ZjwwOmQ8PWYpdGhyb3cgbmV3IG8oYSl9Zm9yKDtlP2Y+PTA6ZD5mO2YrPXApZiBpbiBoJiYoYz1BKGMsaFtmXSxmLHUpKTtyZXR1cm4gY319O2UuZXhwb3J0cz17bGVmdDpsKCExKSxyaWdodDpsKCEwKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zbGljZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKTtlLmV4cG9ydHM9cihbXS5zbGljZSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIpKCJzcGVjaWVzIiksbz1BcnJheTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIHIoZSkmJih0PWUuY29uc3RydWN0b3IsKG4odCkmJih0PT09b3x8cih0LnByb3RvdHlwZSkpfHxzKHQpJiZudWxsPT09KHQ9dFtpXSkpJiYodD12b2lkIDApKSx2b2lkIDA9PT10P286dH19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyhyKGUpKSgwPT09dD8wOnQpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LEEscyl7dHJ5e3JldHVybiBzP3QocihBKVswXSxBWzFdKTp0KEEpfWNhdGNoKHQpe24oZSwidGhyb3ciLHQpfX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiKSgiaXRlcmF0b3IiKSxuPSExO3RyeXt2YXIgcz0wLGk9e25leHQ6ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTohIXMrK319LHJldHVybjpmdW5jdGlvbigpe249ITB9fTtpW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LEFycmF5LmZyb20oaSxmdW5jdGlvbigpe3Rocm93IDJ9KX1jYXRjaChlKXt9ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dHJ5e2lmKCF0JiYhbilyZXR1cm4hMX1jYXRjaChlKXtyZXR1cm4hMX12YXIgQT0hMTt0cnl7dmFyIHM9e307c1tyXT1mdW5jdGlvbigpe3JldHVybntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6QT0hMH19fX0sZShzKX1jYXRjaChlKXt9cmV0dXJuIEF9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiksbj1yKHt9LnRvU3RyaW5nKSxzPXIoIiIuc2xpY2UpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gcyhuKGUpLDgsLTEpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIikoInRvU3RyaW5nVGFnIiksbz1PYmplY3QsYT0iQXJndW1lbnRzIj09PXMoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKTtlLmV4cG9ydHM9cj9zOmZ1bmN0aW9uKGUpe3ZhciB0LEEscjtyZXR1cm4gdm9pZCAwPT09ZT8iVW5kZWZpbmVkIjpudWxsPT09ZT8iTnVsbCI6InN0cmluZyI9PXR5cGVvZihBPWZ1bmN0aW9uKGUsdCl7dHJ5e3JldHVybiBlW3RdfWNhdGNoKGUpe319KHQ9byhlKSxpKSk/QTphP3ModCk6Ik9iamVjdCI9PT0ocj1zKHQpKSYmbih0LmNhbGxlZSk/IkFyZ3VtZW50cyI6cn19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3IuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4taW5zdGFuY2UuanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUuanMiKSx1PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1pdGVyLXJlc3VsdC1vYmplY3QuanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1zcGVjaWVzLmpzIiksZD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyIpLGY9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanMiKS5mYXN0S2V5LHA9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiKSxnPXAuc2V0LG09cC5nZXR0ZXJGb3I7ZS5leHBvcnRzPXtnZXRDb25zdHJ1Y3RvcjpmdW5jdGlvbihlLHQsQSxjKXt2YXIgdT1lKGZ1bmN0aW9uKGUsbil7byhlLGgpLGcoZSx7dHlwZTp0LGluZGV4OnIobnVsbCksZmlyc3Q6bnVsbCxsYXN0Om51bGwsc2l6ZTowfSksZHx8KGUuc2l6ZT0wKSxhKG4pfHxsKG4sZVtjXSx7dGhhdDplLEFTX0VOVFJJRVM6QX0pfSksaD11LnByb3RvdHlwZSxwPW0odCksdz1mdW5jdGlvbihlLHQsQSl7dmFyIHIsbixzPXAoZSksaT1CKGUsdCk7cmV0dXJuIGk/aS52YWx1ZT1BOihzLmxhc3Q9aT17aW5kZXg6bj1mKHQsITApLGtleTp0LHZhbHVlOkEscHJldmlvdXM6cj1zLmxhc3QsbmV4dDpudWxsLHJlbW92ZWQ6ITF9LHMuZmlyc3R8fChzLmZpcnN0PWkpLHImJihyLm5leHQ9aSksZD9zLnNpemUrKzplLnNpemUrKywiRiIhPT1uJiYocy5pbmRleFtuXT1pKSksZX0sQj1mdW5jdGlvbihlLHQpe3ZhciBBLHI9cChlKSxuPWYodCk7aWYoIkYiIT09bilyZXR1cm4gci5pbmRleFtuXTtmb3IoQT1yLmZpcnN0O0E7QT1BLm5leHQpaWYoQS5rZXk9PT10KXJldHVybiBBfTtyZXR1cm4gcyhoLHtjbGVhcjpmdW5jdGlvbigpe2Zvcih2YXIgZT1wKHRoaXMpLHQ9ZS5maXJzdDt0Oyl0LnJlbW92ZWQ9ITAsdC5wcmV2aW91cyYmKHQucHJldmlvdXM9dC5wcmV2aW91cy5uZXh0PW51bGwpLHQ9dC5uZXh0O2UuZmlyc3Q9ZS5sYXN0PW51bGwsZS5pbmRleD1yKG51bGwpLGQ/ZS5zaXplPTA6dGhpcy5zaXplPTB9LGRlbGV0ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLEE9cCh0KSxyPUIodCxlKTtpZihyKXt2YXIgbj1yLm5leHQscz1yLnByZXZpb3VzO2RlbGV0ZSBBLmluZGV4W3IuaW5kZXhdLHIucmVtb3ZlZD0hMCxzJiYocy5uZXh0PW4pLG4mJihuLnByZXZpb3VzPXMpLEEuZmlyc3Q9PT1yJiYoQS5maXJzdD1uKSxBLmxhc3Q9PT1yJiYoQS5sYXN0PXMpLGQ/QS5zaXplLS06dC5zaXplLS19cmV0dXJuISFyfSxmb3JFYWNoOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxBPXAodGhpcykscj1pKGUsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApO3Q9dD90Lm5leHQ6QS5maXJzdDspZm9yKHIodC52YWx1ZSx0LmtleSx0aGlzKTt0JiZ0LnJlbW92ZWQ7KXQ9dC5wcmV2aW91c30saGFzOmZ1bmN0aW9uKGUpe3JldHVybiEhQih0aGlzLGUpfX0pLHMoaCxBP3tnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9Qih0aGlzLGUpO3JldHVybiB0JiZ0LnZhbHVlfSxzZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdyh0aGlzLDA9PT1lPzA6ZSx0KX19OnthZGQ6ZnVuY3Rpb24oZSl7cmV0dXJuIHcodGhpcyxlPTA9PT1lPzA6ZSxlKX19KSxkJiZuKGgsInNpemUiLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHAodGhpcykuc2l6ZX19KSx1fSxzZXRTdHJvbmc6ZnVuY3Rpb24oZSx0LEEpe3ZhciByPXQrIiBJdGVyYXRvciIsbj1tKHQpLHM9bShyKTtjKGUsdCxmdW5jdGlvbihlLHQpe2codGhpcyx7dHlwZTpyLHRhcmdldDplLHN0YXRlOm4oZSksa2luZDp0LGxhc3Q6bnVsbH0pfSxmdW5jdGlvbigpe2Zvcih2YXIgZT1zKHRoaXMpLHQ9ZS5raW5kLEE9ZS5sYXN0O0EmJkEucmVtb3ZlZDspQT1BLnByZXZpb3VzO3JldHVybiBlLnRhcmdldCYmKGUubGFzdD1BPUE/QS5uZXh0OmUuc3RhdGUuZmlyc3QpP3UoImtleXMiPT09dD9BLmtleToidmFsdWVzIj09PXQ/QS52YWx1ZTpbQS5rZXksQS52YWx1ZV0sITEpOihlLnRhcmdldD1udWxsLHUodm9pZCAwLCEwKSl9LEE/ImVudHJpZXMiOiJ2YWx1ZXMiLCFBLCEwKSxoKHQpfX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhLmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyIpLHU9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzIiksZD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiKSxmPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIikscD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMiKSxnPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzIiksbT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxBKXt2YXIgdz0tMSE9PWUuaW5kZXhPZigiTWFwIiksQj0tMSE9PWUuaW5kZXhPZigiV2VhayIpLHk9dz8ic2V0IjoiYWRkIix2PW5bZV0sYj12JiZ2LnByb3RvdHlwZSxDPXYsXz17fSxqPWZ1bmN0aW9uKGUpe3ZhciB0PXMoYltlXSk7byhiLGUsImFkZCI9PT1lP2Z1bmN0aW9uKGUpe3JldHVybiB0KHRoaXMsMD09PWU/MDplKSx0aGlzfToiZGVsZXRlIj09PWU/ZnVuY3Rpb24oZSl7cmV0dXJuIShCJiYhZChlKSkmJnQodGhpcywwPT09ZT8wOmUpfToiZ2V0Ij09PWU/ZnVuY3Rpb24oZSl7cmV0dXJuIEImJiFkKGUpP3ZvaWQgMDp0KHRoaXMsMD09PWU/MDplKX06ImhhcyI9PT1lP2Z1bmN0aW9uKGUpe3JldHVybiEoQiYmIWQoZSkpJiZ0KHRoaXMsMD09PWU/MDplKX06ZnVuY3Rpb24oZSxBKXtyZXR1cm4gdCh0aGlzLDA9PT1lPzA6ZSxBKSx0aGlzfSl9O2lmKGkoZSwhdSh2KXx8IShCfHxiLmZvckVhY2gmJiFmKGZ1bmN0aW9uKCl7KG5ldyB2KS5lbnRyaWVzKCkubmV4dCgpfSkpKSlDPUEuZ2V0Q29uc3RydWN0b3IodCxlLHcseSksYS5lbmFibGUoKTtlbHNlIGlmKGkoZSwhMCkpe3ZhciB4PW5ldyBDLEY9eFt5XShCP3t9Oi0wLDEpIT09eCxRPWYoZnVuY3Rpb24oKXt4LmhhcygxKX0pLFU9cChmdW5jdGlvbihlKXtuZXcgdihlKX0pLEU9IUImJmYoZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IHYsdD01O3QtLTspZVt5XSh0LHQpO3JldHVybiFlLmhhcygtMCl9KTtVfHwoKEM9dChmdW5jdGlvbihlLHQpe2MoZSxiKTt2YXIgQT1tKG5ldyB2LGUsQyk7cmV0dXJuIGgodCl8fGwodCxBW3ldLHt0aGF0OkEsQVNfRU5UUklFUzp3fSksQX0pKS5wcm90b3R5cGU9YixiLmNvbnN0cnVjdG9yPUMpLChRfHxFKSYmKGooImRlbGV0ZSIpLGooImhhcyIpLHcmJmooImdldCIpKSwoRXx8RikmJmooeSksQiYmYi5jbGVhciYmZGVsZXRlIGIuY2xlYXJ9cmV0dXJuIF9bZV09QyxyKHtnbG9iYWw6ITAsY29uc3RydWN0b3I6ITAsZm9yY2VkOkMhPT12fSxfKSxnKEMsZSksQnx8QS5zZXRTdHJvbmcoQyxlLHcpLEN9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxBKXtmb3IodmFyIG89bih0KSxhPWkuZixsPXMuZixjPTA7YzxvLmxlbmd0aDtjKyspe3ZhciB1PW9bY107cihlLHUpfHxBJiZyKEEsdSl8fGEoZSx1LGwodCx1KSl9fX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtaXMtcmVnZXhwLWxvZ2ljLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIikoIm1hdGNoIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PS8uLzt0cnl7Ii8uLyJbZV0odCl9Y2F0Y2goQSl7dHJ5e3JldHVybiB0W3JdPSExLCIvLi8iW2VdKHQpfWNhdGNoKGUpe319cmV0dXJuITF9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIik7ZS5leHBvcnRzPSFyKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUuY29uc3RydWN0b3I9bnVsbCxPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IGUpIT09ZS5wcm90b3R5cGV9KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1odG1sLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMiKSxpPS8iL2csbz1yKCIiLnJlcGxhY2UpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsQSxyKXt2YXIgYT1zKG4oZSkpLGw9IjwiK3Q7cmV0dXJuIiIhPT1BJiYobCs9IiAiK0ErJz0iJytvKHMociksaSwiJnF1b3Q7IikrJyInKSxsKyI+IithKyI8LyIrdCsiPiJ9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qcyI6ZnVuY3Rpb24oZSl7InVzZSBzdHJpY3QiO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3JldHVybnt2YWx1ZTplLGRvbmU6dH19fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIpO2UuZXhwb3J0cz1yP2Z1bmN0aW9uKGUsdCxBKXtyZXR1cm4gbi5mKGUsdCxzKDEsQSkpfTpmdW5jdGlvbihlLHQsQSl7cmV0dXJuIGVbdF09QSxlfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIjpmdW5jdGlvbihlKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7cmV0dXJue2VudW1lcmFibGU6ISgxJmUpLGNvbmZpZ3VyYWJsZTohKDImZSksd3JpdGFibGU6ISg0JmUpLHZhbHVlOnR9fX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LEEpe3I/bi5mKGUsdCxzKDAsQSkpOmVbdF09QX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3IuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbi5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIEEuZ2V0JiZyKEEuZ2V0LHQse2dldHRlcjohMH0pLEEuc2V0JiZyKEEuc2V0LHQse3NldHRlcjohMH0pLG4uZihlLHQsQSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYWtlLWJ1aWx0LWluLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5LmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxBLG8pe298fChvPXt9KTt2YXIgYT1vLmVudW1lcmFibGUsbD12b2lkIDAhPT1vLm5hbWU/by5uYW1lOnQ7aWYocihBKSYmcyhBLGwsbyksby5nbG9iYWwpYT9lW3RdPUE6aSh0LEEpO2Vsc2V7dHJ5e28udW5zYWZlP2VbdF0mJihhPSEwKTpkZWxldGUgZVt0XX1jYXRjaChlKXt9YT9lW3RdPUE6bi5mKGUsdCx7dmFsdWU6QSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohby5ub25Db25maWd1cmFibGUsd3JpdGFibGU6IW8ubm9uV3JpdGFibGV9KX1yZXR1cm4gZX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcyIpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsQSl7Zm9yKHZhciBuIGluIHQpcihlLG4sdFtuXSxBKTtyZXR1cm4gZX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIiksbj1PYmplY3QuZGVmaW5lUHJvcGVydHk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dHJ5e24ocixlLHt2YWx1ZTp0LGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pfWNhdGNoKEEpe3JbZV09dH1yZXR1cm4gdH19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpO2UuZXhwb3J0cz0hcihmdW5jdGlvbigpe3JldHVybiA3IT09T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LDEse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pWzFdfSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIikscz1yLmRvY3VtZW50LGk9bihzKSYmbihzLmNyZWF0ZUVsZW1lbnQpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gaT9zLmNyZWF0ZUVsZW1lbnQoZSk6e319fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlci5qcyI6ZnVuY3Rpb24oZSl7InVzZSBzdHJpY3QiO3ZhciB0PVR5cGVFcnJvcjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoZT45MDA3MTk5MjU0NzQwOTkxKXRocm93IHQoIk1heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCIpO3JldHVybiBlfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMuanMiOmZ1bmN0aW9uKGUpeyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9e0NTU1J1bGVMaXN0OjAsQ1NTU3R5bGVEZWNsYXJhdGlvbjowLENTU1ZhbHVlTGlzdDowLENsaWVudFJlY3RMaXN0OjAsRE9NUmVjdExpc3Q6MCxET01TdHJpbmdMaXN0OjAsRE9NVG9rZW5MaXN0OjEsRGF0YVRyYW5zZmVySXRlbUxpc3Q6MCxGaWxlTGlzdDowLEhUTUxBbGxDb2xsZWN0aW9uOjAsSFRNTENvbGxlY3Rpb246MCxIVE1MRm9ybUVsZW1lbnQ6MCxIVE1MU2VsZWN0RWxlbWVudDowLE1lZGlhTGlzdDowLE1pbWVUeXBlQXJyYXk6MCxOYW1lZE5vZGVNYXA6MCxOb2RlTGlzdDoxLFBhaW50UmVxdWVzdExpc3Q6MCxQbHVnaW46MCxQbHVnaW5BcnJheTowLFNWR0xlbmd0aExpc3Q6MCxTVkdOdW1iZXJMaXN0OjAsU1ZHUGF0aFNlZ0xpc3Q6MCxTVkdQb2ludExpc3Q6MCxTVkdTdHJpbmdMaXN0OjAsU1ZHVHJhbnNmb3JtTGlzdDowLFNvdXJjZUJ1ZmZlckxpc3Q6MCxTdHlsZVNoZWV0TGlzdDowLFRleHRUcmFja0N1ZUxpc3Q6MCxUZXh0VHJhY2tMaXN0OjAsVG91Y2hMaXN0OjB9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9tLXRva2VuLWxpc3QtcHJvdG90eXBlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIikoInNwYW4iKS5jbGFzc0xpc3Qsbj1yJiZyLmNvbnN0cnVjdG9yJiZyLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtlLmV4cG9ydHM9bj09PU9iamVjdC5wcm90b3R5cGU/dm9pZCAwOm59LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIjpmdW5jdGlvbihlKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPVsiY29uc3RydWN0b3IiLCJoYXNPd25Qcm9wZXJ0eSIsImlzUHJvdG90eXBlT2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvTG9jYWxlU3RyaW5nIiwidG9TdHJpbmciLCJ2YWx1ZU9mIl19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC1pcy1pb3MtcGViYmxlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LXVzZXItYWdlbnQuanMiKTtlLmV4cG9ydHM9L2lwYWR8aXBob25lfGlwb2QvaS50ZXN0KHIpJiYidW5kZWZpbmVkIiE9dHlwZW9mIFBlYmJsZX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LWlzLWlvcy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC11c2VyLWFnZW50LmpzIik7ZS5leHBvcnRzPS8oPzppcGFkfGlwaG9uZXxpcG9kKS4qYXBwbGV3ZWJraXQvaS50ZXN0KHIpfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQtaXMtbm9kZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC5qcyIpO2UuZXhwb3J0cz0iTk9ERSI9PT1yfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQtaXMtd2Vib3Mtd2Via2l0LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LXVzZXItYWdlbnQuanMiKTtlLmV4cG9ydHM9L3dlYjBzKD8hLipjaHJvbWUpL2kudGVzdChyKX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LXVzZXItYWdlbnQuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiKS5uYXZpZ2F0b3Isbj1yJiZyLnVzZXJBZ2VudDtlLmV4cG9ydHM9bj9TdHJpbmcobik6IiJ9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByLG4scz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdXNlci1hZ2VudC5qcyIpLG89cy5wcm9jZXNzLGE9cy5EZW5vLGw9byYmby52ZXJzaW9uc3x8YSYmYS52ZXJzaW9uLGM9bCYmbC52ODtjJiYobj0ocj1jLnNwbGl0KCIuIikpWzBdPjAmJnJbMF08ND8xOisoclswXStyWzFdKSksIW4mJmkmJighKHI9aS5tYXRjaCgvRWRnZVwvKFxkKykvKSl8fHJbMV0+PTc0KSYmKHI9aS5tYXRjaCgvQ2hyb21lXC8oXGQrKS8pKSYmKG49K3JbMV0pLGUuZXhwb3J0cz1ufSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LXVzZXItYWdlbnQuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzIiksaT1mdW5jdGlvbihlKXtyZXR1cm4gbi5zbGljZSgwLGUubGVuZ3RoKT09PWV9O2UuZXhwb3J0cz1pKCJCdW4vIik/IkJVTiI6aSgiQ2xvdWRmbGFyZS1Xb3JrZXJzIik/IkNMT1VERkxBUkUiOmkoIkRlbm8vIik/IkRFTk8iOmkoIk5vZGUuanMvIik/Ik5PREUiOnIuQnVuJiYic3RyaW5nIj09dHlwZW9mIEJ1bi52ZXJzaW9uPyJCVU4iOnIuRGVubyYmIm9iamVjdCI9PXR5cGVvZiBEZW5vLnZlcnNpb24/IkRFTk8iOiJwcm9jZXNzIj09PXMoci5wcm9jZXNzKT8iTk9ERSI6ci53aW5kb3cmJnIuZG9jdW1lbnQ/IkJST1dTRVIiOiJSRVNUIn0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIpLmYscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eS5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgQSxjLHUsaCxkLGY9ZS50YXJnZXQscD1lLmdsb2JhbCxnPWUuc3RhdDtpZihBPXA/cjpnP3JbZl18fG8oZix7fSk6cltmXSYmcltmXS5wcm90b3R5cGUpZm9yKGMgaW4gdCl7aWYoaD10W2NdLHU9ZS5kb250Q2FsbEdldFNldD8oZD1uKEEsYykpJiZkLnZhbHVlOkFbY10sIWwocD9jOmYrKGc/Ii4iOiIjIikrYyxlLmZvcmNlZCkmJnZvaWQgMCE9PXUpe2lmKHR5cGVvZiBoPT10eXBlb2YgdSljb250aW51ZTthKGgsdSl9KGUuc2hhbXx8dSYmdS5zaGFtKSYmcyhoLCJzaGFtIiwhMCksaShBLGMsaCxlKX19fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiOmZ1bmN0aW9uKGUpeyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiEhZSgpfWNhdGNoKGUpe3JldHVybiEwfX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0EoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyIpO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIiksbD1vKCJzcGVjaWVzIiksYz1SZWdFeHAucHJvdG90eXBlO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsQSx1KXt2YXIgaD1vKGUpLGQ9IWkoZnVuY3Rpb24oKXt2YXIgdD17fTtyZXR1cm4gdFtoXT1mdW5jdGlvbigpe3JldHVybiA3fSw3IT09IiJbZV0odCl9KSxmPWQmJiFpKGZ1bmN0aW9uKCl7dmFyIHQ9ITEsQT0vYS87cmV0dXJuInNwbGl0Ij09PWUmJigoQT17fSkuY29uc3RydWN0b3I9e30sQS5jb25zdHJ1Y3RvcltsXT1mdW5jdGlvbigpe3JldHVybiBBfSxBLmZsYWdzPSIiLEFbaF09Ly4vW2hdKSxBLmV4ZWM9ZnVuY3Rpb24oKXtyZXR1cm4gdD0hMCxudWxsfSxBW2hdKCIiKSwhdH0pO2lmKCFkfHwhZnx8QSl7dmFyIHA9Ly4vW2hdLGc9dChoLCIiW2VdLGZ1bmN0aW9uKGUsdCxBLG4saSl7dmFyIG89dC5leGVjO3JldHVybiBvPT09c3x8bz09PWMuZXhlYz9kJiYhaT97ZG9uZTohMCx2YWx1ZTpyKHAsdCxBLG4pfTp7ZG9uZTohMCx2YWx1ZTpyKGUsQSx0LG4pfTp7ZG9uZTohMX19KTtuKFN0cmluZy5wcm90b3R5cGUsZSxnWzBdKSxuKGMsaCxnWzFdKX11JiZhKGNbaF0sInNoYW0iLCEwKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpO2UuZXhwb3J0cz0hcihmdW5jdGlvbigpe3JldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpfSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1hcHBseS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qcyIpLG49RnVuY3Rpb24ucHJvdG90eXBlLHM9bi5hcHBseSxpPW4uY2FsbDtlLmV4cG9ydHM9Im9iamVjdCI9PXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0LmFwcGx5fHwocj9pLmJpbmQocyk6ZnVuY3Rpb24oKXtyZXR1cm4gaS5hcHBseShzLGFyZ3VtZW50cyl9KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtY2xhdXNlLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qcyIpLGk9cihyLmJpbmQpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3JldHVybiBuKGUpLHZvaWQgMD09PXQ/ZTpzP2koZSx0KTpmdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHQsYXJndW1lbnRzKX19fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKTtlLmV4cG9ydHM9IXIoZnVuY3Rpb24oKXt2YXIgZT1mdW5jdGlvbigpe30uYmluZCgpO3JldHVybiJmdW5jdGlvbiIhPXR5cGVvZiBlfHxlLmhhc093blByb3BlcnR5KCJwcm90b3R5cGUiKX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZS5qcyIpLG49RnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7ZS5leHBvcnRzPXI/bi5iaW5kKG4pOmZ1bmN0aW9uKCl7cmV0dXJuIG4uYXBwbHkobixhcmd1bWVudHMpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiKSxzPUZ1bmN0aW9uLnByb3RvdHlwZSxpPXImJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Isbz1uKHMsIm5hbWUiKSxhPW8mJiJzb21ldGhpbmciPT09ZnVuY3Rpb24oKXt9Lm5hbWUsbD1vJiYoIXJ8fHImJmkocywibmFtZSIpLmNvbmZpZ3VyYWJsZSk7ZS5leHBvcnRzPXtFWElTVFM6byxQUk9QRVI6YSxDT05GSUdVUkFCTEU6bH19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtYWNjZXNzb3IuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxBKXt0cnl7cmV0dXJuIHIobihPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdClbQV0pKX1jYXRjaChlKXt9fX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1jbGF1c2UuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtpZigiRnVuY3Rpb24iPT09cihlKSlyZXR1cm4gbihlKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanMiKSxuPUZ1bmN0aW9uLnByb3RvdHlwZSxzPW4uY2FsbCxpPXImJm4uYmluZC5iaW5kKHMscyk7ZS5leHBvcnRzPXI/aTpmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gcy5hcHBseShlLGFyZ3VtZW50cyl9fX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aDwyPyhBPXJbZV0sbihBKT9BOnZvaWQgMCk6cltlXSYmcltlXVt0XTt2YXIgQX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItZGlyZWN0LmpzIjpmdW5jdGlvbihlKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybntpdGVyYXRvcjplLG5leHQ6ZS5uZXh0LGRvbmU6ITF9fX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiKSgiaXRlcmF0b3IiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoIXMoZSkpcmV0dXJuIG4oZSxvKXx8bihlLCJAQGl0ZXJhdG9yIil8fGlbcihlKV19fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZy5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIpLGE9VHlwZUVycm9yO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3ZhciBBPWFyZ3VtZW50cy5sZW5ndGg8Mj9vKGUpOnQ7aWYobihBKSlyZXR1cm4gcyhyKEEsZSkpO3Rocm93IG5ldyBhKGkoZSkrIiBpcyBub3QgaXRlcmFibGUiKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtanNvbi1yZXBsYWNlci1mdW5jdGlvbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIpLGE9cihbXS5wdXNoKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYocyhlKSlyZXR1cm4gZTtpZihuKGUpKXtmb3IodmFyIHQ9ZS5sZW5ndGgsQT1bXSxyPTA7cjx0O3IrKyl7dmFyIGw9ZVtyXTsic3RyaW5nIj09dHlwZW9mIGw/YShBLGwpOiJudW1iZXIiIT10eXBlb2YgbCYmIk51bWJlciIhPT1pKGwpJiYiU3RyaW5nIiE9PWkobCl8fGEoQSxvKGwpKX12YXIgYz1BLmxlbmd0aCx1PSEwO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKHUpcmV0dXJuIHU9ITEsdDtpZihuKHRoaXMpKXJldHVybiB0O2Zvcih2YXIgcj0wO3I8YztyKyspaWYoQVtyXT09PWUpcmV0dXJuIHR9fX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtbWV0aG9kLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIEE9ZVt0XTtyZXR1cm4gbihBKT92b2lkIDA6cihBKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtc2V0LXJlY29yZC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHkuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1kaXJlY3QuanMiKSxhPSJJbnZhbGlkIHNpemUiLGw9UmFuZ2VFcnJvcixjPVR5cGVFcnJvcix1PU1hdGgubWF4LGg9ZnVuY3Rpb24oZSx0KXt0aGlzLnNldD1lLHRoaXMuc2l6ZT11KHQsMCksdGhpcy5oYXM9cihlLmhhcyksdGhpcy5rZXlzPXIoZS5rZXlzKX07aC5wcm90b3R5cGU9e2dldEl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIG8obihzKHRoaXMua2V5cyx0aGlzLnNldCkpKX0saW5jbHVkZXM6ZnVuY3Rpb24oZSl7cmV0dXJuIHModGhpcy5oYXMsdGhpcy5zZXQsZSl9fSxlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7bihlKTt2YXIgdD0rZS5zaXplO2lmKHQhPXQpdGhyb3cgbmV3IGMoYSk7dmFyIEE9aSh0KTtpZihBPDApdGhyb3cgbmV3IGwoYSk7cmV0dXJuIG5ldyBoKGUsQSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LXN1YnN0aXR1dGlvbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIpLHM9TWF0aC5mbG9vcixpPXIoIiIuY2hhckF0KSxvPXIoIiIucmVwbGFjZSksYT1yKCIiLnNsaWNlKSxsPS9cJChbJCYnYF18XGR7MSwyfXw8W14+XSo+KS9nLGM9L1wkKFskJidgXXxcZHsxLDJ9KS9nO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsQSxyLHUsaCl7dmFyIGQ9QStlLmxlbmd0aCxmPXIubGVuZ3RoLHA9YztyZXR1cm4gdm9pZCAwIT09dSYmKHU9bih1KSxwPWwpLG8oaCxwLGZ1bmN0aW9uKG4sbyl7dmFyIGw7c3dpdGNoKGkobywwKSl7Y2FzZSIkIjpyZXR1cm4iJCI7Y2FzZSImIjpyZXR1cm4gZTtjYXNlImAiOnJldHVybiBhKHQsMCxBKTtjYXNlIiciOnJldHVybiBhKHQsZCk7Y2FzZSI8IjpsPXVbYShvLDEsLTEpXTticmVhaztkZWZhdWx0OnZhciBjPStvO2lmKDA9PT1jKXJldHVybiBuO2lmKGM+Zil7dmFyIGg9cyhjLzEwKTtyZXR1cm4gMD09PWg/bjpoPD1mP3ZvaWQgMD09PXJbaC0xXT9pKG8sMSk6cltoLTFdK2kobywxKTpufWw9cltjLTFdfXJldHVybiB2b2lkIDA9PT1sPyIiOmx9KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyI6ZnVuY3Rpb24oZSl7InVzZSBzdHJpY3QiO3ZhciB0PWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLk1hdGg9PT1NYXRoJiZlfTtlLmV4cG9ydHM9dCgib2JqZWN0Ij09dHlwZW9mIGdsb2JhbFRoaXMmJmdsb2JhbFRoaXMpfHx0KCJvYmplY3QiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cpfHx0KCJvYmplY3QiPT10eXBlb2Ygc2VsZiYmc2VsZil8fHQoIm9iamVjdCI9PXR5cGVvZiBnbG9iYWwmJmdsb2JhbCl8fHQoIm9iamVjdCI9PXR5cGVvZiB0aGlzJiZ0aGlzKXx8ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKXx8RnVuY3Rpb24oInJldHVybiB0aGlzIikoKX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanMiKSxzPXIoe30uaGFzT3duUHJvcGVydHkpO2UuZXhwb3J0cz1PYmplY3QuaGFzT3dufHxmdW5jdGlvbihlLHQpe3JldHVybiBzKG4oZSksdCl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiOmZ1bmN0aW9uKGUpeyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9e319LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9ob3N0LXJlcG9ydC1lcnJvcnMuanMiOmZ1bmN0aW9uKGUpeyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt0cnl7MT09PWFyZ3VtZW50cy5sZW5ndGg/Y29uc29sZS5lcnJvcihlKTpjb25zb2xlLmVycm9yKGUsdCl9Y2F0Y2goZSl7fX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIpO2UuZXhwb3J0cz1yKCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIpfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qcyIpO2UuZXhwb3J0cz0hciYmIW4oZnVuY3Rpb24oKXtyZXR1cm4gNyE9PU9iamVjdC5kZWZpbmVQcm9wZXJ0eShzKCJkaXYiKSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmF9KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzIiksaT1PYmplY3Qsbz1yKCIiLnNwbGl0KTtlLmV4cG9ydHM9bihmdW5jdGlvbigpe3JldHVybiFpKCJ6IikucHJvcGVydHlJc0VudW1lcmFibGUoMCl9KT9mdW5jdGlvbihlKXtyZXR1cm4iU3RyaW5nIj09PXMoZSk/byhlLCIiKTppKGUpfTppfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyIpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsQSl7dmFyIGksbztyZXR1cm4gcyYmcihpPXQuY29uc3RydWN0b3IpJiZpIT09QSYmbihvPWkucHJvdG90eXBlKSYmbyE9PUEucHJvdG90eXBlJiZzKGUsbyksZX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiKSxpPXIoRnVuY3Rpb24udG9TdHJpbmcpO24ocy5pbnNwZWN0U291cmNlKXx8KHMuaW5zcGVjdFNvdXJjZT1mdW5jdGlvbihlKXtyZXR1cm4gaShlKX0pLGUuZXhwb3J0cz1zLmluc3BlY3RTb3VyY2V9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIpLmYsbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMiKSx1PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1leHRlbnNpYmxlLmpzIiksaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiKSxkPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZyZWV6aW5nLmpzIiksZj0hMSxwPWgoIm1ldGEiKSxnPTAsbT1mdW5jdGlvbihlKXthKGUscCx7dmFsdWU6e29iamVjdElEOiJPIitnKyssd2Vha0RhdGE6e319fSl9LHc9ZS5leHBvcnRzPXtlbmFibGU6ZnVuY3Rpb24oKXt3LmVuYWJsZT1mdW5jdGlvbigpe30sZj0hMDt2YXIgZT1sLmYsdD1uKFtdLnNwbGljZSksQT17fTtBW3BdPTEsZShBKS5sZW5ndGgmJihsLmY9ZnVuY3Rpb24oQSl7Zm9yKHZhciByPWUoQSksbj0wLHM9ci5sZW5ndGg7bjxzO24rKylpZihyW25dPT09cCl7dChyLG4sMSk7YnJlYWt9cmV0dXJuIHJ9LHIoe3RhcmdldDoiT2JqZWN0IixzdGF0OiEwLGZvcmNlZDohMH0se2dldE93blByb3BlcnR5TmFtZXM6Yy5mfSkpfSxmYXN0S2V5OmZ1bmN0aW9uKGUsdCl7aWYoIWkoZSkpcmV0dXJuInN5bWJvbCI9PXR5cGVvZiBlP2U6KCJzdHJpbmciPT10eXBlb2YgZT8iUyI6IlAiKStlO2lmKCFvKGUscCkpe2lmKCF1KGUpKXJldHVybiJGIjtpZighdClyZXR1cm4iRSI7bShlKX1yZXR1cm4gZVtwXS5vYmplY3RJRH0sZ2V0V2Vha0RhdGE6ZnVuY3Rpb24oZSx0KXtpZighbyhlLHApKXtpZighdShlKSlyZXR1cm4hMDtpZighdClyZXR1cm4hMTttKGUpfXJldHVybiBlW3BdLndlYWtEYXRhfSxvbkZyZWV6ZTpmdW5jdGlvbihlKXtyZXR1cm4gZCYmZiYmdShlKSYmIW8oZSxwKSYmbShlKSxlfX07c1twXT0hMH0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByLG4scyxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbi5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMiKSxkPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzIiksZj0iT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQiLHA9by5UeXBlRXJyb3IsZz1vLldlYWtNYXA7aWYoaXx8dS5zdGF0ZSl7dmFyIG09dS5zdGF0ZXx8KHUuc3RhdGU9bmV3IGcpO20uZ2V0PW0uZ2V0LG0uaGFzPW0uaGFzLG0uc2V0PW0uc2V0LHI9ZnVuY3Rpb24oZSx0KXtpZihtLmhhcyhlKSl0aHJvdyBuZXcgcChmKTtyZXR1cm4gdC5mYWNhZGU9ZSxtLnNldChlLHQpLHR9LG49ZnVuY3Rpb24oZSl7cmV0dXJuIG0uZ2V0KGUpfHx7fX0scz1mdW5jdGlvbihlKXtyZXR1cm4gbS5oYXMoZSl9fWVsc2V7dmFyIHc9aCgic3RhdGUiKTtkW3ddPSEwLHI9ZnVuY3Rpb24oZSx0KXtpZihjKGUsdykpdGhyb3cgbmV3IHAoZik7cmV0dXJuIHQuZmFjYWRlPWUsbChlLHcsdCksdH0sbj1mdW5jdGlvbihlKXtyZXR1cm4gYyhlLHcpP2Vbd106e319LHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZSx3KX19ZS5leHBvcnRzPXtzZXQ6cixnZXQ6bixoYXM6cyxlbmZvcmNlOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUpP24oZSk6cihlLHt9KX0sZ2V0dGVyRm9yOmZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgQTtpZighYSh0KXx8KEE9bih0KSkudHlwZSE9PWUpdGhyb3cgbmV3IHAoIkluY29tcGF0aWJsZSByZWNlaXZlciwgIitlKyIgcmVxdWlyZWQiKTtyZXR1cm4gQX19fX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzIikscz1yKCJpdGVyYXRvciIpLGk9QXJyYXkucHJvdG90eXBlO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09ZSYmKG4uQXJyYXk9PT1lfHxpW3NdPT09ZSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiKTtlLmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuIkFycmF5Ij09PXIoZSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiOmZ1bmN0aW9uKGUpeyJ1c2Ugc3RyaWN0Ijt2YXIgdD0ib2JqZWN0Ij09dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5hbGw7ZS5leHBvcnRzPXZvaWQgMD09PXQmJnZvaWQgMCE9PXQ/ZnVuY3Rpb24oZSl7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIGV8fGU9PT10fTpmdW5jdGlvbihlKXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgZX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qcyIpLGw9ZnVuY3Rpb24oKXt9LGM9bygiUmVmbGVjdCIsImNvbnN0cnVjdCIpLHU9L15ccyooPzpjbGFzc3xmdW5jdGlvbilcYi8saD1yKHUuZXhlYyksZD0hdS50ZXN0KGwpLGY9ZnVuY3Rpb24oZSl7aWYoIXMoZSkpcmV0dXJuITE7dHJ5e3JldHVybiBjKGwsW10sZSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fSxwPWZ1bmN0aW9uKGUpe2lmKCFzKGUpKXJldHVybiExO3N3aXRjaChpKGUpKXtjYXNlIkFzeW5jRnVuY3Rpb24iOmNhc2UiR2VuZXJhdG9yRnVuY3Rpb24iOmNhc2UiQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiI6cmV0dXJuITF9dHJ5e3JldHVybiBkfHwhIWgodSxhKGUpKX1jYXRjaChlKXtyZXR1cm4hMH19O3Auc2hhbT0hMCxlLmV4cG9ydHM9IWN8fG4oZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gZihmLmNhbGwpfHwhZihPYmplY3QpfHwhZihmdW5jdGlvbigpe2U9ITB9KXx8ZX0pP3A6Zn0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiKSxzPS8jfFwucHJvdG90eXBlXC4vLGk9ZnVuY3Rpb24oZSx0KXt2YXIgQT1hW28oZSldO3JldHVybiBBPT09Y3x8QSE9PWwmJihuKHQpP3IodCk6ISF0KX0sbz1pLm5vcm1hbGl6ZT1mdW5jdGlvbihlKXtyZXR1cm4gU3RyaW5nKGUpLnJlcGxhY2UocywiLiIpLnRvTG93ZXJDYXNlKCl9LGE9aS5kYXRhPXt9LGw9aS5OQVRJVkU9Ik4iLGM9aS5QT0xZRklMTD0iUCI7ZS5leHBvcnRzPWl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1pdGVyYWJsZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIpLGE9aSgiaXRlcmF0b3IiKSxsPU9iamVjdDtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYocyhlKSlyZXR1cm4hMTt2YXIgdD1sKGUpO3JldHVybiB2b2lkIDAhPT10W2FdfHwiQEBpdGVyYXRvciJpbiB0fHxuKG8scih0KSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanMiOmZ1bmN0aW9uKGUpeyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWV9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiJvYmplY3QiPT10eXBlb2YgZT9udWxsIT09ZTpyKGUpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXBvc3NpYmxlLXByb3RvdHlwZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSl8fG51bGw9PT1lfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiOmZ1bmN0aW9uKGUpeyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9ITF9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1yZWdleHAuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiKSgibWF0Y2giKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIHIoZSkmJih2b2lkIDAhPT0odD1lW3NdKT8hIXQ6IlJlZ0V4cCI9PT1uKGUpKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQuanMiKSxvPU9iamVjdDtlLmV4cG9ydHM9aT9mdW5jdGlvbihlKXtyZXR1cm4ic3ltYm9sIj09dHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3ZhciB0PXIoIlN5bWJvbCIpO3JldHVybiBuKHQpJiZzKHQucHJvdG90eXBlLG8oZSkpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdGUtc2ltcGxlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LEEpe2Zvcih2YXIgbixzLGk9QT9lOmUuaXRlcmF0b3Isbz1lLm5leHQ7IShuPXIobyxpKSkuZG9uZTspaWYodm9pZCAwIT09KHM9dChuLnZhbHVlKSkpcmV0dXJuIHN9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZy5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiksaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyIpLGQ9VHlwZUVycm9yLGY9ZnVuY3Rpb24oZSx0KXt0aGlzLnN0b3BwZWQ9ZSx0aGlzLnJlc3VsdD10fSxwPWYucHJvdG90eXBlO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsQSl7dmFyIGcsbSx3LEIseSx2LGIsQz1BJiZBLnRoYXQsXz0hKCFBfHwhQS5BU19FTlRSSUVTKSxqPSEoIUF8fCFBLklTX1JFQ09SRCkseD0hKCFBfHwhQS5JU19JVEVSQVRPUiksRj0hKCFBfHwhQS5JTlRFUlJVUFRFRCksUT1yKHQsQyksVT1mdW5jdGlvbihlKXtyZXR1cm4gZyYmaChnLCJub3JtYWwiKSxuZXcgZighMCxlKX0sRT1mdW5jdGlvbihlKXtyZXR1cm4gXz8ocyhlKSxGP1EoZVswXSxlWzFdLFUpOlEoZVswXSxlWzFdKSk6Rj9RKGUsVSk6UShlKX07aWYoailnPWUuaXRlcmF0b3I7ZWxzZSBpZih4KWc9ZTtlbHNle2lmKCEobT11KGUpKSl0aHJvdyBuZXcgZChpKGUpKyIgaXMgbm90IGl0ZXJhYmxlIik7aWYobyhtKSl7Zm9yKHc9MCxCPWEoZSk7Qj53O3crKylpZigoeT1FKGVbd10pKSYmbChwLHkpKXJldHVybiB5O3JldHVybiBuZXcgZighMSl9Zz1jKGUsbSl9Zm9yKHY9aj9lLm5leHQ6Zy5uZXh0OyEoYj1uKHYsZykpLmRvbmU7KXt0cnl7eT1FKGIudmFsdWUpfWNhdGNoKGUpe2goZywidGhyb3ciLGUpfWlmKCJvYmplY3QiPT10eXBlb2YgeSYmeSYmbChwLHkpKXJldHVybiB5fXJldHVybiBuZXcgZighMSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UtYWxsLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxBKXtmb3IodmFyIG49ZS5sZW5ndGgtMTtuPj0wO24tLSlpZih2b2lkIDAhPT1lW25dKXRyeXtBPXIoZVtuXS5pdGVyYXRvcix0LEEpfWNhdGNoKGUpe3Q9InRocm93IixBPWV9aWYoInRocm93Ij09PXQpdGhyb3cgQTtyZXR1cm4gQX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LEEpe3ZhciBpLG87bihlKTt0cnl7aWYoIShpPXMoZSwicmV0dXJuIikpKXtpZigidGhyb3ciPT09dCl0aHJvdyBBO3JldHVybiBBfWk9cihpLGUpfWNhdGNoKGUpe289ITAsaT1lfWlmKCJ0aHJvdyI9PT10KXRocm93IEE7aWYobyl0aHJvdyBpO3JldHVybiBuKGkpLEF9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY3JlYXRlLWNvbnN0cnVjdG9yLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzIikuSXRlcmF0b3JQcm90b3R5cGUsbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIpLGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxBLGwpe3ZhciBjPXQrIiBJdGVyYXRvciI7cmV0dXJuIGUucHJvdG90eXBlPW4ocix7bmV4dDpzKCshbCxBKX0pLGkoZSxjLCExLCEwKSxvW2NdPWEsZX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jcmVhdGUtcHJveHkuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW5zLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiKSxsPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzIikuSXRlcmF0b3JQcm90b3R5cGUsdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzIiksaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyIpLGQ9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UtYWxsLmpzIiksZj1vKCJ0b1N0cmluZ1RhZyIpLHA9Ikl0ZXJhdG9ySGVscGVyIixnPSJXcmFwRm9yVmFsaWRJdGVyYXRvciIsbT0ibm9ybWFsIix3PSJ0aHJvdyIsQj1hLnNldCx5PWZ1bmN0aW9uKGUpe3ZhciB0PWEuZ2V0dGVyRm9yKGU/ZzpwKTtyZXR1cm4gaShuKGMpLHtuZXh0OmZ1bmN0aW9uKCl7dmFyIEE9dCh0aGlzKTtpZihlKXJldHVybiBBLm5leHRIYW5kbGVyKCk7aWYoQS5kb25lKXJldHVybiB1KHZvaWQgMCwhMCk7dHJ5e3ZhciByPUEubmV4dEhhbmRsZXIoKTtyZXR1cm4gQS5yZXR1cm5IYW5kbGVyUmVzdWx0P3I6dShyLEEuZG9uZSl9Y2F0Y2goZSl7dGhyb3cgQS5kb25lPSEwLGV9fSxyZXR1cm46ZnVuY3Rpb24oKXt2YXIgQT10KHRoaXMpLG49QS5pdGVyYXRvcjtpZihBLmRvbmU9ITAsZSl7dmFyIHM9bChuLCJyZXR1cm4iKTtyZXR1cm4gcz9yKHMsbik6dSh2b2lkIDAsITApfWlmKEEuaW5uZXIpdHJ5e2goQS5pbm5lci5pdGVyYXRvcixtKX1jYXRjaChlKXtyZXR1cm4gaChuLHcsZSl9aWYoQS5vcGVuSXRlcnMpdHJ5e2QoQS5vcGVuSXRlcnMsbSl9Y2F0Y2goZSl7cmV0dXJuIGgobix3LGUpfXJldHVybiBuJiZoKG4sbSksdSh2b2lkIDAsITApfX0pfSx2PXkoITApLGI9eSghMSk7cyhiLGYsIkl0ZXJhdG9yIEhlbHBlciIpLGUuZXhwb3J0cz1mdW5jdGlvbihlLHQsQSl7dmFyIHI9ZnVuY3Rpb24ocixuKXtuPyhuLml0ZXJhdG9yPXIuaXRlcmF0b3Isbi5uZXh0PXIubmV4dCk6bj1yLG4udHlwZT10P2c6cCxuLnJldHVybkhhbmRsZXJSZXN1bHQ9ISFBLG4ubmV4dEhhbmRsZXI9ZSxuLmNvdW50ZXI9MCxuLmRvbmU9ITEsQih0aGlzLG4pfTtyZXR1cm4gci5wcm90b3R5cGU9dD92OmIscn19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1uYW1lLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY3JlYXRlLWNvbnN0cnVjdG9yLmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanMiKSx1PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzIiksaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanMiKSxkPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcyIpLGY9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiKSxwPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIpLGc9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMiKSxtPWkuUFJPUEVSLHc9aS5DT05GSUdVUkFCTEUsQj1nLkl0ZXJhdG9yUHJvdG90eXBlLHk9Zy5CVUdHWV9TQUZBUklfSVRFUkFUT1JTLHY9ZigiaXRlcmF0b3IiKSxiPSJrZXlzIixDPSJ2YWx1ZXMiLF89ImVudHJpZXMiLGo9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxBLGksZixnLHgpe2EoQSx0LGkpO3ZhciBGLFEsVSxFPWZ1bmN0aW9uKGUpe2lmKGU9PT1mJiZrKXJldHVybiBrO2lmKCF5JiZlJiZlIGluIEkpcmV0dXJuIElbZV07c3dpdGNoKGUpe2Nhc2UgYjpjYXNlIEM6Y2FzZSBfOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgQSh0aGlzLGUpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEEodGhpcyl9fSxTPXQrIiBJdGVyYXRvciIsTD0hMSxJPWUucHJvdG90eXBlLE49SVt2XXx8SVsiQEBpdGVyYXRvciJdfHxmJiZJW2ZdLGs9IXkmJk58fEUoZiksSD0iQXJyYXkiPT09dCYmSS5lbnRyaWVzfHxOO2lmKEgmJihGPWwoSC5jYWxsKG5ldyBlKSkpIT09T2JqZWN0LnByb3RvdHlwZSYmRi5uZXh0JiYoc3x8bChGKT09PUJ8fChjP2MoRixCKTpvKEZbdl0pfHxkKEYsdixqKSksdShGLFMsITAsITApLHMmJihwW1NdPWopKSxtJiZmPT09QyYmTiYmTi5uYW1lIT09QyYmKCFzJiZ3P2goSSwibmFtZSIsQyk6KEw9ITAsaz1mdW5jdGlvbigpe3JldHVybiBuKE4sdGhpcyl9KSksZilpZihRPXt2YWx1ZXM6RShDKSxrZXlzOmc/azpFKGIpLGVudHJpZXM6RShfKX0seClmb3IoVSBpbiBRKSh5fHxMfHwhKFUgaW4gSSkpJiZkKEksVSxRW1VdKTtlbHNlIHIoe3RhcmdldDp0LHByb3RvOiEwLGZvcmNlZDp5fHxMfSxRKTtyZXR1cm4gcyYmIXh8fElbdl09PT1rfHxkKEksdixrLHtuYW1lOmZ9KSxwW3RdPWssUX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1oZWxwZXItdGhyb3dzLW9uLWludmFsaWQtaXRlcmF0b3IuanMiOmZ1bmN0aW9uKGUpeyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgQT0iZnVuY3Rpb24iPT10eXBlb2YgSXRlcmF0b3ImJkl0ZXJhdG9yLnByb3RvdHlwZVtlXTtpZihBKXRyeXtBLmNhbGwoe25leHQ6bnVsbH0sdCkubmV4dCgpfWNhdGNoKGUpe3JldHVybiEwfX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1oZWxwZXItd2l0aG91dC1jbG9zaW5nLW9uLWVhcmx5LWVycm9yLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIEE9ci5JdGVyYXRvcixuPUEmJkEucHJvdG90eXBlLHM9biYmbltlXSxpPSExO2lmKHMpdHJ5e3MuY2FsbCh7bmV4dDpmdW5jdGlvbigpe3JldHVybntkb25lOiEwfX0scmV0dXJuOmZ1bmN0aW9uKCl7aT0hMH19LC0xKX1jYXRjaChlKXtlIGluc3RhbmNlb2YgdHx8KGk9ITEpfWlmKCFpKXJldHVybiBzfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByLG4scyxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyIpLHU9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzIiksaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIpLGQ9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyIpLGY9aCgiaXRlcmF0b3IiKSxwPSExO1tdLmtleXMmJigibmV4dCJpbihzPVtdLmtleXMoKSk/KG49YyhjKHMpKSkhPT1PYmplY3QucHJvdG90eXBlJiYocj1uKTpwPSEwKSwhYShyKXx8aShmdW5jdGlvbigpe3ZhciBlPXt9O3JldHVybiByW2ZdLmNhbGwoZSkhPT1lfSk/cj17fTpkJiYocj1sKHIpKSxvKHJbZl0pfHx1KHIsZixmdW5jdGlvbigpe3JldHVybiB0aGlzfSksZS5leHBvcnRzPXtJdGVyYXRvclByb3RvdHlwZTpyLEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6cH19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanMiOmZ1bmN0aW9uKGUpeyJ1c2Ugc3RyaWN0IjtlLmV4cG9ydHM9e319LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZS5sZW5ndGgpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21ha2UtYnVpbHQtaW4uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1uYW1lLmpzIikuQ09ORklHVVJBQkxFLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzIiksdT1jLmVuZm9yY2UsaD1jLmdldCxkPVN0cmluZyxmPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxwPXIoIiIuc2xpY2UpLGc9cigiIi5yZXBsYWNlKSxtPXIoW10uam9pbiksdz1vJiYhbihmdW5jdGlvbigpe3JldHVybiA4IT09ZihmdW5jdGlvbigpe30sImxlbmd0aCIse3ZhbHVlOjh9KS5sZW5ndGh9KSxCPVN0cmluZyhTdHJpbmcpLnNwbGl0KCJTdHJpbmciKSx5PWUuZXhwb3J0cz1mdW5jdGlvbihlLHQsQSl7IlN5bWJvbCgiPT09cChkKHQpLDAsNykmJih0PSJbIitnKGQodCksL15TeW1ib2xcKChbXildKilcKS4qJC8sIiQxIikrIl0iKSxBJiZBLmdldHRlciYmKHQ9ImdldCAiK3QpLEEmJkEuc2V0dGVyJiYodD0ic2V0ICIrdCksKCFpKGUsIm5hbWUiKXx8YSYmZS5uYW1lIT09dCkmJihvP2YoZSwibmFtZSIse3ZhbHVlOnQsY29uZmlndXJhYmxlOiEwfSk6ZS5uYW1lPXQpLHcmJkEmJmkoQSwiYXJpdHkiKSYmZS5sZW5ndGghPT1BLmFyaXR5JiZmKGUsImxlbmd0aCIse3ZhbHVlOkEuYXJpdHl9KTt0cnl7QSYmaShBLCJjb25zdHJ1Y3RvciIpJiZBLmNvbnN0cnVjdG9yP28mJmYoZSwicHJvdG90eXBlIix7d3JpdGFibGU6ITF9KTplLnByb3RvdHlwZSYmKGUucHJvdG90eXBlPXZvaWQgMCl9Y2F0Y2goZSl7fXZhciByPXUoZSk7cmV0dXJuIGkociwic291cmNlIil8fChyLnNvdXJjZT1tKEIsInN0cmluZyI9PXR5cGVvZiB0P3Q6IiIpKSxlfTtGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc9eShmdW5jdGlvbigpe3JldHVybiBzKHRoaXMpJiZoKHRoaXMpLnNvdXJjZXx8bCh0aGlzKX0sInRvU3RyaW5nIil9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYXRoLXRydW5jLmpzIjpmdW5jdGlvbihlKXsidXNlIHN0cmljdCI7dmFyIHQ9TWF0aC5jZWlsLEE9TWF0aC5mbG9vcjtlLmV4cG9ydHM9TWF0aC50cnVuY3x8ZnVuY3Rpb24oZSl7dmFyIHI9K2U7cmV0dXJuKHI+MD9BOnQpKHIpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21pY3JvdGFzay5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcixuLHMsaSxvLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiKSxsPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NhZmUtZ2V0LWJ1aWx0LWluLmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiKSx1PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Rhc2suanMiKS5zZXQsaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9xdWV1ZS5qcyIpLGQ9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQtaXMtaW9zLmpzIiksZj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC1pcy1pb3MtcGViYmxlLmpzIikscD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC1pcy13ZWJvcy13ZWJraXQuanMiKSxnPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LWlzLW5vZGUuanMiKSxtPWEuTXV0YXRpb25PYnNlcnZlcnx8YS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLHc9YS5kb2N1bWVudCxCPWEucHJvY2Vzcyx5PWEuUHJvbWlzZSx2PWwoInF1ZXVlTWljcm90YXNrIik7aWYoIXYpe3ZhciBiPW5ldyBoLEM9ZnVuY3Rpb24oKXt2YXIgZSx0O2ZvcihnJiYoZT1CLmRvbWFpbikmJmUuZXhpdCgpO3Q9Yi5nZXQoKTspdHJ5e3QoKX1jYXRjaChlKXt0aHJvdyBiLmhlYWQmJnIoKSxlfWUmJmUuZW50ZXIoKX07ZHx8Z3x8cHx8IW18fCF3PyFmJiZ5JiZ5LnJlc29sdmU/KChpPXkucmVzb2x2ZSh2b2lkIDApKS5jb25zdHJ1Y3Rvcj15LG89YyhpLnRoZW4saSkscj1mdW5jdGlvbigpe28oQyl9KTpnP3I9ZnVuY3Rpb24oKXtCLm5leHRUaWNrKEMpfToodT1jKHUsYSkscj1mdW5jdGlvbigpe3UoQyl9KToobj0hMCxzPXcuY3JlYXRlVGV4dE5vZGUoIiIpLG5ldyBtKEMpLm9ic2VydmUocyx7Y2hhcmFjdGVyRGF0YTohMH0pLHI9ZnVuY3Rpb24oKXtzLmRhdGE9bj0hbn0pLHY9ZnVuY3Rpb24oZSl7Yi5oZWFkfHxyKCksYi5hZGQoZSl9fWUuZXhwb3J0cz12fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzIiksbj1UeXBlRXJyb3Iscz1mdW5jdGlvbihlKXt2YXIgdCxBO3RoaXMucHJvbWlzZT1uZXcgZShmdW5jdGlvbihlLHIpe2lmKHZvaWQgMCE9PXR8fHZvaWQgMCE9PUEpdGhyb3cgbmV3IG4oIkJhZCBQcm9taXNlIGNvbnN0cnVjdG9yIik7dD1lLEE9cn0pLHRoaXMucmVzb2x2ZT1yKHQpLHRoaXMucmVqZWN0PXIoQSl9O2UuZXhwb3J0cy5mPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgcyhlKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9ub3QtYS1yZWdleHAuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcmVnZXhwLmpzIiksbj1UeXBlRXJyb3I7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2lmKHIoZSkpdGhyb3cgbmV3IG4oIlRoZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgcmVndWxhciBleHByZXNzaW9ucyIpO3JldHVybiBlfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1hc3NpZ24uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcyIpLGg9T2JqZWN0LmFzc2lnbixkPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxmPW4oW10uY29uY2F0KTtlLmV4cG9ydHM9IWh8fGkoZnVuY3Rpb24oKXtpZihyJiYxIT09aCh7YjoxfSxoKGQoe30sImEiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe2QodGhpcywiYiIse3ZhbHVlOjMsZW51bWVyYWJsZTohMX0pfX0pLHtiOjJ9KSkuYilyZXR1cm4hMDt2YXIgZT17fSx0PXt9LEE9U3ltYm9sKCJhc3NpZ24gZGV0ZWN0aW9uIiksbj0iYWJjZGVmZ2hpamtsbW5vcHFyc3QiO3JldHVybiBlW0FdPTcsbi5zcGxpdCgiIikuZm9yRWFjaChmdW5jdGlvbihlKXt0W2VdPWV9KSw3IT09aCh7fSxlKVtBXXx8byhoKHt9LHQpKS5qb2luKCIiKSE9PW59KT9mdW5jdGlvbihlLHQpe2Zvcih2YXIgQT1jKGUpLG49YXJndW1lbnRzLmxlbmd0aCxpPTEsaD1hLmYsZD1sLmY7bj5pOylmb3IodmFyIHAsZz11KGFyZ3VtZW50c1tpKytdKSxtPWg/ZihvKGcpLGgoZykpOm8oZyksdz1tLmxlbmd0aCxCPTA7dz5COylwPW1bQisrXSxyJiYhcyhkLGcscCl8fChBW3BdPWdbcF0pO3JldHVybiBBfTpofSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcixuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanMiKSx1PSJwcm90b3R5cGUiLGg9InNjcmlwdCIsZD1jKCJJRV9QUk9UTyIpLGY9ZnVuY3Rpb24oKXt9LHA9ZnVuY3Rpb24oZSl7cmV0dXJuIjwiK2grIj4iK2UrIjwvIitoKyI+In0sZz1mdW5jdGlvbihlKXtlLndyaXRlKHAoIiIpKSxlLmNsb3NlKCk7dmFyIHQ9ZS5wYXJlbnRXaW5kb3cuT2JqZWN0O3JldHVybiBlPW51bGwsdH0sbT1mdW5jdGlvbigpe3RyeXtyPW5ldyBBY3RpdmVYT2JqZWN0KCJodG1sZmlsZSIpfWNhdGNoKGUpe312YXIgZSx0LEE7bT0idW5kZWZpbmVkIiE9dHlwZW9mIGRvY3VtZW50P2RvY3VtZW50LmRvbWFpbiYmcj9nKHIpOih0PWwoImlmcmFtZSIpLEE9ImphdmEiK2grIjoiLHQuc3R5bGUuZGlzcGxheT0ibm9uZSIsYS5hcHBlbmRDaGlsZCh0KSx0LnNyYz1TdHJpbmcoQSksKGU9dC5jb250ZW50V2luZG93LmRvY3VtZW50KS5vcGVuKCksZS53cml0ZShwKCJkb2N1bWVudC5GPU9iamVjdCIpKSxlLmNsb3NlKCksZS5GKTpnKHIpO2Zvcih2YXIgbj1pLmxlbmd0aDtuLS07KWRlbGV0ZSBtW3VdW2lbbl1dO3JldHVybiBtKCl9O29bZF09ITAsZS5leHBvcnRzPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKGUsdCl7dmFyIEE7cmV0dXJuIG51bGwhPT1lPyhmW3VdPW4oZSksQT1uZXcgZixmW3VdPW51bGwsQVtkXT1lKTpBPW0oKSx2b2lkIDA9PT10P0E6cy5mKEEsdCl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1Zy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiKTt0LmY9ciYmIW4/T2JqZWN0LmRlZmluZVByb3BlcnRpZXM6ZnVuY3Rpb24oZSx0KXtpKGUpO2Zvcih2YXIgQSxyPW8odCksbj1hKHQpLGw9bi5sZW5ndGgsYz0wO2w+Yzspcy5mKGUsQT1uW2MrK10scltBXSk7cmV0dXJuIGV9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qcyIpLGE9VHlwZUVycm9yLGw9T2JqZWN0LmRlZmluZVByb3BlcnR5LGM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcix1PSJlbnVtZXJhYmxlIixoPSJjb25maWd1cmFibGUiLGQ9IndyaXRhYmxlIjt0LmY9cj9zP2Z1bmN0aW9uKGUsdCxBKXtpZihpKGUpLHQ9byh0KSxpKEEpLCJmdW5jdGlvbiI9PXR5cGVvZiBlJiYicHJvdG90eXBlIj09PXQmJiJ2YWx1ZSJpbiBBJiZkIGluIEEmJiFBW2RdKXt2YXIgcj1jKGUsdCk7ciYmcltkXSYmKGVbdF09QS52YWx1ZSxBPXtjb25maWd1cmFibGU6aCBpbiBBP0FbaF06cltoXSxlbnVtZXJhYmxlOnUgaW4gQT9BW3VdOnJbdV0sd3JpdGFibGU6ITF9KX1yZXR1cm4gbChlLHQsQSl9Omw6ZnVuY3Rpb24oZSx0LEEpe2lmKGkoZSksdD1vKHQpLGkoQSksbil0cnl7cmV0dXJuIGwoZSx0LEEpfWNhdGNoKGUpe31pZigiZ2V0ImluIEF8fCJzZXQiaW4gQSl0aHJvdyBuZXcgYSgiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQiKTtyZXR1cm4idmFsdWUiaW4gQSYmKGVbdF09QS52YWx1ZSksZX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMiKSxsPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzIiksdT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3QuZj1yP3U6ZnVuY3Rpb24oZSx0KXtpZihlPW8oZSksdD1hKHQpLGMpdHJ5e3JldHVybiB1KGUsdCl9Y2F0Y2goZSl7fWlmKGwoZSx0KSlyZXR1cm4gaSghbihzLmYsZSx0KSxlW3RdKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIikuZixpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNsaWNlLmpzIiksbz0ib2JqZWN0Ij09dHlwZW9mIHdpbmRvdyYmd2luZG93JiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz9PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpOltdO2UuZXhwb3J0cy5mPWZ1bmN0aW9uKGUpe3JldHVybiBvJiYiV2luZG93Ij09PXIoZSk/ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBzKGUpfWNhdGNoKGUpe3JldHVybiBpKG8pfX0oZSk6cyhuKGUpKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcyIpLmNvbmNhdCgibGVuZ3RoIiwicHJvdG90eXBlIik7dC5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHxmdW5jdGlvbihlKXtyZXR1cm4gcihlLG4pfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiOmZ1bmN0aW9uKGUsdCl7InVzZSBzdHJpY3QiO3QuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIiksYT1pKCJJRV9QUk9UTyIpLGw9T2JqZWN0LGM9bC5wcm90b3R5cGU7ZS5leHBvcnRzPW8/bC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXt2YXIgdD1zKGUpO2lmKHIodCxhKSlyZXR1cm4gdFthXTt2YXIgQT10LmNvbnN0cnVjdG9yO3JldHVybiBuKEEpJiZ0IGluc3RhbmNlb2YgQT9BLnByb3RvdHlwZTp0IGluc3RhbmNlb2YgbD9jOm51bGx9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLWV4dGVuc2libGUuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci1ub24tZXh0ZW5zaWJsZS5qcyIpLG89T2JqZWN0LmlzRXh0ZW5zaWJsZSxhPXIoZnVuY3Rpb24oKXtvKDEpfSk7ZS5leHBvcnRzPWF8fGk/ZnVuY3Rpb24oZSl7cmV0dXJuISFuKGUpJiYoIWl8fCJBcnJheUJ1ZmZlciIhPT1zKGUpKSYmKCFvfHxvKGUpKX06b30sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIik7ZS5leHBvcnRzPXIoe30uaXNQcm90b3R5cGVPZil9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyIpLmluZGV4T2Ysbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyIpLGE9cihbXS5wdXNoKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgQSxyPXMoZSksbD0wLGM9W107Zm9yKEEgaW4gcikhbihvLEEpJiZuKHIsQSkmJmEoYyxBKTtmb3IoO3QubGVuZ3RoPmw7KW4ocixBPXRbbCsrXSkmJih+aShjLEEpfHxhKGMsQSkpO3JldHVybiBjfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIik7ZS5leHBvcnRzPU9iamVjdC5rZXlzfHxmdW5jdGlvbihlKXtyZXR1cm4gcihlLG4pfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzIjpmdW5jdGlvbihlLHQpeyJ1c2Ugc3RyaWN0Ijt2YXIgQT17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxyPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Isbj1yJiYhQS5jYWxsKHsxOjJ9LDEpO3QuZj1uP2Z1bmN0aW9uKGUpe3ZhciB0PXIodGhpcyxlKTtyZXR1cm4hIXQmJnQuZW51bWVyYWJsZX06QX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1hY2Nlc3Nvci5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzIik7ZS5leHBvcnRzPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8KCJfX3Byb3RvX18iaW57fT9mdW5jdGlvbigpe3ZhciBlLHQ9ITEsQT17fTt0cnl7KGU9cihPYmplY3QucHJvdG90eXBlLCJfX3Byb3RvX18iLCJzZXQiKSkoQSxbXSksdD1BIGluc3RhbmNlb2YgQXJyYXl9Y2F0Y2goZSl7fXJldHVybiBmdW5jdGlvbihBLHIpe3JldHVybiBzKEEpLGkociksbihBKT8odD9lKEEscik6QS5fX3Byb3RvX189cixBKTpBfX0oKTp2b2lkIDApfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiKTtlLmV4cG9ydHM9cj97fS50b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiJbb2JqZWN0ICIrbih0aGlzKSsiXSJ9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiKSxpPVR5cGVFcnJvcjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgQSxvO2lmKCJzdHJpbmciPT09dCYmbihBPWUudG9TdHJpbmcpJiYhcyhvPXIoQSxlKSkpcmV0dXJuIG87aWYobihBPWUudmFsdWVPZikmJiFzKG89cihBLGUpKSlyZXR1cm4gbztpZigic3RyaW5nIiE9PXQmJm4oQT1lLnRvU3RyaW5nKSYmIXMobz1yKEEsZSkpKXJldHVybiBvO3Rocm93IG5ldyBpKCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIpLGE9bihbXS5jb25jYXQpO2UuZXhwb3J0cz1yKCJSZWZsZWN0Iiwib3duS2V5cyIpfHxmdW5jdGlvbihlKXt2YXIgdD1zLmYobyhlKSksQT1pLmY7cmV0dXJuIEE/YSh0LEEoZSkpOnR9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpO2UuZXhwb3J0cz1yfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGVyZm9ybS5qcyI6ZnVuY3Rpb24oZSl7InVzZSBzdHJpY3QiO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt0cnl7cmV0dXJue2Vycm9yOiExLHZhbHVlOmUoKX19Y2F0Y2goZSl7cmV0dXJue2Vycm9yOiEwLHZhbHVlOmV9fX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJvbWlzZS1uYXRpdmUtY29uc3RydWN0b3IuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiKSx1PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LXY4LXZlcnNpb24uanMiKSxoPW4mJm4ucHJvdG90eXBlLGQ9YSgic3BlY2llcyIpLGY9ITEscD1zKHIuUHJvbWlzZVJlamVjdGlvbkV2ZW50KSxnPWkoIlByb21pc2UiLGZ1bmN0aW9uKCl7dmFyIGU9byhuKSx0PWUhPT1TdHJpbmcobik7aWYoIXQmJjY2PT09dSlyZXR1cm4hMDtpZihjJiYoIWguY2F0Y2h8fCFoLmZpbmFsbHkpKXJldHVybiEwO2lmKCF1fHx1PDUxfHwhL25hdGl2ZSBjb2RlLy50ZXN0KGUpKXt2YXIgQT1uZXcgbihmdW5jdGlvbihlKXtlKDEpfSkscj1mdW5jdGlvbihlKXtlKGZ1bmN0aW9uKCl7fSxmdW5jdGlvbigpe30pfTtpZigoQS5jb25zdHJ1Y3Rvcj17fSlbZF09ciwhKGY9QS50aGVuKGZ1bmN0aW9uKCl7fSlpbnN0YW5jZW9mIHIpKXJldHVybiEwfXJldHVybiEodHx8IkJST1dTRVIiIT09bCYmIkRFTk8iIT09bHx8cCl9KTtlLmV4cG9ydHM9e0NPTlNUUlVDVE9SOmcsUkVKRUNUSU9OX0VWRU5UOnAsU1VCQ0xBU1NJTkc6Zn19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLW5hdGl2ZS1jb25zdHJ1Y3Rvci5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpO2UuZXhwb3J0cz1yLlByb21pc2V9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLXJlc29sdmUuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtpZihyKGUpLG4odCkmJnQuY29uc3RydWN0b3I9PT1lKXJldHVybiB0O3ZhciBBPXMuZihlKTtyZXR1cm4oMCxBLnJlc29sdmUpKHQpLEEucHJvbWlzZX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLXN0YXRpY3MtaW5jb3JyZWN0LWl0ZXJhdGlvbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLW5hdGl2ZS1jb25zdHJ1Y3Rvci5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyIpLkNPTlNUUlVDVE9SO2UuZXhwb3J0cz1zfHwhbihmdW5jdGlvbihlKXtyLmFsbChlKS50aGVuKHZvaWQgMCxmdW5jdGlvbigpe30pfSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9xdWV1ZS5qcyI6ZnVuY3Rpb24oZSl7InVzZSBzdHJpY3QiO3ZhciB0PWZ1bmN0aW9uKCl7dGhpcy5oZWFkPW51bGwsdGhpcy50YWlsPW51bGx9O3QucHJvdG90eXBlPXthZGQ6ZnVuY3Rpb24oZSl7dmFyIHQ9e2l0ZW06ZSxuZXh0Om51bGx9LEE9dGhpcy50YWlsO0E/QS5uZXh0PXQ6dGhpcy5oZWFkPXQsdGhpcy50YWlsPXR9LGdldDpmdW5jdGlvbigpe3ZhciBlPXRoaXMuaGVhZDtpZihlKXJldHVybiBudWxsPT09KHRoaXMuaGVhZD1lLm5leHQpJiYodGhpcy50YWlsPW51bGwpLGUuaXRlbX19LGUuZXhwb3J0cz10fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1leGVjLmpzIiksYT1UeXBlRXJyb3I7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIEE9ZS5leGVjO2lmKHMoQSkpe3ZhciBsPXIoQSxlLHQpO3JldHVybiBudWxsIT09bCYmbihsKSxsfWlmKCJSZWdFeHAiPT09aShlKSlyZXR1cm4gcihvLGUsdCk7dGhyb3cgbmV3IGEoIlJlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXIiKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZXhlYy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcixuLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1mbGFncy5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLXN0aWNreS1oZWxwZXJzLmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMiKSx1PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzIikuZ2V0LGQ9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLXVuc3VwcG9ydGVkLWRvdC1hbGwuanMiKSxmPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC11bnN1cHBvcnRlZC1uY2cuanMiKSxwPWMoIm5hdGl2ZS1zdHJpbmctcmVwbGFjZSIsU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKSxnPVJlZ0V4cC5wcm90b3R5cGUuZXhlYyxtPWcsdz1pKCIiLmNoYXJBdCksQj1pKCIiLmluZGV4T2YpLHk9aSgiIi5yZXBsYWNlKSx2PWkoIiIuc2xpY2UpLGI9KG49L2IqL2cscyhnLHI9L2EvLCJhIikscyhnLG4sImEiKSwwIT09ci5sYXN0SW5kZXh8fDAhPT1uLmxhc3RJbmRleCksQz1sLkJST0tFTl9DQVJFVCxfPXZvaWQgMCE9PS8oKT8/Ly5leGVjKCIiKVsxXTsoYnx8X3x8Q3x8ZHx8ZikmJihtPWZ1bmN0aW9uKGUpe3ZhciB0LEEscixuLGksbCxjLGQ9dGhpcyxmPWgoZCksaj1vKGUpLHg9Zi5yYXc7aWYoeClyZXR1cm4geC5sYXN0SW5kZXg9ZC5sYXN0SW5kZXgsdD1zKG0seCxqKSxkLmxhc3RJbmRleD14Lmxhc3RJbmRleCx0O3ZhciBGPWYuZ3JvdXBzLFE9QyYmZC5zdGlja3ksVT1zKGEsZCksRT1kLnNvdXJjZSxTPTAsTD1qO2lmKFEmJihVPXkoVSwieSIsIiIpLC0xPT09QihVLCJnIikmJihVKz0iZyIpLEw9dihqLGQubGFzdEluZGV4KSxkLmxhc3RJbmRleD4wJiYoIWQubXVsdGlsaW5lfHxkLm11bHRpbGluZSYmIlxuIiE9PXcoaixkLmxhc3RJbmRleC0xKSkmJihFPSIoPzogIitFKyIpIixMPSIgIitMLFMrKyksQT1uZXcgUmVnRXhwKCJeKD86IitFKyIpIixVKSksXyYmKEE9bmV3IFJlZ0V4cCgiXiIrRSsiJCg/IVxccykiLFUpKSxiJiYocj1kLmxhc3RJbmRleCksbj1zKGcsUT9BOmQsTCksUT9uPyhuLmlucHV0PXYobi5pbnB1dCxTKSxuWzBdPXYoblswXSxTKSxuLmluZGV4PWQubGFzdEluZGV4LGQubGFzdEluZGV4Kz1uWzBdLmxlbmd0aCk6ZC5sYXN0SW5kZXg9MDpiJiZuJiYoZC5sYXN0SW5kZXg9ZC5nbG9iYWw/bi5pbmRleCtuWzBdLmxlbmd0aDpyKSxfJiZuJiZuLmxlbmd0aD4xJiZzKHAsblswXSxBLGZ1bmN0aW9uKCl7Zm9yKGk9MTtpPGFyZ3VtZW50cy5sZW5ndGgtMjtpKyspdm9pZCAwPT09YXJndW1lbnRzW2ldJiYobltpXT12b2lkIDApfSksbiYmRilmb3Iobi5ncm91cHM9bD11KG51bGwpLGk9MDtpPEYubGVuZ3RoO2krKylsWyhjPUZbaV0pWzBdXT1uW2NbMV1dO3JldHVybiBufSksZS5leHBvcnRzPW19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZmxhZ3MtZGV0ZWN0aW9uLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpLHM9ci5SZWdFeHAsaT0hbihmdW5jdGlvbigpe3ZhciBlPSEwO3RyeXtzKCIuIiwiZCIpfWNhdGNoKHQpe2U9ITF9dmFyIHQ9e30sQT0iIixyPWU/ImRnaW1zeSI6ImdpbXN5IixuPWZ1bmN0aW9uKGUscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEErPXIsITB9fSl9LGk9e2RvdEFsbDoicyIsZ2xvYmFsOiJnIixpZ25vcmVDYXNlOiJpIixtdWx0aWxpbmU6Im0iLHN0aWNreToieSJ9O2Zvcih2YXIgbyBpbiBlJiYoaS5oYXNJbmRpY2VzPSJkIiksaSluKG8saVtvXSk7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iocy5wcm90b3R5cGUsImZsYWdzIikuZ2V0LmNhbGwodCkhPT1yfHxBIT09cn0pO2UuZXhwb3J0cz17Y29ycmVjdDppfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1mbGFncy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oKXt2YXIgZT1yKHRoaXMpLHQ9IiI7cmV0dXJuIGUuaGFzSW5kaWNlcyYmKHQrPSJkIiksZS5nbG9iYWwmJih0Kz0iZyIpLGUuaWdub3JlQ2FzZSYmKHQrPSJpIiksZS5tdWx0aWxpbmUmJih0Kz0ibSIpLGUuZG90QWxsJiYodCs9InMiKSxlLnVuaWNvZGUmJih0Kz0idSIpLGUudW5pY29kZVNldHMmJih0Kz0idiIpLGUuc3RpY2t5JiYodCs9InkiKSx0fX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1nZXQtZmxhZ3MuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLWRldGVjdGlvbi5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzIiksYT1SZWdFeHAucHJvdG90eXBlO2UuZXhwb3J0cz1pLmNvcnJlY3Q/ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZmxhZ3N9OmZ1bmN0aW9uKGUpe3JldHVybiBpLmNvcnJlY3R8fCFzKGEsZSl8fG4oZSwiZmxhZ3MiKT9lLmZsYWdzOnIobyxlKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtc3RpY2t5LWhlbHBlcnMuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIikuUmVnRXhwLHM9cihmdW5jdGlvbigpe3ZhciBlPW4oImEiLCJ5Iik7cmV0dXJuIGUubGFzdEluZGV4PTIsbnVsbCE9PWUuZXhlYygiYWJjZCIpfSksaT1zfHxyKGZ1bmN0aW9uKCl7cmV0dXJuIW4oImEiLCJ5Iikuc3RpY2t5fSksbz1zfHxyKGZ1bmN0aW9uKCl7dmFyIGU9bigiXnIiLCJneSIpO3JldHVybiBlLmxhc3RJbmRleD0yLG51bGwhPT1lLmV4ZWMoInN0ciIpfSk7ZS5leHBvcnRzPXtCUk9LRU5fQ0FSRVQ6byxNSVNTRURfU1RJQ0tZOmksVU5TVVBQT1JURURfWTpzfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC11bnN1cHBvcnRlZC1kb3QtYWxsLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLlJlZ0V4cDtlLmV4cG9ydHM9cihmdW5jdGlvbigpe3ZhciBlPW4oIi4iLCJzIik7cmV0dXJuIShlLmRvdEFsbCYmZS50ZXN0KCJcbiIpJiYicyI9PT1lLmZsYWdzKX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLXVuc3VwcG9ydGVkLW5jZy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiKS5SZWdFeHA7ZS5leHBvcnRzPXIoZnVuY3Rpb24oKXt2YXIgZT1uKCIoPzxhPmIpIiwiZyIpO3JldHVybiJiIiE9PWUuZXhlYygiYiIpLmdyb3Vwcy5hfHwiYmMiIT09ImIiLnJlcGxhY2UoZSwiJDxhPmMiKX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkLmpzIiksbj1UeXBlRXJyb3I7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe2lmKHIoZSkpdGhyb3cgbmV3IG4oIkNhbid0IGNhbGwgbWV0aG9kIG9uICIrZSk7cmV0dXJuIGV9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2FmZS1nZXQtYnVpbHQtaW4uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIikscz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtpZighbilyZXR1cm4gcltlXTt2YXIgdD1zKHIsZSk7cmV0dXJuIHQmJnQudmFsdWV9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2NoZWR1bGVycy1maXguanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHIsbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHkuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdXNlci1hZ2VudC5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc2xpY2UuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3ZhbGlkYXRlLWFyZ3VtZW50cy1sZW5ndGguanMiKSx1PW4uRnVuY3Rpb24saD0vTVNJRSAuXC4vLnRlc3QoYSl8fCJCVU4iPT09byYmKChyPW4uQnVuLnZlcnNpb24uc3BsaXQoIi4iKSkubGVuZ3RoPDN8fCIwIj09PXJbMF0mJihyWzFdPDN8fCIzIj09PXJbMV0mJiIwIj09PXJbMl0pKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgQT10PzI6MTtyZXR1cm4gaD9mdW5jdGlvbihyLG4pe3ZhciBvPWMoYXJndW1lbnRzLmxlbmd0aCwxKT5BLGE9aShyKT9yOnUociksaD1vP2woYXJndW1lbnRzLEEpOltdLGQ9bz9mdW5jdGlvbigpe3MoYSx0aGlzLGgpfTphO3JldHVybiB0P2UoZCxuKTplKGQpfTplfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1jbG9uZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtaGVscGVycy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWl0ZXJhdGUuanMiKSxzPXIuU2V0LGk9ci5hZGQ7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBzO3JldHVybiBuKGUsZnVuY3Rpb24oZSl7aSh0LGUpfSksdH19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZGlmZmVyZW5jZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXNldC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWhlbHBlcnMuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1jbG9uZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXNpemUuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1zZXQtcmVjb3JkLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtaXRlcmF0ZS5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS1zaW1wbGUuanMiKSxjPW4uaGFzLHU9bi5yZW1vdmU7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PXIodGhpcyksQT1vKGUpLG49cyh0KTtyZXR1cm4gaSh0KTw9QS5zaXplP2EodCxmdW5jdGlvbihlKXtBLmluY2x1ZGVzKGUpJiZ1KG4sZSl9KTpsKEEuZ2V0SXRlcmF0b3IoKSxmdW5jdGlvbihlKXtjKG4sZSkmJnUobixlKX0pLG59fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWhlbHBlcnMuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiksbj1TZXQucHJvdG90eXBlO2UuZXhwb3J0cz17U2V0OlNldCxhZGQ6cihuLmFkZCksaGFzOnIobi5oYXMpLHJlbW92ZTpyKG4uZGVsZXRlKSxwcm90bzpufX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1pbnRlcnNlY3Rpb24uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1zZXQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1oZWxwZXJzLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc2l6ZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LXNldC1yZWNvcmQuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1pdGVyYXRlLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLXNpbXBsZS5qcyIpLGw9bi5TZXQsYz1uLmFkZCx1PW4uaGFzO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1yKHRoaXMpLEE9aShlKSxuPW5ldyBsO3JldHVybiBzKHQpPkEuc2l6ZT9hKEEuZ2V0SXRlcmF0b3IoKSxmdW5jdGlvbihlKXt1KHQsZSkmJmMobixlKX0pOm8odCxmdW5jdGlvbihlKXtBLmluY2x1ZGVzKGUpJiZjKG4sZSl9KSxufX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1pcy1kaXNqb2ludC1mcm9tLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Etc2V0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtaGVscGVycy5qcyIpLmhhcyxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1zaXplLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtc2V0LXJlY29yZC5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWl0ZXJhdGUuanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdGUtc2ltcGxlLmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyIpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1yKHRoaXMpLEE9aShlKTtpZihzKHQpPD1BLnNpemUpcmV0dXJuITEhPT1vKHQsZnVuY3Rpb24oZSl7aWYoQS5pbmNsdWRlcyhlKSlyZXR1cm4hMX0sITApO3ZhciBjPUEuZ2V0SXRlcmF0b3IoKTtyZXR1cm4hMSE9PWEoYyxmdW5jdGlvbihlKXtpZihuKHQsZSkpcmV0dXJuIGwoYywibm9ybWFsIiwhMSl9KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtaXMtc3Vic2V0LW9mLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Etc2V0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc2l6ZS5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWl0ZXJhdGUuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1zZXQtcmVjb3JkLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PXIodGhpcyksQT1pKGUpO3JldHVybiEobih0KT5BLnNpemUpJiYhMSE9PXModCxmdW5jdGlvbihlKXtpZighQS5pbmNsdWRlcyhlKSlyZXR1cm4hMX0sITApfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1pcy1zdXBlcnNldC1vZi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXNldC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWhlbHBlcnMuanMiKS5oYXMscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc2l6ZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LXNldC1yZWNvcmQuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdGUtc2ltcGxlLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyIpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1yKHRoaXMpLEE9aShlKTtpZihzKHQpPEEuc2l6ZSlyZXR1cm4hMTt2YXIgbD1BLmdldEl0ZXJhdG9yKCk7cmV0dXJuITEhPT1vKGwsZnVuY3Rpb24oZSl7aWYoIW4odCxlKSlyZXR1cm4gYShsLCJub3JtYWwiLCExKX0pfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1pdGVyYXRlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS1zaW1wbGUuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1oZWxwZXJzLmpzIiksaT1zLlNldCxvPXMucHJvdG8sYT1yKG8uZm9yRWFjaCksbD1yKG8ua2V5cyksYz1sKG5ldyBpKS5uZXh0O2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIEE/bih7aXRlcmF0b3I6bChlKSxuZXh0OmN9LHQpOmEoZSx0KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc2l6ZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtYWNjZXNzb3IuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1oZWxwZXJzLmpzIik7ZS5leHBvcnRzPXIobi5wcm90bywic2l6ZSIsImdldCIpfHxmdW5jdGlvbihlKXtyZXR1cm4gZS5zaXplfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1zcGVjaWVzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLWFjY2Vzc29yLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiKSxvPXMoInNwZWNpZXMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9cihlKTtpJiZ0JiYhdFtvXSYmbih0LG8se2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc3ltbWV0cmljLWRpZmZlcmVuY2UuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1zZXQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1oZWxwZXJzLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtY2xvbmUuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1zZXQtcmVjb3JkLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLXNpbXBsZS5qcyIpLGE9bi5hZGQsbD1uLmhhcyxjPW4ucmVtb3ZlO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1yKHRoaXMpLEE9aShlKS5nZXRJdGVyYXRvcigpLG49cyh0KTtyZXR1cm4gbyhBLGZ1bmN0aW9uKGUpe2wodCxlKT9jKG4sZSk6YShuLGUpfSksbn19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIikuZixuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIikoInRvU3RyaW5nVGFnIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxBKXtlJiYhQSYmKGU9ZS5wcm90b3R5cGUpLGUmJiFuKGUscykmJnIoZSxzLHtjb25maWd1cmFibGU6ITAsdmFsdWU6dH0pfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC11bmlvbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXNldC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWhlbHBlcnMuanMiKS5hZGQscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtY2xvbmUuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1zZXQtcmVjb3JkLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLXNpbXBsZS5qcyIpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1yKHRoaXMpLEE9aShlKS5nZXRJdGVyYXRvcigpLGE9cyh0KTtyZXR1cm4gbyhBLGZ1bmN0aW9uKGUpe24oYSxlKX0pLGF9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyIpLHM9cigia2V5cyIpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gc1tlXXx8KHNbZV09bihlKSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5LmpzIiksaT0iX19jb3JlLWpzX3NoYXJlZF9fIixvPWUuZXhwb3J0cz1uW2ldfHxzKGkse30pOyhvLnZlcnNpb25zfHwoby52ZXJzaW9ucz1bXSkpLnB1c2goe3ZlcnNpb246IjMuNDUuMSIsbW9kZTpyPyJwdXJlIjoiZ2xvYmFsIixjb3B5cmlnaHQ6IsKpIDIwMTQtMjAyNSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSIsbGljZW5zZToiaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My40NS4xL0xJQ0VOU0UiLHNvdXJjZToiaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMifSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHJbZV18fChyW2VdPXR8fHt9KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jb25zdHJ1Y3Rvci5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIikoInNwZWNpZXMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgQSxvPXIoZSkuY29uc3RydWN0b3I7cmV0dXJuIHZvaWQgMD09PW98fHMoQT1yKG8pW2ldKT90Om4oQSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLWh0bWwtZm9yY2VkLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiByKGZ1bmN0aW9uKCl7dmFyIHQ9IiJbZV0oJyInKTtyZXR1cm4gdCE9PXQudG9Mb3dlckNhc2UoKXx8dC5zcGxpdCgnIicpLmxlbmd0aD4zfSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHkuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIiksbz1yKCIiLmNoYXJBdCksYT1yKCIiLmNoYXJDb2RlQXQpLGw9cigiIi5zbGljZSksYz1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxBKXt2YXIgcixjLHU9cyhpKHQpKSxoPW4oQSksZD11Lmxlbmd0aDtyZXR1cm4gaDwwfHxoPj1kP2U/IiI6dm9pZCAwOihyPWEodSxoKSk8NTUyOTZ8fHI+NTYzMTl8fGgrMT09PWR8fChjPWEodSxoKzEpKTw1NjMyMHx8Yz41NzM0Mz9lP28odSxoKTpyOmU/bCh1LGgsaCsyKTpjLTU2MzIwKyhyLTU1Mjk2PDwxMCkrNjU1MzZ9fTtlLmV4cG9ydHM9e2NvZGVBdDpjKCExKSxjaGFyQXQ6YyghMCl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXRyaW0tZm9yY2VkLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMiKS5QUk9QRVIsbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2hpdGVzcGFjZXMuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIG4oZnVuY3Rpb24oKXtyZXR1cm4hIXNbZV0oKXx8IuKAi8KF4aCOIiE9PSLigIvCheGgjiJbZV0oKXx8ciYmc1tlXS5uYW1lIT09ZX0pfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy10cmltLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzIiksbz1yKCIiLnJlcGxhY2UpLGE9UmVnRXhwKCJeWyIraSsiXSsiKSxsPVJlZ0V4cCgiKF58W14iK2krIl0pWyIraSsiXSskIiksYz1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIEE9cyhuKHQpKTtyZXR1cm4gMSZlJiYoQT1vKEEsYSwiIikpLDImZSYmKEE9byhBLGwsIiQxIikpLEF9fTtlLmV4cG9ydHM9e3N0YXJ0OmMoMSksZW5kOmMoMiksdHJpbTpjKDMpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdjgtdmVyc2lvbi5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIikuU3RyaW5nO2UuZXhwb3J0cz0hIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJiFuKGZ1bmN0aW9uKCl7dmFyIGU9U3ltYm9sKCJzeW1ib2wgZGV0ZWN0aW9uIik7cmV0dXJuIXMoZSl8fCEoT2JqZWN0KGUpaW5zdGFuY2VvZiBTeW1ib2wpfHwhU3ltYm9sLnNoYW0mJnImJnI8NDF9KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N5bWJvbC1kZWZpbmUtdG8tcHJpbWl0aXZlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcyIpO2UuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciBlPW4oIlN5bWJvbCIpLHQ9ZSYmZS5wcm90b3R5cGUsQT10JiZ0LnZhbHVlT2Ysbz1zKCJ0b1ByaW1pdGl2ZSIpO3QmJiF0W29dJiZpKHQsbyxmdW5jdGlvbihlKXtyZXR1cm4gcihBLHRoaXMpfSx7YXJpdHk6MX0pfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N5bWJvbC1yZWdpc3RyeS1kZXRlY3Rpb24uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyIpO2UuZXhwb3J0cz1yJiYhIVN5bWJvbC5mb3ImJiEhU3ltYm9sLmtleUZvcn0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Rhc2suanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHIsbixzLGksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHkuanMiKSxsPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiKSx1PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIiksZD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiksZj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zbGljZS5qcyIpLHA9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMiKSxnPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3ZhbGlkYXRlLWFyZ3VtZW50cy1sZW5ndGguanMiKSxtPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LWlzLWlvcy5qcyIpLHc9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQtaXMtbm9kZS5qcyIpLEI9by5zZXRJbW1lZGlhdGUseT1vLmNsZWFySW1tZWRpYXRlLHY9by5wcm9jZXNzLGI9by5EaXNwYXRjaCxDPW8uRnVuY3Rpb24sXz1vLk1lc3NhZ2VDaGFubmVsLGo9by5TdHJpbmcseD0wLEY9e30sUT0ib25yZWFkeXN0YXRlY2hhbmdlIjtoKGZ1bmN0aW9uKCl7cj1vLmxvY2F0aW9ufSk7dmFyIFU9ZnVuY3Rpb24oZSl7aWYodShGLGUpKXt2YXIgdD1GW2VdO2RlbGV0ZSBGW2VdLHQoKX19LEU9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7VShlKX19LFM9ZnVuY3Rpb24oZSl7VShlLmRhdGEpfSxMPWZ1bmN0aW9uKGUpe28ucG9zdE1lc3NhZ2UoaihlKSxyLnByb3RvY29sKyIvLyIrci5ob3N0KX07QiYmeXx8KEI9ZnVuY3Rpb24oZSl7Zyhhcmd1bWVudHMubGVuZ3RoLDEpO3ZhciB0PWMoZSk/ZTpDKGUpLEE9Zihhcmd1bWVudHMsMSk7cmV0dXJuIEZbKyt4XT1mdW5jdGlvbigpe2EodCx2b2lkIDAsQSl9LG4oeCkseH0seT1mdW5jdGlvbihlKXtkZWxldGUgRltlXX0sdz9uPWZ1bmN0aW9uKGUpe3YubmV4dFRpY2soRShlKSl9OmImJmIubm93P249ZnVuY3Rpb24oZSl7Yi5ub3coRShlKSl9Ol8mJiFtPyhpPShzPW5ldyBfKS5wb3J0MixzLnBvcnQxLm9ubWVzc2FnZT1TLG49bChpLnBvc3RNZXNzYWdlLGkpKTpvLmFkZEV2ZW50TGlzdGVuZXImJmMoby5wb3N0TWVzc2FnZSkmJiFvLmltcG9ydFNjcmlwdHMmJnImJiJmaWxlOiIhPT1yLnByb3RvY29sJiYhaChMKT8obj1MLG8uYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsUywhMSkpOm49USBpbiBwKCJzY3JpcHQiKT9mdW5jdGlvbihlKXtkLmFwcGVuZENoaWxkKHAoInNjcmlwdCIpKVtRXT1mdW5jdGlvbigpe2QucmVtb3ZlQ2hpbGQodGhpcyksVShlKX19OmZ1bmN0aW9uKGUpe3NldFRpbWVvdXQoRShlKSwwKX0pLGUuZXhwb3J0cz17c2V0OkIsY2xlYXI6eX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90aGlzLW51bWJlci12YWx1ZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKTtlLmV4cG9ydHM9cigxLjEudmFsdWVPZil9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzIiksbj1NYXRoLm1heCxzPU1hdGgubWluO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3ZhciBBPXIoZSk7cmV0dXJuIEE8MD9uKEErdCwwKTpzKEEsdCl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gcihuKGUpKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL21hdGgtdHJ1bmMuanMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9K2U7cmV0dXJuIHQhPXR8fDA9PT10PzA6cih0KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eS5qcyIpLG49TWF0aC5taW47ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PXIoZSk7cmV0dXJuIHQ+MD9uKHQsOTAwNzE5OTI1NDc0MDk5MSk6MH19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIiksbj1PYmplY3Q7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBuKHIoZSkpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIpLGw9VHlwZUVycm9yLGM9YSgidG9QcmltaXRpdmUiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtpZighbihlKXx8cyhlKSlyZXR1cm4gZTt2YXIgQSxhPWkoZSxjKTtpZihhKXtpZih2b2lkIDA9PT10JiYodD0iZGVmYXVsdCIpLEE9cihhLGUsdCksIW4oQSl8fHMoQSkpcmV0dXJuIEE7dGhyb3cgbmV3IGwoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpfXJldHVybiB2b2lkIDA9PT10JiYodD0ibnVtYmVyIiksbyhlLHQpfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcyIpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1yKGUsInN0cmluZyIpO3JldHVybiBuKHQpP3Q6dCsiIn19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zZXQtbGlrZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1pdGVyYWJsZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiksbz1yKCJTZXQiKTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBpKGUpJiYibnVtYmVyIj09dHlwZW9mIGUuc2l6ZSYmbihlLmhhcykmJm4oZS5rZXlzKX0oZSk/ZTpzKGUpP25ldyBvKGUpOmV9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPXt9O3JbQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiKSgidG9TdHJpbmdUYWciKV09InoiLGUuZXhwb3J0cz0iW29iamVjdCB6XSI9PT1TdHJpbmcocil9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyIpLG49U3RyaW5nO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtpZigiU3ltYm9sIj09PXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmciKTtyZXR1cm4gbihlKX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzIjpmdW5jdGlvbihlKXsidXNlIHN0cmljdCI7dmFyIHQ9U3RyaW5nO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt0cnl7cmV0dXJuIHQoZSl9Y2F0Y2goZSl7cmV0dXJuIk9iamVjdCJ9fX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxuPTAscz1NYXRoLnJhbmRvbSgpLGk9cigxLjEudG9TdHJpbmcpO2UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4iU3ltYm9sKCIrKHZvaWQgMD09PWU/IiI6ZSkrIilfIitpKCsrbitzLDM2KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzIik7ZS5leHBvcnRzPXImJiFTeW1ib2wuc2hhbSYmInN5bWJvbCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3J9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1Zy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKTtlLmV4cG9ydHM9ciYmbihmdW5jdGlvbigpe3JldHVybiA0MiE9PU9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbigpe30sInByb3RvdHlwZSIse3ZhbHVlOjQyLHdyaXRhYmxlOiExfSkucHJvdG90eXBlfSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92YWxpZGF0ZS1hcmd1bWVudHMtbGVuZ3RoLmpzIjpmdW5jdGlvbihlKXsidXNlIHN0cmljdCI7dmFyIHQ9VHlwZUVycm9yO2UuZXhwb3J0cz1mdW5jdGlvbihlLEEpe2lmKGU8QSl0aHJvdyBuZXcgdCgiTm90IGVub3VnaCBhcmd1bWVudHMiKTtyZXR1cm4gZX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWFrLW1hcC1iYXNpYy1kZXRlY3Rpb24uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIikscz1yLldlYWtNYXA7ZS5leHBvcnRzPW4ocykmJi9uYXRpdmUgY29kZS8udGVzdChTdHJpbmcocykpfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiKS5mO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1yLlN5bWJvbHx8KHIuU3ltYm9sPXt9KTtuKHQsZSl8fGkodCxlLHt2YWx1ZTpzLmYoZSl9KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIik7dC5mPXJ9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24uanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIiksbD1yLlN5bWJvbCxjPW4oIndrcyIpLHU9YT9sLmZvcnx8bDpsJiZsLndpdGhvdXRTZXR0ZXJ8fGk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBzKGMsZSl8fChjW2VdPW8mJnMobCxlKT9sW2VdOnUoIlN5bWJvbC4iK2UpKSxjW2VdfX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzIjpmdW5jdGlvbihlKXsidXNlIHN0cmljdCI7ZS5leHBvcnRzPSJcdFxuXHZcZlxyIMKg4ZqA4oCA4oCB4oCC4oCD4oCE4oCF4oCG4oCH4oCI4oCJ4oCK4oCv4oGf44CAXHUyMDI4XHUyMDI5XHVmZWZmIn0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlci5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIpLGg9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMiKSxkPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIiksZj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uLmpzIikscD1kKCJpc0NvbmNhdFNwcmVhZGFibGUiKSxnPWY+PTUxfHwhbihmdW5jdGlvbigpe3ZhciBlPVtdO3JldHVybiBlW3BdPSExLGUuY29uY2F0KClbMF0hPT1lfSksbT1mdW5jdGlvbihlKXtpZighaShlKSlyZXR1cm4hMTt2YXIgdD1lW3BdO3JldHVybiB2b2lkIDAhPT10PyEhdDpzKGUpfTtyKHt0YXJnZXQ6IkFycmF5Iixwcm90bzohMCxhcml0eToxLGZvcmNlZDohZ3x8IWgoImNvbmNhdCIpfSx7Y29uY2F0OmZ1bmN0aW9uKGUpe3ZhciB0LEEscixuLHMsaT1vKHRoaXMpLGg9dShpLDApLGQ9MDtmb3IodD0tMSxyPWFyZ3VtZW50cy5sZW5ndGg7dDxyO3QrKylpZihtKHM9LTE9PT10P2k6YXJndW1lbnRzW3RdKSlmb3Iobj1hKHMpLGwoZCtuKSxBPTA7QTxuO0ErKyxkKyspQSBpbiBzJiZjKGgsZCxzW0FdKTtlbHNlIGwoZCsxKSxjKGgsZCsrLHMpO3JldHVybiBoLmxlbmd0aD1kLGh9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZyb20uanMiKTtyKHt0YXJnZXQ6IkFycmF5IixzdGF0OiEwLGZvcmNlZDohQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIikoZnVuY3Rpb24oZSl7QXJyYXkuZnJvbShlKX0pfSx7ZnJvbTpufSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtY2xhdXNlLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyIpLmluZGV4T2YsaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0LmpzIiksbz1uKFtdLmluZGV4T2YpLGE9ISFvJiYxL28oWzFdLDEsLTApPDA7cih7dGFyZ2V0OiJBcnJheSIscHJvdG86ITAsZm9yY2VkOmF8fCFpKCJpbmRleE9mIil9LHtpbmRleE9mOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwO3JldHVybiBhP28odGhpcyxlLHQpfHwwOnModGhpcyxlLHQpfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiKS5mLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lLmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0LmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyIpLGg9IkFycmF5IEl0ZXJhdG9yIixkPWkuc2V0LGY9aS5nZXR0ZXJGb3IoaCk7ZS5leHBvcnRzPWEoQXJyYXksIkFycmF5IixmdW5jdGlvbihlLHQpe2QodGhpcyx7dHlwZTpoLHRhcmdldDpyKGUpLGluZGV4OjAsa2luZDp0fSl9LGZ1bmN0aW9uKCl7dmFyIGU9Zih0aGlzKSx0PWUudGFyZ2V0LEE9ZS5pbmRleCsrO2lmKCF0fHxBPj10Lmxlbmd0aClyZXR1cm4gZS50YXJnZXQ9bnVsbCxsKHZvaWQgMCwhMCk7c3dpdGNoKGUua2luZCl7Y2FzZSJrZXlzIjpyZXR1cm4gbChBLCExKTtjYXNlInZhbHVlcyI6cmV0dXJuIGwodFtBXSwhMSl9cmV0dXJuIGwoW0EsdFtBXV0sITEpfSwidmFsdWVzIik7dmFyIHA9cy5Bcmd1bWVudHM9cy5BcnJheTtpZihuKCJrZXlzIiksbigidmFsdWVzIiksbigiZW50cmllcyIpLCFjJiZ1JiYidmFsdWVzIiE9PXAubmFtZSl0cnl7byhwLCJuYW1lIix7dmFsdWU6InZhbHVlcyJ9KX1jYXRjaChlKXt9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdC5qcyIpLGE9bihbXS5qb2luKTtyKHt0YXJnZXQ6IkFycmF5Iixwcm90bzohMCxmb3JjZWQ6cyE9PU9iamVjdHx8IW8oImpvaW4iLCIsIil9LHtqb2luOmZ1bmN0aW9uKGUpe3JldHVybiBhKGkodGhpcyksdm9pZCAwPT09ZT8iLCI6ZSl9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uLmpzIikubWFwO3Ioe3RhcmdldDoiQXJyYXkiLHByb3RvOiEwLGZvcmNlZDohQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMiKSgibWFwIil9LHttYXA6ZnVuY3Rpb24oZSl7cmV0dXJuIG4odGhpcyxlLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1yZWR1Y2UuanMiKS5sZWZ0LHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdjgtdmVyc2lvbi5qcyIpO3Ioe3RhcmdldDoiQXJyYXkiLHByb3RvOiEwLGZvcmNlZDohQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW52aXJvbm1lbnQtaXMtbm9kZS5qcyIpJiZpPjc5JiZpPDgzfHwhcygicmVkdWNlIil9LHtyZWR1Y2U6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aDtyZXR1cm4gbih0aGlzLGUsdCx0PjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmV2ZXJzZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiKSxpPW4oW10ucmV2ZXJzZSksbz1bMSwyXTtyKHt0YXJnZXQ6IkFycmF5Iixwcm90bzohMCxmb3JjZWQ6U3RyaW5nKG8pPT09U3RyaW5nKG8ucmV2ZXJzZSgpKX0se3JldmVyc2U6ZnVuY3Rpb24oKXtyZXR1cm4gcyh0aGlzKSYmKHRoaXMubGVuZ3RoPXRoaXMubGVuZ3RoKSxpKHRoaXMpfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNvbnN0cnVjdG9yLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcyIpLHU9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0LmpzIiksZD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zbGljZS5qcyIpLGY9aCgic2xpY2UiKSxwPXUoInNwZWNpZXMiKSxnPUFycmF5LG09TWF0aC5tYXg7cih7dGFyZ2V0OiJBcnJheSIscHJvdG86ITAsZm9yY2VkOiFmfSx7c2xpY2U6ZnVuY3Rpb24oZSx0KXt2YXIgQSxyLHUsaD1sKHRoaXMpLGY9YShoKSx3PW8oZSxmKSxCPW8odm9pZCAwPT09dD9mOnQsZik7aWYobihoKSYmKEE9aC5jb25zdHJ1Y3RvciwocyhBKSYmKEE9PT1nfHxuKEEucHJvdG90eXBlKSl8fGkoQSkmJm51bGw9PT0oQT1BW3BdKSkmJihBPXZvaWQgMCksQT09PWd8fHZvaWQgMD09PUEpKXJldHVybiBkKGgsdyxCKTtmb3Iocj1uZXcodm9pZCAwPT09QT9nOkEpKG0oQi13LDApKSx1PTA7dzxCO3crKyx1KyspdyBpbiBoJiZjKHIsdSxoW3ddKTtyZXR1cm4gci5sZW5ndGg9dSxyfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMiKS5FWElTVFMscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3Nvci5qcyIpLG89RnVuY3Rpb24ucHJvdG90eXBlLGE9cyhvLnRvU3RyaW5nKSxsPS9mdW5jdGlvblxiKD86XHN8XC9cKltcU1xzXSo/XCpcL3xcL1wvW15cblxyXSpbXG5ccl0rKSooW15ccygvXSopLyxjPXMobC5leGVjKTtyJiYhbiYmaShvLCJuYW1lIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3RyeXtyZXR1cm4gYyhsLGEodGhpcykpWzFdfWNhdGNoKGUpe3JldHVybiIifX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci5jb25zdHJ1Y3Rvci5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanMiKSxsPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3Nvci5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpLGg9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qcyIpLGQ9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiKSxmPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzIikuSXRlcmF0b3JQcm90b3R5cGUscD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyIpLGc9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyIpLG09ImNvbnN0cnVjdG9yIix3PSJJdGVyYXRvciIsQj1kKCJ0b1N0cmluZ1RhZyIpLHk9VHlwZUVycm9yLHY9blt3XSxiPWd8fCFvKHYpfHx2LnByb3RvdHlwZSE9PWZ8fCF1KGZ1bmN0aW9uKCl7dih7fSl9KSxDPWZ1bmN0aW9uKCl7aWYocyh0aGlzLGYpLGEodGhpcyk9PT1mKXRocm93IG5ldyB5KCJBYnN0cmFjdCBjbGFzcyBJdGVyYXRvciBub3QgZGlyZWN0bHkgY29uc3RydWN0YWJsZSIpfSxfPWZ1bmN0aW9uKGUsdCl7cD9sKGYsZSx7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0fSxzZXQ6ZnVuY3Rpb24odCl7aWYoaSh0aGlzKSx0aGlzPT09Zil0aHJvdyBuZXcgeSgiWW91IGNhbid0IHJlZGVmaW5lIHRoaXMgcHJvcGVydHkiKTtoKHRoaXMsZSk/dGhpc1tlXT10OmModGhpcyxlLHQpfX0pOmZbZV09dH07aChmLEIpfHxfKEIsdyksIWImJmgoZixtKSYmZlttXSE9PU9iamVjdHx8XyhtLEMpLEMucHJvdG90eXBlPWYscih7Z2xvYmFsOiEwLGNvbnN0cnVjdG9yOiEwLGZvcmNlZDpifSx7SXRlcmF0b3I6Q30pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLml0ZXJhdG9yLmZvci1lYWNoLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0ZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItZGlyZWN0LmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItaGVscGVyLXdpdGhvdXQtY2xvc2luZy1vbi1lYXJseS1lcnJvci5qcyIpKCJmb3JFYWNoIixUeXBlRXJyb3IpO3Ioe3RhcmdldDoiSXRlcmF0b3IiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOmN9LHtmb3JFYWNoOmZ1bmN0aW9uKGUpe28odGhpcyk7dHJ5e2koZSl9Y2F0Y2goZSl7bCh0aGlzLCJ0aHJvdyIsZSl9aWYoYylyZXR1cm4gbihjLHRoaXMsZSk7dmFyIHQ9YSh0aGlzKSxBPTA7cyh0LGZ1bmN0aW9uKHQpe2UodCxBKyspfSx7SVNfUkVDT1JEOiEwfSl9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IubWFwLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItZGlyZWN0LmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jcmVhdGUtcHJveHkuanMiKSxsPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyIpLHU9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItaGVscGVyLXRocm93cy1vbi1pbnZhbGlkLWl0ZXJhdG9yLmpzIiksaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1oZWxwZXItd2l0aG91dC1jbG9zaW5nLW9uLWVhcmx5LWVycm9yLmpzIiksZD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiksZj0hZCYmIXUoIm1hcCIsZnVuY3Rpb24oKXt9KSxwPSFkJiYhZiYmaCgibWFwIixUeXBlRXJyb3IpLGc9ZHx8Znx8cCxtPWEoZnVuY3Rpb24oKXt2YXIgZT10aGlzLml0ZXJhdG9yLHQ9aShuKHRoaXMubmV4dCxlKSk7aWYoISh0aGlzLmRvbmU9ISF0LmRvbmUpKXJldHVybiBsKGUsdGhpcy5tYXBwZXIsW3QudmFsdWUsdGhpcy5jb3VudGVyKytdLCEwKX0pO3Ioe3RhcmdldDoiSXRlcmF0b3IiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOmd9LHttYXA6ZnVuY3Rpb24oZSl7aSh0aGlzKTt0cnl7cyhlKX1jYXRjaChlKXtjKHRoaXMsInRocm93IixlKX1yZXR1cm4gcD9uKHAsdGhpcyxlKTpuZXcgbShvKHRoaXMpLHttYXBwZXI6ZX0pfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmpzb24uc3RyaW5naWZ5LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1hcHBseS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcyIpLHU9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc2xpY2UuanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1qc29uLXJlcGxhY2VyLWZ1bmN0aW9uLmpzIiksZD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzIiksZj1TdHJpbmcscD1uKCJKU09OIiwic3RyaW5naWZ5IiksZz1vKC8uLy5leGVjKSxtPW8oIiIuY2hhckF0KSx3PW8oIiIuY2hhckNvZGVBdCksQj1vKCIiLnJlcGxhY2UpLHk9bygxLjEudG9TdHJpbmcpLHY9L1tcdUQ4MDAtXHVERkZGXS9nLGI9L15bXHVEODAwLVx1REJGRl0kLyxDPS9eW1x1REMwMC1cdURGRkZdJC8sXz0hZHx8YShmdW5jdGlvbigpe3ZhciBlPW4oIlN5bWJvbCIpKCJzdHJpbmdpZnkgZGV0ZWN0aW9uIik7cmV0dXJuIltudWxsXSIhPT1wKFtlXSl8fCJ7fSIhPT1wKHthOmV9KXx8Int9IiE9PXAoT2JqZWN0KGUpKX0pLGo9YShmdW5jdGlvbigpe3JldHVybiciXFx1ZGYwNlxcdWQ4MzQiJyE9PXAoIlx1ZGYwNlx1ZDgzNCIpfHwnIlxcdWRlYWQiJyE9PXAoIlx1ZGVhZCIpfSkseD1mdW5jdGlvbihlLHQpe3ZhciBBPXUoYXJndW1lbnRzKSxyPWgodCk7aWYobChyKXx8dm9pZCAwIT09ZSYmIWMoZSkpcmV0dXJuIEFbMV09ZnVuY3Rpb24oZSx0KXtpZihsKHIpJiYodD1pKHIsdGhpcyxmKGUpLHQpKSwhYyh0KSlyZXR1cm4gdH0scyhwLG51bGwsQSl9LEY9ZnVuY3Rpb24oZSx0LEEpe3ZhciByPW0oQSx0LTEpLG49bShBLHQrMSk7cmV0dXJuIGcoYixlKSYmIWcoQyxuKXx8ZyhDLGUpJiYhZyhiLHIpPyJcXHUiK3kodyhlLDApLDE2KTplfTtwJiZyKHt0YXJnZXQ6IkpTT04iLHN0YXQ6ITAsYXJpdHk6Myxmb3JjZWQ6X3x8an0se3N0cmluZ2lmeTpmdW5jdGlvbihlLHQsQSl7dmFyIHI9dShhcmd1bWVudHMpLG49cyhfP3g6cCxudWxsLHIpO3JldHVybiBqJiYic3RyaW5nIj09dHlwZW9mIG4/QihuLHYsRik6bn19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3IuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiksaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mLmpzIiksZD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMiKSxmPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIpLHA9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKSxnPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIikuZixtPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiKS5mLHc9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIpLmYsQj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90aGlzLW51bWJlci12YWx1ZS5qcyIpLHk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXRyaW0uanMiKS50cmltLHY9Ik51bWJlciIsYj1pW3ZdLEM9b1t2XSxfPWIucHJvdG90eXBlLGo9aS5UeXBlRXJyb3IseD1hKCIiLnNsaWNlKSxGPWEoIiIuY2hhckNvZGVBdCksUT1sKHYsIWIoIiAwbzEiKXx8IWIoIjBiMSIpfHxiKCIrMHgxIikpLFU9ZnVuY3Rpb24oZSl7dmFyIHQsQT1hcmd1bWVudHMubGVuZ3RoPDE/MDpiKGZ1bmN0aW9uKGUpe3ZhciB0PWYoZSwibnVtYmVyIik7cmV0dXJuImJpZ2ludCI9PXR5cGVvZiB0P3Q6ZnVuY3Rpb24oZSl7dmFyIHQsQSxyLG4scyxpLG8sYSxsPWYoZSwibnVtYmVyIik7aWYoZChsKSl0aHJvdyBuZXcgaigiQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBudW1iZXIiKTtpZigic3RyaW5nIj09dHlwZW9mIGwmJmwubGVuZ3RoPjIpaWYobD15KGwpLDQzPT09KHQ9RihsLDApKXx8NDU9PT10KXtpZig4OD09PShBPUYobCwyKSl8fDEyMD09PUEpcmV0dXJuIE5hTn1lbHNlIGlmKDQ4PT09dCl7c3dpdGNoKEYobCwxKSl7Y2FzZSA2NjpjYXNlIDk4OnI9MixuPTQ5O2JyZWFrO2Nhc2UgNzk6Y2FzZSAxMTE6cj04LG49NTU7YnJlYWs7ZGVmYXVsdDpyZXR1cm4rbH1mb3IoaT0ocz14KGwsMikpLmxlbmd0aCxvPTA7bzxpO28rKylpZigoYT1GKHMsbykpPDQ4fHxhPm4pcmV0dXJuIE5hTjtyZXR1cm4gcGFyc2VJbnQocyxyKX1yZXR1cm4rbH0odCl9KGUpKTtyZXR1cm4gaChfLHQ9dGhpcykmJnAoZnVuY3Rpb24oKXtCKHQpfSk/dShPYmplY3QoQSksdGhpcyxVKTpBfTtVLnByb3RvdHlwZT1fLFEmJiFuJiYoXy5jb25zdHJ1Y3Rvcj1VKSxyKHtnbG9iYWw6ITAsY29uc3RydWN0b3I6ITAsd3JhcDohMCxmb3JjZWQ6UX0se051bWJlcjpVfSk7dmFyIEU9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIEEscj1zP2codCk6Ik1BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLEVQU0lMT04sTUFYX1NBRkVfSU5URUdFUixNSU5fU0FGRV9JTlRFR0VSLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLHBhcnNlRmxvYXQscGFyc2VJbnQsZnJvbVN0cmluZyxyYW5nZSIuc3BsaXQoIiwiKSxuPTA7ci5sZW5ndGg+bjtuKyspYyh0LEE9cltuXSkmJiFjKGUsQSkmJncoZSxBLG0odCxBKSl9O24mJkMmJkUob1t2XSxDKSwoUXx8bikmJkUob1t2XSxiKX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qcyIpO3Ioe3RhcmdldDoiT2JqZWN0IixzdGF0OiEwLGFyaXR5OjIsZm9yY2VkOk9iamVjdC5hc3NpZ24hPT1ufSx7YXNzaWduOm59KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIpO3Ioe3RhcmdldDoiT2JqZWN0IixzdGF0OiEwLGZvcmNlZDohbnx8cyhmdW5jdGlvbigpe2kuZigxKX0pfSx7Z2V0T3duUHJvcGVydHlTeW1ib2xzOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZjtyZXR1cm4gdD90KG8oZSkpOltdfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qcyIpO3Ioe3RhcmdldDoiT2JqZWN0IixzdGF0OiEwLGZvcmNlZDpBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpKGZ1bmN0aW9uKCl7cygxKX0pfSx7a2V5czpmdW5jdGlvbihlKXtyZXR1cm4gcyhuKGUpKX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzIik7cnx8bihPYmplY3QucHJvdG90eXBlLCJ0b1N0cmluZyIscyx7dW5zYWZlOiEwfSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5hbGwuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWNhbGxhYmxlLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wZXJmb3JtLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzIik7cih7dGFyZ2V0OiJQcm9taXNlIixzdGF0OiEwLGZvcmNlZDpBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLXN0YXRpY3MtaW5jb3JyZWN0LWl0ZXJhdGlvbi5qcyIpfSx7YWxsOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsQT1pLmYodCkscj1BLnJlc29sdmUsbD1BLnJlamVjdCxjPW8oZnVuY3Rpb24oKXt2YXIgQT1zKHQucmVzb2x2ZSksaT1bXSxvPTAsYz0xO2EoZSxmdW5jdGlvbihlKXt2YXIgcz1vKyssYT0hMTtjKyssbihBLHQsZSkudGhlbihmdW5jdGlvbihlKXthfHwoYT0hMCxpW3NdPWUsLS1jfHxyKGkpKX0sbCl9KSwtLWN8fHIoaSl9KTtyZXR1cm4gYy5lcnJvciYmbChjLnZhbHVlKSxBLnByb21pc2V9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5jYXRjaC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Byb21pc2UtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzIikuQ09OU1RSVUNUT1IsaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLW5hdGl2ZS1jb25zdHJ1Y3Rvci5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLmpzIiksYz1pJiZpLnByb3RvdHlwZTtpZihyKHt0YXJnZXQ6IlByb21pc2UiLHByb3RvOiEwLGZvcmNlZDpzLHJlYWw6ITB9LHtjYXRjaDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxlKX19KSwhbiYmYShpKSl7dmFyIHU9bygiUHJvbWlzZSIpLnByb3RvdHlwZS5jYXRjaDtjLmNhdGNoIT09dSYmbChjLCJjYXRjaCIsdSx7dW5zYWZlOiEwfSl9fSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuY29uc3RydWN0b3IuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHIsbixzLGksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiKSxsPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Vudmlyb25tZW50LWlzLW5vZGUuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzIiksaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIiksZD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanMiKSxmPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIikscD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyIpLGc9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXNwZWNpZXMuanMiKSxtPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiKSx3PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiksQj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiKSx5PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLWluc3RhbmNlLmpzIiksdj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiksYj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90YXNrLmpzIikuc2V0LEM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWljcm90YXNrLmpzIiksXz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9ob3N0LXJlcG9ydC1lcnJvcnMuanMiKSxqPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BlcmZvcm0uanMiKSx4PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3F1ZXVlLmpzIiksRj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIpLFE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJvbWlzZS1uYXRpdmUtY29uc3RydWN0b3IuanMiKSxVPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Byb21pc2UtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzIiksRT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiksUz0iUHJvbWlzZSIsTD1VLkNPTlNUUlVDVE9SLEk9VS5SRUpFQ1RJT05fRVZFTlQsTj1VLlNVQkNMQVNTSU5HLGs9Ri5nZXR0ZXJGb3IoUyksSD1GLnNldCxQPVEmJlEucHJvdG90eXBlLFQ9USxPPVAsTT1jLlR5cGVFcnJvcixEPWMuZG9jdW1lbnQsUj1jLnByb2Nlc3MsSz1FLmYsVj1LLEc9ISEoRCYmRC5jcmVhdGVFdmVudCYmYy5kaXNwYXRjaEV2ZW50KSx6PSJ1bmhhbmRsZWRyZWplY3Rpb24iLHE9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuISghQihlKXx8IXcodD1lLnRoZW4pKSYmdH0sVz1mdW5jdGlvbihlLHQpe3ZhciBBLHIsbixzPXQudmFsdWUsaT0xPT09dC5zdGF0ZSxvPWk/ZS5vazplLmZhaWwsYT1lLnJlc29sdmUsbD1lLnJlamVjdCxjPWUuZG9tYWluO3RyeXtvPyhpfHwoMj09PXQucmVqZWN0aW9uJiYkKHQpLHQucmVqZWN0aW9uPTEpLCEwPT09bz9BPXM6KGMmJmMuZW50ZXIoKSxBPW8ocyksYyYmKGMuZXhpdCgpLG49ITApKSxBPT09ZS5wcm9taXNlP2wobmV3IE0oIlByb21pc2UtY2hhaW4gY3ljbGUiKSk6KHI9cShBKSk/aChyLEEsYSxsKTphKEEpKTpsKHMpfWNhdGNoKGUpe2MmJiFuJiZjLmV4aXQoKSxsKGUpfX0sWD1mdW5jdGlvbihlLHQpe2Uubm90aWZpZWR8fChlLm5vdGlmaWVkPSEwLEMoZnVuY3Rpb24oKXtmb3IodmFyIEEscj1lLnJlYWN0aW9ucztBPXIuZ2V0KCk7KVcoQSxlKTtlLm5vdGlmaWVkPSExLHQmJiFlLnJlamVjdGlvbiYmSihlKX0pKX0sWT1mdW5jdGlvbihlLHQsQSl7dmFyIHIsbjtHPygocj1ELmNyZWF0ZUV2ZW50KCJFdmVudCIpKS5wcm9taXNlPXQsci5yZWFzb249QSxyLmluaXRFdmVudChlLCExLCEwKSxjLmRpc3BhdGNoRXZlbnQocikpOnI9e3Byb21pc2U6dCxyZWFzb246QX0sIUkmJihuPWNbIm9uIitlXSk/bihyKTplPT09eiYmXygiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIixBKX0sSj1mdW5jdGlvbihlKXtoKGIsYyxmdW5jdGlvbigpe3ZhciB0LEE9ZS5mYWNhZGUscj1lLnZhbHVlO2lmKFooZSkmJih0PWooZnVuY3Rpb24oKXtsP1IuZW1pdCgidW5oYW5kbGVkUmVqZWN0aW9uIixyLEEpOlkoeixBLHIpfSksZS5yZWplY3Rpb249bHx8WihlKT8yOjEsdC5lcnJvcikpdGhyb3cgdC52YWx1ZX0pfSxaPWZ1bmN0aW9uKGUpe3JldHVybiAxIT09ZS5yZWplY3Rpb24mJiFlLnBhcmVudH0sJD1mdW5jdGlvbihlKXtoKGIsYyxmdW5jdGlvbigpe3ZhciB0PWUuZmFjYWRlO2w/Ui5lbWl0KCJyZWplY3Rpb25IYW5kbGVkIix0KTpZKCJyZWplY3Rpb25oYW5kbGVkIix0LGUudmFsdWUpfSl9LGVlPWZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gZnVuY3Rpb24ocil7ZSh0LHIsQSl9fSx0ZT1mdW5jdGlvbihlLHQsQSl7ZS5kb25lfHwoZS5kb25lPSEwLEEmJihlPUEpLGUudmFsdWU9dCxlLnN0YXRlPTIsWChlLCEwKSl9LEFlPWZ1bmN0aW9uKGUsdCxBKXtpZighZS5kb25lKXtlLmRvbmU9ITAsQSYmKGU9QSk7dHJ5e2lmKGUuZmFjYWRlPT09dCl0aHJvdyBuZXcgTSgiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGYiKTt2YXIgcj1xKHQpO3I/QyhmdW5jdGlvbigpe3ZhciBBPXtkb25lOiExfTt0cnl7aChyLHQsZWUoQWUsQSxlKSxlZSh0ZSxBLGUpKX1jYXRjaCh0KXt0ZShBLHQsZSl9fSk6KGUudmFsdWU9dCxlLnN0YXRlPTEsWChlLCExKSl9Y2F0Y2godCl7dGUoe2RvbmU6ITF9LHQsZSl9fX07aWYoTCYmKE89KFQ9ZnVuY3Rpb24oZSl7eSh0aGlzLE8pLG0oZSksaChyLHRoaXMpO3ZhciB0PWsodGhpcyk7dHJ5e2UoZWUoQWUsdCksZWUodGUsdCkpfWNhdGNoKGUpe3RlKHQsZSl9fSkucHJvdG90eXBlLChyPWZ1bmN0aW9uKGUpe0godGhpcyx7dHlwZTpTLGRvbmU6ITEsbm90aWZpZWQ6ITEscGFyZW50OiExLHJlYWN0aW9uczpuZXcgeCxyZWplY3Rpb246ITEsc3RhdGU6MCx2YWx1ZTpudWxsfSl9KS5wcm90b3R5cGU9ZChPLCJ0aGVuIixmdW5jdGlvbihlLHQpe3ZhciBBPWsodGhpcykscj1LKHYodGhpcyxUKSk7cmV0dXJuIEEucGFyZW50PSEwLHIub2s9IXcoZSl8fGUsci5mYWlsPXcodCkmJnQsci5kb21haW49bD9SLmRvbWFpbjp2b2lkIDAsMD09PUEuc3RhdGU/QS5yZWFjdGlvbnMuYWRkKHIpOkMoZnVuY3Rpb24oKXtXKHIsQSl9KSxyLnByb21pc2V9KSxuPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IHIsdD1rKGUpO3RoaXMucHJvbWlzZT1lLHRoaXMucmVzb2x2ZT1lZShBZSx0KSx0aGlzLnJlamVjdD1lZSh0ZSx0KX0sRS5mPUs9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1UfHxlPT09cz9uZXcgbihlKTpWKGUpfSwhYSYmdyhRKSYmUCE9PU9iamVjdC5wcm90b3R5cGUpKXtpPVAudGhlbixOfHxkKFAsInRoZW4iLGZ1bmN0aW9uKGUsdCl7dmFyIEE9dGhpcztyZXR1cm4gbmV3IFQoZnVuY3Rpb24oZSx0KXtoKGksQSxlLHQpfSkudGhlbihlLHQpfSx7dW5zYWZlOiEwfSk7dHJ5e2RlbGV0ZSBQLmNvbnN0cnVjdG9yfWNhdGNoKGUpe31mJiZmKFAsTyl9byh7Z2xvYmFsOiEwLGNvbnN0cnVjdG9yOiEwLHdyYXA6ITAsZm9yY2VkOkx9LHtQcm9taXNlOlR9KSxzPXUuUHJvbWlzZSxwKFQsUywhMSwhMCksZyhTKX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0EoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmNvbnN0cnVjdG9yLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuYWxsLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuY2F0Y2guanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5yYWNlLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UucmVqZWN0LmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UucmVzb2x2ZS5qcyIpfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UucmFjZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BlcmZvcm0uanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdGUuanMiKTtyKHt0YXJnZXQ6IlByb21pc2UiLHN0YXQ6ITAsZm9yY2VkOkEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Byb21pc2Utc3RhdGljcy1pbmNvcnJlY3QtaXRlcmF0aW9uLmpzIil9LHtyYWNlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsQT1pLmYodCkscj1BLnJlamVjdCxsPW8oZnVuY3Rpb24oKXt2YXIgaT1zKHQucmVzb2x2ZSk7YShlLGZ1bmN0aW9uKGUpe24oaSx0LGUpLnRoZW4oQS5yZXNvbHZlLHIpfSl9KTtyZXR1cm4gbC5lcnJvciYmcihsLnZhbHVlKSxBLnByb21pc2V9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5yZWplY3QuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIik7cih7dGFyZ2V0OiJQcm9taXNlIixzdGF0OiEwLGZvcmNlZDpBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyIpLkNPTlNUUlVDVE9SfSx7cmVqZWN0OmZ1bmN0aW9uKGUpe3ZhciB0PW4uZih0aGlzKTtyZXR1cm4oMCx0LnJlamVjdCkoZSksdC5wcm9taXNlfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UucmVzb2x2ZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJvbWlzZS1uYXRpdmUtY29uc3RydWN0b3IuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Byb21pc2UtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzIikuQ09OU1RSVUNUT1IsYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wcm9taXNlLXJlc29sdmUuanMiKSxsPW4oIlByb21pc2UiKSxjPXMmJiFvO3Ioe3RhcmdldDoiUHJvbWlzZSIsc3RhdDohMCxmb3JjZWQ6c3x8b30se3Jlc29sdmU6ZnVuY3Rpb24oZSl7cmV0dXJuIGEoYyYmdGhpcz09PWw/aTp0aGlzLGUpfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMuanMiKTtyKHt0YXJnZXQ6IlJlZ0V4cCIscHJvdG86ITAsZm9yY2VkOi8uLy5leGVjIT09bn0se2V4ZWM6bn0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50ZXN0LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0EoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyIpO3ZhciByLG4scz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanMiKSxsPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIpLGM9KHI9ITEsKG49L1thY10vKS5leGVjPWZ1bmN0aW9uKCl7cmV0dXJuIHI9ITAsLy4vLmV4ZWMuYXBwbHkodGhpcyxhcmd1bWVudHMpfSwhMD09PW4udGVzdCgiYWJjIikmJnIpLHU9Ly4vLnRlc3Q7cyh7dGFyZ2V0OiJSZWdFeHAiLHByb3RvOiEwLGZvcmNlZDohY30se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9YSh0aGlzKSxBPWwoZSkscj10LmV4ZWM7aWYoIW8ocikpcmV0dXJuIGkodSx0LEEpO3ZhciBuPWkocix0LEEpO3JldHVybiBudWxsIT09biYmKGEobiksITApfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZS5qcyIpLlBST1BFUixuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZ2V0LWZsYWdzLmpzIiksbD0idG9TdHJpbmciLGM9UmVnRXhwLnByb3RvdHlwZSx1PWNbbF0saD1vKGZ1bmN0aW9uKCl7cmV0dXJuIi9hL2IiIT09dS5jYWxsKHtzb3VyY2U6ImEiLGZsYWdzOiJiIn0pfSksZD1yJiZ1Lm5hbWUhPT1sOyhofHxkKSYmbihjLGwsZnVuY3Rpb24oKXt2YXIgZT1zKHRoaXMpO3JldHVybiIvIitpKGUuc291cmNlKSsiLyIraShhKGUpKX0se3Vuc2FmZTohMH0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5jb25zdHJ1Y3Rvci5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLmpzIikoIlNldCIsZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUodGhpcyxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50c1swXTp2b2lkIDApfX0sQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcuanMiKSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0EoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zZXQuY29uc3RydWN0b3IuanMiKX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuZW5kcy13aXRoLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtY2xhdXNlLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIikuZixvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9ub3QtYS1yZWdleHAuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIpLHU9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1pcy1yZWdleHAtbG9naWMuanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiKSxkPXMoIiIuc2xpY2UpLGY9TWF0aC5taW4scD11KCJlbmRzV2l0aCIpO24oe3RhcmdldDoiU3RyaW5nIixwcm90bzohMCxmb3JjZWQ6ISghaCYmIXAmJihyPWkoU3RyaW5nLnByb3RvdHlwZSwiZW5kc1dpdGgiKSxyJiYhci53cml0YWJsZSl8fHApfSx7ZW5kc1dpdGg6ZnVuY3Rpb24oZSl7dmFyIHQ9YShjKHRoaXMpKTtsKGUpO3ZhciBBPWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLHI9dC5sZW5ndGgsbj12b2lkIDA9PT1BP3I6ZihvKEEpLHIpLHM9YShlKTtyZXR1cm4gZCh0LG4tcy5sZW5ndGgsbik9PT1zfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbm90LWEtcmVnZXhwLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1pcy1yZWdleHAtbG9naWMuanMiKSxsPW4oIiIuaW5kZXhPZik7cih7dGFyZ2V0OiJTdHJpbmciLHByb3RvOiEwLGZvcmNlZDohYSgiaW5jbHVkZXMiKX0se2luY2x1ZGVzOmZ1bmN0aW9uKGUpe3JldHVybiEhfmwobyhpKHRoaXMpKSxvKHMoZSkpLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyIpLmNoYXJBdCxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWRlZmluZS5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qcyIpLGE9IlN0cmluZyBJdGVyYXRvciIsbD1zLnNldCxjPXMuZ2V0dGVyRm9yKGEpO2koU3RyaW5nLCJTdHJpbmciLGZ1bmN0aW9uKGUpe2wodGhpcyx7dHlwZTphLHN0cmluZzpuKGUpLGluZGV4OjB9KX0sZnVuY3Rpb24oKXt2YXIgZSx0PWModGhpcyksQT10LnN0cmluZyxuPXQuaW5kZXg7cmV0dXJuIG4+PUEubGVuZ3RoP28odm9pZCAwLCEwKTooZT1yKEEsbiksdC5pbmRleCs9ZS5sZW5ndGgsbyhlLCExKSl9KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubGluay5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1odG1sLmpzIik7cih7dGFyZ2V0OiJTdHJpbmciLHByb3RvOiEwLGZvcmNlZDpBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctaHRtbC1mb3JjZWQuanMiKSgibGluayIpfSx7bGluazpmdW5jdGlvbihlKXtyZXR1cm4gbih0aGlzLCJhIiwiaHJlZiIsZSl9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYy5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiKSx1PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1tZXRob2QuanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4LmpzIiksZD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZ2V0LWZsYWdzLmpzIiksZj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIpLHA9bigiIi5pbmRleE9mKTtzKCJtYXRjaCIsZnVuY3Rpb24oZSx0LEEpe3JldHVybltmdW5jdGlvbih0KXt2YXIgQT1jKHRoaXMpLG49byh0KT91KHQsZSk6dm9pZCAwO3JldHVybiBuP3Iobix0LEEpOm5ldyBSZWdFeHAodClbZV0obChBKSl9LGZ1bmN0aW9uKGUpe3ZhciByPWkodGhpcyksbj1sKGUpLHM9QSh0LHIsbik7aWYocy5kb25lKXJldHVybiBzLnZhbHVlO3ZhciBvPWwoZChyKSk7aWYoLTE9PT1wKG8sImciKSlyZXR1cm4gZihyLG4pO3ZhciBjPS0xIT09cChvLCJ1Iik7ci5sYXN0SW5kZXg9MDtmb3IodmFyIHUsZz1bXSxtPTA7bnVsbCE9PSh1PWYocixuKSk7KXt2YXIgdz1sKHVbMF0pO2dbbV09dywiIj09PXcmJihyLmxhc3RJbmRleD1oKG4sYShyLmxhc3RJbmRleCksYykpLG0rK31yZXR1cm4gMD09PW0/bnVsbDpnfV19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1hcHBseS5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzIiksaD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiKSxkPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIpLGY9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIikscD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZHZhbmNlLXN0cmluZy1pbmRleC5qcyIpLGc9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyIpLG09QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LXN1YnN0aXR1dGlvbi5qcyIpLHc9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWdldC1mbGFncy5qcyIpLEI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QuanMiKSx5PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIikoInJlcGxhY2UiKSx2PU1hdGgubWF4LGI9TWF0aC5taW4sQz1zKFtdLmNvbmNhdCksXz1zKFtdLnB1c2gpLGo9cygiIi5pbmRleE9mKSx4PXMoIiIuc2xpY2UpLEY9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWU/ZTpTdHJpbmcoZSl9LFE9IiQwIj09PSJhIi5yZXBsYWNlKC8uLywiJDAiKSxVPSEhLy4vW3ldJiYiIj09PS8uL1t5XSgiYSIsIiQwIik7aSgicmVwbGFjZSIsZnVuY3Rpb24oZSx0LEEpe3ZhciBzPVU/IiQiOiIkMCI7cmV0dXJuW2Z1bmN0aW9uKGUsQSl7dmFyIHI9Zih0aGlzKSxzPWMoZSk/ZyhlLHkpOnZvaWQgMDtyZXR1cm4gcz9uKHMsZSxyLEEpOm4odCxkKHIpLGUsQSl9LGZ1bmN0aW9uKGUsbil7dmFyIGk9YSh0aGlzKSxvPWQoZSk7aWYoInN0cmluZyI9PXR5cGVvZiBuJiYtMT09PWoobixzKSYmLTE9PT1qKG4sIiQ8Iikpe3ZhciBjPUEodCxpLG8sbik7aWYoYy5kb25lKXJldHVybiBjLnZhbHVlfXZhciBmPWwobik7Znx8KG49ZChuKSk7dmFyIGcseT1kKHcoaSkpLFE9LTEhPT1qKHksImciKTtRJiYoZz0tMSE9PWooeSwidSIpLGkubGFzdEluZGV4PTApO2Zvcih2YXIgVSxFPVtdO251bGwhPT0oVT1CKGksbykpJiYoXyhFLFUpLFEpOykiIj09PWQoVVswXSkmJihpLmxhc3RJbmRleD1wKG8saChpLmxhc3RJbmRleCksZykpO2Zvcih2YXIgUz0iIixMPTAsST0wO0k8RS5sZW5ndGg7SSsrKXtmb3IodmFyIE4saz1kKChVPUVbSV0pWzBdKSxIPXYoYih1KFUuaW5kZXgpLG8ubGVuZ3RoKSwwKSxQPVtdLFQ9MTtUPFUubGVuZ3RoO1QrKylfKFAsRihVW1RdKSk7dmFyIE89VS5ncm91cHM7aWYoZil7dmFyIE09Qyhba10sUCxILG8pO3ZvaWQgMCE9PU8mJl8oTSxPKSxOPWQocihuLHZvaWQgMCxNKSl9ZWxzZSBOPW0oayxvLEgsUCxPLG4pO0g+PUwmJihTKz14KG8sTCxIKStOLEw9SCtrLmxlbmd0aCl9cmV0dXJuIFMreChvLEwpfV19LCEhbyhmdW5jdGlvbigpe3ZhciBlPS8uLztyZXR1cm4gZS5leGVjPWZ1bmN0aW9uKCl7dmFyIGU9W107cmV0dXJuIGUuZ3JvdXBzPXthOiI3In0sZX0sIjciIT09IiIucmVwbGFjZShlLCIkPGE+Iil9KXx8IVF8fFUpfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiKSxsPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3IuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4LmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qcyIpLGQ9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyIpLGY9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QuanMiKSxwPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1zdGlja3ktaGVscGVycy5qcyIpLGc9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiKSxtPXAuVU5TVVBQT1JURURfWSx3PU1hdGgubWluLEI9bihbXS5wdXNoKSx5PW4oIiIuc2xpY2UpLHY9IWcoZnVuY3Rpb24oKXt2YXIgZT0vKD86KS8sdD1lLmV4ZWM7ZS5leGVjPWZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgQT0iYWIiLnNwbGl0KGUpO3JldHVybiAyIT09QS5sZW5ndGh8fCJhIiE9PUFbMF18fCJiIiE9PUFbMV19KSxiPSJjIj09PSJhYmJjIi5zcGxpdCgvKGIpKi8pWzFdfHw0IT09InRlc3QiLnNwbGl0KC8oPzopLywtMSkubGVuZ3RofHwyIT09ImFiIi5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aHx8NCE9PSIuIi5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGh8fCIuIi5zcGxpdCgvKCkoKS8pLmxlbmd0aD4xfHwiIi5zcGxpdCgvLj8vKS5sZW5ndGg7cygic3BsaXQiLGZ1bmN0aW9uKGUsdCxBKXt2YXIgbj0iMCIuc3BsaXQodm9pZCAwLDApLmxlbmd0aD9mdW5jdGlvbihlLEEpe3JldHVybiB2b2lkIDA9PT1lJiYwPT09QT9bXTpyKHQsdGhpcyxlLEEpfTp0O3JldHVybltmdW5jdGlvbih0LEEpe3ZhciBzPWEodGhpcyksaT1vKHQpP2QodCxlKTp2b2lkIDA7cmV0dXJuIGk/cihpLHQscyxBKTpyKG4saChzKSx0LEEpfSxmdW5jdGlvbihlLHIpe3ZhciBzPWkodGhpcyksbz1oKGUpO2lmKCFiKXt2YXIgYT1BKG4scyxvLHIsbiE9PXQpO2lmKGEuZG9uZSlyZXR1cm4gYS52YWx1ZX12YXIgZD1sKHMsUmVnRXhwKSxwPXMudW5pY29kZSxnPShzLmlnbm9yZUNhc2U/ImkiOiIiKSsocy5tdWx0aWxpbmU/Im0iOiIiKSsocy51bmljb2RlPyJ1IjoiIikrKG0/ImciOiJ5Iiksdj1uZXcgZChtPyJeKD86IitzLnNvdXJjZSsiKSI6cyxnKSxDPXZvaWQgMD09PXI/NDI5NDk2NzI5NTpyPj4+MDtpZigwPT09QylyZXR1cm5bXTtpZigwPT09by5sZW5ndGgpcmV0dXJuIG51bGw9PT1mKHYsbyk/W29dOltdO2Zvcih2YXIgXz0wLGo9MCx4PVtdO2o8by5sZW5ndGg7KXt2Lmxhc3RJbmRleD1tPzA6ajt2YXIgRixRPWYodixtP3kobyxqKTpvKTtpZihudWxsPT09UXx8KEY9dyh1KHYubGFzdEluZGV4KyhtP2o6MCkpLG8ubGVuZ3RoKSk9PT1fKWo9YyhvLGoscCk7ZWxzZXtpZihCKHgseShvLF8saikpLHgubGVuZ3RoPT09QylyZXR1cm4geDtmb3IodmFyIFU9MTtVPD1RLmxlbmd0aC0xO1UrKylpZihCKHgsUVtVXSkseC5sZW5ndGg9PT1DKXJldHVybiB4O2o9Xz1GfX1yZXR1cm4gQih4LHkobyxfKSkseH1dfSxifHwhdixtKX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGguanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHIsbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1jbGF1c2UuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiKS5mLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMiKSxsPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25vdC1hLXJlZ2V4cC5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYy5qcyIpLGg9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyIpLGQ9cygiIi5zbGljZSksZj1NYXRoLm1pbixwPXUoInN0YXJ0c1dpdGgiKTtuKHt0YXJnZXQ6IlN0cmluZyIscHJvdG86ITAsZm9yY2VkOiEoIWgmJiFwJiYocj1pKFN0cmluZy5wcm90b3R5cGUsInN0YXJ0c1dpdGgiKSxyJiYhci53cml0YWJsZSl8fHApfSx7c3RhcnRzV2l0aDpmdW5jdGlvbihlKXt2YXIgdD1hKGModGhpcykpO2woZSk7dmFyIEE9byhmKGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLHQubGVuZ3RoKSkscj1hKGUpO3JldHVybiBkKHQsQSxBK3IubGVuZ3RoKT09PXJ9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW0uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qcyIpLnRyaW07cih7dGFyZ2V0OiJTdHJpbmciLHByb3RvOiEwLGZvcmNlZDpBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS1mb3JjZWQuanMiKSgidHJpbSIpfSx7dHJpbTpmdW5jdGlvbigpe3JldHVybiBuKHRoaXMpfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5jb25zdHJ1Y3Rvci5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiksbD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uLmpzIiksYz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIpLHU9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qcyIpLGg9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qcyIpLGQ9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiksZj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyIpLHA9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzIiksZz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMiKSxtPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiksdz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIiksQj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qcyIpLHk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiKSx2PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzIiksYj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiksQz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiksXz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzIiksaj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMiKSx4PUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzIiksRj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4uanMiKSxRPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi1hY2Nlc3Nvci5qcyIpLFU9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzIiksRT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiksUz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyIpLEw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzIiksST1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIpLE49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZC5qcyIpLGs9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lLmpzIiksSD1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zeW1ib2wtZGVmaW5lLXRvLXByaW1pdGl2ZS5qcyIpLFA9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiKSxUPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzIiksTz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanMiKS5mb3JFYWNoLE09RSgiaGlkZGVuIiksRD0iU3ltYm9sIixSPSJwcm90b3R5cGUiLEs9VC5zZXQsVj1ULmdldHRlckZvcihEKSxHPU9iamVjdFtSXSx6PW4uU3ltYm9sLHE9eiYmeltSXSxXPW4uUmFuZ2VFcnJvcixYPW4uVHlwZUVycm9yLFk9bi5RT2JqZWN0LEo9Qy5mLFo9Xy5mLCQ9di5mLGVlPXguZix0ZT1pKFtdLnB1c2gpLEFlPVUoInN5bWJvbHMiKSxyZT1VKCJvcC1zeW1ib2xzIiksbmU9VSgid2tzIiksc2U9IVl8fCFZW1JdfHwhWVtSXS5maW5kQ2hpbGQsaWU9ZnVuY3Rpb24oZSx0LEEpe3ZhciByPUooRyx0KTtyJiZkZWxldGUgR1t0XSxaKGUsdCxBKSxyJiZlIT09RyYmWihHLHQscil9LG9lPWEmJmMoZnVuY3Rpb24oKXtyZXR1cm4gNyE9PXcoWih7fSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiBaKHRoaXMsImEiLHt2YWx1ZTo3fSkuYX19KSkuYX0pP2llOlosYWU9ZnVuY3Rpb24oZSx0KXt2YXIgQT1BZVtlXT13KHEpO3JldHVybiBLKEEse3R5cGU6RCx0YWc6ZSxkZXNjcmlwdGlvbjp0fSksYXx8KEEuZGVzY3JpcHRpb249dCksQX0sbGU9ZnVuY3Rpb24oZSx0LEEpe2U9PT1HJiZsZShyZSx0LEEpLGQoZSk7dmFyIHI9cCh0KTtyZXR1cm4gZChBKSx1KEFlLHIpPyhBLmVudW1lcmFibGU/KHUoZSxNKSYmZVtNXVtyXSYmKGVbTV1bcl09ITEpLEE9dyhBLHtlbnVtZXJhYmxlOm0oMCwhMSl9KSk6KHUoZSxNKXx8WihlLE0sbSgxLHcobnVsbCkpKSxlW01dW3JdPSEwKSxvZShlLHIsQSkpOlooZSxyLEEpfSxjZT1mdW5jdGlvbihlLHQpe2QoZSk7dmFyIEE9Zih0KSxyPUIoQSkuY29uY2F0KGZlKEEpKTtyZXR1cm4gTyhyLGZ1bmN0aW9uKHQpe2EmJiFzKHVlLEEsdCl8fGxlKGUsdCxBW3RdKX0pLGV9LHVlPWZ1bmN0aW9uKGUpe3ZhciB0PXAoZSksQT1zKGVlLHRoaXMsdCk7cmV0dXJuISh0aGlzPT09RyYmdShBZSx0KSYmIXUocmUsdCkpJiYoIShBfHwhdSh0aGlzLHQpfHwhdShBZSx0KXx8dSh0aGlzLE0pJiZ0aGlzW01dW3RdKXx8QSl9LGhlPWZ1bmN0aW9uKGUsdCl7dmFyIEE9ZihlKSxyPXAodCk7aWYoQSE9PUd8fCF1KEFlLHIpfHx1KHJlLHIpKXt2YXIgbj1KKEEscik7cmV0dXJuIW58fCF1KEFlLHIpfHx1KEEsTSkmJkFbTV1bcl18fChuLmVudW1lcmFibGU9ITApLG59fSxkZT1mdW5jdGlvbihlKXt2YXIgdD0kKGYoZSkpLEE9W107cmV0dXJuIE8odCxmdW5jdGlvbihlKXt1KEFlLGUpfHx1KFMsZSl8fHRlKEEsZSl9KSxBfSxmZT1mdW5jdGlvbihlKXt2YXIgdD1lPT09RyxBPSQodD9yZTpmKGUpKSxyPVtdO3JldHVybiBPKEEsZnVuY3Rpb24oZSl7IXUoQWUsZSl8fHQmJiF1KEcsZSl8fHRlKHIsQWVbZV0pfSkscn07bHx8KHo9ZnVuY3Rpb24oKXtpZihoKHEsdGhpcykpdGhyb3cgbmV3IFgoIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciIpO3ZhciBlPWFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9nKGFyZ3VtZW50c1swXSk6dm9pZCAwLHQ9TChlKSxBPWZ1bmN0aW9uKGUpe3ZhciByPXZvaWQgMD09PXRoaXM/bjp0aGlzO3I9PT1HJiZzKEEscmUsZSksdShyLE0pJiZ1KHJbTV0sdCkmJihyW01dW3RdPSExKTt2YXIgaT1tKDEsZSk7dHJ5e29lKHIsdCxpKX1jYXRjaChlKXtpZighKGUgaW5zdGFuY2VvZiBXKSl0aHJvdyBlO2llKHIsdCxpKX19O3JldHVybiBhJiZzZSYmb2UoRyx0LHtjb25maWd1cmFibGU6ITAsc2V0OkF9KSxhZSh0LGUpfSxGKHE9eltSXSwidG9TdHJpbmciLGZ1bmN0aW9uKCl7cmV0dXJuIFYodGhpcykudGFnfSksRih6LCJ3aXRob3V0U2V0dGVyIixmdW5jdGlvbihlKXtyZXR1cm4gYWUoTChlKSxlKX0pLHguZj11ZSxfLmY9bGUsai5mPWNlLEMuZj1oZSx5LmY9di5mPWRlLGIuZj1mZSxOLmY9ZnVuY3Rpb24oZSl7cmV0dXJuIGFlKEkoZSksZSl9LGEmJihRKHEsImRlc2NyaXB0aW9uIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBWKHRoaXMpLmRlc2NyaXB0aW9ufX0pLG98fEYoRywicHJvcGVydHlJc0VudW1lcmFibGUiLHVlLHt1bnNhZmU6ITB9KSkpLHIoe2dsb2JhbDohMCxjb25zdHJ1Y3RvcjohMCx3cmFwOiEwLGZvcmNlZDohbCxzaGFtOiFsfSx7U3ltYm9sOnp9KSxPKEIobmUpLGZ1bmN0aW9uKGUpe2soZSl9KSxyKHt0YXJnZXQ6RCxzdGF0OiEwLGZvcmNlZDohbH0se3VzZVNldHRlcjpmdW5jdGlvbigpe3NlPSEwfSx1c2VTaW1wbGU6ZnVuY3Rpb24oKXtzZT0hMX19KSxyKHt0YXJnZXQ6Ik9iamVjdCIsc3RhdDohMCxmb3JjZWQ6IWwsc2hhbTohYX0se2NyZWF0ZTpmdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10P3coZSk6Y2UodyhlKSx0KX0sZGVmaW5lUHJvcGVydHk6bGUsZGVmaW5lUHJvcGVydGllczpjZSxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6aGV9KSxyKHt0YXJnZXQ6Ik9iamVjdCIsc3RhdDohMCxmb3JjZWQ6IWx9LHtnZXRPd25Qcm9wZXJ0eU5hbWVzOmRlfSksSCgpLFAoeixEKSxTW01dPSEwfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jYWxsYWJsZS5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qcyIpLGM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzIiksdT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3IuanMiKSxoPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcyIpLGQ9cy5TeW1ib2wsZj1kJiZkLnByb3RvdHlwZTtpZihuJiZhKGQpJiYoISgiZGVzY3JpcHRpb24iaW4gZil8fHZvaWQgMCE9PWQoKS5kZXNjcmlwdGlvbikpe3ZhciBwPXt9LGc9ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPDF8fHZvaWQgMD09PWFyZ3VtZW50c1swXT92b2lkIDA6Yyhhcmd1bWVudHNbMF0pLHQ9bChmLHRoaXMpP25ldyBkKGUpOnZvaWQgMD09PWU/ZCgpOmQoZSk7cmV0dXJuIiI9PT1lJiYocFt0XT0hMCksdH07aChnLGQpLGcucHJvdG90eXBlPWYsZi5jb25zdHJ1Y3Rvcj1nO3ZhciBtPSJTeW1ib2woZGVzY3JpcHRpb24gZGV0ZWN0aW9uKSI9PT1TdHJpbmcoZCgiZGVzY3JpcHRpb24gZGV0ZWN0aW9uIikpLHc9aShmLnZhbHVlT2YpLEI9aShmLnRvU3RyaW5nKSx5PS9eU3ltYm9sXCgoLiopXClbXildKyQvLHY9aSgiIi5yZXBsYWNlKSxiPWkoIiIuc2xpY2UpO3UoZiwiZGVzY3JpcHRpb24iLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7dmFyIGU9dyh0aGlzKTtpZihvKHAsZSkpcmV0dXJuIiI7dmFyIHQ9QihlKSxBPW0/Yih0LDcsLTEpOnYodCx5LCIkMSIpO3JldHVybiIiPT09QT92b2lkIDA6QX19KSxyKHtnbG9iYWw6ITAsY29uc3RydWN0b3I6ITAsZm9yY2VkOiEwfSx7U3ltYm9sOmd9KX19LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmZvci5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N5bWJvbC1yZWdpc3RyeS1kZXRlY3Rpb24uanMiKSxsPW8oInN0cmluZy10by1zeW1ib2wtcmVnaXN0cnkiKSxjPW8oInN5bWJvbC10by1zdHJpbmctcmVnaXN0cnkiKTtyKHt0YXJnZXQ6IlN5bWJvbCIsc3RhdDohMCxmb3JjZWQ6IWF9LHtmb3I6ZnVuY3Rpb24oZSl7dmFyIHQ9aShlKTtpZihzKGwsdCkpcmV0dXJuIGxbdF07dmFyIEE9bigiU3ltYm9sIikodCk7cmV0dXJuIGxbdF09QSxjW0FdPXQsQX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lLmpzIikoIml0ZXJhdG9yIil9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0EoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuY29uc3RydWN0b3IuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmZvci5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wua2V5LWZvci5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5qc29uLnN0cmluZ2lmeS5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIil9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmtleS1mb3IuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RyeS10by1zdHJpbmcuanMiKSxvPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLXJlZ2lzdHJ5LWRldGVjdGlvbi5qcyIpLGw9bygic3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeSIpO3Ioe3RhcmdldDoiU3ltYm9sIixzdGF0OiEwLGZvcmNlZDohYX0se2tleUZvcjpmdW5jdGlvbihlKXtpZighcyhlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGkoZSkrIiBpcyBub3QgYSBzeW1ib2wiKTtpZihuKGwsZSkpcmV0dXJuIGxbZV19fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLmNvbnN0cnVjdG9yLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0EoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci5jb25zdHJ1Y3Rvci5qcyIpfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5pdGVyYXRvci5mb3ItZWFjaC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IuZm9yLWVhY2guanMiKX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuaXRlcmF0b3IubWFwLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0EoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5pdGVyYXRvci5tYXAuanMiKX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LmFkZC1hbGwuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXNldC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWhlbHBlcnMuanMiKS5hZGQ7cih7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOiEwfSx7YWRkQWxsOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPW4odGhpcyksdD0wLEE9YXJndW1lbnRzLmxlbmd0aDt0PEE7dCsrKXMoZSxhcmd1bWVudHNbdF0pO3JldHVybiBlfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQuZGVsZXRlLWFsbC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Etc2V0LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtaGVscGVycy5qcyIpLnJlbW92ZTtyKHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6ITB9LHtkZWxldGVBbGw6ZnVuY3Rpb24oKXtmb3IodmFyIGUsdD1uKHRoaXMpLEE9ITAscj0wLGk9YXJndW1lbnRzLmxlbmd0aDtyPGk7cisrKWU9cyh0LGFyZ3VtZW50c1tyXSksQT1BJiZlO3JldHVybiEhQX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LmRpZmZlcmVuY2UuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zZXQtbGlrZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWRpZmZlcmVuY2UuanMiKTtyKHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6ITB9LHtkaWZmZXJlbmNlOmZ1bmN0aW9uKGUpe3JldHVybiBuKGksdGhpcyxzKGUpKX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LmV2ZXJ5LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0LmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXNldC5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWl0ZXJhdGUuanMiKTtyKHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6ITB9LHtldmVyeTpmdW5jdGlvbihlKXt2YXIgdD1zKHRoaXMpLEE9bihlLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKTtyZXR1cm4hMSE9PWkodCxmdW5jdGlvbihlKXtpZighQShlLGUsdCkpcmV0dXJuITF9LCEwKX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LmZpbHRlci5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1zZXQuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1oZWxwZXJzLmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtaXRlcmF0ZS5qcyIpLGE9aS5TZXQsbD1pLmFkZDtyKHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6ITB9LHtmaWx0ZXI6ZnVuY3Rpb24oZSl7dmFyIHQ9cyh0aGlzKSxBPW4oZSxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCkscj1uZXcgYTtyZXR1cm4gbyh0LGZ1bmN0aW9uKGUpe0EoZSxlLHQpJiZsKHIsZSl9KSxyfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQuZmluZC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1zZXQuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1pdGVyYXRlLmpzIik7cih7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOiEwfSx7ZmluZDpmdW5jdGlvbihlKXt2YXIgdD1zKHRoaXMpLEE9bihlLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKSxyPWkodCxmdW5jdGlvbihlKXtpZihBKGUsZSx0KSlyZXR1cm57dmFsdWU6ZX19LCEwKTtyZXR1cm4gciYmci52YWx1ZX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LmludGVyc2VjdGlvbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXNldC1saWtlLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtaW50ZXJzZWN0aW9uLmpzIik7cih7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOiEwfSx7aW50ZXJzZWN0aW9uOmZ1bmN0aW9uKGUpe3JldHVybiBuKGksdGhpcyxzKGUpKX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LmlzLWRpc2pvaW50LWZyb20uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zZXQtbGlrZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWlzLWRpc2pvaW50LWZyb20uanMiKTtyKHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6ITB9LHtpc0Rpc2pvaW50RnJvbTpmdW5jdGlvbihlKXtyZXR1cm4gbihpLHRoaXMscyhlKSl9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnNldC5pcy1zdWJzZXQtb2YuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zZXQtbGlrZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWlzLXN1YnNldC1vZi5qcyIpO3Ioe3RhcmdldDoiU2V0Iixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDohMH0se2lzU3Vic2V0T2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIG4oaSx0aGlzLHMoZSkpfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQuaXMtc3VwZXJzZXQtb2YuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zZXQtbGlrZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWlzLXN1cGVyc2V0LW9mLmpzIik7cih7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOiEwfSx7aXNTdXBlcnNldE9mOmZ1bmN0aW9uKGUpe3JldHVybiBuKGksdGhpcyxzKGUpKX19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LmpvaW4uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Etc2V0LmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtaXRlcmF0ZS5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzIiksYT1uKFtdLmpvaW4pLGw9bihbXS5wdXNoKTtyKHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6ITB9LHtqb2luOmZ1bmN0aW9uKGUpe3ZhciB0PXModGhpcyksQT12b2lkIDA9PT1lPyIsIjpvKGUpLHI9W107cmV0dXJuIGkodCxmdW5jdGlvbihlKXtsKHIsZSl9KSxhKHIsQSl9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnNldC5tYXAuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Etc2V0LmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtaGVscGVycy5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWl0ZXJhdGUuanMiKSxhPWkuU2V0LGw9aS5hZGQ7cih7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOiEwfSx7bWFwOmZ1bmN0aW9uKGUpe3ZhciB0PXModGhpcyksQT1uKGUsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApLHI9bmV3IGE7cmV0dXJuIG8odCxmdW5jdGlvbihlKXtsKHIsQShlLGUsdCkpfSkscn19KX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LnJlZHVjZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Etc2V0LmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtaXRlcmF0ZS5qcyIpLG89VHlwZUVycm9yO3Ioe3RhcmdldDoiU2V0Iixwcm90bzohMCxyZWFsOiEwLGZvcmNlZDohMH0se3JlZHVjZTpmdW5jdGlvbihlKXt2YXIgdD1zKHRoaXMpLEE9YXJndW1lbnRzLmxlbmd0aDwyLHI9QT92b2lkIDA6YXJndW1lbnRzWzFdO2lmKG4oZSksaSh0LGZ1bmN0aW9uKG4pe0E/KEE9ITEscj1uKTpyPWUocixuLG4sdCl9KSxBKXRocm93IG5ldyBvKCJSZWR1Y2Ugb2YgZW1wdHkgc2V0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSIpO3JldHVybiByfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQuc29tZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1zZXQuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1pdGVyYXRlLmpzIik7cih7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOiEwfSx7c29tZTpmdW5jdGlvbihlKXt2YXIgdD1zKHRoaXMpLEE9bihlLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKTtyZXR1cm4hMD09PWkodCxmdW5jdGlvbihlKXtpZihBKGUsZSx0KSlyZXR1cm4hMH0sITApfX0pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQuc3ltbWV0cmljLWRpZmZlcmVuY2UuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zZXQtbGlrZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXN5bW1ldHJpYy1kaWZmZXJlbmNlLmpzIik7cih7dGFyZ2V0OiJTZXQiLHByb3RvOiEwLHJlYWw6ITAsZm9yY2VkOiEwfSx7c3ltbWV0cmljRGlmZmVyZW5jZTpmdW5jdGlvbihlKXtyZXR1cm4gbihpLHRoaXMscyhlKSl9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnNldC51bmlvbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXNldC1saWtlLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdW5pb24uanMiKTtyKHt0YXJnZXQ6IlNldCIscHJvdG86ITAscmVhbDohMCxmb3JjZWQ6ITB9LHt1bmlvbjpmdW5jdGlvbihlKXtyZXR1cm4gbihpLHRoaXMscyhlKSl9fSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0Ijt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9tLXRva2VuLWxpc3QtcHJvdG90eXBlLmpzIiksaT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIiksYT1mdW5jdGlvbihlKXtpZihlJiZlLmZvckVhY2ghPT1pKXRyeXtvKGUsImZvckVhY2giLGkpfWNhdGNoKHQpe2UuZm9yRWFjaD1pfX07Zm9yKHZhciBsIGluIG4pbltsXSYmYShyW2xdJiZyW2xdLnByb3RvdHlwZSk7YShzKX0sIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC10aGlzLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIikscz1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20tdG9rZW4tbGlzdC1wcm90b3R5cGUuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIiksYT1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanMiKSgiaXRlcmF0b3IiKSxjPWkudmFsdWVzLHU9ZnVuY3Rpb24oZSx0KXtpZihlKXtpZihlW2xdIT09Yyl0cnl7byhlLGwsYyl9Y2F0Y2godCl7ZVtsXT1jfWlmKGEoZSx0LCEwKSxuW3RdKWZvcih2YXIgQSBpbiBpKWlmKGVbQV0hPT1pW0FdKXRyeXtvKGUsQSxpW0FdKX1jYXRjaCh0KXtlW0FdPWlbQV19fX07Zm9yKHZhciBoIGluIG4pdShyW2hdJiZyW2hdLnByb3RvdHlwZSxoKTt1KHMsIkRPTVRva2VuTGlzdCIpfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5zZXQtaW50ZXJ2YWwuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwtdGhpcy5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2NoZWR1bGVycy1maXguanMiKShuLnNldEludGVydmFsLCEwKTtyKHtnbG9iYWw6ITAsYmluZDohMCxmb3JjZWQ6bi5zZXRJbnRlcnZhbCE9PXN9LHtzZXRJbnRlcnZhbDpzfSl9LCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnNldC10aW1lb3V0LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NjaGVkdWxlcnMtZml4LmpzIikobi5zZXRUaW1lb3V0LCEwKTtyKHtnbG9iYWw6ITAsYmluZDohMCxmb3JjZWQ6bi5zZXRUaW1lb3V0IT09c30se3NldFRpbWVvdXQ6c30pfSwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5zZXQtaW50ZXJ2YWwuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnNldC10aW1lb3V0LmpzIil9LCIuL25vZGVfbW9kdWxlcy9kb21wdXJpZnkvZGlzdC9wdXJpZnkuZXMubWpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0Eucih0KSxBLmQodCx7ZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybiBBZX19KTtjb25zdHtlbnRyaWVzOnIsc2V0UHJvdG90eXBlT2Y6bixpc0Zyb3plbjpzLGdldFByb3RvdHlwZU9mOmksZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOm99PU9iamVjdDtsZXR7ZnJlZXplOmEsc2VhbDpsLGNyZWF0ZTpjfT1PYmplY3Qse2FwcGx5OnUsY29uc3RydWN0Omh9PSJ1bmRlZmluZWQiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdDthfHwoYT1mdW5jdGlvbihlKXtyZXR1cm4gZX0pLGx8fChsPWZ1bmN0aW9uKGUpe3JldHVybiBlfSksdXx8KHU9ZnVuY3Rpb24oZSx0LEEpe3JldHVybiBlLmFwcGx5KHQsQSl9KSxofHwoaD1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcgZSguLi50KX0pO2NvbnN0IGQ9UShBcnJheS5wcm90b3R5cGUuZm9yRWFjaCksZj1RKEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZikscD1RKEFycmF5LnByb3RvdHlwZS5wb3ApLGc9UShBcnJheS5wcm90b3R5cGUucHVzaCksbT1RKEFycmF5LnByb3RvdHlwZS5zcGxpY2UpLHc9UShTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKSxCPVEoU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZykseT1RKFN0cmluZy5wcm90b3R5cGUubWF0Y2gpLHY9UShTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpLGI9UShTdHJpbmcucHJvdG90eXBlLmluZGV4T2YpLEM9UShTdHJpbmcucHJvdG90eXBlLnRyaW0pLF89UShPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KSxqPVEoUmVnRXhwLnByb3RvdHlwZS50ZXN0KSx4PShGPVR5cGVFcnJvcixmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLEE9MDtBPGU7QSsrKXRbQV09YXJndW1lbnRzW0FdO3JldHVybiBoKEYsdCl9KTt2YXIgRjtmdW5jdGlvbiBRKGUpe3JldHVybiBmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgUmVnRXhwJiYodC5sYXN0SW5kZXg9MCk7Zm9yKHZhciBBPWFyZ3VtZW50cy5sZW5ndGgscj1uZXcgQXJyYXkoQT4xP0EtMTowKSxuPTE7bjxBO24rKylyW24tMV09YXJndW1lbnRzW25dO3JldHVybiB1KGUsdCxyKX19ZnVuY3Rpb24gVShlLHQpe2xldCBBPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp3O24mJm4oZSxudWxsKTtsZXQgcj10Lmxlbmd0aDtmb3IoO3ItLTspe2xldCBuPXRbcl07aWYoInN0cmluZyI9PXR5cGVvZiBuKXtjb25zdCBlPUEobik7ZSE9PW4mJihzKHQpfHwodFtyXT1lKSxuPWUpfWVbbl09ITB9cmV0dXJuIGV9ZnVuY3Rpb24gRShlKXtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKylfKGUsdCl8fChlW3RdPW51bGwpO3JldHVybiBlfWZ1bmN0aW9uIFMoZSl7Y29uc3QgdD1jKG51bGwpO2Zvcihjb25zdFtBLG5db2YgcihlKSlfKGUsQSkmJihBcnJheS5pc0FycmF5KG4pP3RbQV09RShuKTpuJiYib2JqZWN0Ij09dHlwZW9mIG4mJm4uY29uc3RydWN0b3I9PT1PYmplY3Q/dFtBXT1TKG4pOnRbQV09bik7cmV0dXJuIHR9ZnVuY3Rpb24gTChlLHQpe2Zvcig7bnVsbCE9PWU7KXtjb25zdCBBPW8oZSx0KTtpZihBKXtpZihBLmdldClyZXR1cm4gUShBLmdldCk7aWYoImZ1bmN0aW9uIj09dHlwZW9mIEEudmFsdWUpcmV0dXJuIFEoQS52YWx1ZSl9ZT1pKGUpfXJldHVybiBmdW5jdGlvbigpe3JldHVybiBudWxsfX1jb25zdCBJPWEoWyJhIiwiYWJiciIsImFjcm9ueW0iLCJhZGRyZXNzIiwiYXJlYSIsImFydGljbGUiLCJhc2lkZSIsImF1ZGlvIiwiYiIsImJkaSIsImJkbyIsImJpZyIsImJsaW5rIiwiYmxvY2txdW90ZSIsImJvZHkiLCJiciIsImJ1dHRvbiIsImNhbnZhcyIsImNhcHRpb24iLCJjZW50ZXIiLCJjaXRlIiwiY29kZSIsImNvbCIsImNvbGdyb3VwIiwiY29udGVudCIsImRhdGEiLCJkYXRhbGlzdCIsImRkIiwiZGVjb3JhdG9yIiwiZGVsIiwiZGV0YWlscyIsImRmbiIsImRpYWxvZyIsImRpciIsImRpdiIsImRsIiwiZHQiLCJlbGVtZW50IiwiZW0iLCJmaWVsZHNldCIsImZpZ2NhcHRpb24iLCJmaWd1cmUiLCJmb250IiwiZm9vdGVyIiwiZm9ybSIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImhlYWQiLCJoZWFkZXIiLCJoZ3JvdXAiLCJociIsImh0bWwiLCJpIiwiaW1nIiwiaW5wdXQiLCJpbnMiLCJrYmQiLCJsYWJlbCIsImxlZ2VuZCIsImxpIiwibWFpbiIsIm1hcCIsIm1hcmsiLCJtYXJxdWVlIiwibWVudSIsIm1lbnVpdGVtIiwibWV0ZXIiLCJuYXYiLCJub2JyIiwib2wiLCJvcHRncm91cCIsIm9wdGlvbiIsIm91dHB1dCIsInAiLCJwaWN0dXJlIiwicHJlIiwicHJvZ3Jlc3MiLCJxIiwicnAiLCJydCIsInJ1YnkiLCJzIiwic2FtcCIsInNlY3Rpb24iLCJzZWxlY3QiLCJzaGFkb3ciLCJzbWFsbCIsInNvdXJjZSIsInNwYWNlciIsInNwYW4iLCJzdHJpa2UiLCJzdHJvbmciLCJzdHlsZSIsInN1YiIsInN1bW1hcnkiLCJzdXAiLCJ0YWJsZSIsInRib2R5IiwidGQiLCJ0ZW1wbGF0ZSIsInRleHRhcmVhIiwidGZvb3QiLCJ0aCIsInRoZWFkIiwidGltZSIsInRyIiwidHJhY2siLCJ0dCIsInUiLCJ1bCIsInZhciIsInZpZGVvIiwid2JyIl0pLE49YShbInN2ZyIsImEiLCJhbHRnbHlwaCIsImFsdGdseXBoZGVmIiwiYWx0Z2x5cGhpdGVtIiwiYW5pbWF0ZWNvbG9yIiwiYW5pbWF0ZW1vdGlvbiIsImFuaW1hdGV0cmFuc2Zvcm0iLCJjaXJjbGUiLCJjbGlwcGF0aCIsImRlZnMiLCJkZXNjIiwiZWxsaXBzZSIsImZpbHRlciIsImZvbnQiLCJnIiwiZ2x5cGgiLCJnbHlwaHJlZiIsImhrZXJuIiwiaW1hZ2UiLCJsaW5lIiwibGluZWFyZ3JhZGllbnQiLCJtYXJrZXIiLCJtYXNrIiwibWV0YWRhdGEiLCJtcGF0aCIsInBhdGgiLCJwYXR0ZXJuIiwicG9seWdvbiIsInBvbHlsaW5lIiwicmFkaWFsZ3JhZGllbnQiLCJyZWN0Iiwic3RvcCIsInN0eWxlIiwic3dpdGNoIiwic3ltYm9sIiwidGV4dCIsInRleHRwYXRoIiwidGl0bGUiLCJ0cmVmIiwidHNwYW4iLCJ2aWV3Iiwidmtlcm4iXSksaz1hKFsiZmVCbGVuZCIsImZlQ29sb3JNYXRyaXgiLCJmZUNvbXBvbmVudFRyYW5zZmVyIiwiZmVDb21wb3NpdGUiLCJmZUNvbnZvbHZlTWF0cml4IiwiZmVEaWZmdXNlTGlnaHRpbmciLCJmZURpc3BsYWNlbWVudE1hcCIsImZlRGlzdGFudExpZ2h0IiwiZmVEcm9wU2hhZG93IiwiZmVGbG9vZCIsImZlRnVuY0EiLCJmZUZ1bmNCIiwiZmVGdW5jRyIsImZlRnVuY1IiLCJmZUdhdXNzaWFuQmx1ciIsImZlSW1hZ2UiLCJmZU1lcmdlIiwiZmVNZXJnZU5vZGUiLCJmZU1vcnBob2xvZ3kiLCJmZU9mZnNldCIsImZlUG9pbnRMaWdodCIsImZlU3BlY3VsYXJMaWdodGluZyIsImZlU3BvdExpZ2h0IiwiZmVUaWxlIiwiZmVUdXJidWxlbmNlIl0pLEg9YShbImFuaW1hdGUiLCJjb2xvci1wcm9maWxlIiwiY3Vyc29yIiwiZGlzY2FyZCIsImZvbnQtZmFjZSIsImZvbnQtZmFjZS1mb3JtYXQiLCJmb250LWZhY2UtbmFtZSIsImZvbnQtZmFjZS1zcmMiLCJmb250LWZhY2UtdXJpIiwiZm9yZWlnbm9iamVjdCIsImhhdGNoIiwiaGF0Y2hwYXRoIiwibWVzaCIsIm1lc2hncmFkaWVudCIsIm1lc2hwYXRjaCIsIm1lc2hyb3ciLCJtaXNzaW5nLWdseXBoIiwic2NyaXB0Iiwic2V0Iiwic29saWRjb2xvciIsInVua25vd24iLCJ1c2UiXSksUD1hKFsibWF0aCIsIm1lbmNsb3NlIiwibWVycm9yIiwibWZlbmNlZCIsIm1mcmFjIiwibWdseXBoIiwibWkiLCJtbGFiZWxlZHRyIiwibW11bHRpc2NyaXB0cyIsIm1uIiwibW8iLCJtb3ZlciIsIm1wYWRkZWQiLCJtcGhhbnRvbSIsIm1yb290IiwibXJvdyIsIm1zIiwibXNwYWNlIiwibXNxcnQiLCJtc3R5bGUiLCJtc3ViIiwibXN1cCIsIm1zdWJzdXAiLCJtdGFibGUiLCJtdGQiLCJtdGV4dCIsIm10ciIsIm11bmRlciIsIm11bmRlcm92ZXIiLCJtcHJlc2NyaXB0cyJdKSxUPWEoWyJtYWN0aW9uIiwibWFsaWduZ3JvdXAiLCJtYWxpZ25tYXJrIiwibWxvbmdkaXYiLCJtc2NhcnJpZXMiLCJtc2NhcnJ5IiwibXNncm91cCIsIm1zdGFjayIsIm1zbGluZSIsIm1zcm93Iiwic2VtYW50aWNzIiwiYW5ub3RhdGlvbiIsImFubm90YXRpb24teG1sIiwibXByZXNjcmlwdHMiLCJub25lIl0pLE89YShbIiN0ZXh0Il0pLE09YShbImFjY2VwdCIsImFjdGlvbiIsImFsaWduIiwiYWx0IiwiYXV0b2NhcGl0YWxpemUiLCJhdXRvY29tcGxldGUiLCJhdXRvcGljdHVyZWlucGljdHVyZSIsImF1dG9wbGF5IiwiYmFja2dyb3VuZCIsImJnY29sb3IiLCJib3JkZXIiLCJjYXB0dXJlIiwiY2VsbHBhZGRpbmciLCJjZWxsc3BhY2luZyIsImNoZWNrZWQiLCJjaXRlIiwiY2xhc3MiLCJjbGVhciIsImNvbG9yIiwiY29scyIsImNvbHNwYW4iLCJjb250cm9scyIsImNvbnRyb2xzbGlzdCIsImNvb3JkcyIsImNyb3Nzb3JpZ2luIiwiZGF0ZXRpbWUiLCJkZWNvZGluZyIsImRlZmF1bHQiLCJkaXIiLCJkaXNhYmxlZCIsImRpc2FibGVwaWN0dXJlaW5waWN0dXJlIiwiZGlzYWJsZXJlbW90ZXBsYXliYWNrIiwiZG93bmxvYWQiLCJkcmFnZ2FibGUiLCJlbmN0eXBlIiwiZW50ZXJrZXloaW50IiwiZmFjZSIsImZvciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWRkZW4iLCJoaWdoIiwiaHJlZiIsImhyZWZsYW5nIiwiaWQiLCJpbnB1dG1vZGUiLCJpbnRlZ3JpdHkiLCJpc21hcCIsImtpbmQiLCJsYWJlbCIsImxhbmciLCJsaXN0IiwibG9hZGluZyIsImxvb3AiLCJsb3ciLCJtYXgiLCJtYXhsZW5ndGgiLCJtZWRpYSIsIm1ldGhvZCIsIm1pbiIsIm1pbmxlbmd0aCIsIm11bHRpcGxlIiwibXV0ZWQiLCJuYW1lIiwibm9uY2UiLCJub3NoYWRlIiwibm92YWxpZGF0ZSIsIm5vd3JhcCIsIm9wZW4iLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3BvdmVyIiwicG9wb3ZlcnRhcmdldCIsInBvcG92ZXJ0YXJnZXRhY3Rpb24iLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHViZGF0ZSIsInJhZGlvZ3JvdXAiLCJyZWFkb25seSIsInJlbCIsInJlcXVpcmVkIiwicmV2IiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd3NwYW4iLCJzcGVsbGNoZWNrIiwic2NvcGUiLCJzZWxlY3RlZCIsInNoYXBlIiwic2l6ZSIsInNpemVzIiwic3BhbiIsInNyY2xhbmciLCJzdGFydCIsInNyYyIsInNyY3NldCIsInN0ZXAiLCJzdHlsZSIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInRpdGxlIiwidHJhbnNsYXRlIiwidHlwZSIsInVzZW1hcCIsInZhbGlnbiIsInZhbHVlIiwid2lkdGgiLCJ3cmFwIiwieG1sbnMiLCJzbG90Il0pLEQ9YShbImFjY2VudC1oZWlnaHQiLCJhY2N1bXVsYXRlIiwiYWRkaXRpdmUiLCJhbGlnbm1lbnQtYmFzZWxpbmUiLCJhbXBsaXR1ZGUiLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF6aW11dGgiLCJiYXNlZnJlcXVlbmN5IiwiYmFzZWxpbmUtc2hpZnQiLCJiZWdpbiIsImJpYXMiLCJieSIsImNsYXNzIiwiY2xpcCIsImNsaXBwYXRodW5pdHMiLCJjbGlwLXBhdGgiLCJjbGlwLXJ1bGUiLCJjb2xvciIsImNvbG9yLWludGVycG9sYXRpb24iLCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMiLCJjb2xvci1wcm9maWxlIiwiY29sb3ItcmVuZGVyaW5nIiwiY3giLCJjeSIsImQiLCJkeCIsImR5IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkdXIiLCJlZGdlbW9kZSIsImVsZXZhdGlvbiIsImVuZCIsImV4cG9uZW50IiwiZmlsbCIsImZpbGwtb3BhY2l0eSIsImZpbGwtcnVsZSIsImZpbHRlciIsImZpbHRlcnVuaXRzIiwiZmxvb2QtY29sb3IiLCJmbG9vZC1vcGFjaXR5IiwiZm9udC1mYW1pbHkiLCJmb250LXNpemUiLCJmb250LXNpemUtYWRqdXN0IiwiZm9udC1zdHJldGNoIiwiZm9udC1zdHlsZSIsImZvbnQtdmFyaWFudCIsImZvbnQtd2VpZ2h0IiwiZngiLCJmeSIsImcxIiwiZzIiLCJnbHlwaC1uYW1lIiwiZ2x5cGhyZWYiLCJncmFkaWVudHVuaXRzIiwiZ3JhZGllbnR0cmFuc2Zvcm0iLCJoZWlnaHQiLCJocmVmIiwiaWQiLCJpbWFnZS1yZW5kZXJpbmciLCJpbiIsImluMiIsImludGVyY2VwdCIsImsiLCJrMSIsImsyIiwiazMiLCJrNCIsImtlcm5pbmciLCJrZXlwb2ludHMiLCJrZXlzcGxpbmVzIiwia2V5dGltZXMiLCJsYW5nIiwibGVuZ3RoYWRqdXN0IiwibGV0dGVyLXNwYWNpbmciLCJrZXJuZWxtYXRyaXgiLCJrZXJuZWx1bml0bGVuZ3RoIiwibGlnaHRpbmctY29sb3IiLCJsb2NhbCIsIm1hcmtlci1lbmQiLCJtYXJrZXItbWlkIiwibWFya2VyLXN0YXJ0IiwibWFya2VyaGVpZ2h0IiwibWFya2VydW5pdHMiLCJtYXJrZXJ3aWR0aCIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXgiLCJtYXNrIiwibWVkaWEiLCJtZXRob2QiLCJtb2RlIiwibWluIiwibmFtZSIsIm51bW9jdGF2ZXMiLCJvZmZzZXQiLCJvcGVyYXRvciIsIm9wYWNpdHkiLCJvcmRlciIsIm9yaWVudCIsIm9yaWVudGF0aW9uIiwib3JpZ2luIiwib3ZlcmZsb3ciLCJwYWludC1vcmRlciIsInBhdGgiLCJwYXRobGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyIsInBhdHRlcm50cmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiLCJwb2ludHMiLCJwcmVzZXJ2ZWFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyIsInByaW1pdGl2ZXVuaXRzIiwiciIsInJ4IiwicnkiLCJyYWRpdXMiLCJyZWZ4IiwicmVmeSIsInJlcGVhdGNvdW50IiwicmVwZWF0ZHVyIiwicmVzdGFydCIsInJlc3VsdCIsInJvdGF0ZSIsInNjYWxlIiwic2VlZCIsInNoYXBlLXJlbmRlcmluZyIsInNsb3BlIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcHJlYWRtZXRob2QiLCJzdGFydG9mZnNldCIsInN0ZGRldmlhdGlvbiIsInN0aXRjaHRpbGVzIiwic3RvcC1jb2xvciIsInN0b3Atb3BhY2l0eSIsInN0cm9rZS1kYXNoYXJyYXkiLCJzdHJva2UtZGFzaG9mZnNldCIsInN0cm9rZS1saW5lY2FwIiwic3Ryb2tlLWxpbmVqb2luIiwic3Ryb2tlLW1pdGVybGltaXQiLCJzdHJva2Utb3BhY2l0eSIsInN0cm9rZSIsInN0cm9rZS13aWR0aCIsInN0eWxlIiwic3VyZmFjZXNjYWxlIiwic3lzdGVtbGFuZ3VhZ2UiLCJ0YWJpbmRleCIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0cmFuc2Zvcm0iLCJ0cmFuc2Zvcm0tb3JpZ2luIiwidGV4dC1hbmNob3IiLCJ0ZXh0LWRlY29yYXRpb24iLCJ0ZXh0LXJlbmRlcmluZyIsInRleHRsZW5ndGgiLCJ0eXBlIiwidTEiLCJ1MiIsInVuaWNvZGUiLCJ2YWx1ZXMiLCJ2aWV3Ym94IiwidmlzaWJpbGl0eSIsInZlcnNpb24iLCJ2ZXJ0LWFkdi15IiwidmVydC1vcmlnaW4teCIsInZlcnQtb3JpZ2luLXkiLCJ3aWR0aCIsIndvcmQtc3BhY2luZyIsIndyYXAiLCJ3cml0aW5nLW1vZGUiLCJ4Y2hhbm5lbHNlbGVjdG9yIiwieWNoYW5uZWxzZWxlY3RvciIsIngiLCJ4MSIsIngyIiwieG1sbnMiLCJ5IiwieTEiLCJ5MiIsInoiLCJ6b29tYW5kcGFuIl0pLFI9YShbImFjY2VudCIsImFjY2VudHVuZGVyIiwiYWxpZ24iLCJiZXZlbGxlZCIsImNsb3NlIiwiY29sdW1uc2FsaWduIiwiY29sdW1ubGluZXMiLCJjb2x1bW5zcGFuIiwiZGVub21hbGlnbiIsImRlcHRoIiwiZGlyIiwiZGlzcGxheSIsImRpc3BsYXlzdHlsZSIsImVuY29kaW5nIiwiZmVuY2UiLCJmcmFtZSIsImhlaWdodCIsImhyZWYiLCJpZCIsImxhcmdlb3AiLCJsZW5ndGgiLCJsaW5ldGhpY2tuZXNzIiwibHNwYWNlIiwibHF1b3RlIiwibWF0aGJhY2tncm91bmQiLCJtYXRoY29sb3IiLCJtYXRoc2l6ZSIsIm1hdGh2YXJpYW50IiwibWF4c2l6ZSIsIm1pbnNpemUiLCJtb3ZhYmxlbGltaXRzIiwibm90YXRpb24iLCJudW1hbGlnbiIsIm9wZW4iLCJyb3dhbGlnbiIsInJvd2xpbmVzIiwicm93c3BhY2luZyIsInJvd3NwYW4iLCJyc3BhY2UiLCJycXVvdGUiLCJzY3JpcHRsZXZlbCIsInNjcmlwdG1pbnNpemUiLCJzY3JpcHRzaXplbXVsdGlwbGllciIsInNlbGVjdGlvbiIsInNlcGFyYXRvciIsInNlcGFyYXRvcnMiLCJzdHJldGNoeSIsInN1YnNjcmlwdHNoaWZ0Iiwic3Vwc2NyaXB0c2hpZnQiLCJzeW1tZXRyaWMiLCJ2b2Zmc2V0Iiwid2lkdGgiLCJ4bWxucyJdKSxLPWEoWyJ4bGluazpocmVmIiwieG1sOmlkIiwieGxpbms6dGl0bGUiLCJ4bWw6c3BhY2UiLCJ4bWxuczp4bGluayJdKSxWPWwoL1x7XHtbXHdcV10qfFtcd1xXXSpcfVx9L2dtKSxHPWwoLzwlW1x3XFddKnxbXHdcV10qJT4vZ20pLHo9bCgvXCRce1tcd1xXXSovZ20pLHE9bCgvXmRhdGEtW1wtXHcuXHUwMEI3LVx1RkZGRl0rJC8pLFc9bCgvXmFyaWEtW1wtXHddKyQvKSxYPWwoL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98c21zfGNpZHx4bXBwfG1hdHJpeCk6fFteYS16XXxbYS16Ky5cLV0rKD86W15hLXorLlwtOl18JCkpL2kpLFk9bCgvXig/Olx3K3NjcmlwdHxkYXRhKTovaSksSj1sKC9bXHUwMDAwLVx1MDAyMFx1MDBBMFx1MTY4MFx1MTgwRVx1MjAwMC1cdTIwMjlcdTIwNUZcdTMwMDBdL2cpLFo9bCgvXmh0bWwkL2kpLCQ9bCgvXlthLXpdWy5cd10qKC1bLlx3XSspKyQvaSk7dmFyIGVlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFSSUFfQVRUUjpXLEFUVFJfV0hJVEVTUEFDRTpKLENVU1RPTV9FTEVNRU5UOiQsREFUQV9BVFRSOnEsRE9DVFlQRV9OQU1FOlosRVJCX0VYUFI6RyxJU19BTExPV0VEX1VSSTpYLElTX1NDUklQVF9PUl9EQVRBOlksTVVTVEFDSEVfRVhQUjpWLFRNUExJVF9FWFBSOnp9KTtjb25zdCB0ZT1mdW5jdGlvbigpe3JldHVybiJ1bmRlZmluZWQiPT10eXBlb2Ygd2luZG93P251bGw6d2luZG93fTt2YXIgQWU9ZnVuY3Rpb24gZSgpe2xldCB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp0ZSgpO2NvbnN0IEE9dD0+ZSh0KTtpZihBLnZlcnNpb249IjMuMi42IixBLnJlbW92ZWQ9W10sIXR8fCF0LmRvY3VtZW50fHw5IT09dC5kb2N1bWVudC5ub2RlVHlwZXx8IXQuRWxlbWVudClyZXR1cm4gQS5pc1N1cHBvcnRlZD0hMSxBO2xldHtkb2N1bWVudDpufT10O2NvbnN0IHM9bixpPXMuY3VycmVudFNjcmlwdCx7RG9jdW1lbnRGcmFnbWVudDpvLEhUTUxUZW1wbGF0ZUVsZW1lbnQ6bCxOb2RlOnUsRWxlbWVudDpoLE5vZGVGaWx0ZXI6RixOYW1lZE5vZGVNYXA6UT10Lk5hbWVkTm9kZU1hcHx8dC5Nb3pOYW1lZEF0dHJNYXAsSFRNTEZvcm1FbGVtZW50OkUsRE9NUGFyc2VyOlYsdHJ1c3RlZFR5cGVzOkd9PXQsej1oLnByb3RvdHlwZSxxPUwoeiwiY2xvbmVOb2RlIiksVz1MKHosInJlbW92ZSIpLFk9TCh6LCJuZXh0U2libGluZyIpLEo9TCh6LCJjaGlsZE5vZGVzIiksJD1MKHosInBhcmVudE5vZGUiKTtpZigiZnVuY3Rpb24iPT10eXBlb2YgbCl7Y29uc3QgZT1uLmNyZWF0ZUVsZW1lbnQoInRlbXBsYXRlIik7ZS5jb250ZW50JiZlLmNvbnRlbnQub3duZXJEb2N1bWVudCYmKG49ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQpfWxldCBBZSxyZT0iIjtjb25zdHtpbXBsZW1lbnRhdGlvbjpuZSxjcmVhdGVOb2RlSXRlcmF0b3I6c2UsY3JlYXRlRG9jdW1lbnRGcmFnbWVudDppZSxnZXRFbGVtZW50c0J5VGFnTmFtZTpvZX09bix7aW1wb3J0Tm9kZTphZX09cztsZXQgbGU9e2FmdGVyU2FuaXRpemVBdHRyaWJ1dGVzOltdLGFmdGVyU2FuaXRpemVFbGVtZW50czpbXSxhZnRlclNhbml0aXplU2hhZG93RE9NOltdLGJlZm9yZVNhbml0aXplQXR0cmlidXRlczpbXSxiZWZvcmVTYW5pdGl6ZUVsZW1lbnRzOltdLGJlZm9yZVNhbml0aXplU2hhZG93RE9NOltdLHVwb25TYW5pdGl6ZUF0dHJpYnV0ZTpbXSx1cG9uU2FuaXRpemVFbGVtZW50OltdLHVwb25TYW5pdGl6ZVNoYWRvd05vZGU6W119O0EuaXNTdXBwb3J0ZWQ9ImZ1bmN0aW9uIj09dHlwZW9mIHImJiJmdW5jdGlvbiI9PXR5cGVvZiAkJiZuZSYmdm9pZCAwIT09bmUuY3JlYXRlSFRNTERvY3VtZW50O2NvbnN0e01VU1RBQ0hFX0VYUFI6Y2UsRVJCX0VYUFI6dWUsVE1QTElUX0VYUFI6aGUsREFUQV9BVFRSOmRlLEFSSUFfQVRUUjpmZSxJU19TQ1JJUFRfT1JfREFUQTpwZSxBVFRSX1dISVRFU1BBQ0U6Z2UsQ1VTVE9NX0VMRU1FTlQ6bWV9PWVlO2xldHtJU19BTExPV0VEX1VSSTp3ZX09ZWUsQmU9bnVsbDtjb25zdCB5ZT1VKHt9LFsuLi5JLC4uLk4sLi4uaywuLi5QLC4uLk9dKTtsZXQgdmU9bnVsbDtjb25zdCBiZT1VKHt9LFsuLi5NLC4uLkQsLi4uUiwuLi5LXSk7bGV0IENlPU9iamVjdC5zZWFsKGMobnVsbCx7dGFnTmFtZUNoZWNrOnt3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCx2YWx1ZTpudWxsfSxhdHRyaWJ1dGVOYW1lQ2hlY2s6e3dyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLHZhbHVlOm51bGx9LGFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50czp7d3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsdmFsdWU6ITF9fSkpLF9lPW51bGwsamU9bnVsbCx4ZT0hMCxGZT0hMCxRZT0hMSxVZT0hMCxFZT0hMSxTZT0hMCxMZT0hMSxJZT0hMSxOZT0hMSxrZT0hMSxIZT0hMSxQZT0hMSxUZT0hMCxPZT0hMSxNZT0hMCxEZT0hMSxSZT17fSxLZT1udWxsO2NvbnN0IFZlPVUoe30sWyJhbm5vdGF0aW9uLXhtbCIsImF1ZGlvIiwiY29sZ3JvdXAiLCJkZXNjIiwiZm9yZWlnbm9iamVjdCIsImhlYWQiLCJpZnJhbWUiLCJtYXRoIiwibWkiLCJtbiIsIm1vIiwibXMiLCJtdGV4dCIsIm5vZW1iZWQiLCJub2ZyYW1lcyIsIm5vc2NyaXB0IiwicGxhaW50ZXh0Iiwic2NyaXB0Iiwic3R5bGUiLCJzdmciLCJ0ZW1wbGF0ZSIsInRoZWFkIiwidGl0bGUiLCJ2aWRlbyIsInhtcCJdKTtsZXQgR2U9bnVsbDtjb25zdCB6ZT1VKHt9LFsiYXVkaW8iLCJ2aWRlbyIsImltZyIsInNvdXJjZSIsImltYWdlIiwidHJhY2siXSk7bGV0IHFlPW51bGw7Y29uc3QgV2U9VSh7fSxbImFsdCIsImNsYXNzIiwiZm9yIiwiaWQiLCJsYWJlbCIsIm5hbWUiLCJwYXR0ZXJuIiwicGxhY2Vob2xkZXIiLCJyb2xlIiwic3VtbWFyeSIsInRpdGxlIiwidmFsdWUiLCJzdHlsZSIsInhtbG5zIl0pLFhlPSJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MIixZZT0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLEplPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIjtsZXQgWmU9SmUsJGU9ITEsZXQ9bnVsbDtjb25zdCB0dD1VKHt9LFtYZSxZZSxKZV0sQik7bGV0IEF0PVUoe30sWyJtaSIsIm1vIiwibW4iLCJtcyIsIm10ZXh0Il0pLHJ0PVUoe30sWyJhbm5vdGF0aW9uLXhtbCJdKTtjb25zdCBudD1VKHt9LFsidGl0bGUiLCJzdHlsZSIsImZvbnQiLCJhIiwic2NyaXB0Il0pO2xldCBzdD1udWxsO2NvbnN0IGl0PVsiYXBwbGljYXRpb24veGh0bWwreG1sIiwidGV4dC9odG1sIl07bGV0IG90PW51bGwsYXQ9bnVsbDtjb25zdCBsdD1uLmNyZWF0ZUVsZW1lbnQoImZvcm0iKSxjdD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFJlZ0V4cHx8ZSBpbnN0YW5jZW9mIEZ1bmN0aW9ufSx1dD1mdW5jdGlvbigpe2xldCBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpZighYXR8fGF0IT09ZSl7aWYoZSYmIm9iamVjdCI9PXR5cGVvZiBlfHwoZT17fSksZT1TKGUpLHN0PS0xPT09aXQuaW5kZXhPZihlLlBBUlNFUl9NRURJQV9UWVBFKT8idGV4dC9odG1sIjplLlBBUlNFUl9NRURJQV9UWVBFLG90PSJhcHBsaWNhdGlvbi94aHRtbCt4bWwiPT09c3Q/Qjp3LEJlPV8oZSwiQUxMT1dFRF9UQUdTIik/VSh7fSxlLkFMTE9XRURfVEFHUyxvdCk6eWUsdmU9XyhlLCJBTExPV0VEX0FUVFIiKT9VKHt9LGUuQUxMT1dFRF9BVFRSLG90KTpiZSxldD1fKGUsIkFMTE9XRURfTkFNRVNQQUNFUyIpP1Uoe30sZS5BTExPV0VEX05BTUVTUEFDRVMsQik6dHQscWU9XyhlLCJBRERfVVJJX1NBRkVfQVRUUiIpP1UoUyhXZSksZS5BRERfVVJJX1NBRkVfQVRUUixvdCk6V2UsR2U9XyhlLCJBRERfREFUQV9VUklfVEFHUyIpP1UoUyh6ZSksZS5BRERfREFUQV9VUklfVEFHUyxvdCk6emUsS2U9XyhlLCJGT1JCSURfQ09OVEVOVFMiKT9VKHt9LGUuRk9SQklEX0NPTlRFTlRTLG90KTpWZSxfZT1fKGUsIkZPUkJJRF9UQUdTIik/VSh7fSxlLkZPUkJJRF9UQUdTLG90KTpTKHt9KSxqZT1fKGUsIkZPUkJJRF9BVFRSIik/VSh7fSxlLkZPUkJJRF9BVFRSLG90KTpTKHt9KSxSZT0hIV8oZSwiVVNFX1BST0ZJTEVTIikmJmUuVVNFX1BST0ZJTEVTLHhlPSExIT09ZS5BTExPV19BUklBX0FUVFIsRmU9ITEhPT1lLkFMTE9XX0RBVEFfQVRUUixRZT1lLkFMTE9XX1VOS05PV05fUFJPVE9DT0xTfHwhMSxVZT0hMSE9PWUuQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSLEVlPWUuU0FGRV9GT1JfVEVNUExBVEVTfHwhMSxTZT0hMSE9PWUuU0FGRV9GT1JfWE1MLExlPWUuV0hPTEVfRE9DVU1FTlR8fCExLGtlPWUuUkVUVVJOX0RPTXx8ITEsSGU9ZS5SRVRVUk5fRE9NX0ZSQUdNRU5UfHwhMSxQZT1lLlJFVFVSTl9UUlVTVEVEX1RZUEV8fCExLE5lPWUuRk9SQ0VfQk9EWXx8ITEsVGU9ITEhPT1lLlNBTklUSVpFX0RPTSxPZT1lLlNBTklUSVpFX05BTUVEX1BST1BTfHwhMSxNZT0hMSE9PWUuS0VFUF9DT05URU5ULERlPWUuSU5fUExBQ0V8fCExLHdlPWUuQUxMT1dFRF9VUklfUkVHRVhQfHxYLFplPWUuTkFNRVNQQUNFfHxKZSxBdD1lLk1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU3x8QXQscnQ9ZS5IVE1MX0lOVEVHUkFUSU9OX1BPSU5UU3x8cnQsQ2U9ZS5DVVNUT01fRUxFTUVOVF9IQU5ETElOR3x8e30sZS5DVVNUT01fRUxFTUVOVF9IQU5ETElORyYmY3QoZS5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2spJiYoQ2UudGFnTmFtZUNoZWNrPWUuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKSxlLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HJiZjdChlLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaykmJihDZS5hdHRyaWJ1dGVOYW1lQ2hlY2s9ZS5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2spLGUuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcmJiJib29sZWFuIj09dHlwZW9mIGUuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzJiYoQ2UuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzPWUuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzKSxFZSYmKEZlPSExKSxIZSYmKGtlPSEwKSxSZSYmKEJlPVUoe30sTyksdmU9W10sITA9PT1SZS5odG1sJiYoVShCZSxJKSxVKHZlLE0pKSwhMD09PVJlLnN2ZyYmKFUoQmUsTiksVSh2ZSxEKSxVKHZlLEspKSwhMD09PVJlLnN2Z0ZpbHRlcnMmJihVKEJlLGspLFUodmUsRCksVSh2ZSxLKSksITA9PT1SZS5tYXRoTWwmJihVKEJlLFApLFUodmUsUiksVSh2ZSxLKSkpLGUuQUREX1RBR1MmJihCZT09PXllJiYoQmU9UyhCZSkpLFUoQmUsZS5BRERfVEFHUyxvdCkpLGUuQUREX0FUVFImJih2ZT09PWJlJiYodmU9Uyh2ZSkpLFUodmUsZS5BRERfQVRUUixvdCkpLGUuQUREX1VSSV9TQUZFX0FUVFImJlUocWUsZS5BRERfVVJJX1NBRkVfQVRUUixvdCksZS5GT1JCSURfQ09OVEVOVFMmJihLZT09PVZlJiYoS2U9UyhLZSkpLFUoS2UsZS5GT1JCSURfQ09OVEVOVFMsb3QpKSxNZSYmKEJlWyIjdGV4dCJdPSEwKSxMZSYmVShCZSxbImh0bWwiLCJoZWFkIiwiYm9keSJdKSxCZS50YWJsZSYmKFUoQmUsWyJ0Ym9keSJdKSxkZWxldGUgX2UudGJvZHkpLGUuVFJVU1RFRF9UWVBFU19QT0xJQ1kpe2lmKCJmdW5jdGlvbiIhPXR5cGVvZiBlLlRSVVNURURfVFlQRVNfUE9MSUNZLmNyZWF0ZUhUTUwpdGhyb3cgeCgnVFJVU1RFRF9UWVBFU19QT0xJQ1kgY29uZmlndXJhdGlvbiBvcHRpb24gbXVzdCBwcm92aWRlIGEgImNyZWF0ZUhUTUwiIGhvb2suJyk7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIGUuVFJVU1RFRF9UWVBFU19QT0xJQ1kuY3JlYXRlU2NyaXB0VVJMKXRocm93IHgoJ1RSVVNURURfVFlQRVNfUE9MSUNZIGNvbmZpZ3VyYXRpb24gb3B0aW9uIG11c3QgcHJvdmlkZSBhICJjcmVhdGVTY3JpcHRVUkwiIGhvb2suJyk7QWU9ZS5UUlVTVEVEX1RZUEVTX1BPTElDWSxyZT1BZS5jcmVhdGVIVE1MKCIiKX1lbHNlIHZvaWQgMD09PUFlJiYoQWU9ZnVuY3Rpb24oZSx0KXtpZigib2JqZWN0IiE9dHlwZW9mIGV8fCJmdW5jdGlvbiIhPXR5cGVvZiBlLmNyZWF0ZVBvbGljeSlyZXR1cm4gbnVsbDtsZXQgQT1udWxsO2NvbnN0IHI9ImRhdGEtdHQtcG9saWN5LXN1ZmZpeCI7dCYmdC5oYXNBdHRyaWJ1dGUocikmJihBPXQuZ2V0QXR0cmlidXRlKHIpKTtjb25zdCBuPSJkb21wdXJpZnkiKyhBPyIjIitBOiIiKTt0cnl7cmV0dXJuIGUuY3JlYXRlUG9saWN5KG4se2NyZWF0ZUhUTUwoZSl7cmV0dXJuIGV9LGNyZWF0ZVNjcmlwdFVSTChlKXtyZXR1cm4gZX19KX1jYXRjaChlKXtyZXR1cm4gY29uc29sZS53YXJuKCJUcnVzdGVkVHlwZXMgcG9saWN5ICIrbisiIGNvdWxkIG5vdCBiZSBjcmVhdGVkLiIpLG51bGx9fShHLGkpKSxudWxsIT09QWUmJiJzdHJpbmciPT10eXBlb2YgcmUmJihyZT1BZS5jcmVhdGVIVE1MKCIiKSk7YSYmYShlKSxhdD1lfX0saHQ9VSh7fSxbLi4uTiwuLi5rLC4uLkhdKSxkdD1VKHt9LFsuLi5QLC4uLlRdKSxmdD1mdW5jdGlvbihlKXtnKEEucmVtb3ZlZCx7ZWxlbWVudDplfSk7dHJ5eyQoZSkucmVtb3ZlQ2hpbGQoZSl9Y2F0Y2godCl7VyhlKX19LHB0PWZ1bmN0aW9uKGUsdCl7dHJ5e2coQS5yZW1vdmVkLHthdHRyaWJ1dGU6dC5nZXRBdHRyaWJ1dGVOb2RlKGUpLGZyb206dH0pfWNhdGNoKGUpe2coQS5yZW1vdmVkLHthdHRyaWJ1dGU6bnVsbCxmcm9tOnR9KX1pZih0LnJlbW92ZUF0dHJpYnV0ZShlKSwiaXMiPT09ZSlpZihrZXx8SGUpdHJ5e2Z0KHQpfWNhdGNoKGUpe31lbHNlIHRyeXt0LnNldEF0dHJpYnV0ZShlLCIiKX1jYXRjaChlKXt9fSxndD1mdW5jdGlvbihlKXtsZXQgdD1udWxsLEE9bnVsbDtpZihOZSllPSI8cmVtb3ZlPjwvcmVtb3ZlPiIrZTtlbHNle2NvbnN0IHQ9eShlLC9eW1xyXG5cdCBdKy8pO0E9dCYmdFswXX0iYXBwbGljYXRpb24veGh0bWwreG1sIj09PXN0JiZaZT09PUplJiYoZT0nPGh0bWwgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxoZWFkPjwvaGVhZD48Ym9keT4nK2UrIjwvYm9keT48L2h0bWw+Iik7Y29uc3Qgcj1BZT9BZS5jcmVhdGVIVE1MKGUpOmU7aWYoWmU9PT1KZSl0cnl7dD0obmV3IFYpLnBhcnNlRnJvbVN0cmluZyhyLHN0KX1jYXRjaChlKXt9aWYoIXR8fCF0LmRvY3VtZW50RWxlbWVudCl7dD1uZS5jcmVhdGVEb2N1bWVudChaZSwidGVtcGxhdGUiLG51bGwpO3RyeXt0LmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUw9JGU/cmU6cn1jYXRjaChlKXt9fWNvbnN0IHM9dC5ib2R5fHx0LmRvY3VtZW50RWxlbWVudDtyZXR1cm4gZSYmQSYmcy5pbnNlcnRCZWZvcmUobi5jcmVhdGVUZXh0Tm9kZShBKSxzLmNoaWxkTm9kZXNbMF18fG51bGwpLFplPT09SmU/b2UuY2FsbCh0LExlPyJodG1sIjoiYm9keSIpWzBdOkxlP3QuZG9jdW1lbnRFbGVtZW50OnN9LG10PWZ1bmN0aW9uKGUpe3JldHVybiBzZS5jYWxsKGUub3duZXJEb2N1bWVudHx8ZSxlLEYuU0hPV19FTEVNRU5UfEYuU0hPV19DT01NRU5UfEYuU0hPV19URVhUfEYuU0hPV19QUk9DRVNTSU5HX0lOU1RSVUNUSU9OfEYuU0hPV19DREFUQV9TRUNUSU9OLG51bGwpfSx3dD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEUmJigic3RyaW5nIiE9dHlwZW9mIGUubm9kZU5hbWV8fCJzdHJpbmciIT10eXBlb2YgZS50ZXh0Q29udGVudHx8ImZ1bmN0aW9uIiE9dHlwZW9mIGUucmVtb3ZlQ2hpbGR8fCEoZS5hdHRyaWJ1dGVzIGluc3RhbmNlb2YgUSl8fCJmdW5jdGlvbiIhPXR5cGVvZiBlLnJlbW92ZUF0dHJpYnV0ZXx8ImZ1bmN0aW9uIiE9dHlwZW9mIGUuc2V0QXR0cmlidXRlfHwic3RyaW5nIiE9dHlwZW9mIGUubmFtZXNwYWNlVVJJfHwiZnVuY3Rpb24iIT10eXBlb2YgZS5pbnNlcnRCZWZvcmV8fCJmdW5jdGlvbiIhPXR5cGVvZiBlLmhhc0NoaWxkTm9kZXMpfSxCdD1mdW5jdGlvbihlKXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgdSYmZSBpbnN0YW5jZW9mIHV9O2Z1bmN0aW9uIHl0KGUsdCxyKXtkKGUsZT0+e2UuY2FsbChBLHQscixhdCl9KX1jb25zdCB2dD1mdW5jdGlvbihlKXtsZXQgdD1udWxsO2lmKHl0KGxlLmJlZm9yZVNhbml0aXplRWxlbWVudHMsZSxudWxsKSx3dChlKSlyZXR1cm4gZnQoZSksITA7Y29uc3Qgcj1vdChlLm5vZGVOYW1lKTtpZih5dChsZS51cG9uU2FuaXRpemVFbGVtZW50LGUse3RhZ05hbWU6cixhbGxvd2VkVGFnczpCZX0pLFNlJiZlLmhhc0NoaWxkTm9kZXMoKSYmIUJ0KGUuZmlyc3RFbGVtZW50Q2hpbGQpJiZqKC88Wy9cdyFdL2csZS5pbm5lckhUTUwpJiZqKC88Wy9cdyFdL2csZS50ZXh0Q29udGVudCkpcmV0dXJuIGZ0KGUpLCEwO2lmKDc9PT1lLm5vZGVUeXBlKXJldHVybiBmdChlKSwhMDtpZihTZSYmOD09PWUubm9kZVR5cGUmJmooLzxbL1x3XS9nLGUuZGF0YSkpcmV0dXJuIGZ0KGUpLCEwO2lmKCFCZVtyXXx8X2Vbcl0pe2lmKCFfZVtyXSYmQ3Qocikpe2lmKENlLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCYmaihDZS50YWdOYW1lQ2hlY2sscikpcmV0dXJuITE7aWYoQ2UudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24mJkNlLnRhZ05hbWVDaGVjayhyKSlyZXR1cm4hMX1pZihNZSYmIUtlW3JdKXtjb25zdCB0PSQoZSl8fGUucGFyZW50Tm9kZSxBPUooZSl8fGUuY2hpbGROb2RlcztpZihBJiZ0KWZvcihsZXQgcj1BLmxlbmd0aC0xO3I+PTA7LS1yKXtjb25zdCBuPXEoQVtyXSwhMCk7bi5fX3JlbW92YWxDb3VudD0oZS5fX3JlbW92YWxDb3VudHx8MCkrMSx0Lmluc2VydEJlZm9yZShuLFkoZSkpfX1yZXR1cm4gZnQoZSksITB9cmV0dXJuIGUgaW5zdGFuY2VvZiBoJiYhZnVuY3Rpb24oZSl7bGV0IHQ9JChlKTt0JiZ0LnRhZ05hbWV8fCh0PXtuYW1lc3BhY2VVUkk6WmUsdGFnTmFtZToidGVtcGxhdGUifSk7Y29uc3QgQT13KGUudGFnTmFtZSkscj13KHQudGFnTmFtZSk7cmV0dXJuISFldFtlLm5hbWVzcGFjZVVSSV0mJihlLm5hbWVzcGFjZVVSST09PVllP3QubmFtZXNwYWNlVVJJPT09SmU/InN2ZyI9PT1BOnQubmFtZXNwYWNlVVJJPT09WGU/InN2ZyI9PT1BJiYoImFubm90YXRpb24teG1sIj09PXJ8fEF0W3JdKTpCb29sZWFuKGh0W0FdKTplLm5hbWVzcGFjZVVSST09PVhlP3QubmFtZXNwYWNlVVJJPT09SmU/Im1hdGgiPT09QTp0Lm5hbWVzcGFjZVVSST09PVllPyJtYXRoIj09PUEmJnJ0W3JdOkJvb2xlYW4oZHRbQV0pOmUubmFtZXNwYWNlVVJJPT09SmU/ISh0Lm5hbWVzcGFjZVVSST09PVllJiYhcnRbcl0pJiYhKHQubmFtZXNwYWNlVVJJPT09WGUmJiFBdFtyXSkmJiFkdFtBXSYmKG50W0FdfHwhaHRbQV0pOiEoImFwcGxpY2F0aW9uL3hodG1sK3htbCIhPT1zdHx8IWV0W2UubmFtZXNwYWNlVVJJXSkpfShlKT8oZnQoZSksITApOiJub3NjcmlwdCIhPT1yJiYibm9lbWJlZCIhPT1yJiYibm9mcmFtZXMiIT09cnx8IWooLzxcL25vKHNjcmlwdHxlbWJlZHxmcmFtZXMpL2ksZS5pbm5lckhUTUwpPyhFZSYmMz09PWUubm9kZVR5cGUmJih0PWUudGV4dENvbnRlbnQsZChbY2UsdWUsaGVdLGU9Pnt0PXYodCxlLCIgIil9KSxlLnRleHRDb250ZW50IT09dCYmKGcoQS5yZW1vdmVkLHtlbGVtZW50OmUuY2xvbmVOb2RlKCl9KSxlLnRleHRDb250ZW50PXQpKSx5dChsZS5hZnRlclNhbml0aXplRWxlbWVudHMsZSxudWxsKSwhMSk6KGZ0KGUpLCEwKX0sYnQ9ZnVuY3Rpb24oZSx0LEEpe2lmKFRlJiYoImlkIj09PXR8fCJuYW1lIj09PXQpJiYoQSBpbiBufHxBIGluIGx0KSlyZXR1cm4hMTtpZihGZSYmIWplW3RdJiZqKGRlLHQpKTtlbHNlIGlmKHhlJiZqKGZlLHQpKTtlbHNlIGlmKCF2ZVt0XXx8amVbdF0pe2lmKCEoQ3QoZSkmJihDZS50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAmJmooQ2UudGFnTmFtZUNoZWNrLGUpfHxDZS50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiYmQ2UudGFnTmFtZUNoZWNrKGUpKSYmKENlLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCYmaihDZS5hdHRyaWJ1dGVOYW1lQ2hlY2ssdCl8fENlLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uJiZDZS5hdHRyaWJ1dGVOYW1lQ2hlY2sodCkpfHwiaXMiPT09dCYmQ2UuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzJiYoQ2UudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwJiZqKENlLnRhZ05hbWVDaGVjayxBKXx8Q2UudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24mJkNlLnRhZ05hbWVDaGVjayhBKSkpKXJldHVybiExfWVsc2UgaWYocWVbdF0pO2Vsc2UgaWYoaih3ZSx2KEEsZ2UsIiIpKSk7ZWxzZSBpZigic3JjIiE9PXQmJiJ4bGluazpocmVmIiE9PXQmJiJocmVmIiE9PXR8fCJzY3JpcHQiPT09ZXx8MCE9PWIoQSwiZGF0YToiKXx8IUdlW2VdKWlmKFFlJiYhaihwZSx2KEEsZ2UsIiIpKSk7ZWxzZSBpZihBKXJldHVybiExO3JldHVybiEwfSxDdD1mdW5jdGlvbihlKXtyZXR1cm4iYW5ub3RhdGlvbi14bWwiIT09ZSYmeShlLG1lKX0sX3Q9ZnVuY3Rpb24oZSl7eXQobGUuYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzLGUsbnVsbCk7Y29uc3R7YXR0cmlidXRlczp0fT1lO2lmKCF0fHx3dChlKSlyZXR1cm47Y29uc3Qgcj17YXR0ck5hbWU6IiIsYXR0clZhbHVlOiIiLGtlZXBBdHRyOiEwLGFsbG93ZWRBdHRyaWJ1dGVzOnZlLGZvcmNlS2VlcEF0dHI6dm9pZCAwfTtsZXQgbj10Lmxlbmd0aDtmb3IoO24tLTspe2NvbnN0IHM9dFtuXSx7bmFtZTppLG5hbWVzcGFjZVVSSTpvLHZhbHVlOmF9PXMsbD1vdChpKSxjPWE7bGV0IHU9InZhbHVlIj09PWk/YzpDKGMpO2lmKHIuYXR0ck5hbWU9bCxyLmF0dHJWYWx1ZT11LHIua2VlcEF0dHI9ITAsci5mb3JjZUtlZXBBdHRyPXZvaWQgMCx5dChsZS51cG9uU2FuaXRpemVBdHRyaWJ1dGUsZSxyKSx1PXIuYXR0clZhbHVlLCFPZXx8ImlkIiE9PWwmJiJuYW1lIiE9PWx8fChwdChpLGUpLHU9InVzZXItY29udGVudC0iK3UpLFNlJiZqKC8oKC0tIT98XSk+KXw8XC8oc3R5bGV8dGl0bGUpL2ksdSkpe3B0KGksZSk7Y29udGludWV9aWYoci5mb3JjZUtlZXBBdHRyKWNvbnRpbnVlO2lmKCFyLmtlZXBBdHRyKXtwdChpLGUpO2NvbnRpbnVlfWlmKCFVZSYmaigvXC8+L2ksdSkpe3B0KGksZSk7Y29udGludWV9RWUmJmQoW2NlLHVlLGhlXSxlPT57dT12KHUsZSwiICIpfSk7Y29uc3QgaD1vdChlLm5vZGVOYW1lKTtpZihidChoLGwsdSkpe2lmKEFlJiYib2JqZWN0Ij09dHlwZW9mIEcmJiJmdW5jdGlvbiI9PXR5cGVvZiBHLmdldEF0dHJpYnV0ZVR5cGUpaWYobyk7ZWxzZSBzd2l0Y2goRy5nZXRBdHRyaWJ1dGVUeXBlKGgsbCkpe2Nhc2UiVHJ1c3RlZEhUTUwiOnU9QWUuY3JlYXRlSFRNTCh1KTticmVhaztjYXNlIlRydXN0ZWRTY3JpcHRVUkwiOnU9QWUuY3JlYXRlU2NyaXB0VVJMKHUpfWlmKHUhPT1jKXRyeXtvP2Uuc2V0QXR0cmlidXRlTlMobyxpLHUpOmUuc2V0QXR0cmlidXRlKGksdSksd3QoZSk/ZnQoZSk6cChBLnJlbW92ZWQpfWNhdGNoKHQpe3B0KGksZSl9fWVsc2UgcHQoaSxlKX15dChsZS5hZnRlclNhbml0aXplQXR0cmlidXRlcyxlLG51bGwpfSxqdD1mdW5jdGlvbiBlKHQpe2xldCBBPW51bGw7Y29uc3Qgcj1tdCh0KTtmb3IoeXQobGUuYmVmb3JlU2FuaXRpemVTaGFkb3dET00sdCxudWxsKTtBPXIubmV4dE5vZGUoKTspeXQobGUudXBvblNhbml0aXplU2hhZG93Tm9kZSxBLG51bGwpLHZ0KEEpLF90KEEpLEEuY29udGVudCBpbnN0YW5jZW9mIG8mJmUoQS5jb250ZW50KTt5dChsZS5hZnRlclNhbml0aXplU2hhZG93RE9NLHQsbnVsbCl9O3JldHVybiBBLnNhbml0aXplPWZ1bmN0aW9uKGUpe2xldCB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fSxyPW51bGwsbj1udWxsLGk9bnVsbCxhPW51bGw7aWYoJGU9IWUsJGUmJihlPSJceDNjIS0tXHgzZSIpLCJzdHJpbmciIT10eXBlb2YgZSYmIUJ0KGUpKXtpZigiZnVuY3Rpb24iIT10eXBlb2YgZS50b1N0cmluZyl0aHJvdyB4KCJ0b1N0cmluZyBpcyBub3QgYSBmdW5jdGlvbiIpO2lmKCJzdHJpbmciIT10eXBlb2YoZT1lLnRvU3RyaW5nKCkpKXRocm93IHgoImRpcnR5IGlzIG5vdCBhIHN0cmluZywgYWJvcnRpbmciKX1pZighQS5pc1N1cHBvcnRlZClyZXR1cm4gZTtpZihJZXx8dXQodCksQS5yZW1vdmVkPVtdLCJzdHJpbmciPT10eXBlb2YgZSYmKERlPSExKSxEZSl7aWYoZS5ub2RlTmFtZSl7Y29uc3QgdD1vdChlLm5vZGVOYW1lKTtpZighQmVbdF18fF9lW3RdKXRocm93IHgoInJvb3Qgbm9kZSBpcyBmb3JiaWRkZW4gYW5kIGNhbm5vdCBiZSBzYW5pdGl6ZWQgaW4tcGxhY2UiKX19ZWxzZSBpZihlIGluc3RhbmNlb2YgdSlyPWd0KCJceDNjIS0tLS1ceDNlIiksbj1yLm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShlLCEwKSwxPT09bi5ub2RlVHlwZSYmIkJPRFkiPT09bi5ub2RlTmFtZXx8IkhUTUwiPT09bi5ub2RlTmFtZT9yPW46ci5hcHBlbmRDaGlsZChuKTtlbHNle2lmKCFrZSYmIUVlJiYhTGUmJi0xPT09ZS5pbmRleE9mKCI8IikpcmV0dXJuIEFlJiZQZT9BZS5jcmVhdGVIVE1MKGUpOmU7aWYocj1ndChlKSwhcilyZXR1cm4ga2U/bnVsbDpQZT9yZToiIn1yJiZOZSYmZnQoci5maXJzdENoaWxkKTtjb25zdCBsPW10KERlP2U6cik7Zm9yKDtpPWwubmV4dE5vZGUoKTspdnQoaSksX3QoaSksaS5jb250ZW50IGluc3RhbmNlb2YgbyYmanQoaS5jb250ZW50KTtpZihEZSlyZXR1cm4gZTtpZihrZSl7aWYoSGUpZm9yKGE9aWUuY2FsbChyLm93bmVyRG9jdW1lbnQpO3IuZmlyc3RDaGlsZDspYS5hcHBlbmRDaGlsZChyLmZpcnN0Q2hpbGQpO2Vsc2UgYT1yO3JldHVybih2ZS5zaGFkb3dyb290fHx2ZS5zaGFkb3dyb290bW9kZSkmJihhPWFlLmNhbGwocyxhLCEwKSksYX1sZXQgYz1MZT9yLm91dGVySFRNTDpyLmlubmVySFRNTDtyZXR1cm4gTGUmJkJlWyIhZG9jdHlwZSJdJiZyLm93bmVyRG9jdW1lbnQmJnIub3duZXJEb2N1bWVudC5kb2N0eXBlJiZyLm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lJiZqKFosci5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSkmJihjPSI8IURPQ1RZUEUgIityLm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lKyI+XG4iK2MpLEVlJiZkKFtjZSx1ZSxoZV0sZT0+e2M9dihjLGUsIiAiKX0pLEFlJiZQZT9BZS5jcmVhdGVIVE1MKGMpOmN9LEEuc2V0Q29uZmlnPWZ1bmN0aW9uKCl7dXQoYXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9KSxJZT0hMH0sQS5jbGVhckNvbmZpZz1mdW5jdGlvbigpe2F0PW51bGwsSWU9ITF9LEEuaXNWYWxpZEF0dHJpYnV0ZT1mdW5jdGlvbihlLHQsQSl7YXR8fHV0KHt9KTtjb25zdCByPW90KGUpLG49b3QodCk7cmV0dXJuIGJ0KHIsbixBKX0sQS5hZGRIb29rPWZ1bmN0aW9uKGUsdCl7ImZ1bmN0aW9uIj09dHlwZW9mIHQmJmcobGVbZV0sdCl9LEEucmVtb3ZlSG9vaz1mdW5jdGlvbihlLHQpe2lmKHZvaWQgMCE9PXQpe2NvbnN0IEE9ZihsZVtlXSx0KTtyZXR1cm4tMT09PUE/dm9pZCAwOm0obGVbZV0sQSwxKVswXX1yZXR1cm4gcChsZVtlXSl9LEEucmVtb3ZlSG9va3M9ZnVuY3Rpb24oZSl7bGVbZV09W119LEEucmVtb3ZlQWxsSG9va3M9ZnVuY3Rpb24oKXtsZT17YWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXM6W10sYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzOltdLGFmdGVyU2FuaXRpemVTaGFkb3dET006W10sYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzOltdLGJlZm9yZVNhbml0aXplRWxlbWVudHM6W10sYmVmb3JlU2FuaXRpemVTaGFkb3dET006W10sdXBvblNhbml0aXplQXR0cmlidXRlOltdLHVwb25TYW5pdGl6ZUVsZW1lbnQ6W10sdXBvblNhbml0aXplU2hhZG93Tm9kZTpbXX19LEF9KCl9LCIuL25vZGVfbW9kdWxlcy9mYXN0LXBuZy9saWItZXNtL1BuZ0RlY29kZXIuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QS5yKHQpLEEuZCh0LHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIHV9fSk7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvaW9idWZmZXIvbGliLWVzbS9JT0J1ZmZlci5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvcGFrby9kaXN0L3Bha28uZXNtLm1qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS9oZWxwZXJzL2NyYy5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS9oZWxwZXJzL2RlY29kZUludGVybGFjZUFkYW03LmpzIiksbz1BKCIuL25vZGVfbW9kdWxlcy9mYXN0LXBuZy9saWItZXNtL2hlbHBlcnMvZGVjb2RlSW50ZXJsYWNlTnVsbC5qcyIpLGE9QSgiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS9oZWxwZXJzL3NpZ25hdHVyZS5qcyIpLGw9QSgiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS9oZWxwZXJzL3RleHQuanMiKSxjPUEoIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaW50ZXJuYWxUeXBlcy5qcyIpO2NsYXNzIHUgZXh0ZW5kcyByLklPQnVmZmVye19jaGVja0NyYztfaW5mbGF0b3I7X3BuZztfYXBuZztfZW5kO19oYXNQYWxldHRlO19wYWxldHRlO19oYXNUcmFuc3BhcmVuY3k7X3RyYW5zcGFyZW5jeTtfY29tcHJlc3Npb25NZXRob2Q7X2ZpbHRlck1ldGhvZDtfaW50ZXJsYWNlTWV0aG9kO19jb2xvclR5cGU7X2lzQW5pbWF0ZWQ7X251bWJlck9mRnJhbWVzO19udW1iZXJPZlBsYXlzO19mcmFtZXM7X3dyaXRpbmdEYXRhQ2h1bmtzO2NvbnN0cnVjdG9yKGUsdD17fSl7c3VwZXIoZSk7Y29uc3R7Y2hlY2tDcmM6QT0hMX09dDt0aGlzLl9jaGVja0NyYz1BLHRoaXMuX2luZmxhdG9yPW5ldyBuLkluZmxhdGUsdGhpcy5fcG5nPXt3aWR0aDotMSxoZWlnaHQ6LTEsY2hhbm5lbHM6LTEsZGF0YTpuZXcgVWludDhBcnJheSgwKSxkZXB0aDoxLHRleHQ6e319LHRoaXMuX2Fwbmc9e3dpZHRoOi0xLGhlaWdodDotMSxjaGFubmVsczotMSxkZXB0aDoxLG51bWJlck9mRnJhbWVzOjEsbnVtYmVyT2ZQbGF5czowLHRleHQ6e30sZnJhbWVzOltdfSx0aGlzLl9lbmQ9ITEsdGhpcy5faGFzUGFsZXR0ZT0hMSx0aGlzLl9wYWxldHRlPVtdLHRoaXMuX2hhc1RyYW5zcGFyZW5jeT0hMSx0aGlzLl90cmFuc3BhcmVuY3k9bmV3IFVpbnQxNkFycmF5KDApLHRoaXMuX2NvbXByZXNzaW9uTWV0aG9kPWMuQ29tcHJlc3Npb25NZXRob2QuVU5LTk9XTix0aGlzLl9maWx0ZXJNZXRob2Q9Yy5GaWx0ZXJNZXRob2QuVU5LTk9XTix0aGlzLl9pbnRlcmxhY2VNZXRob2Q9Yy5JbnRlcmxhY2VNZXRob2QuVU5LTk9XTix0aGlzLl9jb2xvclR5cGU9Yy5Db2xvclR5cGUuVU5LTk9XTix0aGlzLl9pc0FuaW1hdGVkPSExLHRoaXMuX251bWJlck9mRnJhbWVzPTEsdGhpcy5fbnVtYmVyT2ZQbGF5cz0wLHRoaXMuX2ZyYW1lcz1bXSx0aGlzLl93cml0aW5nRGF0YUNodW5rcz0hMSx0aGlzLnNldEJpZ0VuZGlhbigpfWRlY29kZSgpe2ZvcigoMCxhLmNoZWNrU2lnbmF0dXJlKSh0aGlzKTshdGhpcy5fZW5kOyl7Y29uc3QgZT10aGlzLnJlYWRVaW50MzIoKSx0PXRoaXMucmVhZENoYXJzKDQpO3RoaXMuZGVjb2RlQ2h1bmsoZSx0KX1yZXR1cm4gdGhpcy5kZWNvZGVJbWFnZSgpLHRoaXMuX3BuZ31kZWNvZGVBcG5nKCl7Zm9yKCgwLGEuY2hlY2tTaWduYXR1cmUpKHRoaXMpOyF0aGlzLl9lbmQ7KXtjb25zdCBlPXRoaXMucmVhZFVpbnQzMigpLHQ9dGhpcy5yZWFkQ2hhcnMoNCk7dGhpcy5kZWNvZGVBcG5nQ2h1bmsoZSx0KX1yZXR1cm4gdGhpcy5kZWNvZGVBcG5nSW1hZ2UoKSx0aGlzLl9hcG5nfWRlY29kZUNodW5rKGUsdCl7Y29uc3QgQT10aGlzLm9mZnNldDtzd2l0Y2godCl7Y2FzZSJJSERSIjp0aGlzLmRlY29kZUlIRFIoKTticmVhaztjYXNlIlBMVEUiOnRoaXMuZGVjb2RlUExURShlKTticmVhaztjYXNlIklEQVQiOnRoaXMuZGVjb2RlSURBVChlKTticmVhaztjYXNlIklFTkQiOnRoaXMuX2VuZD0hMDticmVhaztjYXNlInRSTlMiOnRoaXMuZGVjb2RldFJOUyhlKTticmVhaztjYXNlImlDQ1AiOnRoaXMuZGVjb2RlaUNDUChlKTticmVhaztjYXNlIGwudGV4dENodW5rTmFtZTooMCxsLmRlY29kZXRFWHQpKHRoaXMuX3BuZy50ZXh0LHRoaXMsZSk7YnJlYWs7Y2FzZSJwSFlzIjp0aGlzLmRlY29kZXBIWXMoKTticmVhaztkZWZhdWx0OnRoaXMuc2tpcChlKX1pZih0aGlzLm9mZnNldC1BIT09ZSl0aHJvdyBuZXcgRXJyb3IoYExlbmd0aCBtaXNtYXRjaCB3aGlsZSBkZWNvZGluZyBjaHVuayAke3R9YCk7dGhpcy5fY2hlY2tDcmM/KDAscy5jaGVja0NyYykodGhpcyxlKzQsdCk6dGhpcy5za2lwKDQpfWRlY29kZUFwbmdDaHVuayhlLHQpe2NvbnN0IEE9dGhpcy5vZmZzZXQ7c3dpdGNoKCJmZEFUIiE9PXQmJiJJREFUIiE9PXQmJnRoaXMuX3dyaXRpbmdEYXRhQ2h1bmtzJiZ0aGlzLnB1c2hEYXRhVG9GcmFtZSgpLHQpe2Nhc2UiYWNUTCI6dGhpcy5kZWNvZGVBQ1RMKCk7YnJlYWs7Y2FzZSJmY1RMIjp0aGlzLmRlY29kZUZDVEwoKTticmVhaztjYXNlImZkQVQiOnRoaXMuZGVjb2RlRkRBVChlKTticmVhaztkZWZhdWx0OnRoaXMuZGVjb2RlQ2h1bmsoZSx0KSx0aGlzLm9mZnNldD1BK2V9aWYodGhpcy5vZmZzZXQtQSE9PWUpdGhyb3cgbmV3IEVycm9yKGBMZW5ndGggbWlzbWF0Y2ggd2hpbGUgZGVjb2RpbmcgY2h1bmsgJHt0fWApO3RoaXMuX2NoZWNrQ3JjPygwLHMuY2hlY2tDcmMpKHRoaXMsZSs0LHQpOnRoaXMuc2tpcCg0KX1kZWNvZGVJSERSKCl7Y29uc3QgZT10aGlzLl9wbmc7ZS53aWR0aD10aGlzLnJlYWRVaW50MzIoKSxlLmhlaWdodD10aGlzLnJlYWRVaW50MzIoKSxlLmRlcHRoPWZ1bmN0aW9uKGUpe2lmKDEhPT1lJiYyIT09ZSYmNCE9PWUmJjghPT1lJiYxNiE9PWUpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGJpdCBkZXB0aDogJHtlfWApO3JldHVybiBlfSh0aGlzLnJlYWRVaW50OCgpKTtjb25zdCB0PXRoaXMucmVhZFVpbnQ4KCk7bGV0IEE7c3dpdGNoKHRoaXMuX2NvbG9yVHlwZT10LHQpe2Nhc2UgYy5Db2xvclR5cGUuR1JFWVNDQUxFOkE9MTticmVhaztjYXNlIGMuQ29sb3JUeXBlLlRSVUVDT0xPVVI6QT0zO2JyZWFrO2Nhc2UgYy5Db2xvclR5cGUuSU5ERVhFRF9DT0xPVVI6QT0xO2JyZWFrO2Nhc2UgYy5Db2xvclR5cGUuR1JFWVNDQUxFX0FMUEhBOkE9MjticmVhaztjYXNlIGMuQ29sb3JUeXBlLlRSVUVDT0xPVVJfQUxQSEE6QT00O2JyZWFrO2Nhc2UgYy5Db2xvclR5cGUuVU5LTk9XTjpkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb2xvciB0eXBlOiAke3R9YCl9aWYodGhpcy5fcG5nLmNoYW5uZWxzPUEsdGhpcy5fY29tcHJlc3Npb25NZXRob2Q9dGhpcy5yZWFkVWludDgoKSx0aGlzLl9jb21wcmVzc2lvbk1ldGhvZCE9PWMuQ29tcHJlc3Npb25NZXRob2QuREVGTEFURSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZDogJHt0aGlzLl9jb21wcmVzc2lvbk1ldGhvZH1gKTt0aGlzLl9maWx0ZXJNZXRob2Q9dGhpcy5yZWFkVWludDgoKSx0aGlzLl9pbnRlcmxhY2VNZXRob2Q9dGhpcy5yZWFkVWludDgoKX1kZWNvZGVBQ1RMKCl7dGhpcy5fbnVtYmVyT2ZGcmFtZXM9dGhpcy5yZWFkVWludDMyKCksdGhpcy5fbnVtYmVyT2ZQbGF5cz10aGlzLnJlYWRVaW50MzIoKSx0aGlzLl9pc0FuaW1hdGVkPSEwfWRlY29kZUZDVEwoKXtjb25zdCBlPXtzZXF1ZW5jZU51bWJlcjp0aGlzLnJlYWRVaW50MzIoKSx3aWR0aDp0aGlzLnJlYWRVaW50MzIoKSxoZWlnaHQ6dGhpcy5yZWFkVWludDMyKCkseE9mZnNldDp0aGlzLnJlYWRVaW50MzIoKSx5T2Zmc2V0OnRoaXMucmVhZFVpbnQzMigpLGRlbGF5TnVtYmVyOnRoaXMucmVhZFVpbnQxNigpLGRlbGF5RGVub21pbmF0b3I6dGhpcy5yZWFkVWludDE2KCksZGlzcG9zZU9wOnRoaXMucmVhZFVpbnQ4KCksYmxlbmRPcDp0aGlzLnJlYWRVaW50OCgpLGRhdGE6bmV3IFVpbnQ4QXJyYXkoMCl9O3RoaXMuX2ZyYW1lcy5wdXNoKGUpfWRlY29kZVBMVEUoZSl7aWYoZSUzIT0wKXRocm93IG5ldyBSYW5nZUVycm9yKGBQTFRFIGZpZWxkIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMy4gR290ICR7ZX1gKTtjb25zdCB0PWUvMzt0aGlzLl9oYXNQYWxldHRlPSEwO2NvbnN0IEE9W107dGhpcy5fcGFsZXR0ZT1BO2ZvcihsZXQgZT0wO2U8dDtlKyspQS5wdXNoKFt0aGlzLnJlYWRVaW50OCgpLHRoaXMucmVhZFVpbnQ4KCksdGhpcy5yZWFkVWludDgoKV0pfWRlY29kZUlEQVQoZSl7dGhpcy5fd3JpdGluZ0RhdGFDaHVua3M9ITA7Y29uc3QgdD1lLEE9dGhpcy5vZmZzZXQrdGhpcy5ieXRlT2Zmc2V0O2lmKHRoaXMuX2luZmxhdG9yLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsQSx0KSksdGhpcy5faW5mbGF0b3IuZXJyKXRocm93IG5ldyBFcnJvcihgRXJyb3Igd2hpbGUgZGVjb21wcmVzc2luZyB0aGUgZGF0YTogJHt0aGlzLl9pbmZsYXRvci5lcnJ9YCk7dGhpcy5za2lwKGUpfWRlY29kZUZEQVQoZSl7dGhpcy5fd3JpdGluZ0RhdGFDaHVua3M9ITA7bGV0IHQ9ZSxBPXRoaXMub2Zmc2V0K3RoaXMuYnl0ZU9mZnNldDtpZihBKz00LHQtPTQsdGhpcy5faW5mbGF0b3IucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcixBLHQpKSx0aGlzLl9pbmZsYXRvci5lcnIpdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBkZWNvbXByZXNzaW5nIHRoZSBkYXRhOiAke3RoaXMuX2luZmxhdG9yLmVycn1gKTt0aGlzLnNraXAoZSl9ZGVjb2RldFJOUyhlKXtzd2l0Y2godGhpcy5fY29sb3JUeXBlKXtjYXNlIGMuQ29sb3JUeXBlLkdSRVlTQ0FMRTpjYXNlIGMuQ29sb3JUeXBlLlRSVUVDT0xPVVI6aWYoZSUyIT0wKXRocm93IG5ldyBSYW5nZUVycm9yKGB0Uk5TIGNodW5rIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMi4gR290ICR7ZX1gKTtpZihlLzI+dGhpcy5fcG5nLndpZHRoKnRoaXMuX3BuZy5oZWlnaHQpdGhyb3cgbmV3IEVycm9yKGB0Uk5TIGNodW5rIGNvbnRhaW5zIG1vcmUgYWxwaGEgdmFsdWVzIHRoYW4gdGhlcmUgYXJlIHBpeGVscyAoJHtlLzJ9IHZzICR7dGhpcy5fcG5nLndpZHRoKnRoaXMuX3BuZy5oZWlnaHR9KWApO3RoaXMuX2hhc1RyYW5zcGFyZW5jeT0hMCx0aGlzLl90cmFuc3BhcmVuY3k9bmV3IFVpbnQxNkFycmF5KGUvMik7Zm9yKGxldCB0PTA7dDxlLzI7dCsrKXRoaXMuX3RyYW5zcGFyZW5jeVt0XT10aGlzLnJlYWRVaW50MTYoKTticmVhaztjYXNlIGMuQ29sb3JUeXBlLklOREVYRURfQ09MT1VSOntpZihlPnRoaXMuX3BhbGV0dGUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgdFJOUyBjaHVuayBjb250YWlucyBtb3JlIGFscGhhIHZhbHVlcyB0aGFuIHRoZXJlIGFyZSBwYWxldHRlIGNvbG9ycyAoJHtlfSB2cyAke3RoaXMuX3BhbGV0dGUubGVuZ3RofSlgKTtsZXQgdD0wO2Zvcig7dDxlO3QrKyl7Y29uc3QgZT10aGlzLnJlYWRCeXRlKCk7dGhpcy5fcGFsZXR0ZVt0XS5wdXNoKGUpfWZvcig7dDx0aGlzLl9wYWxldHRlLmxlbmd0aDt0KyspdGhpcy5fcGFsZXR0ZVt0XS5wdXNoKDI1NSk7YnJlYWt9Y2FzZSBjLkNvbG9yVHlwZS5VTktOT1dOOmNhc2UgYy5Db2xvclR5cGUuR1JFWVNDQUxFX0FMUEhBOmNhc2UgYy5Db2xvclR5cGUuVFJVRUNPTE9VUl9BTFBIQTpkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdFJOUyBjaHVuayBpcyBub3Qgc3VwcG9ydGVkIGZvciBjb2xvciB0eXBlICR7dGhpcy5fY29sb3JUeXBlfWApfX1kZWNvZGVpQ0NQKGUpe2NvbnN0IHQ9KDAsbC5yZWFkS2V5d29yZCkodGhpcyksQT10aGlzLnJlYWRVaW50OCgpO2lmKEEhPT1jLkNvbXByZXNzaW9uTWV0aG9kLkRFRkxBVEUpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBpQ0NQIGNvbXByZXNzaW9uIG1ldGhvZDogJHtBfWApO2NvbnN0IHI9dGhpcy5yZWFkQnl0ZXMoZS10Lmxlbmd0aC0yKTt0aGlzLl9wbmcuaWNjRW1iZWRkZWRQcm9maWxlPXtuYW1lOnQscHJvZmlsZTooMCxuLmluZmxhdGUpKHIpfX1kZWNvZGVwSFlzKCl7Y29uc3QgZT10aGlzLnJlYWRVaW50MzIoKSx0PXRoaXMucmVhZFVpbnQzMigpLEE9dGhpcy5yZWFkQnl0ZSgpO3RoaXMuX3BuZy5yZXNvbHV0aW9uPXt4OmUseTp0LHVuaXQ6QX19ZGVjb2RlQXBuZ0ltYWdlKCl7dGhpcy5fYXBuZy53aWR0aD10aGlzLl9wbmcud2lkdGgsdGhpcy5fYXBuZy5oZWlnaHQ9dGhpcy5fcG5nLmhlaWdodCx0aGlzLl9hcG5nLmNoYW5uZWxzPXRoaXMuX3BuZy5jaGFubmVscyx0aGlzLl9hcG5nLmRlcHRoPXRoaXMuX3BuZy5kZXB0aCx0aGlzLl9hcG5nLm51bWJlck9mRnJhbWVzPXRoaXMuX251bWJlck9mRnJhbWVzLHRoaXMuX2FwbmcubnVtYmVyT2ZQbGF5cz10aGlzLl9udW1iZXJPZlBsYXlzLHRoaXMuX2FwbmcudGV4dD10aGlzLl9wbmcudGV4dCx0aGlzLl9hcG5nLnJlc29sdXRpb249dGhpcy5fcG5nLnJlc29sdXRpb247Zm9yKGxldCBlPTA7ZTx0aGlzLl9udW1iZXJPZkZyYW1lcztlKyspe2NvbnN0IHQ9e3NlcXVlbmNlTnVtYmVyOnRoaXMuX2ZyYW1lc1tlXS5zZXF1ZW5jZU51bWJlcixkZWxheU51bWJlcjp0aGlzLl9mcmFtZXNbZV0uZGVsYXlOdW1iZXIsZGVsYXlEZW5vbWluYXRvcjp0aGlzLl9mcmFtZXNbZV0uZGVsYXlEZW5vbWluYXRvcixkYXRhOjg9PT10aGlzLl9hcG5nLmRlcHRoP25ldyBVaW50OEFycmF5KHRoaXMuX2Fwbmcud2lkdGgqdGhpcy5fYXBuZy5oZWlnaHQqdGhpcy5fYXBuZy5jaGFubmVscyk6bmV3IFVpbnQxNkFycmF5KHRoaXMuX2Fwbmcud2lkdGgqdGhpcy5fYXBuZy5oZWlnaHQqdGhpcy5fYXBuZy5jaGFubmVscyl9LEE9dGhpcy5fZnJhbWVzLmF0KGUpO2lmKEEpe2lmKEEuZGF0YT0oMCxvLmRlY29kZUludGVybGFjZU51bGwpKHtkYXRhOkEuZGF0YSx3aWR0aDpBLndpZHRoLGhlaWdodDpBLmhlaWdodCxjaGFubmVsczp0aGlzLl9hcG5nLmNoYW5uZWxzLGRlcHRoOnRoaXMuX2FwbmcuZGVwdGh9KSx0aGlzLl9oYXNQYWxldHRlJiYodGhpcy5fYXBuZy5wYWxldHRlPXRoaXMuX3BhbGV0dGUpLHRoaXMuX2hhc1RyYW5zcGFyZW5jeSYmKHRoaXMuX2FwbmcudHJhbnNwYXJlbmN5PXRoaXMuX3RyYW5zcGFyZW5jeSksMD09PWV8fDA9PT1BLnhPZmZzZXQmJjA9PT1BLnlPZmZzZXQmJkEud2lkdGg9PT10aGlzLl9wbmcud2lkdGgmJkEuaGVpZ2h0PT09dGhpcy5fcG5nLmhlaWdodCl0LmRhdGE9QS5kYXRhO2Vsc2V7Y29uc3Qgcj10aGlzLl9hcG5nLmZyYW1lcy5hdChlLTEpO3RoaXMuZGlzcG9zZUZyYW1lKEEscix0KSx0aGlzLmFkZEZyYW1lRGF0YVRvQ2FudmFzKHQsQSl9dGhpcy5fYXBuZy5mcmFtZXMucHVzaCh0KX19cmV0dXJuIHRoaXMuX2Fwbmd9ZGlzcG9zZUZyYW1lKGUsdCxBKXtzd2l0Y2goZS5kaXNwb3NlT3Ape2Nhc2UgYy5EaXNwb3NlT3BUeXBlLk5PTkU6YnJlYWs7Y2FzZSBjLkRpc3Bvc2VPcFR5cGUuQkFDS0dST1VORDpmb3IobGV0IHQ9MDt0PHRoaXMuX3BuZy5oZWlnaHQ7dCsrKWZvcihsZXQgcj0wO3I8dGhpcy5fcG5nLndpZHRoO3IrKyl7Y29uc3Qgbj0odCplLndpZHRoK3IpKnRoaXMuX3BuZy5jaGFubmVscztmb3IobGV0IGU9MDtlPHRoaXMuX3BuZy5jaGFubmVscztlKyspQS5kYXRhW24rZV09MH1icmVhaztjYXNlIGMuRGlzcG9zZU9wVHlwZS5QUkVWSU9VUzpBLmRhdGEuc2V0KHQuZGF0YSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gZGlzcG9zZU9wIil9fWFkZEZyYW1lRGF0YVRvQ2FudmFzKGUsdCl7Y29uc3QgQT0xPDx0aGlzLl9wbmcuZGVwdGgscj0oZSxBKT0+KHtpbmRleDooKGUrdC55T2Zmc2V0KSp0aGlzLl9wbmcud2lkdGgrdC54T2Zmc2V0K0EpKnRoaXMuX3BuZy5jaGFubmVscyxmcmFtZUluZGV4OihlKnQud2lkdGgrQSkqdGhpcy5fcG5nLmNoYW5uZWxzfSk7c3dpdGNoKHQuYmxlbmRPcCl7Y2FzZSBjLkJsZW5kT3BUeXBlLlNPVVJDRTpmb3IobGV0IEE9MDtBPHQuaGVpZ2h0O0ErKylmb3IobGV0IG49MDtuPHQud2lkdGg7bisrKXtjb25zdHtpbmRleDpzLGZyYW1lSW5kZXg6aX09cihBLG4pO2ZvcihsZXQgQT0wO0E8dGhpcy5fcG5nLmNoYW5uZWxzO0ErKyllLmRhdGFbcytBXT10LmRhdGFbaStBXX1icmVhaztjYXNlIGMuQmxlbmRPcFR5cGUuT1ZFUjpmb3IobGV0IG49MDtuPHQuaGVpZ2h0O24rKylmb3IobGV0IHM9MDtzPHQud2lkdGg7cysrKXtjb25zdHtpbmRleDppLGZyYW1lSW5kZXg6b309cihuLHMpO2ZvcihsZXQgcj0wO3I8dGhpcy5fcG5nLmNoYW5uZWxzO3IrKyl7Y29uc3Qgbj10LmRhdGFbbyt0aGlzLl9wbmcuY2hhbm5lbHMtMV0vQSxzPXIlKHRoaXMuX3BuZy5jaGFubmVscy0xKT09MD8xOnQuZGF0YVtvK3JdLGE9TWF0aC5mbG9vcihuKnMrKDEtbikqZS5kYXRhW2krcl0pO2UuZGF0YVtpK3JdKz1hfX1icmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5rbm93biBibGVuZE9wIil9fWRlY29kZUltYWdlKCl7aWYodGhpcy5faW5mbGF0b3IuZXJyKXRocm93IG5ldyBFcnJvcihgRXJyb3Igd2hpbGUgZGVjb21wcmVzc2luZyB0aGUgZGF0YTogJHt0aGlzLl9pbmZsYXRvci5lcnJ9YCk7Y29uc3QgZT10aGlzLl9pc0FuaW1hdGVkPyh0aGlzLl9mcmFtZXM/LmF0KDApKS5kYXRhOnRoaXMuX2luZmxhdG9yLnJlc3VsdDtpZih0aGlzLl9maWx0ZXJNZXRob2QhPT1jLkZpbHRlck1ldGhvZC5BREFQVElWRSl0aHJvdyBuZXcgRXJyb3IoYEZpbHRlciBtZXRob2QgJHt0aGlzLl9maWx0ZXJNZXRob2R9IG5vdCBzdXBwb3J0ZWRgKTtpZih0aGlzLl9pbnRlcmxhY2VNZXRob2Q9PT1jLkludGVybGFjZU1ldGhvZC5OT19JTlRFUkxBQ0UpdGhpcy5fcG5nLmRhdGE9KDAsby5kZWNvZGVJbnRlcmxhY2VOdWxsKSh7ZGF0YTplLHdpZHRoOnRoaXMuX3BuZy53aWR0aCxoZWlnaHQ6dGhpcy5fcG5nLmhlaWdodCxjaGFubmVsczp0aGlzLl9wbmcuY2hhbm5lbHMsZGVwdGg6dGhpcy5fcG5nLmRlcHRofSk7ZWxzZXtpZih0aGlzLl9pbnRlcmxhY2VNZXRob2QhPT1jLkludGVybGFjZU1ldGhvZC5BREFNNyl0aHJvdyBuZXcgRXJyb3IoYEludGVybGFjZSBtZXRob2QgJHt0aGlzLl9pbnRlcmxhY2VNZXRob2R9IG5vdCBzdXBwb3J0ZWRgKTt0aGlzLl9wbmcuZGF0YT0oMCxpLmRlY29kZUludGVybGFjZUFkYW03KSh7ZGF0YTplLHdpZHRoOnRoaXMuX3BuZy53aWR0aCxoZWlnaHQ6dGhpcy5fcG5nLmhlaWdodCxjaGFubmVsczp0aGlzLl9wbmcuY2hhbm5lbHMsZGVwdGg6dGhpcy5fcG5nLmRlcHRofSl9dGhpcy5faGFzUGFsZXR0ZSYmKHRoaXMuX3BuZy5wYWxldHRlPXRoaXMuX3BhbGV0dGUpLHRoaXMuX2hhc1RyYW5zcGFyZW5jeSYmKHRoaXMuX3BuZy50cmFuc3BhcmVuY3k9dGhpcy5fdHJhbnNwYXJlbmN5KX1wdXNoRGF0YVRvRnJhbWUoKXtjb25zdCBlPXRoaXMuX2luZmxhdG9yLnJlc3VsdCx0PXRoaXMuX2ZyYW1lcy5hdCgtMSk7dD90LmRhdGE9ZTp0aGlzLl9mcmFtZXMucHVzaCh7c2VxdWVuY2VOdW1iZXI6MCx3aWR0aDp0aGlzLl9wbmcud2lkdGgsaGVpZ2h0OnRoaXMuX3BuZy5oZWlnaHQseE9mZnNldDowLHlPZmZzZXQ6MCxkZWxheU51bWJlcjowLGRlbGF5RGVub21pbmF0b3I6MCxkaXNwb3NlT3A6Yy5EaXNwb3NlT3BUeXBlLk5PTkUsYmxlbmRPcDpjLkJsZW5kT3BUeXBlLlNPVVJDRSxkYXRhOmV9KSx0aGlzLl9pbmZsYXRvcj1uZXcgbi5JbmZsYXRlLHRoaXMuX3dyaXRpbmdEYXRhQ2h1bmtzPSExfX19LCIuL25vZGVfbW9kdWxlcy9mYXN0LXBuZy9saWItZXNtL1BuZ0VuY29kZXIuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QS5yKHQpLEEuZCh0LHtkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIGN9fSk7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvaW9idWZmZXIvbGliLWVzbS9JT0J1ZmZlci5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvcGFrby9kaXN0L3Bha28uZXNtLm1qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS9oZWxwZXJzL2NyYy5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS9oZWxwZXJzL3NpZ25hdHVyZS5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS9oZWxwZXJzL3RleHQuanMiKSxhPUEoIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaW50ZXJuYWxUeXBlcy5qcyIpO2NvbnN0IGw9e2xldmVsOjN9O2NsYXNzIGMgZXh0ZW5kcyByLklPQnVmZmVye19wbmc7X3psaWJPcHRpb25zO19jb2xvclR5cGU7X2ludGVybGFjZU1ldGhvZDtjb25zdHJ1Y3RvcihlLHQ9e30pe3N1cGVyKCksdGhpcy5fY29sb3JUeXBlPWEuQ29sb3JUeXBlLlVOS05PV04sdGhpcy5femxpYk9wdGlvbnM9ey4uLmwsLi4udC56bGlifSx0aGlzLl9wbmc9dGhpcy5fY2hlY2tEYXRhKGUpLHRoaXMuX2ludGVybGFjZU1ldGhvZD0oIkFkYW03Ij09PXQuaW50ZXJsYWNlP2EuSW50ZXJsYWNlTWV0aG9kLkFEQU03OmEuSW50ZXJsYWNlTWV0aG9kLk5PX0lOVEVSTEFDRSk/P2EuSW50ZXJsYWNlTWV0aG9kLk5PX0lOVEVSTEFDRSx0aGlzLnNldEJpZ0VuZGlhbigpfWVuY29kZSgpe2lmKCgwLGkud3JpdGVTaWduYXR1cmUpKHRoaXMpLHRoaXMuZW5jb2RlSUhEUigpLHRoaXMuX3BuZy5wYWxldHRlJiYodGhpcy5lbmNvZGVQTFRFKCksND09PXRoaXMuX3BuZy5wYWxldHRlWzBdLmxlbmd0aCYmdGhpcy5lbmNvZGVUUk5TKCkpLHRoaXMuZW5jb2RlRGF0YSgpLHRoaXMuX3BuZy50ZXh0KWZvcihjb25zdFtlLHRdb2YgT2JqZWN0LmVudHJpZXModGhpcy5fcG5nLnRleHQpKSgwLG8uZW5jb2RldEVYdCkodGhpcyxlLHQpO3JldHVybiB0aGlzLmVuY29kZUlFTkQoKSx0aGlzLnRvQXJyYXkoKX1lbmNvZGVJSERSKCl7dGhpcy53cml0ZVVpbnQzMigxMyksdGhpcy53cml0ZUNoYXJzKCJJSERSIiksdGhpcy53cml0ZVVpbnQzMih0aGlzLl9wbmcud2lkdGgpLHRoaXMud3JpdGVVaW50MzIodGhpcy5fcG5nLmhlaWdodCksdGhpcy53cml0ZUJ5dGUodGhpcy5fcG5nLmRlcHRoKSx0aGlzLndyaXRlQnl0ZSh0aGlzLl9jb2xvclR5cGUpLHRoaXMud3JpdGVCeXRlKGEuQ29tcHJlc3Npb25NZXRob2QuREVGTEFURSksdGhpcy53cml0ZUJ5dGUoYS5GaWx0ZXJNZXRob2QuQURBUFRJVkUpLHRoaXMud3JpdGVCeXRlKHRoaXMuX2ludGVybGFjZU1ldGhvZCksKDAscy53cml0ZUNyYykodGhpcywxNyl9ZW5jb2RlSUVORCgpe3RoaXMud3JpdGVVaW50MzIoMCksdGhpcy53cml0ZUNoYXJzKCJJRU5EIiksKDAscy53cml0ZUNyYykodGhpcyw0KX1lbmNvZGVQTFRFKCl7Y29uc3QgZT0zKnRoaXMuX3BuZy5wYWxldHRlPy5sZW5ndGg7dGhpcy53cml0ZVVpbnQzMihlKSx0aGlzLndyaXRlQ2hhcnMoIlBMVEUiKTtmb3IoY29uc3QgZSBvZiB0aGlzLl9wbmcucGFsZXR0ZSl0aGlzLndyaXRlQnl0ZShlWzBdKSx0aGlzLndyaXRlQnl0ZShlWzFdKSx0aGlzLndyaXRlQnl0ZShlWzJdKTsoMCxzLndyaXRlQ3JjKSh0aGlzLDQrZSl9ZW5jb2RlVFJOUygpe2NvbnN0IGU9dGhpcy5fcG5nLnBhbGV0dGUuZmlsdGVyKGU9PjI1NSE9PWUuYXQoLTEpKTt0aGlzLndyaXRlVWludDMyKGUubGVuZ3RoKSx0aGlzLndyaXRlQ2hhcnMoInRSTlMiKTtmb3IoY29uc3QgdCBvZiBlKXRoaXMud3JpdGVCeXRlKHQuYXQoLTEpKTsoMCxzLndyaXRlQ3JjKSh0aGlzLDQrZS5sZW5ndGgpfWVuY29kZUlEQVQoZSl7dGhpcy53cml0ZVVpbnQzMihlLmxlbmd0aCksdGhpcy53cml0ZUNoYXJzKCJJREFUIiksdGhpcy53cml0ZUJ5dGVzKGUpLCgwLHMud3JpdGVDcmMpKHRoaXMsZS5sZW5ndGgrNCl9ZW5jb2RlRGF0YSgpe2NvbnN0e3dpZHRoOmUsaGVpZ2h0OnQsY2hhbm5lbHM6QSxkZXB0aDpzLGRhdGE6aX09dGhpcy5fcG5nLG89czw9OD9NYXRoLmNlaWwoZSpzLzgpKkE6TWF0aC5jZWlsKGUqcy84KkEvMiksbD0obmV3IHIuSU9CdWZmZXIpLnNldEJpZ0VuZGlhbigpO2xldCBjPTA7aWYodGhpcy5faW50ZXJsYWNlTWV0aG9kPT09YS5JbnRlcmxhY2VNZXRob2QuTk9fSU5URVJMQUNFKWZvcihsZXQgZT0wO2U8dDtlKyspbC53cml0ZUJ5dGUoMCksYz0xNj09PXM/ZChpLGwsbyxjKTpoKGksbCxvLGMpO2Vsc2UgdGhpcy5faW50ZXJsYWNlTWV0aG9kPT09YS5JbnRlcmxhY2VNZXRob2QuQURBTTcmJihjPWZ1bmN0aW9uKGUsdCxBLHIpe2NvbnN0IG49W3t4OjAseTowLHhTdGVwOjgseVN0ZXA6OH0se3g6NCx5OjAseFN0ZXA6OCx5U3RlcDo4fSx7eDowLHk6NCx4U3RlcDo0LHlTdGVwOjh9LHt4OjIseTowLHhTdGVwOjQseVN0ZXA6NH0se3g6MCx5OjIseFN0ZXA6Mix5U3RlcDo0fSx7eDoxLHk6MCx4U3RlcDoyLHlTdGVwOjJ9LHt4OjAseToxLHhTdGVwOjEseVN0ZXA6Mn1dLHt3aWR0aDpzLGhlaWdodDppLGNoYW5uZWxzOm8sZGVwdGg6YX09ZTtsZXQgbD0wO2w9MTY9PT1hP28qYS84LzI6byphLzg7Zm9yKGxldCBlPTA7ZTw3O2UrKyl7Y29uc3Qgcj1uW2VdLG89TWF0aC5mbG9vcigocy1yLngrci54U3RlcC0xKS9yLnhTdGVwKSxjPU1hdGguZmxvb3IoKGktci55K3IueVN0ZXAtMSkvci55U3RlcCk7aWYobzw9MHx8Yzw9MCljb250aW51ZTtjb25zdCB1PW8qbDtmb3IobGV0IGU9MDtlPGM7ZSsrKXtjb25zdCBuPXIueStlKnIueVN0ZXAsYz1hPD04P25ldyBVaW50OEFycmF5KHUpOm5ldyBVaW50MTZBcnJheSh1KTtsZXQgaD0wO2ZvcihsZXQgZT0wO2U8bztlKyspe2NvbnN0IEE9ci54K2Uqci54U3RlcDtpZihBPHMmJm48aSl7Y29uc3QgZT0obipzK0EpKmw7Zm9yKGxldCBBPTA7QTxsO0ErKyljW2grK109dFtlK0FdfX1pZihBLndyaXRlQnl0ZSgwKSw4PT09YSlBLndyaXRlQnl0ZXMoYyk7ZWxzZSBpZigxNj09PWEpZm9yKGNvbnN0IGUgb2YgYylBLndyaXRlQnl0ZShlPj44JjI1NSksQS53cml0ZUJ5dGUoMjU1JmUpfX1yZXR1cm4gcn0odGhpcy5fcG5nLGksbCxjKSk7Y29uc3QgdT1sLnRvQXJyYXkoKSxmPSgwLG4uZGVmbGF0ZSkodSx0aGlzLl96bGliT3B0aW9ucyk7dGhpcy5lbmNvZGVJREFUKGYpfV9jaGVja0RhdGEoZSl7Y29uc3R7Y29sb3JUeXBlOnQsY2hhbm5lbHM6QSxkZXB0aDpyfT1mdW5jdGlvbihlLHQpe2NvbnN0e2NoYW5uZWxzOkE9NCxkZXB0aDpyPTh9PWU7aWYoNCE9PUEmJjMhPT1BJiYyIT09QSYmMSE9PUEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVuc3VwcG9ydGVkIG51bWJlciBvZiBjaGFubmVsczogJHtBfWApO2NvbnN0IG49e2NoYW5uZWxzOkEsZGVwdGg6cixjb2xvclR5cGU6YS5Db2xvclR5cGUuVU5LTk9XTn07c3dpdGNoKEEpe2Nhc2UgNDpuLmNvbG9yVHlwZT1hLkNvbG9yVHlwZS5UUlVFQ09MT1VSX0FMUEhBO2JyZWFrO2Nhc2UgMzpuLmNvbG9yVHlwZT1hLkNvbG9yVHlwZS5UUlVFQ09MT1VSO2JyZWFrO2Nhc2UgMTpuLmNvbG9yVHlwZT10P2EuQ29sb3JUeXBlLklOREVYRURfQ09MT1VSOmEuQ29sb3JUeXBlLkdSRVlTQ0FMRTticmVhaztjYXNlIDI6bi5jb2xvclR5cGU9YS5Db2xvclR5cGUuR1JFWVNDQUxFX0FMUEhBO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJ1bnN1cHBvcnRlZCBudW1iZXIgb2YgY2hhbm5lbHMiKX1yZXR1cm4gbn0oZSxlLnBhbGV0dGUpLG49e3dpZHRoOnUoZS53aWR0aCwid2lkdGgiKSxoZWlnaHQ6dShlLmhlaWdodCwiaGVpZ2h0IiksY2hhbm5lbHM6QSxkYXRhOmUuZGF0YSxkZXB0aDpyLHRleHQ6ZS50ZXh0LHBhbGV0dGU6ZS5wYWxldHRlfTt0aGlzLl9jb2xvclR5cGU9dDtjb25zdCBzPXI8OD9NYXRoLmNlaWwobi53aWR0aCpyLzgpKm4uaGVpZ2h0KkE6bi53aWR0aCpuLmhlaWdodCpBO2lmKG4uZGF0YS5sZW5ndGghPT1zKXRocm93IG5ldyBSYW5nZUVycm9yKGB3cm9uZyBkYXRhIHNpemUuIEZvdW5kICR7bi5kYXRhLmxlbmd0aH0sIGV4cGVjdGVkICR7c31gKTtyZXR1cm4gbn19ZnVuY3Rpb24gdShlLHQpe2lmKE51bWJlci5pc0ludGVnZXIoZSkmJmU+MClyZXR1cm4gZTt0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyYCl9ZnVuY3Rpb24gaChlLHQsQSxyKXtmb3IobGV0IG49MDtuPEE7bisrKXQud3JpdGVCeXRlKGVbcisrXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gZChlLHQsQSxyKXtmb3IobGV0IG49MDtuPEE7bisrKXQud3JpdGVVaW50MTYoZVtyKytdKTtyZXR1cm4gcn19LCIuL25vZGVfbW9kdWxlcy9mYXN0LXBuZy9saWItZXNtL2NvbnZlcnRJbmRleGVkVG9SZ2IuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtjb25zdCB0PWUucGFsZXR0ZSxBPWUuZGVwdGg7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCJDb2xvciBwYWxldHRlIGlzIHVuZGVmaW5lZC4iKTshZnVuY3Rpb24oZSl7Y29uc3QgdD1lLmRlcHRoPDg/TWF0aC5jZWlsKGUud2lkdGgqZS5kZXB0aC84KSplLmhlaWdodCplLmNoYW5uZWxzOmUud2lkdGgqZS5oZWlnaHQqZS5jaGFubmVscztpZihlLmRhdGEubGVuZ3RoIT09dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgd3JvbmcgZGF0YSBzaXplLiBGb3VuZCAke2UuZGF0YS5sZW5ndGh9LCBleHBlY3RlZCAke3R9YCl9KGUpO2NvbnN0IHI9ZS53aWR0aCplLmhlaWdodCxuPXIqdFswXS5sZW5ndGgscz1uZXcgVWludDhBcnJheShuKTtsZXQgaT0wLG89MDtjb25zdCBhPW5ldyBVaW50OEFycmF5KHIpO2xldCBsPTI1NTtzd2l0Y2goQSl7Y2FzZSAxOmw9MTI4O2JyZWFrO2Nhc2UgMjpsPTE5MjticmVhaztjYXNlIDQ6bD0yNDA7YnJlYWs7Y2FzZSA4Omw9MjU1O2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJJbmNvcnJlY3QgZGVwdGggdmFsdWUiKX1mb3IoY29uc3QgdCBvZiBlLmRhdGEpe2xldCByPWwsbj04O2Zvcig7ciYmKG4tPUEsYVtpKytdPSh0JnIpPj5uLHI+Pj1BLGklZS53aWR0aCE9PTApOyk7fWlmKGUucGFsZXR0ZSlmb3IoY29uc3QgdCBvZiBhKXtjb25zdCBBPWUucGFsZXR0ZS5hdCh0KTtpZighQSl0aHJvdyBuZXcgRXJyb3IoIkluY29ycmVjdCBpbmRleCBvZiBwYWxldHRlIGNvbG9yIik7cy5zZXQoQSxvKSxvKz1BLmxlbmd0aH1yZXR1cm4gc31BLnIodCksQS5kKHQse2NvbnZlcnRJbmRleGVkVG9SZ2I6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KX0sIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaGVscGVycy9hcHBseVVuZmlsdGVyLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0Eucih0KSxBLmQodCx7YXBwbHlVbmZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBufX0pO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaGVscGVycy91bmZpbHRlci5qcyIpO2Z1bmN0aW9uIG4oZSx0LEEsbixzLGkpe3N3aXRjaChlKXtjYXNlIDA6KDAsci51bmZpbHRlck5vbmUpKHQsQSxzKTticmVhaztjYXNlIDE6KDAsci51bmZpbHRlclN1YikodCxBLHMsaSk7YnJlYWs7Y2FzZSAyOigwLHIudW5maWx0ZXJVcCkodCxBLG4scyk7YnJlYWs7Y2FzZSAzOigwLHIudW5maWx0ZXJBdmVyYWdlKSh0LEEsbixzLGkpO2JyZWFrO2Nhc2UgNDooMCxyLnVuZmlsdGVyUGFldGgpKHQsQSxuLHMsaSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGZpbHRlcjogJHtlfWApfX19LCIuL25vZGVfbW9kdWxlcy9mYXN0LXBuZy9saWItZXNtL2hlbHBlcnMvY3JjLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0Eucih0KSxBLmQodCx7Y2hlY2tDcmM6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sd3JpdGVDcmM6ZnVuY3Rpb24oKXtyZXR1cm4gb319KTtjb25zdCByPVtdO2ZvcihsZXQgZT0wO2U8MjU2O2UrKyl7bGV0IHQ9ZTtmb3IobGV0IGU9MDtlPDg7ZSsrKTEmdD90PTM5ODgyOTIzODRedD4+PjE6dD4+Pj0xO3JbZV09dH1jb25zdCBuPTQyOTQ5NjcyOTU7ZnVuY3Rpb24gcyhlLHQpe3JldHVybihmdW5jdGlvbihlLHQsQSl7bGV0IG49ZTtmb3IobGV0IGU9MDtlPEE7ZSsrKW49clsyNTUmKG5edFtlXSldXm4+Pj44O3JldHVybiBufShuLGUsdClebik+Pj4wfWZ1bmN0aW9uIGkoZSx0LEEpe2NvbnN0IHI9ZS5yZWFkVWludDMyKCksbj1zKG5ldyBVaW50OEFycmF5KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCtlLm9mZnNldC10LTQsdCksdCk7aWYobiE9PXIpdGhyb3cgbmV3IEVycm9yKGBDUkMgbWlzbWF0Y2ggZm9yIGNodW5rICR7QX0uIEV4cGVjdGVkICR7cn0sIGZvdW5kICR7bn1gKX1mdW5jdGlvbiBvKGUsdCl7ZS53cml0ZVVpbnQzMihzKG5ldyBVaW50OEFycmF5KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCtlLm9mZnNldC10LHQpLHQpKX19LCIuL25vZGVfbW9kdWxlcy9mYXN0LXBuZy9saWItZXNtL2hlbHBlcnMvZGVjb2RlSW50ZXJsYWNlQWRhbTcuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QS5yKHQpLEEuZCh0LHtkZWNvZGVJbnRlcmxhY2VBZGFtNzpmdW5jdGlvbigpe3JldHVybiBpfX0pO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaGVscGVycy9hcHBseVVuZmlsdGVyLmpzIik7Y29uc3Qgbj1uZXcgVWludDE2QXJyYXkoWzI1NV0pLHM9MjU1PT09bmV3IFVpbnQ4QXJyYXkobi5idWZmZXIpWzBdO2Z1bmN0aW9uIGkoZSl7Y29uc3R7ZGF0YTp0LHdpZHRoOkEsaGVpZ2h0Om4sY2hhbm5lbHM6aSxkZXB0aDphfT1lLGw9W3t4OjAseTowLHhTdGVwOjgseVN0ZXA6OH0se3g6NCx5OjAseFN0ZXA6OCx5U3RlcDo4fSx7eDowLHk6NCx4U3RlcDo0LHlTdGVwOjh9LHt4OjIseTowLHhTdGVwOjQseVN0ZXA6NH0se3g6MCx5OjIseFN0ZXA6Mix5U3RlcDo0fSx7eDoxLHk6MCx4U3RlcDoyLHlTdGVwOjJ9LHt4OjAseToxLHhTdGVwOjEseVN0ZXA6Mn1dLGM9TWF0aC5jZWlsKGEvOCkqaSx1PW5ldyBVaW50OEFycmF5KG4qQSpjKTtsZXQgaD0wO2ZvcihsZXQgZT0wO2U8NztlKyspe2NvbnN0IHM9bFtlXSxpPU1hdGguY2VpbCgoQS1zLngpL3MueFN0ZXApLG89TWF0aC5jZWlsKChuLXMueSkvcy55U3RlcCk7aWYoaTw9MHx8bzw9MCljb250aW51ZTtjb25zdCBhPWkqYyxkPW5ldyBVaW50OEFycmF5KGEpO2ZvcihsZXQgZT0wO2U8bztlKyspe2NvbnN0IG89dFtoKytdLGw9dC5zdWJhcnJheShoLGgrYSk7aCs9YTtjb25zdCBmPW5ldyBVaW50OEFycmF5KGEpOygwLHIuYXBwbHlVbmZpbHRlcikobyxsLGYsZCxhLGMpLGQuc2V0KGYpO2ZvcihsZXQgdD0wO3Q8aTt0Kyspe2NvbnN0IHI9cy54K3Qqcy54U3RlcCxpPXMueStlKnMueVN0ZXA7aWYoIShyPj1BfHxpPj1uKSlmb3IobGV0IGU9MDtlPGM7ZSsrKXVbKGkqQStyKSpjK2VdPWZbdCpjK2VdfX19aWYoMTY9PT1hKXtjb25zdCBlPW5ldyBVaW50MTZBcnJheSh1LmJ1ZmZlcik7aWYocylmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdPW8oZVt0XSk7cmV0dXJuIGV9cmV0dXJuIHV9ZnVuY3Rpb24gbyhlKXtyZXR1cm4oMjU1JmUpPDw4fGU+PjgmMjU1fX0sIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaGVscGVycy9kZWNvZGVJbnRlcmxhY2VOdWxsLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0Eucih0KSxBLmQodCx7ZGVjb2RlSW50ZXJsYWNlTnVsbDpmdW5jdGlvbigpe3JldHVybiBvfX0pO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaGVscGVycy91bmZpbHRlci5qcyIpO2NvbnN0IG49bmV3IFVpbnQxNkFycmF5KFsyNTVdKSxzPTI1NT09PW5ldyBVaW50OEFycmF5KG4uYnVmZmVyKVswXSxpPW5ldyBVaW50OEFycmF5KDApO2Z1bmN0aW9uIG8oZSl7Y29uc3R7ZGF0YTp0LHdpZHRoOkEsaGVpZ2h0Om4sY2hhbm5lbHM6byxkZXB0aDpsfT1lLGM9TWF0aC5jZWlsKGwvOCkqbyx1PU1hdGguY2VpbChsLzgqbypBKSxoPW5ldyBVaW50OEFycmF5KG4qdSk7bGV0IGQsZixwPWksZz0wO2ZvcihsZXQgZT0wO2U8bjtlKyspe3N3aXRjaChkPXQuc3ViYXJyYXkoZysxLGcrMSt1KSxmPWguc3ViYXJyYXkoZSp1LChlKzEpKnUpLHRbZ10pe2Nhc2UgMDooMCxyLnVuZmlsdGVyTm9uZSkoZCxmLHUpO2JyZWFrO2Nhc2UgMTooMCxyLnVuZmlsdGVyU3ViKShkLGYsdSxjKTticmVhaztjYXNlIDI6KDAsci51bmZpbHRlclVwKShkLGYscCx1KTticmVhaztjYXNlIDM6KDAsci51bmZpbHRlckF2ZXJhZ2UpKGQsZixwLHUsYyk7YnJlYWs7Y2FzZSA0OigwLHIudW5maWx0ZXJQYWV0aCkoZCxmLHAsdSxjKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZmlsdGVyOiAke3RbZ119YCl9cD1mLGcrPXUrMX1pZigxNj09PWwpe2NvbnN0IGU9bmV3IFVpbnQxNkFycmF5KGguYnVmZmVyKTtpZihzKWZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF09YShlW3RdKTtyZXR1cm4gZX1yZXR1cm4gaH1mdW5jdGlvbiBhKGUpe3JldHVybigyNTUmZSk8PDh8ZT4+OCYyNTV9fSwiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS9oZWxwZXJzL3NpZ25hdHVyZS5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtBLnIodCksQS5kKHQse2NoZWNrU2lnbmF0dXJlOmZ1bmN0aW9uKCl7cmV0dXJuIHN9LGhhc1BuZ1NpZ25hdHVyZTpmdW5jdGlvbigpe3JldHVybiBpfSx3cml0ZVNpZ25hdHVyZTpmdW5jdGlvbigpe3JldHVybiBufX0pO2NvbnN0IHI9VWludDhBcnJheS5vZigxMzcsODAsNzgsNzEsMTMsMTAsMjYsMTApO2Z1bmN0aW9uIG4oZSl7ZS53cml0ZUJ5dGVzKHIpfWZ1bmN0aW9uIHMoZSl7aWYoIWkoZS5yZWFkQnl0ZXMoci5sZW5ndGgpKSl0aHJvdyBuZXcgRXJyb3IoIndyb25nIFBORyBzaWduYXR1cmUiKX1mdW5jdGlvbiBpKGUpe2lmKGUubGVuZ3RoPHIubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgdD0wO3Q8ci5sZW5ndGg7dCsrKWlmKGVbdF0hPT1yW3RdKXJldHVybiExO3JldHVybiEwfX0sIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaGVscGVycy90ZXh0LmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0Eucih0KSxBLmQodCx7ZGVjb2RldEVYdDpmdW5jdGlvbigpe3JldHVybiBjfSxlbmNvZGV0RVh0OmZ1bmN0aW9uKCl7cmV0dXJuIHV9LHJlYWRLZXl3b3JkOmZ1bmN0aW9uKCl7cmV0dXJuIGh9LHJlYWRMYXRpbjE6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sdGV4dENodW5rTmFtZTpmdW5jdGlvbigpe3JldHVybiBufX0pO3ZhciByPUEoIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaGVscGVycy9jcmMuanMiKTtjb25zdCBuPSJ0RVh0IixzPTAsaT1uZXcgVGV4dERlY29kZXIoImxhdGluMSIpO2Z1bmN0aW9uIG8oZSl7aWYobChlKSwwPT09ZS5sZW5ndGh8fGUubGVuZ3RoPjc5KXRocm93IG5ldyBFcnJvcigia2V5d29yZCBsZW5ndGggbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDc5Iil9Y29uc3QgYT0vXltcdTAwMDAtXHUwMEZGXSokLztmdW5jdGlvbiBsKGUpe2lmKCFhLnRlc3QoZSkpdGhyb3cgbmV3IEVycm9yKCJpbnZhbGlkIGxhdGluMSB0ZXh0Iil9ZnVuY3Rpb24gYyhlLHQsQSl7Y29uc3Qgcj1oKHQpO2Vbcl09ZCh0LEEtci5sZW5ndGgtMSl9ZnVuY3Rpb24gdShlLHQsQSl7byh0KSxsKEEpO2NvbnN0IGk9dC5sZW5ndGgrMStBLmxlbmd0aDtlLndyaXRlVWludDMyKGkpLGUud3JpdGVDaGFycyhuKSxlLndyaXRlQ2hhcnModCksZS53cml0ZUJ5dGUocyksZS53cml0ZUNoYXJzKEEpLCgwLHIud3JpdGVDcmMpKGUsaSs0KX1mdW5jdGlvbiBoKGUpe2ZvcihlLm1hcmsoKTtlLnJlYWRCeXRlKCkhPT1zOyk7Y29uc3QgdD1lLm9mZnNldDtlLnJlc2V0KCk7Y29uc3QgQT1pLmRlY29kZShlLnJlYWRCeXRlcyh0LWUub2Zmc2V0LTEpKTtyZXR1cm4gZS5za2lwKDEpLG8oQSksQX1mdW5jdGlvbiBkKGUsdCl7cmV0dXJuIGkuZGVjb2RlKGUucmVhZEJ5dGVzKHQpKX19LCIuL25vZGVfbW9kdWxlcy9mYXN0LXBuZy9saWItZXNtL2hlbHBlcnMvdW5maWx0ZXIuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQsQSl7Zm9yKGxldCByPTA7cjxBO3IrKyl0W3JdPWVbcl19ZnVuY3Rpb24gbihlLHQsQSxyKXtsZXQgbj0wO2Zvcig7bjxyO24rKyl0W25dPWVbbl07Zm9yKDtuPEE7bisrKXRbbl09ZVtuXSt0W24tcl0mMjU1fWZ1bmN0aW9uIHMoZSx0LEEscil7bGV0IG49MDtpZigwPT09QS5sZW5ndGgpZm9yKDtuPHI7bisrKXRbbl09ZVtuXTtlbHNlIGZvcig7bjxyO24rKyl0W25dPWVbbl0rQVtuXSYyNTV9ZnVuY3Rpb24gaShlLHQsQSxyLG4pe2xldCBzPTA7aWYoMD09PUEubGVuZ3RoKXtmb3IoO3M8bjtzKyspdFtzXT1lW3NdO2Zvcig7czxyO3MrKyl0W3NdPWVbc10rKHRbcy1uXT4+MSkmMjU1fWVsc2V7Zm9yKDtzPG47cysrKXRbc109ZVtzXSsoQVtzXT4+MSkmMjU1O2Zvcig7czxyO3MrKyl0W3NdPWVbc10rKHRbcy1uXStBW3NdPj4xKSYyNTV9fWZ1bmN0aW9uIG8oZSx0LEEscixuKXtsZXQgcz0wO2lmKDA9PT1BLmxlbmd0aCl7Zm9yKDtzPG47cysrKXRbc109ZVtzXTtmb3IoO3M8cjtzKyspdFtzXT1lW3NdK3Rbcy1uXSYyNTV9ZWxzZXtmb3IoO3M8bjtzKyspdFtzXT1lW3NdK0Fbc10mMjU1O2Zvcig7czxyO3MrKyl0W3NdPWVbc10rYSh0W3Mtbl0sQVtzXSxBW3Mtbl0pJjI1NX19ZnVuY3Rpb24gYShlLHQsQSl7Y29uc3Qgcj1lK3QtQSxuPU1hdGguYWJzKHItZSkscz1NYXRoLmFicyhyLXQpLGk9TWF0aC5hYnMoci1BKTtyZXR1cm4gbjw9cyYmbjw9aT9lOnM8PWk/dDpBfUEucih0KSxBLmQodCx7dW5maWx0ZXJBdmVyYWdlOmZ1bmN0aW9uKCl7cmV0dXJuIGl9LHVuZmlsdGVyTm9uZTpmdW5jdGlvbigpe3JldHVybiByfSx1bmZpbHRlclBhZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIG99LHVuZmlsdGVyU3ViOmZ1bmN0aW9uKCl7cmV0dXJuIG59LHVuZmlsdGVyVXA6ZnVuY3Rpb24oKXtyZXR1cm4gc319KX0sIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaW5kZXguanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QS5yKHQpLEEuZCh0LHtSZXNvbHV0aW9uVW5pdFNwZWNpZmllcjpmdW5jdGlvbigpe3JldHVybiBpLlJlc29sdXRpb25Vbml0U3BlY2lmaWVyfSxjb252ZXJ0SW5kZXhlZFRvUmdiOmZ1bmN0aW9uKCl7cmV0dXJuIG8uY29udmVydEluZGV4ZWRUb1JnYn0sZGVjb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIGF9LGRlY29kZUFwbmc6ZnVuY3Rpb24oKXtyZXR1cm4gY30sZW5jb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIGx9LGhhc1BuZ1NpZ25hdHVyZTpmdW5jdGlvbigpe3JldHVybiBzLmhhc1BuZ1NpZ25hdHVyZX19KTt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9mYXN0LXBuZy9saWItZXNtL1BuZ0RlY29kZXIuanMiKSxuPUEoIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vUG5nRW5jb2Rlci5qcyIpLHM9QSgiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS9oZWxwZXJzL3NpZ25hdHVyZS5qcyIpLGk9QSgiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS90eXBlcy5qcyIpLG89QSgiLi9ub2RlX21vZHVsZXMvZmFzdC1wbmcvbGliLWVzbS9jb252ZXJ0SW5kZXhlZFRvUmdiLmpzIik7ZnVuY3Rpb24gYShlLHQpe3JldHVybiBuZXcgci5kZWZhdWx0KGUsdCkuZGVjb2RlKCl9ZnVuY3Rpb24gbChlLHQpe3JldHVybiBuZXcgbi5kZWZhdWx0KGUsdCkuZW5jb2RlKCl9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiBuZXcgci5kZWZhdWx0KGUsdCkuZGVjb2RlQXBuZygpfX0sIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaW50ZXJuYWxUeXBlcy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtBLnIodCksQS5kKHQse0JsZW5kT3BUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuIGF9LENvbG9yVHlwZTpmdW5jdGlvbigpe3JldHVybiByfSxDb21wcmVzc2lvbk1ldGhvZDpmdW5jdGlvbigpe3JldHVybiBufSxEaXNwb3NlT3BUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuIG99LEZpbHRlck1ldGhvZDpmdW5jdGlvbigpe3JldHVybiBzfSxJbnRlcmxhY2VNZXRob2Q6ZnVuY3Rpb24oKXtyZXR1cm4gaX19KTtjb25zdCByPXtVTktOT1dOOi0xLEdSRVlTQ0FMRTowLFRSVUVDT0xPVVI6MixJTkRFWEVEX0NPTE9VUjozLEdSRVlTQ0FMRV9BTFBIQTo0LFRSVUVDT0xPVVJfQUxQSEE6Nn0sbj17VU5LTk9XTjotMSxERUZMQVRFOjB9LHM9e1VOS05PV046LTEsQURBUFRJVkU6MH0saT17VU5LTk9XTjotMSxOT19JTlRFUkxBQ0U6MCxBREFNNzoxfSxvPXtOT05FOjAsQkFDS0dST1VORDoxLFBSRVZJT1VTOjJ9LGE9e1NPVVJDRTowLE9WRVI6MX19LCIuL25vZGVfbW9kdWxlcy9mYXN0LXBuZy9saWItZXNtL3R5cGVzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO3ZhciByO0Eucih0KSxBLmQodCx7UmVzb2x1dGlvblVuaXRTcGVjaWZpZXI6ZnVuY3Rpb24oKXtyZXR1cm4gcn19KSxmdW5jdGlvbihlKXtlW2UuVU5LTk9XTj0wXT0iVU5LTk9XTiIsZVtlLk1FVFJFPTFdPSJNRVRSRSJ9KHJ8fChyPXt9KSl9LCIuL25vZGVfbW9kdWxlcy9mZmxhdGUvZXNtL2Jyb3dzZXIuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QS5yKHQpLEEuZCh0LHtBc3luY0NvbXByZXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExlfSxBc3luY0RlY29tcHJlc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV2V9LEFzeW5jRGVmbGF0ZTpmdW5jdGlvbigpe3JldHVybiBfZX0sQXN5bmNHdW56aXA6ZnVuY3Rpb24oKXtyZXR1cm4gSGV9LEFzeW5jR3ppcDpmdW5jdGlvbigpe3JldHVybiBMZX0sQXN5bmNJbmZsYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIFFlfSxBc3luY1VuemlwSW5mbGF0ZTpmdW5jdGlvbigpe3JldHVybiB2dH0sQXN5bmNVbnpsaWI6ZnVuY3Rpb24oKXtyZXR1cm4gVmV9LEFzeW5jWmlwRGVmbGF0ZTpmdW5jdGlvbigpe3JldHVybiBwdH0sQXN5bmNabGliOmZ1bmN0aW9uKCl7cmV0dXJuIE1lfSxDb21wcmVzczpmdW5jdGlvbigpe3JldHVybiBTZX0sRGVjb2RlVVRGODpmdW5jdGlvbigpe3JldHVybiBBdH0sRGVjb21wcmVzczpmdW5jdGlvbigpe3JldHVybiBxZX0sRGVmbGF0ZTpmdW5jdGlvbigpe3JldHVybiBDZX0sRW5jb2RlVVRGODpmdW5jdGlvbigpe3JldHVybiBydH0sRmxhdGVFcnJvckNvZGU6ZnVuY3Rpb24oKXtyZXR1cm4gTH0sR3VuemlwOmZ1bmN0aW9uKCl7cmV0dXJuIGtlfSxHemlwOmZ1bmN0aW9uKCl7cmV0dXJuIFNlfSxJbmZsYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIEZlfSxVbnppcDpmdW5jdGlvbigpe3JldHVybiBidH0sVW56aXBJbmZsYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHl0fSxVbnppcFBhc3NUaHJvdWdoOmZ1bmN0aW9uKCl7cmV0dXJuIEJ0fSxVbnpsaWI6ZnVuY3Rpb24oKXtyZXR1cm4gS2V9LFppcDpmdW5jdGlvbigpe3JldHVybiBndH0sWmlwRGVmbGF0ZTpmdW5jdGlvbigpe3JldHVybiBmdH0sWmlwUGFzc1Rocm91Z2g6ZnVuY3Rpb24oKXtyZXR1cm4gZHR9LFpsaWI6ZnVuY3Rpb24oKXtyZXR1cm4gT2V9LGNvbXByZXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEllfSxjb21wcmVzc1N5bmM6ZnVuY3Rpb24oKXtyZXR1cm4gTmV9LGRlY29tcHJlc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWGV9LGRlY29tcHJlc3NTeW5jOmZ1bmN0aW9uKCl7cmV0dXJuIFllfSxkZWZsYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIGplfSxkZWZsYXRlU3luYzpmdW5jdGlvbigpe3JldHVybiB4ZX0sZ3VuemlwOmZ1bmN0aW9uKCl7cmV0dXJuIFBlfSxndW56aXBTeW5jOmZ1bmN0aW9uKCl7cmV0dXJuIFRlfSxnemlwOmZ1bmN0aW9uKCl7cmV0dXJuIEllfSxnemlwU3luYzpmdW5jdGlvbigpe3JldHVybiBOZX0saW5mbGF0ZTpmdW5jdGlvbigpe3JldHVybiBVZX0saW5mbGF0ZVN5bmM6ZnVuY3Rpb24oKXtyZXR1cm4gRWV9LHN0ckZyb21VODpmdW5jdGlvbigpe3JldHVybiBzdH0sc3RyVG9VODpmdW5jdGlvbigpe3JldHVybiBudH0sdW56aXA6ZnVuY3Rpb24oKXtyZXR1cm4gX3R9LHVuemlwU3luYzpmdW5jdGlvbigpe3JldHVybiBqdH0sdW56bGliOmZ1bmN0aW9uKCl7cmV0dXJuIEdlfSx1bnpsaWJTeW5jOmZ1bmN0aW9uKCl7cmV0dXJuIHplfSx6aXA6ZnVuY3Rpb24oKXtyZXR1cm4gbXR9LHppcFN5bmM6ZnVuY3Rpb24oKXtyZXR1cm4gd3R9LHpsaWI6ZnVuY3Rpb24oKXtyZXR1cm4gRGV9LHpsaWJTeW5jOmZ1bmN0aW9uKCl7cmV0dXJuIFJlfX0pO3ZhciByPXt9LG49VWludDhBcnJheSxzPVVpbnQxNkFycmF5LGk9SW50MzJBcnJheSxvPW5ldyBuKFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxhPW5ldyBuKFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzLDAsMF0pLGw9bmV3IG4oWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSxjPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBBPW5ldyBzKDMxKSxyPTA7cjwzMTsrK3IpQVtyXT10Kz0xPDxlW3ItMV07dmFyIG49bmV3IGkoQVszMF0pO2ZvcihyPTE7cjwzMDsrK3IpZm9yKHZhciBvPUFbcl07bzxBW3IrMV07KytvKW5bb109by1BW3JdPDw1fHI7cmV0dXJue2I6QSxyOm59fSx1PWMobywyKSxoPXUuYixkPXUucjtoWzI4XT0yNTgsZFsyNThdPTI4O2Zvcih2YXIgZj1jKGEsMCkscD1mLmIsZz1mLnIsbT1uZXcgcygzMjc2OCksdz0wO3c8MzI3Njg7Kyt3KXt2YXIgQj0oNDM2OTAmdyk+PjF8KDIxODQ1JncpPDwxO0I9KDYxNjgwJihCPSg1MjQyOCZCKT4+MnwoMTMxMDcmQik8PDIpKT4+NHwoMzg1NSZCKTw8NCxtW3ddPSgoNjUyODAmQik+Pjh8KDI1NSZCKTw8OCk+PjF9dmFyIHk9ZnVuY3Rpb24oZSx0LEEpe2Zvcih2YXIgcj1lLmxlbmd0aCxuPTAsaT1uZXcgcyh0KTtuPHI7KytuKWVbbl0mJisraVtlW25dLTFdO3ZhciBvLGE9bmV3IHModCk7Zm9yKG49MTtuPHQ7KytuKWFbbl09YVtuLTFdK2lbbi0xXTw8MTtpZihBKXtvPW5ldyBzKDE8PHQpO3ZhciBsPTE1LXQ7Zm9yKG49MDtuPHI7KytuKWlmKGVbbl0pZm9yKHZhciBjPW48PDR8ZVtuXSx1PXQtZVtuXSxoPWFbZVtuXS0xXSsrPDx1LGQ9aHwoMTw8dSktMTtoPD1kOysraClvW21baF0+PmxdPWN9ZWxzZSBmb3Iobz1uZXcgcyhyKSxuPTA7bjxyOysrbillW25dJiYob1tuXT1tW2FbZVtuXS0xXSsrXT4+MTUtZVtuXSk7cmV0dXJuIG99LHY9bmV3IG4oMjg4KTtmb3Iodz0wO3c8MTQ0Oysrdyl2W3ddPTg7Zm9yKHc9MTQ0O3c8MjU2Oysrdyl2W3ddPTk7Zm9yKHc9MjU2O3c8MjgwOysrdyl2W3ddPTc7Zm9yKHc9MjgwO3c8Mjg4Oysrdyl2W3ddPTg7dmFyIGI9bmV3IG4oMzIpO2Zvcih3PTA7dzwzMjsrK3cpYlt3XT01O3ZhciBDPXkodiw5LDApLF89eSh2LDksMSksaj15KGIsNSwwKSx4PXkoYiw1LDEpLEY9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWVbMF0sQT0xO0E8ZS5sZW5ndGg7KytBKWVbQV0+dCYmKHQ9ZVtBXSk7cmV0dXJuIHR9LFE9ZnVuY3Rpb24oZSx0LEEpe3ZhciByPXQvOHwwO3JldHVybihlW3JdfGVbcisxXTw8OCk+Pig3JnQpJkF9LFU9ZnVuY3Rpb24oZSx0KXt2YXIgQT10Lzh8MDtyZXR1cm4oZVtBXXxlW0ErMV08PDh8ZVtBKzJdPDwxNik+Pig3JnQpfSxFPWZ1bmN0aW9uKGUpe3JldHVybihlKzcpLzh8MH0sUz1mdW5jdGlvbihlLHQsQSl7cmV0dXJuKG51bGw9PXR8fHQ8MCkmJih0PTApLChudWxsPT1BfHxBPmUubGVuZ3RoKSYmKEE9ZS5sZW5ndGgpLG5ldyBuKGUuc3ViYXJyYXkodCxBKSl9LEw9e1VuZXhwZWN0ZWRFT0Y6MCxJbnZhbGlkQmxvY2tUeXBlOjEsSW52YWxpZExlbmd0aExpdGVyYWw6MixJbnZhbGlkRGlzdGFuY2U6MyxTdHJlYW1GaW5pc2hlZDo0LE5vU3RyZWFtSGFuZGxlcjo1LEludmFsaWRIZWFkZXI6NixOb0NhbGxiYWNrOjcsSW52YWxpZFVURjg6OCxFeHRyYUZpZWxkVG9vTG9uZzo5LEludmFsaWREYXRlOjEwLEZpbGVuYW1lVG9vTG9uZzoxMSxTdHJlYW1GaW5pc2hpbmc6MTIsSW52YWxpZFppcERhdGE6MTMsVW5rbm93bkNvbXByZXNzaW9uTWV0aG9kOjE0fSxJPVsidW5leHBlY3RlZCBFT0YiLCJpbnZhbGlkIGJsb2NrIHR5cGUiLCJpbnZhbGlkIGxlbmd0aC9saXRlcmFsIiwiaW52YWxpZCBkaXN0YW5jZSIsInN0cmVhbSBmaW5pc2hlZCIsIm5vIHN0cmVhbSBoYW5kbGVyIiwsIm5vIGNhbGxiYWNrIiwiaW52YWxpZCBVVEYtOCBkYXRhIiwiZXh0cmEgZmllbGQgdG9vIGxvbmciLCJkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTkiLCJmaWxlbmFtZSB0b28gbG9uZyIsInN0cmVhbSBmaW5pc2hpbmciLCJpbnZhbGlkIHppcCBkYXRhIl0sTj1mdW5jdGlvbihlLHQsQSl7dmFyIHI9bmV3IEVycm9yKHR8fElbZV0pO2lmKHIuY29kZT1lLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShyLE4pLCFBKXRocm93IHI7cmV0dXJuIHJ9LGs9ZnVuY3Rpb24oZSx0LEEscil7dmFyIHM9ZS5sZW5ndGgsaT1yP3IubGVuZ3RoOjA7aWYoIXN8fHQuZiYmIXQubClyZXR1cm4gQXx8bmV3IG4oMCk7dmFyIGM9IUEsdT1jfHwyIT10LmksZD10Lmk7YyYmKEE9bmV3IG4oMypzKSk7dmFyIGY9ZnVuY3Rpb24oZSl7dmFyIHQ9QS5sZW5ndGg7aWYoZT50KXt2YXIgcj1uZXcgbihNYXRoLm1heCgyKnQsZSkpO3Iuc2V0KEEpLEE9cn19LGc9dC5mfHwwLG09dC5wfHwwLHc9dC5ifHwwLEI9dC5sLHY9dC5kLGI9dC5tLEM9dC5uLGo9OCpzO2Rve2lmKCFCKXtnPVEoZSxtLDEpO3ZhciBMPVEoZSxtKzEsMyk7aWYobSs9MywhTCl7dmFyIEk9ZVsoRz1FKG0pKzQpLTRdfGVbRy0zXTw8OCxrPUcrSTtpZihrPnMpe2QmJk4oMCk7YnJlYWt9dSYmZih3K0kpLEEuc2V0KGUuc3ViYXJyYXkoRyxrKSx3KSx0LmI9dys9SSx0LnA9bT04KmssdC5mPWc7Y29udGludWV9aWYoMT09TClCPV8sdj14LGI9OSxDPTU7ZWxzZSBpZigyPT1MKXt2YXIgSD1RKGUsbSwzMSkrMjU3LFA9UShlLG0rMTAsMTUpKzQsVD1IK1EoZSxtKzUsMzEpKzE7bSs9MTQ7Zm9yKHZhciBPPW5ldyBuKFQpLE09bmV3IG4oMTkpLEQ9MDtEPFA7KytEKU1bbFtEXV09UShlLG0rMypELDcpO20rPTMqUDt2YXIgUj1GKE0pLEs9KDE8PFIpLTEsVj15KE0sUiwxKTtmb3IoRD0wO0Q8VDspe3ZhciBHLHo9VltRKGUsbSxLKV07aWYobSs9MTUmeiwoRz16Pj40KTwxNilPW0QrK109RztlbHNle3ZhciBxPTAsVz0wO2ZvcigxNj09Rz8oVz0zK1EoZSxtLDMpLG0rPTIscT1PW0QtMV0pOjE3PT1HPyhXPTMrUShlLG0sNyksbSs9Myk6MTg9PUcmJihXPTExK1EoZSxtLDEyNyksbSs9Nyk7Vy0tOylPW0QrK109cX19dmFyIFg9Ty5zdWJhcnJheSgwLEgpLFk9Ty5zdWJhcnJheShIKTtiPUYoWCksQz1GKFkpLEI9eShYLGIsMSksdj15KFksQywxKX1lbHNlIE4oMSk7aWYobT5qKXtkJiZOKDApO2JyZWFrfX11JiZmKHcrMTMxMDcyKTtmb3IodmFyIEo9KDE8PGIpLTEsWj0oMTw8QyktMSwkPW07OyQ9bSl7dmFyIGVlPShxPUJbVShlLG0pJkpdKT4+NDtpZigobSs9MTUmcSk+ail7ZCYmTigwKTticmVha31pZihxfHxOKDIpLGVlPDI1NilBW3crK109ZWU7ZWxzZXtpZigyNTY9PWVlKXskPW0sQj1udWxsO2JyZWFrfXZhciB0ZT1lZS0yNTQ7aWYoZWU+MjY0KXt2YXIgQWU9b1tEPWVlLTI1N107dGU9UShlLG0sKDE8PEFlKS0xKStoW0RdLG0rPUFlfXZhciByZT12W1UoZSxtKSZaXSxuZT1yZT4+NDtpZihyZXx8TigzKSxtKz0xNSZyZSxZPXBbbmVdLG5lPjMmJihBZT1hW25lXSxZKz1VKGUsbSkmKDE8PEFlKS0xLG0rPUFlKSxtPmope2QmJk4oMCk7YnJlYWt9dSYmZih3KzEzMTA3Mik7dmFyIHNlPXcrdGU7aWYodzxZKXt2YXIgaWU9aS1ZLG9lPU1hdGgubWluKFksc2UpO2ZvcihpZSt3PDAmJk4oMyk7dzxvZTsrK3cpQVt3XT1yW2llK3ddfWZvcig7dzxzZTsrK3cpQVt3XT1BW3ctWV19fXQubD1CLHQucD0kLHQuYj13LHQuZj1nLEImJihnPTEsdC5tPWIsdC5kPXYsdC5uPUMpfXdoaWxlKCFnKTtyZXR1cm4gdyE9QS5sZW5ndGgmJmM/UyhBLDAsdyk6QS5zdWJhcnJheSgwLHcpfSxIPWZ1bmN0aW9uKGUsdCxBKXtBPDw9NyZ0O3ZhciByPXQvOHwwO2Vbcl18PUEsZVtyKzFdfD1BPj44fSxQPWZ1bmN0aW9uKGUsdCxBKXtBPDw9NyZ0O3ZhciByPXQvOHwwO2Vbcl18PUEsZVtyKzFdfD1BPj44LGVbcisyXXw9QT4+MTZ9LFQ9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIEE9W10scj0wO3I8ZS5sZW5ndGg7KytyKWVbcl0mJkEucHVzaCh7czpyLGY6ZVtyXX0pO3ZhciBpPUEubGVuZ3RoLG89QS5zbGljZSgpO2lmKCFpKXJldHVybnt0OkcsbDowfTtpZigxPT1pKXt2YXIgYT1uZXcgbihBWzBdLnMrMSk7cmV0dXJuIGFbQVswXS5zXT0xLHt0OmEsbDoxfX1BLnNvcnQoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5mLXQuZn0pLEEucHVzaCh7czotMSxmOjI1MDAxfSk7dmFyIGw9QVswXSxjPUFbMV0sdT0wLGg9MSxkPTI7Zm9yKEFbMF09e3M6LTEsZjpsLmYrYy5mLGw6bCxyOmN9O2ghPWktMTspbD1BW0FbdV0uZjxBW2RdLmY/dSsrOmQrK10sYz1BW3UhPWgmJkFbdV0uZjxBW2RdLmY/dSsrOmQrK10sQVtoKytdPXtzOi0xLGY6bC5mK2MuZixsOmwscjpjfTt2YXIgZj1vWzBdLnM7Zm9yKHI9MTtyPGk7KytyKW9bcl0ucz5mJiYoZj1vW3JdLnMpO3ZhciBwPW5ldyBzKGYrMSksZz1PKEFbaC0xXSxwLDApO2lmKGc+dCl7cj0wO3ZhciBtPTAsdz1nLXQsQj0xPDx3O2ZvcihvLnNvcnQoZnVuY3Rpb24oZSx0KXtyZXR1cm4gcFt0LnNdLXBbZS5zXXx8ZS5mLXQuZn0pO3I8aTsrK3Ipe3ZhciB5PW9bcl0ucztpZighKHBbeV0+dCkpYnJlYWs7bSs9Qi0oMTw8Zy1wW3ldKSxwW3ldPXR9Zm9yKG0+Pj13O20+MDspe3ZhciB2PW9bcl0ucztwW3ZdPHQ/bS09MTw8dC1wW3ZdKystMTorK3J9Zm9yKDtyPj0wJiZtOy0tcil7dmFyIGI9b1tyXS5zO3BbYl09PXQmJigtLXBbYl0sKyttKX1nPXR9cmV0dXJue3Q6bmV3IG4ocCksbDpnfX0sTz1mdW5jdGlvbihlLHQsQSl7cmV0dXJuLTE9PWUucz9NYXRoLm1heChPKGUubCx0LEErMSksTyhlLnIsdCxBKzEpKTp0W2Uuc109QX0sTT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5sZW5ndGg7dCYmIWVbLS10XTspO2Zvcih2YXIgQT1uZXcgcygrK3QpLHI9MCxuPWVbMF0saT0xLG89ZnVuY3Rpb24oZSl7QVtyKytdPWV9LGE9MTthPD10OysrYSlpZihlW2FdPT1uJiZhIT10KSsraTtlbHNle2lmKCFuJiZpPjIpe2Zvcig7aT4xMzg7aS09MTM4KW8oMzI3NTQpO2k+MiYmKG8oaT4xMD9pLTExPDw1fDI4NjkwOmktMzw8NXwxMjMwNSksaT0wKX1lbHNlIGlmKGk+Myl7Zm9yKG8obiksLS1pO2k+NjtpLT02KW8oODMwNCk7aT4yJiYobyhpLTM8PDV8ODIwOCksaT0wKX1mb3IoO2ktLTspbyhuKTtpPTEsbj1lW2FdfXJldHVybntjOkEuc3ViYXJyYXkoMCxyKSxuOnR9fSxEPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBBPTAscj0wO3I8dC5sZW5ndGg7KytyKUErPWVbcl0qdFtyXTtyZXR1cm4gQX0sUj1mdW5jdGlvbihlLHQsQSl7dmFyIHI9QS5sZW5ndGgsbj1FKHQrMik7ZVtuXT0yNTUmcixlW24rMV09cj4+OCxlW24rMl09MjU1XmVbbl0sZVtuKzNdPTI1NV5lW24rMV07Zm9yKHZhciBzPTA7czxyOysrcyllW24rcys0XT1BW3NdO3JldHVybiA4KihuKzQrcil9LEs9ZnVuY3Rpb24oZSx0LEEscixuLGksYyx1LGgsZCxmKXtIKHQsZisrLEEpLCsrblsyNTZdO2Zvcih2YXIgcD1UKG4sMTUpLGc9cC50LG09cC5sLHc9VChpLDE1KSxCPXcudCxfPXcubCx4PU0oZyksRj14LmMsUT14Lm4sVT1NKEIpLEU9VS5jLFM9VS5uLEw9bmV3IHMoMTkpLEk9MDtJPEYubGVuZ3RoOysrSSkrK0xbMzEmRltJXV07Zm9yKEk9MDtJPEUubGVuZ3RoOysrSSkrK0xbMzEmRVtJXV07Zm9yKHZhciBOPVQoTCw3KSxrPU4udCxPPU4ubCxLPTE5O0s+NCYmIWtbbFtLLTFdXTstLUspO3ZhciBWLEcseixxLFc9ZCs1PDwzLFg9RChuLHYpK0QoaSxiKStjLFk9RChuLGcpK0QoaSxCKStjKzE0KzMqSytEKEwsaykrMipMWzE2XSszKkxbMTddKzcqTFsxOF07aWYoaD49MCYmVzw9WCYmVzw9WSlyZXR1cm4gUih0LGYsZS5zdWJhcnJheShoLGgrZCkpO2lmKEgodCxmLDErKFk8WCkpLGYrPTIsWTxYKXtWPXkoZyxtLDApLEc9Zyx6PXkoQixfLDApLHE9Qjt2YXIgSj15KGssTywwKTtmb3IoSCh0LGYsUS0yNTcpLEgodCxmKzUsUy0xKSxIKHQsZisxMCxLLTQpLGYrPTE0LEk9MDtJPEs7KytJKUgodCxmKzMqSSxrW2xbSV1dKTtmKz0zKks7Zm9yKHZhciBaPVtGLEVdLCQ9MDskPDI7KyskKXt2YXIgZWU9WlskXTtmb3IoST0wO0k8ZWUubGVuZ3RoOysrSSl7dmFyIHRlPTMxJmVlW0ldO0godCxmLEpbdGVdKSxmKz1rW3RlXSx0ZT4xNSYmKEgodCxmLGVlW0ldPj41JjEyNyksZis9ZWVbSV0+PjEyKX19fWVsc2UgVj1DLEc9dix6PWoscT1iO2ZvcihJPTA7STx1OysrSSl7dmFyIEFlPXJbSV07aWYoQWU+MjU1KXtQKHQsZixWWzI1NysodGU9QWU+PjE4JjMxKV0pLGYrPUdbdGUrMjU3XSx0ZT43JiYoSCh0LGYsQWU+PjIzJjMxKSxmKz1vW3RlXSk7dmFyIHJlPTMxJkFlO1AodCxmLHpbcmVdKSxmKz1xW3JlXSxyZT4zJiYoUCh0LGYsQWU+PjUmODE5MSksZis9YVtyZV0pfWVsc2UgUCh0LGYsVltBZV0pLGYrPUdbQWVdfXJldHVybiBQKHQsZixWWzI1Nl0pLGYrR1syNTZdfSxWPW5ldyBpKFs2NTU0MCwxMzEwODAsMTMxMDg4LDEzMTEwNCwyNjIxNzYsMTA0ODcwNCwxMDQ4ODMyLDIxMTQ1NjAsMjExNzYzMl0pLEc9bmV3IG4oMCksej1mdW5jdGlvbihlLHQsQSxyLGwsYyl7dmFyIHU9Yy56fHxlLmxlbmd0aCxoPW5ldyBuKHIrdSs1KigxK01hdGguY2VpbCh1LzdlMykpK2wpLGY9aC5zdWJhcnJheShyLGgubGVuZ3RoLWwpLHA9Yy5sLG09NyYoYy5yfHwwKTtpZih0KXttJiYoZlswXT1jLnI+PjMpO2Zvcih2YXIgdz1WW3QtMV0sQj13Pj4xMyx5PTgxOTEmdyx2PSgxPDxBKS0xLGI9Yy5wfHxuZXcgcygzMjc2OCksQz1jLmh8fG5ldyBzKHYrMSksXz1NYXRoLmNlaWwoQS8zKSxqPTIqXyx4PWZ1bmN0aW9uKHQpe3JldHVybihlW3RdXmVbdCsxXTw8X15lW3QrMl08PGopJnZ9LEY9bmV3IGkoMjVlMyksUT1uZXcgcygyODgpLFU9bmV3IHMoMzIpLEw9MCxJPTAsTj1jLml8fDAsaz0wLEg9Yy53fHwwLFA9MDtOKzI8dTsrK04pe3ZhciBUPXgoTiksTz0zMjc2NyZOLE09Q1tUXTtpZihiW09dPU0sQ1tUXT1PLEg8PU4pe3ZhciBEPXUtTjtpZigoTD43ZTN8fGs+MjQ1NzYpJiYoRD40MjN8fCFwKSl7bT1LKGUsZiwwLEYsUSxVLEksayxQLE4tUCxtKSxrPUw9ST0wLFA9Tjtmb3IodmFyIEc9MDtHPDI4NjsrK0cpUVtHXT0wO2ZvcihHPTA7RzwzMDsrK0cpVVtHXT0wfXZhciB6PTIscT0wLFc9eSxYPU8tTSYzMjc2NztpZihEPjImJlQ9PXgoTi1YKSlmb3IodmFyIFk9TWF0aC5taW4oQixEKS0xLEo9TWF0aC5taW4oMzI3NjcsTiksWj1NYXRoLm1pbigyNTgsRCk7WDw9SiYmLS1XJiZPIT1NOyl7aWYoZVtOK3pdPT1lW04rei1YXSl7Zm9yKHZhciAkPTA7JDxaJiZlW04rJF09PWVbTiskLVhdOysrJCk7aWYoJD56KXtpZih6PSQscT1YLCQ+WSlicmVhazt2YXIgZWU9TWF0aC5taW4oWCwkLTIpLHRlPTA7Zm9yKEc9MDtHPGVlOysrRyl7dmFyIEFlPU4tWCtHJjMyNzY3LHJlPUFlLWJbQWVdJjMyNzY3O3JlPnRlJiYodGU9cmUsTT1BZSl9fX1YKz0oTz1NKS0oTT1iW09dKSYzMjc2N31pZihxKXtGW2srK109MjY4NDM1NDU2fGRbel08PDE4fGdbcV07dmFyIG5lPTMxJmRbel0sc2U9MzEmZ1txXTtJKz1vW25lXSthW3NlXSwrK1FbMjU3K25lXSwrK1Vbc2VdLEg9Tit6LCsrTH1lbHNlIEZbaysrXT1lW05dLCsrUVtlW05dXX19Zm9yKE49TWF0aC5tYXgoTixIKTtOPHU7KytOKUZbaysrXT1lW05dLCsrUVtlW05dXTttPUsoZSxmLHAsRixRLFUsSSxrLFAsTi1QLG0pLHB8fChjLnI9NyZtfGZbbS84fDBdPDwzLG0tPTcsYy5oPUMsYy5wPWIsYy5pPU4sYy53PUgpfWVsc2V7Zm9yKE49Yy53fHwwO048dStwO04rPTY1NTM1KXt2YXIgaWU9Tis2NTUzNTtpZT49dSYmKGZbbS84fDBdPXAsaWU9dSksbT1SKGYsbSsxLGUuc3ViYXJyYXkoTixpZSkpfWMuaT11fXJldHVybiBTKGgsMCxyK0UobSkrbCl9LHE9ZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IEludDMyQXJyYXkoMjU2KSx0PTA7dDwyNTY7Kyt0KXtmb3IodmFyIEE9dCxyPTk7LS1yOylBPSgxJkEmJi0zMDY2NzQ5MTIpXkE+Pj4xO2VbdF09QX1yZXR1cm4gZX0oKSxXPWZ1bmN0aW9uKCl7dmFyIGU9LTE7cmV0dXJue3A6ZnVuY3Rpb24odCl7Zm9yKHZhciBBPWUscj0wO3I8dC5sZW5ndGg7KytyKUE9cVsyNTUmQV50W3JdXV5BPj4+ODtlPUF9LGQ6ZnVuY3Rpb24oKXtyZXR1cm5+ZX19fSxYPWZ1bmN0aW9uKCl7dmFyIGU9MSx0PTA7cmV0dXJue3A6ZnVuY3Rpb24oQSl7Zm9yKHZhciByPWUsbj10LHM9MHxBLmxlbmd0aCxpPTA7aSE9czspe2Zvcih2YXIgbz1NYXRoLm1pbihpKzI2NTUscyk7aTxvOysraSluKz1yKz1BW2ldO3I9KDY1NTM1JnIpKzE1KihyPj4xNiksbj0oNjU1MzUmbikrMTUqKG4+PjE2KX1lPXIsdD1ufSxkOmZ1bmN0aW9uKCl7cmV0dXJuKDI1NSYoZSU9NjU1MjEpKTw8MjR8KDY1MjgwJmUpPDw4fCgyNTUmKHQlPTY1NTIxKSk8PDh8dD4+OH19fSxZPWZ1bmN0aW9uKGUsdCxBLHIscyl7aWYoIXMmJihzPXtsOjF9LHQuZGljdGlvbmFyeSkpe3ZhciBpPXQuZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpLG89bmV3IG4oaS5sZW5ndGgrZS5sZW5ndGgpO28uc2V0KGkpLG8uc2V0KGUsaS5sZW5ndGgpLGU9byxzLnc9aS5sZW5ndGh9cmV0dXJuIHooZSxudWxsPT10LmxldmVsPzY6dC5sZXZlbCxudWxsPT10Lm1lbT9zLmw/TWF0aC5jZWlsKDEuNSpNYXRoLm1heCg4LE1hdGgubWluKDEzLE1hdGgubG9nKGUubGVuZ3RoKSkpKToyMDoxMit0Lm1lbSxBLHIscyl9LEo9ZnVuY3Rpb24oZSx0KXt2YXIgQT17fTtmb3IodmFyIHIgaW4gZSlBW3JdPWVbcl07Zm9yKHZhciByIGluIHQpQVtyXT10W3JdO3JldHVybiBBfSxaPWZ1bmN0aW9uKGUsdCxBKXtmb3IodmFyIHI9ZSgpLG49ZS50b1N0cmluZygpLHM9bi5zbGljZShuLmluZGV4T2YoIlsiKSsxLG4ubGFzdEluZGV4T2YoIl0iKSkucmVwbGFjZSgvXHMrL2csIiIpLnNwbGl0KCIsIiksaT0wO2k8ci5sZW5ndGg7KytpKXt2YXIgbz1yW2ldLGE9c1tpXTtpZigiZnVuY3Rpb24iPT10eXBlb2Ygbyl7dCs9IjsiK2ErIj0iO3ZhciBsPW8udG9TdHJpbmcoKTtpZihvLnByb3RvdHlwZSlpZigtMSE9bC5pbmRleE9mKCJbbmF0aXZlIGNvZGVdIikpe3ZhciBjPWwuaW5kZXhPZigiICIsOCkrMTt0Kz1sLnNsaWNlKGMsbC5pbmRleE9mKCIoIixjKSl9ZWxzZSBmb3IodmFyIHUgaW4gdCs9bCxvLnByb3RvdHlwZSl0Kz0iOyIrYSsiLnByb3RvdHlwZS4iK3UrIj0iK28ucHJvdG90eXBlW3VdLnRvU3RyaW5nKCk7ZWxzZSB0Kz1sfWVsc2UgQVthXT1vfXJldHVybiB0fSwkPVtdLGVlPWZ1bmN0aW9uKGUsdCxBLG4pe2lmKCEkW0FdKXtmb3IodmFyIHM9IiIsaT17fSxvPWUubGVuZ3RoLTEsYT0wO2E8bzsrK2Epcz1aKGVbYV0scyxpKTskW0FdPXtjOlooZVtvXSxzLGkpLGU6aX19dmFyIGw9Sih7fSwkW0FdLmUpO3JldHVybiBmdW5jdGlvbihlLHQsQSxuLHMpe3ZhciBpPW5ldyBXb3JrZXIoclt0XXx8KHJbdF09VVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbZSsnO2FkZEV2ZW50TGlzdGVuZXIoImVycm9yIixmdW5jdGlvbihlKXtlPWUuZXJyb3I7cG9zdE1lc3NhZ2UoeyRlJDpbZS5tZXNzYWdlLGUuY29kZSxlLnN0YWNrXX0pfSknXSx7dHlwZToidGV4dC9qYXZhc2NyaXB0In0pKSkpO3JldHVybiBpLm9ubWVzc2FnZT1mdW5jdGlvbihlKXt2YXIgdD1lLmRhdGEsQT10LiRlJDtpZihBKXt2YXIgcj1uZXcgRXJyb3IoQVswXSk7ci5jb2RlPUFbMV0sci5zdGFjaz1BWzJdLHMocixudWxsKX1lbHNlIHMobnVsbCx0KX0saS5wb3N0TWVzc2FnZShBLG4pLGl9KCRbQV0uYysiO29ubWVzc2FnZT1mdW5jdGlvbihlKXtmb3IodmFyIGsgaW4gZS5kYXRhKXNlbGZba109ZS5kYXRhW2tdO29ubWVzc2FnZT0iK3QudG9TdHJpbmcoKSsifSIsQSxsLGZ1bmN0aW9uKGUpe3ZhciB0PVtdO2Zvcih2YXIgQSBpbiBlKWVbQV0uYnVmZmVyJiZ0LnB1c2goKGVbQV09bmV3IGVbQV0uY29uc3RydWN0b3IoZVtBXSkpLmJ1ZmZlcik7cmV0dXJuIHR9KGwpLG4pfSx0ZT1mdW5jdGlvbigpe3JldHVybltuLHMsaSxvLGEsbCxoLHAsXyx4LG0sSSx5LEYsUSxVLEUsUyxOLGssRWUsb2UsYWVdfSxBZT1mdW5jdGlvbigpe3JldHVybltuLHMsaSxvLGEsbCxkLGcsQyx2LGosYixtLFYsRyx5LEgsUCxULE8sTSxELFIsSyxFLFMseixZLHhlLG9lXX0scmU9ZnVuY3Rpb24oKXtyZXR1cm5bZ2UsQmUscGUsVyxxXX0sbmU9ZnVuY3Rpb24oKXtyZXR1cm5bbWUsd2VdfSxzZT1mdW5jdGlvbigpe3JldHVyblt5ZSxwZSxYXX0saWU9ZnVuY3Rpb24oKXtyZXR1cm5bdmVdfSxvZT1mdW5jdGlvbihlKXtyZXR1cm4gcG9zdE1lc3NhZ2UoZSxbZS5idWZmZXJdKX0sYWU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJntvdXQ6ZS5zaXplJiZuZXcgbihlLnNpemUpLGRpY3Rpb25hcnk6ZS5kaWN0aW9uYXJ5fX0sbGU9ZnVuY3Rpb24oZSx0LEEscixuLHMpe3ZhciBpPWVlKEEscixuLGZ1bmN0aW9uKGUsdCl7aS50ZXJtaW5hdGUoKSxzKGUsdCl9KTtyZXR1cm4gaS5wb3N0TWVzc2FnZShbZSx0XSx0LmNvbnN1bWU/W2UuYnVmZmVyXTpbXSksZnVuY3Rpb24oKXtpLnRlcm1pbmF0ZSgpfX0sY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGUub25kYXRhPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHBvc3RNZXNzYWdlKFtlLHRdLFtlLmJ1ZmZlcl0pfSxmdW5jdGlvbih0KXt0LmRhdGEubGVuZ3RoPyhlLnB1c2godC5kYXRhWzBdLHQuZGF0YVsxXSkscG9zdE1lc3NhZ2UoW3QuZGF0YVswXS5sZW5ndGhdKSk6ZS5mbHVzaCgpfX0sdWU9ZnVuY3Rpb24oZSx0LEEscixuLHMsaSl7dmFyIG8sYT1lZShlLHIsbixmdW5jdGlvbihlLEEpe2U/KGEudGVybWluYXRlKCksdC5vbmRhdGEuY2FsbCh0LGUpKTpBcnJheS5pc0FycmF5KEEpPzE9PUEubGVuZ3RoPyh0LnF1ZXVlZFNpemUtPUFbMF0sdC5vbmRyYWluJiZ0Lm9uZHJhaW4oQVswXSkpOihBWzFdJiZhLnRlcm1pbmF0ZSgpLHQub25kYXRhLmNhbGwodCxlLEFbMF0sQVsxXSkpOmkoQSl9KTthLnBvc3RNZXNzYWdlKEEpLHQucXVldWVkU2l6ZT0wLHQucHVzaD1mdW5jdGlvbihlLEEpe3Qub25kYXRhfHxOKDUpLG8mJnQub25kYXRhKE4oNCwwLDEpLG51bGwsISFBKSx0LnF1ZXVlZFNpemUrPWUubGVuZ3RoLGEucG9zdE1lc3NhZ2UoW2Usbz1BXSxbZS5idWZmZXJdKX0sdC50ZXJtaW5hdGU9ZnVuY3Rpb24oKXthLnRlcm1pbmF0ZSgpfSxzJiYodC5mbHVzaD1mdW5jdGlvbigpe2EucG9zdE1lc3NhZ2UoW10pfSl9LGhlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbdF18ZVt0KzFdPDw4fSxkZT1mdW5jdGlvbihlLHQpe3JldHVybihlW3RdfGVbdCsxXTw8OHxlW3QrMl08PDE2fGVbdCszXTw8MjQpPj4+MH0sZmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZGUoZSx0KSs0Mjk0OTY3Mjk2KmRlKGUsdCs0KX0scGU9ZnVuY3Rpb24oZSx0LEEpe2Zvcig7QTsrK3QpZVt0XT1BLEE+Pj49OH0sZ2U9ZnVuY3Rpb24oZSx0KXt2YXIgQT10LmZpbGVuYW1lO2lmKGVbMF09MzEsZVsxXT0xMzksZVsyXT04LGVbOF09dC5sZXZlbDwyPzQ6OT09dC5sZXZlbD8yOjAsZVs5XT0zLDAhPXQubXRpbWUmJnBlKGUsNCxNYXRoLmZsb29yKG5ldyBEYXRlKHQubXRpbWV8fERhdGUubm93KCkpLzFlMykpLEEpe2VbM109ODtmb3IodmFyIHI9MDtyPD1BLmxlbmd0aDsrK3IpZVtyKzEwXT1BLmNoYXJDb2RlQXQocil9fSxtZT1mdW5jdGlvbihlKXszMT09ZVswXSYmMTM5PT1lWzFdJiY4PT1lWzJdfHxOKDYsImludmFsaWQgZ3ppcCBkYXRhIik7dmFyIHQ9ZVszXSxBPTEwOzQmdCYmKEErPTIrKGVbMTBdfGVbMTFdPDw4KSk7Zm9yKHZhciByPSh0Pj4zJjEpKyh0Pj40JjEpO3I+MDtyLT0hZVtBKytdKTtyZXR1cm4gQSsoMiZ0KX0sd2U9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg7cmV0dXJuKGVbdC00XXxlW3QtM108PDh8ZVt0LTJdPDwxNnxlW3QtMV08PDI0KT4+PjB9LEJlPWZ1bmN0aW9uKGUpe3JldHVybiAxMCsoZS5maWxlbmFtZT9lLmZpbGVuYW1lLmxlbmd0aCsxOjApfSx5ZT1mdW5jdGlvbihlLHQpe3ZhciBBPXQubGV2ZWwscj0wPT1BPzA6QTw2PzE6OT09QT8zOjI7aWYoZVswXT0xMjAsZVsxXT1yPDw2fCh0LmRpY3Rpb25hcnkmJjMyKSxlWzFdfD0zMS0oZVswXTw8OHxlWzFdKSUzMSx0LmRpY3Rpb25hcnkpe3ZhciBuPVgoKTtuLnAodC5kaWN0aW9uYXJ5KSxwZShlLDIsbi5kKCkpfX0sdmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4oOCE9KDE1JmVbMF0pfHxlWzBdPj40Pjd8fChlWzBdPDw4fGVbMV0pJTMxKSYmTig2LCJpbnZhbGlkIHpsaWIgZGF0YSIpLChlWzFdPj41JjEpPT0rIXQmJk4oNiwiaW52YWxpZCB6bGliIGRhdGE6ICIrKDMyJmVbMV0/Im5lZWQiOiJ1bmV4cGVjdGVkIikrIiBkaWN0aW9uYXJ5IiksMisoZVsxXT4+MyY0KX07ZnVuY3Rpb24gYmUoZSx0KXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgZSYmKHQ9ZSxlPXt9KSx0aGlzLm9uZGF0YT10LGV9dmFyIENlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBlJiYodD1lLGU9e30pLHRoaXMub25kYXRhPXQsdGhpcy5vPWV8fHt9LHRoaXMucz17bDowLGk6MzI3NjgsdzozMjc2OCx6OjMyNzY4fSx0aGlzLmI9bmV3IG4oOTgzMDQpLHRoaXMuby5kaWN0aW9uYXJ5KXt2YXIgQT10aGlzLm8uZGljdGlvbmFyeS5zdWJhcnJheSgtMzI3NjgpO3RoaXMuYi5zZXQoQSwzMjc2OC1BLmxlbmd0aCksdGhpcy5zLmk9MzI3NjgtQS5sZW5ndGh9fXJldHVybiBlLnByb3RvdHlwZS5wPWZ1bmN0aW9uKGUsdCl7dGhpcy5vbmRhdGEoWShlLHRoaXMubywwLDAsdGhpcy5zKSx0KX0sZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe3RoaXMub25kYXRhfHxOKDUpLHRoaXMucy5sJiZOKDQpO3ZhciBBPWUubGVuZ3RoK3RoaXMucy56O2lmKEE+dGhpcy5iLmxlbmd0aCl7aWYoQT4yKnRoaXMuYi5sZW5ndGgtMzI3Njgpe3ZhciByPW5ldyBuKC0zMjc2OCZBKTtyLnNldCh0aGlzLmIuc3ViYXJyYXkoMCx0aGlzLnMueikpLHRoaXMuYj1yfXZhciBzPXRoaXMuYi5sZW5ndGgtdGhpcy5zLno7dGhpcy5iLnNldChlLnN1YmFycmF5KDAscyksdGhpcy5zLnopLHRoaXMucy56PXRoaXMuYi5sZW5ndGgsdGhpcy5wKHRoaXMuYiwhMSksdGhpcy5iLnNldCh0aGlzLmIuc3ViYXJyYXkoLTMyNzY4KSksdGhpcy5iLnNldChlLnN1YmFycmF5KHMpLDMyNzY4KSx0aGlzLnMuej1lLmxlbmd0aC1zKzMyNzY4LHRoaXMucy5pPTMyNzY2LHRoaXMucy53PTMyNzY4fWVsc2UgdGhpcy5iLnNldChlLHRoaXMucy56KSx0aGlzLnMueis9ZS5sZW5ndGg7dGhpcy5zLmw9MSZ0LCh0aGlzLnMuej50aGlzLnMudys4MTkxfHx0KSYmKHRoaXMucCh0aGlzLmIsdHx8ITEpLHRoaXMucy53PXRoaXMucy5pLHRoaXMucy5pLT0yKX0sZS5wcm90b3R5cGUuZmx1c2g9ZnVuY3Rpb24oKXt0aGlzLm9uZGF0YXx8Tig1KSx0aGlzLnMubCYmTig0KSx0aGlzLnAodGhpcy5iLCExKSx0aGlzLnMudz10aGlzLnMuaSx0aGlzLnMuaS09Mn0sZX0oKSxfZT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQpe3VlKFtBZSxmdW5jdGlvbigpe3JldHVybltjZSxDZV19XSx0aGlzLGJlLmNhbGwodGhpcyxlLHQpLGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBDZShlLmRhdGEpO29ubWVzc2FnZT1jZSh0KX0sNiwxKX19KCk7ZnVuY3Rpb24gamUoZSx0LEEpe3JldHVybiBBfHwoQT10LHQ9e30pLCJmdW5jdGlvbiIhPXR5cGVvZiBBJiZOKDcpLGxlKGUsdCxbQWVdLGZ1bmN0aW9uKGUpe3JldHVybiBvZSh4ZShlLmRhdGFbMF0sZS5kYXRhWzFdKSl9LDAsQSl9ZnVuY3Rpb24geGUoZSx0KXtyZXR1cm4gWShlLHR8fHt9LDAsMCl9dmFyIEZlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpeyJmdW5jdGlvbiI9PXR5cGVvZiBlJiYodD1lLGU9e30pLHRoaXMub25kYXRhPXQ7dmFyIEE9ZSYmZS5kaWN0aW9uYXJ5JiZlLmRpY3Rpb25hcnkuc3ViYXJyYXkoLTMyNzY4KTt0aGlzLnM9e2k6MCxiOkE/QS5sZW5ndGg6MH0sdGhpcy5vPW5ldyBuKDMyNzY4KSx0aGlzLnA9bmV3IG4oMCksQSYmdGhpcy5vLnNldChBKX1yZXR1cm4gZS5wcm90b3R5cGUuZT1mdW5jdGlvbihlKXtpZih0aGlzLm9uZGF0YXx8Tig1KSx0aGlzLmQmJk4oNCksdGhpcy5wLmxlbmd0aCl7aWYoZS5sZW5ndGgpe3ZhciB0PW5ldyBuKHRoaXMucC5sZW5ndGgrZS5sZW5ndGgpO3Quc2V0KHRoaXMucCksdC5zZXQoZSx0aGlzLnAubGVuZ3RoKSx0aGlzLnA9dH19ZWxzZSB0aGlzLnA9ZX0sZS5wcm90b3R5cGUuYz1mdW5jdGlvbihlKXt0aGlzLnMuaT0rKHRoaXMuZD1lfHwhMSk7dmFyIHQ9dGhpcy5zLmIsQT1rKHRoaXMucCx0aGlzLnMsdGhpcy5vKTt0aGlzLm9uZGF0YShTKEEsdCx0aGlzLnMuYiksdGhpcy5kKSx0aGlzLm89UyhBLHRoaXMucy5iLTMyNzY4KSx0aGlzLnMuYj10aGlzLm8ubGVuZ3RoLHRoaXMucD1TKHRoaXMucCx0aGlzLnMucC84fDApLHRoaXMucy5wJj03fSxlLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGUsdCl7dGhpcy5lKGUpLHRoaXMuYyh0KX0sZX0oKSxRZT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQpe3VlKFt0ZSxmdW5jdGlvbigpe3JldHVybltjZSxGZV19XSx0aGlzLGJlLmNhbGwodGhpcyxlLHQpLGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBGZShlLmRhdGEpO29ubWVzc2FnZT1jZSh0KX0sNywwKX19KCk7ZnVuY3Rpb24gVWUoZSx0LEEpe3JldHVybiBBfHwoQT10LHQ9e30pLCJmdW5jdGlvbiIhPXR5cGVvZiBBJiZOKDcpLGxlKGUsdCxbdGVdLGZ1bmN0aW9uKGUpe3JldHVybiBvZShFZShlLmRhdGFbMF0sYWUoZS5kYXRhWzFdKSkpfSwxLEEpfWZ1bmN0aW9uIEVlKGUsdCl7cmV0dXJuIGsoZSx7aToyfSx0JiZ0Lm91dCx0JiZ0LmRpY3Rpb25hcnkpfXZhciBTZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLmM9VygpLHRoaXMubD0wLHRoaXMudj0xLENlLmNhbGwodGhpcyxlLHQpfXJldHVybiBlLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGUsdCl7dGhpcy5jLnAoZSksdGhpcy5sKz1lLmxlbmd0aCxDZS5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsZSx0KX0sZS5wcm90b3R5cGUucD1mdW5jdGlvbihlLHQpe3ZhciBBPVkoZSx0aGlzLm8sdGhpcy52JiZCZSh0aGlzLm8pLHQmJjgsdGhpcy5zKTt0aGlzLnYmJihnZShBLHRoaXMubyksdGhpcy52PTApLHQmJihwZShBLEEubGVuZ3RoLTgsdGhpcy5jLmQoKSkscGUoQSxBLmxlbmd0aC00LHRoaXMubCkpLHRoaXMub25kYXRhKEEsdCl9LGUucHJvdG90eXBlLmZsdXNoPWZ1bmN0aW9uKCl7Q2UucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyl9LGV9KCksTGU9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt1ZShbQWUscmUsZnVuY3Rpb24oKXtyZXR1cm5bY2UsQ2UsU2VdfV0sdGhpcyxiZS5jYWxsKHRoaXMsZSx0KSxmdW5jdGlvbihlKXt2YXIgdD1uZXcgU2UoZS5kYXRhKTtvbm1lc3NhZ2U9Y2UodCl9LDgsMSl9fSgpO2Z1bmN0aW9uIEllKGUsdCxBKXtyZXR1cm4gQXx8KEE9dCx0PXt9KSwiZnVuY3Rpb24iIT10eXBlb2YgQSYmTig3KSxsZShlLHQsW0FlLHJlLGZ1bmN0aW9uKCl7cmV0dXJuW05lXX1dLGZ1bmN0aW9uKGUpe3JldHVybiBvZShOZShlLmRhdGFbMF0sZS5kYXRhWzFdKSl9LDIsQSl9ZnVuY3Rpb24gTmUoZSx0KXt0fHwodD17fSk7dmFyIEE9VygpLHI9ZS5sZW5ndGg7QS5wKGUpO3ZhciBuPVkoZSx0LEJlKHQpLDgpLHM9bi5sZW5ndGg7cmV0dXJuIGdlKG4sdCkscGUobixzLTgsQS5kKCkpLHBlKG4scy00LHIpLG59dmFyIGtlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3RoaXMudj0xLHRoaXMucj0wLEZlLmNhbGwodGhpcyxlLHQpfXJldHVybiBlLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGUsdCl7aWYoRmUucHJvdG90eXBlLmUuY2FsbCh0aGlzLGUpLHRoaXMucis9ZS5sZW5ndGgsdGhpcy52KXt2YXIgQT10aGlzLnAuc3ViYXJyYXkodGhpcy52LTEpLHI9QS5sZW5ndGg+Mz9tZShBKTo0O2lmKHI+QS5sZW5ndGgpe2lmKCF0KXJldHVybn1lbHNlIHRoaXMudj4xJiZ0aGlzLm9ubWVtYmVyJiZ0aGlzLm9ubWVtYmVyKHRoaXMuci1BLmxlbmd0aCk7dGhpcy5wPUEuc3ViYXJyYXkociksdGhpcy52PTB9RmUucHJvdG90eXBlLmMuY2FsbCh0aGlzLHQpLCF0aGlzLnMuZnx8dGhpcy5zLmx8fHR8fCh0aGlzLnY9RSh0aGlzLnMucCkrOSx0aGlzLnM9e2k6MH0sdGhpcy5vPW5ldyBuKDApLHRoaXMucHVzaChuZXcgbigwKSx0KSl9LGV9KCksSGU9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt2YXIgQT10aGlzO3VlKFt0ZSxuZSxmdW5jdGlvbigpe3JldHVybltjZSxGZSxrZV19XSx0aGlzLGJlLmNhbGwodGhpcyxlLHQpLGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBrZShlLmRhdGEpO3Qub25tZW1iZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIHBvc3RNZXNzYWdlKGUpfSxvbm1lc3NhZ2U9Y2UodCl9LDksMCxmdW5jdGlvbihlKXtyZXR1cm4gQS5vbm1lbWJlciYmQS5vbm1lbWJlcihlKX0pfX0oKTtmdW5jdGlvbiBQZShlLHQsQSl7cmV0dXJuIEF8fChBPXQsdD17fSksImZ1bmN0aW9uIiE9dHlwZW9mIEEmJk4oNyksbGUoZSx0LFt0ZSxuZSxmdW5jdGlvbigpe3JldHVybltUZV19XSxmdW5jdGlvbihlKXtyZXR1cm4gb2UoVGUoZS5kYXRhWzBdLGUuZGF0YVsxXSkpfSwzLEEpfWZ1bmN0aW9uIFRlKGUsdCl7dmFyIEE9bWUoZSk7cmV0dXJuIEErOD5lLmxlbmd0aCYmTig2LCJpbnZhbGlkIGd6aXAgZGF0YSIpLGsoZS5zdWJhcnJheShBLC04KSx7aToyfSx0JiZ0Lm91dHx8bmV3IG4od2UoZSkpLHQmJnQuZGljdGlvbmFyeSl9dmFyIE9lPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3RoaXMuYz1YKCksdGhpcy52PTEsQ2UuY2FsbCh0aGlzLGUsdCl9cmV0dXJuIGUucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSx0KXt0aGlzLmMucChlKSxDZS5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsZSx0KX0sZS5wcm90b3R5cGUucD1mdW5jdGlvbihlLHQpe3ZhciBBPVkoZSx0aGlzLm8sdGhpcy52JiYodGhpcy5vLmRpY3Rpb25hcnk/NjoyKSx0JiY0LHRoaXMucyk7dGhpcy52JiYoeWUoQSx0aGlzLm8pLHRoaXMudj0wKSx0JiZwZShBLEEubGVuZ3RoLTQsdGhpcy5jLmQoKSksdGhpcy5vbmRhdGEoQSx0KX0sZS5wcm90b3R5cGUuZmx1c2g9ZnVuY3Rpb24oKXtDZS5wcm90b3R5cGUuZmx1c2guY2FsbCh0aGlzKX0sZX0oKSxNZT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQpe3VlKFtBZSxzZSxmdW5jdGlvbigpe3JldHVybltjZSxDZSxPZV19XSx0aGlzLGJlLmNhbGwodGhpcyxlLHQpLGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBPZShlLmRhdGEpO29ubWVzc2FnZT1jZSh0KX0sMTAsMSl9fSgpO2Z1bmN0aW9uIERlKGUsdCxBKXtyZXR1cm4gQXx8KEE9dCx0PXt9KSwiZnVuY3Rpb24iIT10eXBlb2YgQSYmTig3KSxsZShlLHQsW0FlLHNlLGZ1bmN0aW9uKCl7cmV0dXJuW1JlXX1dLGZ1bmN0aW9uKGUpe3JldHVybiBvZShSZShlLmRhdGFbMF0sZS5kYXRhWzFdKSl9LDQsQSl9ZnVuY3Rpb24gUmUoZSx0KXt0fHwodD17fSk7dmFyIEE9WCgpO0EucChlKTt2YXIgcj1ZKGUsdCx0LmRpY3Rpb25hcnk/NjoyLDQpO3JldHVybiB5ZShyLHQpLHBlKHIsci5sZW5ndGgtNCxBLmQoKSkscn12YXIgS2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7RmUuY2FsbCh0aGlzLGUsdCksdGhpcy52PWUmJmUuZGljdGlvbmFyeT8yOjF9cmV0dXJuIGUucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSx0KXtpZihGZS5wcm90b3R5cGUuZS5jYWxsKHRoaXMsZSksdGhpcy52KXtpZih0aGlzLnAubGVuZ3RoPDYmJiF0KXJldHVybjt0aGlzLnA9dGhpcy5wLnN1YmFycmF5KHZlKHRoaXMucCx0aGlzLnYtMSkpLHRoaXMudj0wfXQmJih0aGlzLnAubGVuZ3RoPDQmJk4oNiwiaW52YWxpZCB6bGliIGRhdGEiKSx0aGlzLnA9dGhpcy5wLnN1YmFycmF5KDAsLTQpKSxGZS5wcm90b3R5cGUuYy5jYWxsKHRoaXMsdCl9LGV9KCksVmU9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt1ZShbdGUsaWUsZnVuY3Rpb24oKXtyZXR1cm5bY2UsRmUsS2VdfV0sdGhpcyxiZS5jYWxsKHRoaXMsZSx0KSxmdW5jdGlvbihlKXt2YXIgdD1uZXcgS2UoZS5kYXRhKTtvbm1lc3NhZ2U9Y2UodCl9LDExLDApfX0oKTtmdW5jdGlvbiBHZShlLHQsQSl7cmV0dXJuIEF8fChBPXQsdD17fSksImZ1bmN0aW9uIiE9dHlwZW9mIEEmJk4oNyksbGUoZSx0LFt0ZSxpZSxmdW5jdGlvbigpe3JldHVyblt6ZV19XSxmdW5jdGlvbihlKXtyZXR1cm4gb2UoemUoZS5kYXRhWzBdLGFlKGUuZGF0YVsxXSkpKX0sNSxBKX1mdW5jdGlvbiB6ZShlLHQpe3JldHVybiBrKGUuc3ViYXJyYXkodmUoZSx0JiZ0LmRpY3Rpb25hcnkpLC00KSx7aToyfSx0JiZ0Lm91dCx0JiZ0LmRpY3Rpb25hcnkpfXZhciBxZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLm89YmUuY2FsbCh0aGlzLGUsdCl8fHt9LHRoaXMuRz1rZSx0aGlzLkk9RmUsdGhpcy5aPUtlfXJldHVybiBlLnByb3RvdHlwZS5pPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnMub25kYXRhPWZ1bmN0aW9uKHQsQSl7ZS5vbmRhdGEodCxBKX19LGUucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLm9uZGF0YXx8Tig1KSx0aGlzLnMpdGhpcy5zLnB1c2goZSx0KTtlbHNle2lmKHRoaXMucCYmdGhpcy5wLmxlbmd0aCl7dmFyIEE9bmV3IG4odGhpcy5wLmxlbmd0aCtlLmxlbmd0aCk7QS5zZXQodGhpcy5wKSxBLnNldChlLHRoaXMucC5sZW5ndGgpfWVsc2UgdGhpcy5wPWU7dGhpcy5wLmxlbmd0aD4yJiYodGhpcy5zPTMxPT10aGlzLnBbMF0mJjEzOT09dGhpcy5wWzFdJiY4PT10aGlzLnBbMl0/bmV3IHRoaXMuRyh0aGlzLm8pOjghPSgxNSZ0aGlzLnBbMF0pfHx0aGlzLnBbMF0+PjQ+N3x8KHRoaXMucFswXTw8OHx0aGlzLnBbMV0pJTMxP25ldyB0aGlzLkkodGhpcy5vKTpuZXcgdGhpcy5aKHRoaXMubyksdGhpcy5pKCksdGhpcy5zLnB1c2godGhpcy5wLHQpLHRoaXMucD1udWxsKX19LGV9KCksV2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7cWUuY2FsbCh0aGlzLGUsdCksdGhpcy5xdWV1ZWRTaXplPTAsdGhpcy5HPUhlLHRoaXMuST1RZSx0aGlzLlo9VmV9cmV0dXJuIGUucHJvdG90eXBlLmk9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucy5vbmRhdGE9ZnVuY3Rpb24odCxBLHIpe2Uub25kYXRhKHQsQSxyKX0sdGhpcy5zLm9uZHJhaW49ZnVuY3Rpb24odCl7ZS5xdWV1ZWRTaXplLT10LGUub25kcmFpbiYmZS5vbmRyYWluKHQpfX0sZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe3RoaXMucXVldWVkU2l6ZSs9ZS5sZW5ndGgscWUucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLGUsdCl9LGV9KCk7ZnVuY3Rpb24gWGUoZSx0LEEpe3JldHVybiBBfHwoQT10LHQ9e30pLCJmdW5jdGlvbiIhPXR5cGVvZiBBJiZOKDcpLDMxPT1lWzBdJiYxMzk9PWVbMV0mJjg9PWVbMl0/UGUoZSx0LEEpOjghPSgxNSZlWzBdKXx8ZVswXT4+ND43fHwoZVswXTw8OHxlWzFdKSUzMT9VZShlLHQsQSk6R2UoZSx0LEEpfWZ1bmN0aW9uIFllKGUsdCl7cmV0dXJuIDMxPT1lWzBdJiYxMzk9PWVbMV0mJjg9PWVbMl0/VGUoZSx0KTo4IT0oMTUmZVswXSl8fGVbMF0+PjQ+N3x8KGVbMF08PDh8ZVsxXSklMzE/RWUoZSx0KTp6ZShlLHQpfXZhciBKZT1mdW5jdGlvbihlLHQsQSxyKXtmb3IodmFyIHMgaW4gZSl7dmFyIGk9ZVtzXSxvPXQrcyxhPXI7QXJyYXkuaXNBcnJheShpKSYmKGE9SihyLGlbMV0pLGk9aVswXSksaSBpbnN0YW5jZW9mIG4/QVtvXT1baSxhXTooQVtvKz0iLyJdPVtuZXcgbigwKSxhXSxKZShpLG8sQSxyKSl9fSxaZT0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHRFbmNvZGVyJiZuZXcgVGV4dEVuY29kZXIsJGU9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2RlciYmbmV3IFRleHREZWNvZGVyLGV0PTA7dHJ5eyRlLmRlY29kZShHLHtzdHJlYW06ITB9KSxldD0xfWNhdGNoKGUpe312YXIgdHQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PSIiLEE9MDs7KXt2YXIgcj1lW0ErK10sbj0ocj4xMjcpKyhyPjIyMykrKHI+MjM5KTtpZihBK24+ZS5sZW5ndGgpcmV0dXJue3M6dCxyOlMoZSxBLTEpfTtuPzM9PW4/KHI9KCgxNSZyKTw8MTh8KDYzJmVbQSsrXSk8PDEyfCg2MyZlW0ErK10pPDw2fDYzJmVbQSsrXSktNjU1MzYsdCs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxyPj4xMCw1NjMyMHwxMDIzJnIpKTp0Kz0xJm4/U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmcik8PDZ8NjMmZVtBKytdKTpTdHJpbmcuZnJvbUNoYXJDb2RlKCgxNSZyKTw8MTJ8KDYzJmVbQSsrXSk8PDZ8NjMmZVtBKytdKTp0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKHIpfX0sQXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMub25kYXRhPWUsZXQ/dGhpcy50PW5ldyBUZXh0RGVjb2Rlcjp0aGlzLnA9R31yZXR1cm4gZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe2lmKHRoaXMub25kYXRhfHxOKDUpLHQ9ISF0LHRoaXMudClyZXR1cm4gdGhpcy5vbmRhdGEodGhpcy50LmRlY29kZShlLHtzdHJlYW06ITB9KSx0KSx2b2lkKHQmJih0aGlzLnQuZGVjb2RlKCkubGVuZ3RoJiZOKDgpLHRoaXMudD1udWxsKSk7dGhpcy5wfHxOKDQpO3ZhciBBPW5ldyBuKHRoaXMucC5sZW5ndGgrZS5sZW5ndGgpO0Euc2V0KHRoaXMucCksQS5zZXQoZSx0aGlzLnAubGVuZ3RoKTt2YXIgcj10dChBKSxzPXIucyxpPXIucjt0PyhpLmxlbmd0aCYmTig4KSx0aGlzLnA9bnVsbCk6dGhpcy5wPWksdGhpcy5vbmRhdGEocyx0KX0sZX0oKSxydD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5vbmRhdGE9ZX1yZXR1cm4gZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe3RoaXMub25kYXRhfHxOKDUpLHRoaXMuZCYmTig0KSx0aGlzLm9uZGF0YShudChlKSx0aGlzLmQ9dHx8ITEpfSxlfSgpO2Z1bmN0aW9uIG50KGUsdCl7aWYodCl7Zm9yKHZhciBBPW5ldyBuKGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpQVtyXT1lLmNoYXJDb2RlQXQocik7cmV0dXJuIEF9aWYoWmUpcmV0dXJuIFplLmVuY29kZShlKTt2YXIgcz1lLmxlbmd0aCxpPW5ldyBuKGUubGVuZ3RoKyhlLmxlbmd0aD4+MSkpLG89MCxhPWZ1bmN0aW9uKGUpe2lbbysrXT1lfTtmb3Iocj0wO3I8czsrK3Ipe2lmKG8rNT5pLmxlbmd0aCl7dmFyIGw9bmV3IG4obys4KyhzLXI8PDEpKTtsLnNldChpKSxpPWx9dmFyIGM9ZS5jaGFyQ29kZUF0KHIpO2M8MTI4fHx0P2EoYyk6YzwyMDQ4PyhhKDE5MnxjPj42KSxhKDEyOHw2MyZjKSk6Yz41NTI5NSYmYzw1NzM0ND8oYSgyNDB8KGM9NjU1MzYrKDEwNDc1NTImYyl8MTAyMyZlLmNoYXJDb2RlQXQoKytyKSk+PjE4KSxhKDEyOHxjPj4xMiY2MyksYSgxMjh8Yz4+NiY2MyksYSgxMjh8NjMmYykpOihhKDIyNHxjPj4xMiksYSgxMjh8Yz4+NiY2MyksYSgxMjh8NjMmYykpfXJldHVybiBTKGksMCxvKX1mdW5jdGlvbiBzdChlLHQpe2lmKHQpe2Zvcih2YXIgQT0iIixyPTA7cjxlLmxlbmd0aDtyKz0xNjM4NClBKz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsZS5zdWJhcnJheShyLHIrMTYzODQpKTtyZXR1cm4gQX1pZigkZSlyZXR1cm4gJGUuZGVjb2RlKGUpO3ZhciBuPXR0KGUpLHM9bi5zO3JldHVybihBPW4ucikubGVuZ3RoJiZOKDgpLHN9dmFyIGl0PWZ1bmN0aW9uKGUpe3JldHVybiAxPT1lPzM6ZTw2PzI6OT09ZT8xOjB9LG90PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQrMzAraGUoZSx0KzI2KStoZShlLHQrMjgpfSxhdD1mdW5jdGlvbihlLHQsQSl7dmFyIHI9aGUoZSx0KzI4KSxuPXN0KGUuc3ViYXJyYXkodCs0Nix0KzQ2K3IpLCEoMjA0OCZoZShlLHQrOCkpKSxzPXQrNDYrcixpPWRlKGUsdCsyMCksbz1BJiY0Mjk0OTY3Mjk1PT1pP2x0KGUscyk6W2ksZGUoZSx0KzI0KSxkZShlLHQrNDIpXSxhPW9bMF0sbD1vWzFdLGM9b1syXTtyZXR1cm5baGUoZSx0KzEwKSxhLGwsbixzK2hlKGUsdCszMCkraGUoZSx0KzMyKSxjXX0sbHQ9ZnVuY3Rpb24oZSx0KXtmb3IoOzEhPWhlKGUsdCk7dCs9NCtoZShlLHQrMikpO3JldHVybltmZShlLHQrMTIpLGZlKGUsdCs0KSxmZShlLHQrMjApXX0sY3Q9ZnVuY3Rpb24oZSl7dmFyIHQ9MDtpZihlKWZvcih2YXIgQSBpbiBlKXt2YXIgcj1lW0FdLmxlbmd0aDtyPjY1NTM1JiZOKDkpLHQrPXIrNH1yZXR1cm4gdH0sdXQ9ZnVuY3Rpb24oZSx0LEEscixuLHMsaSxvKXt2YXIgYT1yLmxlbmd0aCxsPUEuZXh0cmEsYz1vJiZvLmxlbmd0aCx1PWN0KGwpO3BlKGUsdCxudWxsIT1pPzMzNjM5MjQ4OjY3MzI0NzUyKSx0Kz00LG51bGwhPWkmJihlW3QrK109MjAsZVt0KytdPUEub3MpLGVbdF09MjAsdCs9MixlW3QrK109QS5mbGFnPDwxfChzPDAmJjgpLGVbdCsrXT1uJiY4LGVbdCsrXT0yNTUmQS5jb21wcmVzc2lvbixlW3QrK109QS5jb21wcmVzc2lvbj4+ODt2YXIgaD1uZXcgRGF0ZShudWxsPT1BLm10aW1lP0RhdGUubm93KCk6QS5tdGltZSksZD1oLmdldEZ1bGxZZWFyKCktMTk4MDtpZigoZDwwfHxkPjExOSkmJk4oMTApLHBlKGUsdCxkPDwyNXxoLmdldE1vbnRoKCkrMTw8MjF8aC5nZXREYXRlKCk8PDE2fGguZ2V0SG91cnMoKTw8MTF8aC5nZXRNaW51dGVzKCk8PDV8aC5nZXRTZWNvbmRzKCk+PjEpLHQrPTQsLTEhPXMmJihwZShlLHQsQS5jcmMpLHBlKGUsdCs0LHM8MD8tcy0yOnMpLHBlKGUsdCs4LEEuc2l6ZSkpLHBlKGUsdCsxMixhKSxwZShlLHQrMTQsdSksdCs9MTYsbnVsbCE9aSYmKHBlKGUsdCxjKSxwZShlLHQrNixBLmF0dHJzKSxwZShlLHQrMTAsaSksdCs9MTQpLGUuc2V0KHIsdCksdCs9YSx1KWZvcih2YXIgZiBpbiBsKXt2YXIgcD1sW2ZdLGc9cC5sZW5ndGg7cGUoZSx0LCtmKSxwZShlLHQrMixnKSxlLnNldChwLHQrNCksdCs9NCtnfXJldHVybiBjJiYoZS5zZXQobyx0KSx0Kz1jKSx0fSxodD1mdW5jdGlvbihlLHQsQSxyLG4pe3BlKGUsdCwxMDEwMTAyNTYpLHBlKGUsdCs4LEEpLHBlKGUsdCsxMCxBKSxwZShlLHQrMTIscikscGUoZSx0KzE2LG4pfSxkdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5maWxlbmFtZT1lLHRoaXMuYz1XKCksdGhpcy5zaXplPTAsdGhpcy5jb21wcmVzc2lvbj0wfXJldHVybiBlLnByb3RvdHlwZS5wcm9jZXNzPWZ1bmN0aW9uKGUsdCl7dGhpcy5vbmRhdGEobnVsbCxlLHQpfSxlLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGUsdCl7dGhpcy5vbmRhdGF8fE4oNSksdGhpcy5jLnAoZSksdGhpcy5zaXplKz1lLmxlbmd0aCx0JiYodGhpcy5jcmM9dGhpcy5jLmQoKSksdGhpcy5wcm9jZXNzKGUsdHx8ITEpfSxlfSgpLGZ0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZhciBBPXRoaXM7dHx8KHQ9e30pLGR0LmNhbGwodGhpcyxlKSx0aGlzLmQ9bmV3IENlKHQsZnVuY3Rpb24oZSx0KXtBLm9uZGF0YShudWxsLGUsdCl9KSx0aGlzLmNvbXByZXNzaW9uPTgsdGhpcy5mbGFnPWl0KHQubGV2ZWwpfXJldHVybiBlLnByb3RvdHlwZS5wcm9jZXNzPWZ1bmN0aW9uKGUsdCl7dHJ5e3RoaXMuZC5wdXNoKGUsdCl9Y2F0Y2goZSl7dGhpcy5vbmRhdGEoZSxudWxsLHQpfX0sZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe2R0LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcyxlLHQpfSxlfSgpLHB0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZhciBBPXRoaXM7dHx8KHQ9e30pLGR0LmNhbGwodGhpcyxlKSx0aGlzLmQ9bmV3IF9lKHQsZnVuY3Rpb24oZSx0LHIpe0Eub25kYXRhKGUsdCxyKX0pLHRoaXMuY29tcHJlc3Npb249OCx0aGlzLmZsYWc9aXQodC5sZXZlbCksdGhpcy50ZXJtaW5hdGU9dGhpcy5kLnRlcm1pbmF0ZX1yZXR1cm4gZS5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbihlLHQpe3RoaXMuZC5wdXNoKGUsdCl9LGUucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSx0KXtkdC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsZSx0KX0sZX0oKSxndD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5vbmRhdGE9ZSx0aGlzLnU9W10sdGhpcy5kPTF9cmV0dXJuIGUucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlKXt2YXIgdD10aGlzO2lmKHRoaXMub25kYXRhfHxOKDUpLDImdGhpcy5kKXRoaXMub25kYXRhKE4oNCs4KigxJnRoaXMuZCksMCwxKSxudWxsLCExKTtlbHNle3ZhciBBPW50KGUuZmlsZW5hbWUpLHI9QS5sZW5ndGgscz1lLmNvbW1lbnQsaT1zJiZudChzKSxvPXIhPWUuZmlsZW5hbWUubGVuZ3RofHxpJiZzLmxlbmd0aCE9aS5sZW5ndGgsYT1yK2N0KGUuZXh0cmEpKzMwO3I+NjU1MzUmJnRoaXMub25kYXRhKE4oMTEsMCwxKSxudWxsLCExKTt2YXIgbD1uZXcgbihhKTt1dChsLDAsZSxBLG8sLTEpO3ZhciBjPVtsXSx1PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPTAsQT1jO2U8QS5sZW5ndGg7ZSsrKXt2YXIgcj1BW2VdO3Qub25kYXRhKG51bGwsciwhMSl9Yz1bXX0saD10aGlzLmQ7dGhpcy5kPTA7dmFyIGQ9dGhpcy51Lmxlbmd0aCxmPUooZSx7ZjpBLHU6byxvOmksdDpmdW5jdGlvbigpe2UudGVybWluYXRlJiZlLnRlcm1pbmF0ZSgpfSxyOmZ1bmN0aW9uKCl7aWYodSgpLGgpe3ZhciBlPXQudVtkKzFdO2U/ZS5yKCk6dC5kPTF9aD0xfX0pLHA9MDtlLm9uZGF0YT1mdW5jdGlvbihBLHIscyl7aWYoQSl0Lm9uZGF0YShBLHIscyksdC50ZXJtaW5hdGUoKTtlbHNlIGlmKHArPXIubGVuZ3RoLGMucHVzaChyKSxzKXt2YXIgaT1uZXcgbigxNik7cGUoaSwwLDEzNDY5NTc2MCkscGUoaSw0LGUuY3JjKSxwZShpLDgscCkscGUoaSwxMixlLnNpemUpLGMucHVzaChpKSxmLmM9cCxmLmI9YStwKzE2LGYuY3JjPWUuY3JjLGYuc2l6ZT1lLnNpemUsaCYmZi5yKCksaD0xfWVsc2UgaCYmdSgpfSx0aGlzLnUucHVzaChmKX19LGUucHJvdG90eXBlLmVuZD1mdW5jdGlvbigpe3ZhciBlPXRoaXM7MiZ0aGlzLmQ/dGhpcy5vbmRhdGEoTig0KzgqKDEmdGhpcy5kKSwwLDEpLG51bGwsITApOih0aGlzLmQ/dGhpcy5lKCk6dGhpcy51LnB1c2goe3I6ZnVuY3Rpb24oKXsxJmUuZCYmKGUudS5zcGxpY2UoLTEsMSksZS5lKCkpfSx0OmZ1bmN0aW9uKCl7fX0pLHRoaXMuZD0zKX0sZS5wcm90b3R5cGUuZT1mdW5jdGlvbigpe2Zvcih2YXIgZT0wLHQ9MCxBPTAscj0wLHM9dGhpcy51O3I8cy5sZW5ndGg7cisrKUErPTQ2KyhsPXNbcl0pLmYubGVuZ3RoK2N0KGwuZXh0cmEpKyhsLm8/bC5vLmxlbmd0aDowKTtmb3IodmFyIGk9bmV3IG4oQSsyMiksbz0wLGE9dGhpcy51O288YS5sZW5ndGg7bysrKXt2YXIgbD1hW29dO3V0KGksZSxsLGwuZixsLnUsLWwuYy0yLHQsbC5vKSxlKz00NitsLmYubGVuZ3RoK2N0KGwuZXh0cmEpKyhsLm8/bC5vLmxlbmd0aDowKSx0Kz1sLmJ9aHQoaSxlLHRoaXMudS5sZW5ndGgsQSx0KSx0aGlzLm9uZGF0YShudWxsLGksITApLHRoaXMuZD0yfSxlLnByb3RvdHlwZS50ZXJtaW5hdGU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9MCx0PXRoaXMudTtlPHQubGVuZ3RoO2UrKyl0W2VdLnQoKTt0aGlzLmQ9Mn0sZX0oKTtmdW5jdGlvbiBtdChlLHQsQSl7QXx8KEE9dCx0PXt9KSwiZnVuY3Rpb24iIT10eXBlb2YgQSYmTig3KTt2YXIgcj17fTtKZShlLCIiLHIsdCk7dmFyIHM9T2JqZWN0LmtleXMociksaT1zLmxlbmd0aCxvPTAsYT0wLGw9aSxjPW5ldyBBcnJheShpKSx1PVtdLGg9ZnVuY3Rpb24oKXtmb3IodmFyIGU9MDtlPHUubGVuZ3RoOysrZSl1W2VdKCl9LGQ9ZnVuY3Rpb24oZSx0KXtDdChmdW5jdGlvbigpe0EoZSx0KX0pfTtDdChmdW5jdGlvbigpe2Q9QX0pO3ZhciBmPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IG4oYSsyMiksdD1vLEE9YS1vO2E9MDtmb3IodmFyIHI9MDtyPGw7KytyKXt2YXIgcz1jW3JdO3RyeXt2YXIgaT1zLmMubGVuZ3RoO3V0KGUsYSxzLHMuZixzLnUsaSk7dmFyIHU9MzArcy5mLmxlbmd0aCtjdChzLmV4dHJhKSxoPWErdTtlLnNldChzLmMsaCksdXQoZSxvLHMscy5mLHMudSxpLGEscy5tKSxvKz0xNit1KyhzLm0/cy5tLmxlbmd0aDowKSxhPWgraX1jYXRjaChlKXtyZXR1cm4gZChlLG51bGwpfX1odChlLG8sYy5sZW5ndGgsQSx0KSxkKG51bGwsZSl9O2l8fGYoKTtmb3IodmFyIHA9ZnVuY3Rpb24oZSl7dmFyIHQ9c1tlXSxBPXJbdF0sbj1BWzBdLGw9QVsxXSxwPVcoKSxnPW4ubGVuZ3RoO3AucChuKTt2YXIgbT1udCh0KSx3PW0ubGVuZ3RoLEI9bC5jb21tZW50LHk9QiYmbnQoQiksdj15JiZ5Lmxlbmd0aCxiPWN0KGwuZXh0cmEpLEM9MD09bC5sZXZlbD8wOjgsXz1mdW5jdGlvbihBLHIpe2lmKEEpaCgpLGQoQSxudWxsKTtlbHNle3ZhciBuPXIubGVuZ3RoO2NbZV09SihsLHtzaXplOmcsY3JjOnAuZCgpLGM6cixmOm0sbTp5LHU6dyE9dC5sZW5ndGh8fHkmJkIubGVuZ3RoIT12LGNvbXByZXNzaW9uOkN9KSxvKz0zMCt3K2IrbixhKz03NisyKih3K2IpKyh2fHwwKStuLC0taXx8ZigpfX07aWYodz42NTUzNSYmXyhOKDExLDAsMSksbnVsbCksQylpZihnPDE2ZTQpdHJ5e18obnVsbCx4ZShuLGwpKX1jYXRjaChlKXtfKGUsbnVsbCl9ZWxzZSB1LnB1c2goamUobixsLF8pKTtlbHNlIF8obnVsbCxuKX0sZz0wO2c8bDsrK2cpcChnKTtyZXR1cm4gaH1mdW5jdGlvbiB3dChlLHQpe3R8fCh0PXt9KTt2YXIgQT17fSxyPVtdO0plKGUsIiIsQSx0KTt2YXIgcz0wLGk9MDtmb3IodmFyIG8gaW4gQSl7dmFyIGE9QVtvXSxsPWFbMF0sYz1hWzFdLHU9MD09Yy5sZXZlbD8wOjgsaD0oXz1udChvKSkubGVuZ3RoLGQ9Yy5jb21tZW50LGY9ZCYmbnQoZCkscD1mJiZmLmxlbmd0aCxnPWN0KGMuZXh0cmEpO2g+NjU1MzUmJk4oMTEpO3ZhciBtPXU/eGUobCxjKTpsLHc9bS5sZW5ndGgsQj1XKCk7Qi5wKGwpLHIucHVzaChKKGMse3NpemU6bC5sZW5ndGgsY3JjOkIuZCgpLGM6bSxmOl8sbTpmLHU6aCE9by5sZW5ndGh8fGYmJmQubGVuZ3RoIT1wLG86cyxjb21wcmVzc2lvbjp1fSkpLHMrPTMwK2grZyt3LGkrPTc2KzIqKGgrZykrKHB8fDApK3d9Zm9yKHZhciB5PW5ldyBuKGkrMjIpLHY9cyxiPWktcyxDPTA7QzxyLmxlbmd0aDsrK0Mpe3ZhciBfPXJbQ107dXQoeSxfLm8sXyxfLmYsXy51LF8uYy5sZW5ndGgpO3ZhciBqPTMwK18uZi5sZW5ndGgrY3QoXy5leHRyYSk7eS5zZXQoXy5jLF8ubytqKSx1dCh5LHMsXyxfLmYsXy51LF8uYy5sZW5ndGgsXy5vLF8ubSkscys9MTYraisoXy5tP18ubS5sZW5ndGg6MCl9cmV0dXJuIGh0KHkscyxyLmxlbmd0aCxiLHYpLHl9dmFyIEJ0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe3RoaXMub25kYXRhKG51bGwsZSx0KX0sZS5jb21wcmVzc2lvbj0wLGV9KCkseXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dmFyIGU9dGhpczt0aGlzLmk9bmV3IEZlKGZ1bmN0aW9uKHQsQSl7ZS5vbmRhdGEobnVsbCx0LEEpfSl9cmV0dXJuIGUucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSx0KXt0cnl7dGhpcy5pLnB1c2goZSx0KX1jYXRjaChlKXt0aGlzLm9uZGF0YShlLG51bGwsdCl9fSxlLmNvbXByZXNzaW9uPTgsZX0oKSx2dD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt2YXIgQT10aGlzO3Q8MzJlND90aGlzLmk9bmV3IEZlKGZ1bmN0aW9uKGUsdCl7QS5vbmRhdGEobnVsbCxlLHQpfSk6KHRoaXMuaT1uZXcgUWUoZnVuY3Rpb24oZSx0LHIpe0Eub25kYXRhKGUsdCxyKX0pLHRoaXMudGVybWluYXRlPXRoaXMuaS50ZXJtaW5hdGUpfXJldHVybiBlLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGUsdCl7dGhpcy5pLnRlcm1pbmF0ZSYmKGU9UyhlLDApKSx0aGlzLmkucHVzaChlLHQpfSxlLmNvbXByZXNzaW9uPTgsZX0oKSxidD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5vbmZpbGU9ZSx0aGlzLms9W10sdGhpcy5vPXswOkJ0fSx0aGlzLnA9R31yZXR1cm4gZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe3ZhciBBPXRoaXM7aWYodGhpcy5vbmZpbGV8fE4oNSksdGhpcy5wfHxOKDQpLHRoaXMuYz4wKXt2YXIgcj1NYXRoLm1pbih0aGlzLmMsZS5sZW5ndGgpLHM9ZS5zdWJhcnJheSgwLHIpO2lmKHRoaXMuYy09cix0aGlzLmQ/dGhpcy5kLnB1c2gocywhdGhpcy5jKTp0aGlzLmtbMF0ucHVzaChzKSwoZT1lLnN1YmFycmF5KHIpKS5sZW5ndGgpcmV0dXJuIHRoaXMucHVzaChlLHQpfWVsc2V7dmFyIGk9MCxvPTAsYT12b2lkIDAsbD12b2lkIDA7dGhpcy5wLmxlbmd0aD9lLmxlbmd0aD8oKGw9bmV3IG4odGhpcy5wLmxlbmd0aCtlLmxlbmd0aCkpLnNldCh0aGlzLnApLGwuc2V0KGUsdGhpcy5wLmxlbmd0aCkpOmw9dGhpcy5wOmw9ZTtmb3IodmFyIGM9bC5sZW5ndGgsdT10aGlzLmMsaD11JiZ0aGlzLmQsZD1mdW5jdGlvbigpe3ZhciBlLHQ9ZGUobCxvKTtpZig2NzMyNDc1Mj09dCl7aT0xLGE9byxmLmQ9bnVsbCxmLmM9MDt2YXIgcj1oZShsLG8rNiksbj1oZShsLG8rOCkscz0yMDQ4JnIsaD04JnIsZD1oZShsLG8rMjYpLHA9aGUobCxvKzI4KTtpZihjPm8rMzArZCtwKXt2YXIgZz1bXTtmLmsudW5zaGlmdChnKSxpPTI7dmFyIG0sdz1kZShsLG8rMTgpLEI9ZGUobCxvKzIyKSx5PXN0KGwuc3ViYXJyYXkobyszMCxvKz0zMCtkKSwhcyk7NDI5NDk2NzI5NT09dz8oZT1oP1stMl06bHQobCxvKSx3PWVbMF0sQj1lWzFdKTpoJiYodz0tMSksbys9cCxmLmM9dzt2YXIgdj17bmFtZTp5LGNvbXByZXNzaW9uOm4sc3RhcnQ6ZnVuY3Rpb24oKXtpZih2Lm9uZGF0YXx8Tig1KSx3KXt2YXIgZT1BLm9bbl07ZXx8di5vbmRhdGEoTigxNCwidW5rbm93biBjb21wcmVzc2lvbiB0eXBlICIrbiwxKSxudWxsLCExKSwobT13PDA/bmV3IGUoeSk6bmV3IGUoeSx3LEIpKS5vbmRhdGE9ZnVuY3Rpb24oZSx0LEEpe3Yub25kYXRhKGUsdCxBKX07Zm9yKHZhciB0PTAscj1nO3Q8ci5sZW5ndGg7dCsrKXt2YXIgcz1yW3RdO20ucHVzaChzLCExKX1BLmtbMF09PWcmJkEuYz9BLmQ9bTptLnB1c2goRywhMCl9ZWxzZSB2Lm9uZGF0YShudWxsLEcsITApfSx0ZXJtaW5hdGU6ZnVuY3Rpb24oKXttJiZtLnRlcm1pbmF0ZSYmbS50ZXJtaW5hdGUoKX19O3c+PTAmJih2LnNpemU9dyx2Lm9yaWdpbmFsU2l6ZT1CKSxmLm9uZmlsZSh2KX1yZXR1cm4iYnJlYWsifWlmKHUpe2lmKDEzNDY5NTc2MD09dClyZXR1cm4gYT1vKz0xMisoLTI9PXUmJjgpLGk9MyxmLmM9MCwiYnJlYWsiO2lmKDMzNjM5MjQ4PT10KXJldHVybiBhPW8tPTQsaT0zLGYuYz0wLCJicmVhayJ9fSxmPXRoaXM7bzxjLTQmJiJicmVhayIhPT1kKCk7KytvKTtpZih0aGlzLnA9Ryx1PDApe3ZhciBwPWk/bC5zdWJhcnJheSgwLGEtMTItKC0yPT11JiY4KS0oMTM0Njk1NzYwPT1kZShsLGEtMTYpJiY0KSk6bC5zdWJhcnJheSgwLG8pO2g/aC5wdXNoKHAsISFpKTp0aGlzLmtbKygyPT1pKV0ucHVzaChwKX1pZigyJmkpcmV0dXJuIHRoaXMucHVzaChsLnN1YmFycmF5KG8pLHQpO3RoaXMucD1sLnN1YmFycmF5KG8pfXQmJih0aGlzLmMmJk4oMTMpLHRoaXMucD1udWxsKX0sZS5wcm90b3R5cGUucmVnaXN0ZXI9ZnVuY3Rpb24oZSl7dGhpcy5vW2UuY29tcHJlc3Npb25dPWV9LGV9KCksQ3Q9ImZ1bmN0aW9uIj09dHlwZW9mIHF1ZXVlTWljcm90YXNrP3F1ZXVlTWljcm90YXNrOiJmdW5jdGlvbiI9PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6ZnVuY3Rpb24oZSl7ZSgpfTtmdW5jdGlvbiBfdChlLHQsQSl7QXx8KEE9dCx0PXt9KSwiZnVuY3Rpb24iIT10eXBlb2YgQSYmTig3KTt2YXIgcj1bXSxzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPTA7ZTxyLmxlbmd0aDsrK2UpcltlXSgpfSxpPXt9LG89ZnVuY3Rpb24oZSx0KXtDdChmdW5jdGlvbigpe0EoZSx0KX0pfTtDdChmdW5jdGlvbigpe289QX0pO2Zvcih2YXIgYT1lLmxlbmd0aC0yMjsxMDEwMTAyNTYhPWRlKGUsYSk7LS1hKWlmKCFhfHxlLmxlbmd0aC1hPjY1NTU4KXJldHVybiBvKE4oMTMsMCwxKSxudWxsKSxzO3ZhciBsPWhlKGUsYSs4KTtpZihsKXt2YXIgYz1sLHU9ZGUoZSxhKzE2KSxoPTQyOTQ5NjcyOTU9PXV8fDY1NTM1PT1jO2lmKGgpe3ZhciBkPWRlKGUsYS0xMik7KGg9MTAxMDc1NzkyPT1kZShlLGQpKSYmKGM9bD1kZShlLGQrMzIpLHU9ZGUoZSxkKzQ4KSl9Zm9yKHZhciBmPXQmJnQuZmlsdGVyLHA9ZnVuY3Rpb24odCl7dmFyIEE9YXQoZSx1LGgpLGE9QVswXSxjPUFbMV0sZD1BWzJdLHA9QVszXSxnPUFbNF0sbT1BWzVdLHc9b3QoZSxtKTt1PWc7dmFyIEI9ZnVuY3Rpb24oZSx0KXtlPyhzKCksbyhlLG51bGwpKToodCYmKGlbcF09dCksLS1sfHxvKG51bGwsaSkpfTtpZighZnx8Zih7bmFtZTpwLHNpemU6YyxvcmlnaW5hbFNpemU6ZCxjb21wcmVzc2lvbjphfSkpaWYoYSlpZig4PT1hKXt2YXIgeT1lLnN1YmFycmF5KHcsdytjKTtpZihkPDUyNDI4OHx8Yz4uOCpkKXRyeXtCKG51bGwsRWUoeSx7b3V0Om5ldyBuKGQpfSkpfWNhdGNoKGUpe0IoZSxudWxsKX1lbHNlIHIucHVzaChVZSh5LHtzaXplOmR9LEIpKX1lbHNlIEIoTigxNCwidW5rbm93biBjb21wcmVzc2lvbiB0eXBlICIrYSwxKSxudWxsKTtlbHNlIEIobnVsbCxTKGUsdyx3K2MpKTtlbHNlIEIobnVsbCxudWxsKX0sZz0wO2c8YzsrK2cpcCgpfWVsc2UgbyhudWxsLHt9KTtyZXR1cm4gc31mdW5jdGlvbiBqdChlLHQpe2Zvcih2YXIgQT17fSxyPWUubGVuZ3RoLTIyOzEwMTAxMDI1NiE9ZGUoZSxyKTstLXIpKCFyfHxlLmxlbmd0aC1yPjY1NTU4KSYmTigxMyk7dmFyIHM9aGUoZSxyKzgpO2lmKCFzKXJldHVybnt9O3ZhciBpPWRlKGUscisxNiksbz00Mjk0OTY3Mjk1PT1pfHw2NTUzNT09cztpZihvKXt2YXIgYT1kZShlLHItMTIpOyhvPTEwMTA3NTc5Mj09ZGUoZSxhKSkmJihzPWRlKGUsYSszMiksaT1kZShlLGErNDgpKX1mb3IodmFyIGw9dCYmdC5maWx0ZXIsYz0wO2M8czsrK2Mpe3ZhciB1PWF0KGUsaSxvKSxoPXVbMF0sZD11WzFdLGY9dVsyXSxwPXVbM10sZz11WzRdLG09dVs1XSx3PW90KGUsbSk7aT1nLGwmJiFsKHtuYW1lOnAsc2l6ZTpkLG9yaWdpbmFsU2l6ZTpmLGNvbXByZXNzaW9uOmh9KXx8KGg/OD09aD9BW3BdPUVlKGUuc3ViYXJyYXkodyx3K2QpLHtvdXQ6bmV3IG4oZil9KTpOKDE0LCJ1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgIitoKTpBW3BdPVMoZSx3LHcrZCkpfXJldHVybiBBfX0sIi4vbm9kZV9tb2R1bGVzL2h0bWwyY2FudmFzL2Rpc3QvaHRtbDJjYW52YXMuanMiOmZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1mdW5jdGlvbigpeyJ1c2Ugc3RyaWN0Ijt2YXIgZT1mdW5jdGlvbih0LEEpe3JldHVybiBlPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgQSBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LEEpJiYoZVtBXT10W0FdKX0sZSh0LEEpfTtmdW5jdGlvbiB0KHQsQSl7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIEEmJm51bGwhPT1BKXRocm93IG5ldyBUeXBlRXJyb3IoIkNsYXNzIGV4dGVuZHMgdmFsdWUgIitTdHJpbmcoQSkrIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsIik7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9dH1lKHQsQSksdC5wcm90b3R5cGU9bnVsbD09PUE/T2JqZWN0LmNyZWF0ZShBKTooci5wcm90b3R5cGU9QS5wcm90b3R5cGUsbmV3IHIpfXZhciBBPWZ1bmN0aW9uKCl7cmV0dXJuIEE9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LEE9MSxyPWFyZ3VtZW50cy5sZW5ndGg7QTxyO0ErKylmb3IodmFyIG4gaW4gdD1hcmd1bWVudHNbQV0pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO3JldHVybiBlfSxBLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZnVuY3Rpb24gcihlLHQsQSxyKXtyZXR1cm4gbmV3KEF8fChBPVByb21pc2UpKShmdW5jdGlvbihuLHMpe2Z1bmN0aW9uIGkoZSl7dHJ5e2Eoci5uZXh0KGUpKX1jYXRjaChlKXtzKGUpfX1mdW5jdGlvbiBvKGUpe3RyeXthKHIudGhyb3coZSkpfWNhdGNoKGUpe3MoZSl9fWZ1bmN0aW9uIGEoZSl7dmFyIHQ7ZS5kb25lP24oZS52YWx1ZSk6KHQ9ZS52YWx1ZSx0IGluc3RhbmNlb2YgQT90Om5ldyBBKGZ1bmN0aW9uKGUpe2UodCl9KSkudGhlbihpLG8pfWEoKHI9ci5hcHBseShlLHR8fFtdKSkubmV4dCgpKX0pfWZ1bmN0aW9uIG4oZSx0KXt2YXIgQSxyLG4scyxpPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJm5bMF0pdGhyb3cgblsxXTtyZXR1cm4gblsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBzPXtuZXh0Om8oMCksdGhyb3c6bygxKSxyZXR1cm46bygyKX0sImZ1bmN0aW9uIj09dHlwZW9mIFN5bWJvbCYmKHNbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSkscztmdW5jdGlvbiBvKHMpe3JldHVybiBmdW5jdGlvbihvKXtyZXR1cm4gZnVuY3Rpb24ocyl7aWYoQSl0aHJvdyBuZXcgVHlwZUVycm9yKCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuIik7Zm9yKDtpOyl0cnl7aWYoQT0xLHImJihuPTImc1swXT9yLnJldHVybjpzWzBdP3IudGhyb3d8fCgobj1yLnJldHVybikmJm4uY2FsbChyKSwwKTpyLm5leHQpJiYhKG49bi5jYWxsKHIsc1sxXSkpLmRvbmUpcmV0dXJuIG47c3dpdGNoKHI9MCxuJiYocz1bMiZzWzBdLG4udmFsdWVdKSxzWzBdKXtjYXNlIDA6Y2FzZSAxOm49czticmVhaztjYXNlIDQ6cmV0dXJuIGkubGFiZWwrKyx7dmFsdWU6c1sxXSxkb25lOiExfTtjYXNlIDU6aS5sYWJlbCsrLHI9c1sxXSxzPVswXTtjb250aW51ZTtjYXNlIDc6cz1pLm9wcy5wb3AoKSxpLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKChuPShuPWkudHJ5cykubGVuZ3RoPjAmJm5bbi5sZW5ndGgtMV0pfHw2IT09c1swXSYmMiE9PXNbMF0pKXtpPTA7Y29udGludWV9aWYoMz09PXNbMF0mJighbnx8c1sxXT5uWzBdJiZzWzFdPG5bM10pKXtpLmxhYmVsPXNbMV07YnJlYWt9aWYoNj09PXNbMF0mJmkubGFiZWw8blsxXSl7aS5sYWJlbD1uWzFdLG49czticmVha31pZihuJiZpLmxhYmVsPG5bMl0pe2kubGFiZWw9blsyXSxpLm9wcy5wdXNoKHMpO2JyZWFrfW5bMl0mJmkub3BzLnBvcCgpLGkudHJ5cy5wb3AoKTtjb250aW51ZX1zPXQuY2FsbChlLGkpfWNhdGNoKGUpe3M9WzYsZV0scj0wfWZpbmFsbHl7QT1uPTB9aWYoNSZzWzBdKXRocm93IHNbMV07cmV0dXJue3ZhbHVlOnNbMF0/c1sxXTp2b2lkIDAsZG9uZTohMH19KFtzLG9dKX19fWZ1bmN0aW9uIHMoZSx0LEEpe2lmKEF8fDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgcixuPTAscz10Lmxlbmd0aDtuPHM7bisrKSFyJiZuIGluIHR8fChyfHwocj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LDAsbikpLHJbbl09dFtuXSk7cmV0dXJuIGUuY29uY2F0KHJ8fHQpfWZvcih2YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LEEscil7dGhpcy5sZWZ0PWUsdGhpcy50b3A9dCx0aGlzLndpZHRoPUEsdGhpcy5oZWlnaHQ9cn1yZXR1cm4gZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsQSxyLG4pe3JldHVybiBuZXcgZSh0aGlzLmxlZnQrdCx0aGlzLnRvcCtBLHRoaXMud2lkdGgrcix0aGlzLmhlaWdodCtuKX0sZS5mcm9tQ2xpZW50UmVjdD1mdW5jdGlvbih0LEEpe3JldHVybiBuZXcgZShBLmxlZnQrdC53aW5kb3dCb3VuZHMubGVmdCxBLnRvcCt0LndpbmRvd0JvdW5kcy50b3AsQS53aWR0aCxBLmhlaWdodCl9LGUuZnJvbURPTVJlY3RMaXN0PWZ1bmN0aW9uKHQsQSl7dmFyIHI9QXJyYXkuZnJvbShBKS5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiAwIT09ZS53aWR0aH0pO3JldHVybiByP25ldyBlKHIubGVmdCt0LndpbmRvd0JvdW5kcy5sZWZ0LHIudG9wK3Qud2luZG93Qm91bmRzLnRvcCxyLndpZHRoLHIuaGVpZ2h0KTplLkVNUFRZfSxlLkVNUFRZPW5ldyBlKDAsMCwwLDApLGV9KCksbz1mdW5jdGlvbihlLHQpe3JldHVybiBpLmZyb21DbGllbnRSZWN0KGUsdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSl9LGE9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLEE9MCxyPWUubGVuZ3RoO0E8cjspe3ZhciBuPWUuY2hhckNvZGVBdChBKyspO2lmKG4+PTU1Mjk2JiZuPD01NjMxOSYmQTxyKXt2YXIgcz1lLmNoYXJDb2RlQXQoQSsrKTs1NjMyMD09KDY0NTEyJnMpP3QucHVzaCgoKDEwMjMmbik8PDEwKSsoMTAyMyZzKSs2NTUzNik6KHQucHVzaChuKSxBLS0pfWVsc2UgdC5wdXNoKG4pfXJldHVybiB0fSxsPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO2lmKFN0cmluZy5mcm9tQ29kZVBvaW50KXJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShTdHJpbmcsZSk7dmFyIEE9ZS5sZW5ndGg7aWYoIUEpcmV0dXJuIiI7Zm9yKHZhciByPVtdLG49LTEscz0iIjsrK248QTspe3ZhciBpPWVbbl07aTw9NjU1MzU/ci5wdXNoKGkpOihpLT02NTUzNixyLnB1c2goNTUyOTYrKGk+PjEwKSxpJTEwMjQrNTYzMjApKSwobisxPT09QXx8ci5sZW5ndGg+MTYzODQpJiYocys9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsciksci5sZW5ndGg9MCl9cmV0dXJuIHN9LGM9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLHU9InVuZGVmaW5lZCI9PXR5cGVvZiBVaW50OEFycmF5P1tdOm5ldyBVaW50OEFycmF5KDI1NiksaD0wO2g8NjQ7aCsrKXVbYy5jaGFyQ29kZUF0KGgpXT1oO2Zvcih2YXIgZD0iQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyIsZj0idW5kZWZpbmVkIj09dHlwZW9mIFVpbnQ4QXJyYXk/W106bmV3IFVpbnQ4QXJyYXkoMjU2KSxwPTA7cDw2NDtwKyspZltkLmNoYXJDb2RlQXQocCldPXA7Zm9yKHZhciBnPWZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gZS5zbGljZT9lLnNsaWNlKHQsQSk6bmV3IFVpbnQxNkFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUsdCxBKSl9LG09ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxBLHIsbixzKXt0aGlzLmluaXRpYWxWYWx1ZT1lLHRoaXMuZXJyb3JWYWx1ZT10LHRoaXMuaGlnaFN0YXJ0PUEsdGhpcy5oaWdoVmFsdWVJbmRleD1yLHRoaXMuaW5kZXg9bix0aGlzLmRhdGE9c31yZXR1cm4gZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUpe3ZhciB0O2lmKGU+PTApe2lmKGU8NTUyOTZ8fGU+NTYzMTkmJmU8PTY1NTM1KXJldHVybiB0PSgodD10aGlzLmluZGV4W2U+PjVdKTw8MikrKDMxJmUpLHRoaXMuZGF0YVt0XTtpZihlPD02NTUzNSlyZXR1cm4gdD0oKHQ9dGhpcy5pbmRleFsyMDQ4KyhlLTU1Mjk2Pj41KV0pPDwyKSsoMzEmZSksdGhpcy5kYXRhW3RdO2lmKGU8dGhpcy5oaWdoU3RhcnQpcmV0dXJuIHQ9MjA4MCsoZT4+MTEpLHQ9dGhpcy5pbmRleFt0XSx0Kz1lPj41JjYzLHQ9KCh0PXRoaXMuaW5kZXhbdF0pPDwyKSsoMzEmZSksdGhpcy5kYXRhW3RdO2lmKGU8PTExMTQxMTEpcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmhpZ2hWYWx1ZUluZGV4XX1yZXR1cm4gdGhpcy5lcnJvclZhbHVlfSxlfSgpLHc9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLEI9InVuZGVmaW5lZCI9PXR5cGVvZiBVaW50OEFycmF5P1tdOm5ldyBVaW50OEFycmF5KDI1NikseT0wO3k8NjQ7eSsrKUJbdy5jaGFyQ29kZUF0KHkpXT15O3ZhciB2PTEwLGI9MTMsQz0xNSxfPTE3LGo9MTgseD0xOSxGPTIwLFE9MjEsVT0yMixFPTI0LFM9MjUsTD0yNixJPTI3LE49Mjgsaz0zMCxIPTMyLFA9MzMsVD0zNCxPPTM1LE09MzcsRD0zOCxSPTM5LEs9NDAsVj00MixHPVs5MDAxLDY1Mjg4XSx6PSLDlyIscT0iw7ciLFc9ZnVuY3Rpb24oZSl7dmFyIHQsQSxyLG49ZnVuY3Rpb24oZSl7dmFyIHQsQSxyLG4scyxpPS43NSplLmxlbmd0aCxvPWUubGVuZ3RoLGE9MDsiPSI9PT1lW2UubGVuZ3RoLTFdJiYoaS0tLCI9Ij09PWVbZS5sZW5ndGgtMl0mJmktLSk7dmFyIGw9InVuZGVmaW5lZCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmInVuZGVmaW5lZCIhPXR5cGVvZiBVaW50OEFycmF5JiZ2b2lkIDAhPT1VaW50OEFycmF5LnByb3RvdHlwZS5zbGljZT9uZXcgQXJyYXlCdWZmZXIoaSk6bmV3IEFycmF5KGkpLGM9QXJyYXkuaXNBcnJheShsKT9sOm5ldyBVaW50OEFycmF5KGwpO2Zvcih0PTA7dDxvO3QrPTQpQT1mW2UuY2hhckNvZGVBdCh0KV0scj1mW2UuY2hhckNvZGVBdCh0KzEpXSxuPWZbZS5jaGFyQ29kZUF0KHQrMildLHM9ZltlLmNoYXJDb2RlQXQodCszKV0sY1thKytdPUE8PDJ8cj4+NCxjW2ErK109KDE1JnIpPDw0fG4+PjIsY1thKytdPSgzJm4pPDw2fDYzJnM7cmV0dXJuIGx9KGUpLHM9QXJyYXkuaXNBcnJheShuKT9mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5sZW5ndGgsQT1bXSxyPTA7cjx0O3IrPTQpQS5wdXNoKGVbciszXTw8MjR8ZVtyKzJdPDwxNnxlW3IrMV08PDh8ZVtyXSk7cmV0dXJuIEF9KG4pOm5ldyBVaW50MzJBcnJheShuKSxpPUFycmF5LmlzQXJyYXkobik/ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUubGVuZ3RoLEE9W10scj0wO3I8dDtyKz0yKUEucHVzaChlW3IrMV08PDh8ZVtyXSk7cmV0dXJuIEF9KG4pOm5ldyBVaW50MTZBcnJheShuKSxvPWcoaSwxMixzWzRdLzIpLGE9Mj09PXNbNV0/ZyhpLCgyNCtzWzRdKS8yKToodD1zLEE9TWF0aC5jZWlsKCgyNCtzWzRdKS80KSx0LnNsaWNlP3Quc2xpY2UoQSxyKTpuZXcgVWludDMyQXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCxBLHIpKSk7cmV0dXJuIG5ldyBtKHNbMF0sc1sxXSxzWzJdLHNbM10sbyxhKX0oIkt3QUFBQUFBQUFBQUNBNEFVRDBBQURBZ0FBQUNBQUFBQUFBSUFCQUFHQUJBQUVnQVVBQllBR0FBYUFCZ0FHZ0FZZ0JxQUY4QVp3QmdBR2dBY1FCNUFIVUFmUUNGQUkwQWxRQ2RBS0lBcWdDeUFMb0FZQUJvQUdBQWFBQmdBR2dBd2dES0FHQUFhQURHQU00QTB3RGJBT0VBNlFEeEFQa0FBUUVKQVE4QkZ3RjFBSDBBSEFFa0FTd0JOQUU2QVVJQlFRRkpBVkVCV1FGaEFXZ0JjQUY0QVRBQWdBR0dBWTRCbFFHWEFaOEJwd0d2QWJVQnZRSEZBYzBCMHdIYkFlTUI2d0h4QWZrQkFRSUpBdkVCRVFJWkFpRUNLUUl4QWpnQ1FBSkdBazRDVmdKZUFtUUNiQUowQW53Q2dRS0pBcEVDbVFLZ0FxZ0NzQUs0QXJ3Q3hBSXdBTXdDMHdMYkFqQUE0d0xyQXZNQytBSUFBd2NERHdNd0FCY0RIUU1sQXkwRE5RTjFBRDBEUVFOSkEwa0RTUU5SQTFFRFZ3TlpBMWtEZFFCMUFHRURkUUJwQTIwRGRRTjFBSHNEZFFDQkE0a0RrUU4xQUhVQW1RT2hBM1VBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBS1lEcmdOMUFIVUF0Z08rQThZRHpnUFdBeGNEM2dQakErc0Q4d04xQUhVQSt3TURCQWtFZFFBTkJCVUVIUVFsQkNvRUZ3TXlCRGdFWUFCQUJCY0RTQVJRQkZnRVlBUm9CREFBY0FRekFYZ0VnQVNJQkpBRWRRQ1hCSFVBbndTbkJLNEV0Z1M2Qk1JRXlBUjFBSFVBZFFCMUFIVUFkUUNWQU5BRVlBQmdBR0FBWUFCZ0FHQUFZQUJnQU5nRVlBRGNCT1FFWUFEc0JQUUUvQVFFQlF3RkZBVWNCU1FGTEFVMEJXUUVQQVZFQlVzRlV3VmJCV0FBWWdWZ0FHb0ZjZ1Y2QllJRmlnV1JCV0FBbVFXZkJhWUZZQUJnQUdBQVlBQmdBS29GWUFDeEJiQUZ1UVc2QmNFRndRWEhCY0VGd1FYUEJkTUYyd1hqQmVvRjhnWDZCUUlHQ2dZU0Job0dJZ1lxQmpJR09nWmdBRDRHUmdaTUJtQUFVd1phQm1BQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0lHWUFCcEJuQUdZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFZQUI0Qm44R2hRWmdBR0FBWUFCMUFIY0RGUVNMQm1BQVlBQmdBSk1HZFFBOUEzVUFtd2FqQnFzR3F3YVZBTE1HdXdiREJqQUF5d2JTQnRJRzFRYlNCdElHMGdiU0J0SUcwZ2JkQnVNRzZ3YnpCdnNHQXdjTEJ4TUhBd2NiQnlNSEp3Y3NCeXdITVFjc0I5SUdPQWRBQjBnSFRnZlNCa2dIVmdmU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0Jpd0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFkZ0FHQUFMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFkYkIyTUhMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0Iya0gwZ1p3QjY0RWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVSGZRZGdBSVVIalFkMUFIVUFsUWVkQjJBQVlBQ2xCNnNIWUFDekI3WUh2Z2ZHQjNVQXpnZldCek1CM2dmbUIxRUI3Z2YxQi8wSGxRRU5BUVVJRFFoMUFCVUlIUWdsQ0JjRExRZzFDRDBJUlFoTkNFRURVd2gxQUhVQWRRQmJDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJYVFoakNHUUlaUWhtQ0djSWFBaHBDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJYVFoakNHUUlaUWhtQ0djSWFBaHBDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJYVFoakNHUUlaUWhtQ0djSWFBaHBDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJYVFoakNHUUlaUWhtQ0djSWFBaHBDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWFRaGpDR1FJWlFobUNHY0lhQWhwQ0dNSVpBaGxDR1lJWndob0NHa0lZd2hrQ0dVSVpnaG5DR2dJYVFoakNHUUlaUWhtQ0djSWFBaHBDR01JWkFobENHWUlad2hvQ0drSVl3aGtDR1VJWmdobkNHZ0lhUWhqQ0dRSVpRaG1DR2NJYUFocENHTUlaQWhsQ0dZSVp3aG9DR2tJWXdoa0NHVUlaZ2huQ0dnSWNBaDNDSG9JTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QUlJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dnd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQjRvSUxBY3NCNDRJMGdhV0NKNElwZ2gxQUhVQXFnaXlDSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBdHdoOEFYVUF2d2gxQU1VSXlRalJDTmtJNEFqb0NIVUFkUUIxQU80STlnaitDQVlKRGdrVENTMEhHd2tqQ1lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQUFJQUFBQUZBQVlBQmdBR0lBWHdCZ0FIRUFkUUJGQUpVQW9nQ3lBS0FBWUFCZ0FFSUE0QUJHQU5NQTRRRHhBTUVCRHdFMUFGd0JMQUU2QVFFQlVRRjRRa2hDbUVLb1FyaENnQUhJUXNBQjBNTEFBY0FCd0FIQUFlREM2QUJvQUhEQ3dNTUFBY0FCd0FIQUFkRERHTU1BQWNBQjZNTTR3d2pEV01Ob3czakRhQUJvQUdnQWFBQm9BR2dBYUFCb0FHZ0FhQUJvQUdnQWFBQm9BR2dBYUFCb0FHZ0FhQUJvQUVqRHFBQld3NmJEcUFCcGc2Z0FhQUJvQUhjRHZ3T1BBK2dBYUFCZkEvOER2d08vQTc4RHZ3Ty9BNzhEdndPL0E3OER2d08vQTc4RHZ3Ty9BNzhEdndPL0E3OER2d08vQTc4RHZ3Ty9BNzhEdndPL0E3OERwY1BBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCOWNQS3dreUNUb0pNQUIxQUhVQWRRQkNDVW9KVFFsMUFGVUpYQWxqQ1djSmF3a3dBREFBTUFBd0FITUpkUUIyQ1g0SmRRQ0VDWW9KamdtV0NYVUFuZ2t3QUdBQVlBQnhBSFVBcGduM0E2NEp0QWwxQUxrSmRRREFDVEFBTUFBd0FEQUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFvd1lOQk1VSU1BQXdBREFBTUFESUNjc0owd25aQ1JVRTRRa3dBT2tKOEFuNENUQUFNQUIxQUFBS3Z3aDFBQWdLRHdvWENoOEtkUUF3QUNjS0xncDFBRFlLcUFtSUNUNEtSZ293QURBQWRRQjFBRTRLTUFCMUFGWUtkUUJlQ25VQVpRb3dBREFBTUFBd0FEQUFNQUF3QURBQU1BQVZCSFVBYlFvd0FEQUFkUUM1Q1hVS01BQXdBSHdCeEFpakJvZ0VNZ0Y5Q29RS2lBU01DcFFLbWdxSUJLSUtxZ3F1Q29nRURRRzJDcjRLeGdyTENqQUFNQURUQ3RzS0NnSGpDdXNLOFFyNUNnRUxNQUF3QURBQU1BQjFBSXNFQ1FzUkMzVUFOQUVaQ3pBQU1BQXdBREFBTUFCMUFDRUxLUXN3QUhVQU5BRXhDemtMZFFCQkMwa0xNQUJSQzFrTE1BQXdBREFBTUFBd0FEQUFkUUJoQ3pBQU1BQXdBR0FBWUFCcEMzRUxkd3QvQ3pBQU1BQ0hDNHNMa3d1YkM1OExwd3QxQUs0THRndDFBUHNETUFBd0FEQUFNQUF3QURBQU1BQXdBTDRMd3d2TEM5SUwxd3ZkQ3pBQU1BRGxDK2tMOFF2NUMvOExTUXN3QURBQU1BQXdBREFBTUFBd0FEQUFNQUFIRERBQU1BQXdBREFBTUFBT0RCWU1IZ3gxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUNZTU1BQXdBREFBZFFCMUFIVUFMZ3gxQUhVQWRRQjFBSFVBZFFBMkREQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUQ0TWRRQkdESFVBZFFCMUFIVUFkUUIxQUVrTWRRQjFBSFVBZFFCMUFGQU1NQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUJZREhVQWRRQjFBRjhNTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUErd01WQkdjTU1BQXdBSHdCYnd4MUFIY01md3lIREk4TU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBWUFCZ0FKY01NQUF3QURBQWRRQjFBSjhNbFFDbEREQUFNQUN0REN3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQjdVTUxBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hkUUIxQUhVQWRRQjFBSFVBZFFCMUFIVUFkUUIxQUhVQWRRQjFBQTBFTUFDOUREQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXNCeXdITEFjc0J5d0hMQWNzQnl3SExRY3dBTUVNeUF3c0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0h6QXd3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBSFVBZFFCMUFOUU0yUXpoRERBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUJnQUdBQVlBQmdBR0FBWUFCZ0FPa01ZQUR4REdBQStBd0FEUVlOWUFCaENXQUFZQUFPRFRBQU1BQXdBREFBRmcxZ0FHQUFIZzM3QXpBQU1BQXdBREFBWUFCZ0FDWU5ZQUFzRFRRTlBBMWdBRU1OUGcxTERXQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFVZzFhRFlzR1ZnbGhEVjBOY1FCbkRXME5kUTE1RFdBQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFsUUNCRFpVQWlBMlBEWmNOTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQW53Mm5EVEFBTUFBd0FEQUFNQUF3QUhVQXJ3MjNEVEFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFCMUFMOE5NQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQjFBSFVBZFFCMUFIVUFkUURIRFRBQVlBQmdBTThOTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQTF3MTFBTndOTUFBd0FEMEI1QTB3QURBQU1BQXdBREFBTUFEc0RmUU4vQTBFRGd3T0ZBNHdBQnNPTUFBd0FEQUFNQUF3QURBQU1BQXdBTklHMGdiU0J0SUcwZ2JTQnRJRzBnWWpEaWdPd1FVdURzRUZNdzdTQmpvTzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHUWc1S0RsSU9WZzdTQnRJR1hnNWxEbTBPZFE3U0J0SUdmUTZFRG9vT2pRNlVEdElHbWc2aER0SUcwZ2FvRHF3TzBnYTBEcndPMGdaZ0FHQUFZQURFRG1BQVlBQWtCdElHekE1Z0FOSU9ZQURhRG9rTzBnYlNCdDhPNXc3U0J1OE8wZ2IxRHZ3TzBnWmdBR0FBeEE3U0J0SUcwZ2JTQnRJR1lBQmdBR0FBWUFBRUQyQUFzQVVNRDlJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHRkE4c0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjY0Q5SUdMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SEpBOHNCeXdITEFjc0J5d0hMQWNjRHl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3UExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjMEQ5SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUdMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjY0Q5SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUdGQThzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hMQWNzQnl3SExBY3NCeXdITEFjc0J5d0hQQS9TQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ2JTQnRJRzBnYlNCdElHMGdiU0J0SUcwZ1lVRDBRUGxRQ1ZBSlVBTUFBd0FEQUFNQUNWQUpVQWxRQ1ZBSlVBbFFDVkFFd1BNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQS8vOEVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQU5BQU1BQVFBQkFBSUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFDZ0FUQUJjQUhnQWJBQm9BSGdBWEFCWUFFZ0FlQUJzQUdBQVBBQmdBSEFCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFCZ0FHQUFlQUI0QUhnQVRBQjRBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQllBR3dBU0FCNEFIZ0FlQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFXQUEwQUVRQWVBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFBUUFCQUFFQUFRQUJBQUZBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUpBQllBR2dBYkFCc0FHd0FlQUIwQUhRQWVBRThBRndBZUFBMEFIZ0FlQUJvQUd3QlBBRThBRGdCUUFCMEFIUUFkQUU4QVR3QVhBRThBVHdCUEFCWUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQjBBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FkQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBRkFBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBZUFCNEFIZ0FlQUZBQVR3QkFBRThBVHdCUEFFQUFUd0JRQUZBQVR3QlFBQjRBSGdBZUFCNEFIZ0FlQUIwQUhRQWRBQjBBSGdBZEFCNEFEZ0JRQUZBQVVBQlFBRkFBSGdBZUFCNEFIZ0FlQUI0QUhnQlFBQjRBVUFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFKQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQWtBQ1FBSkFBa0FDUUFKQUFrQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBZUFCNEFIZ0FlQUZBQUhnQWVBQjRBS3dBckFGQUFVQUJRQUZBQUdBQlFBQ3NBS3dBckFDc0FIZ0FlQUZBQUhnQlFBRkFBVUFBckFGQUFLd0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUt3QWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFCQUFFQUFRQUJBQUVBQVFBQkFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FVQUFlQUI0QUhnQWVBQjRBSGdCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQVlBQTBBS3dBckFCNEFIZ0FiQUNzQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQURRQUVBQjRBQkFBRUFCNEFCQUFFQUJNQUJBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQVZnQldBRllBVmdCV0FGWUFWZ0JXQUZZQVZnQldBRllBVmdCV0FGWUFWZ0JXQUZZQVZnQldBRllBVmdCV0FGWUFWZ0JXQUZZQUt3QXJBQ3NBS3dCV0FGWUFWZ0JXQUI0QUhnQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBR2dBYUFCb0FHQUFZQUI0QUhnQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBRXdBRUFDc0FFd0FUQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBQm9BR1FBWkFCNEFVQUJRQUFRQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFCTUFVQUFFQUFRQUJBQUVBQVFBQkFBRUFCNEFIZ0FFQUFRQUJBQUVBQVFBQkFCUUFGQUFCQUFFQUI0QUJBQUVBQVFBQkFCUUFGQUFTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JRQUZBQVVBQWVBQjRBVUFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUt3QWVBRkFBQkFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBRkFBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFVQUJRQUI0QUhnQVlBQk1BVUFBckFDc0FCQUFiQUJzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUZBQUJBQUVBQVFBQkFBRUFGQUFCQUFFQUFRQVVBQUVBQVFBQkFBRUFBUUFLd0FyQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFyQUNzQUhnQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQjRBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFRQUJBQUVBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBVUFBRUFBUUFCQUFFQUFRQUJBQUVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFBMEFEUUJMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUI0QVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBVUFCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFBckFDc0FLd0JRQUZBQVVBQlFBQ3NBS3dBRUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBckFDc0FCQUFFQUNzQUt3QUVBQVFBQkFCUUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBRUFDc0FLd0FyQUNzQVVBQlFBQ3NBVUFCUUFGQUFCQUFFQUNzQUt3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRkFBVUFBYUFCb0FVQUJRQUZBQVVBQlFBRXdBSGdBYkFGQUFIZ0FFQUNzQUt3QUVBQVFBQkFBckFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FVQUJRQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUJRQUNzQVVBQlFBQ3NBVUFCUUFDc0FLd0FFQUNzQUJBQUVBQVFBQkFBRUFDc0FLd0FyQUNzQUJBQUVBQ3NBS3dBRUFBUUFCQUFyQUNzQUt3QUVBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFBckFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFBUUFCQUJRQUZBQVVBQUVBQjRBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBRUFBUUFCQUFyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBQ3NBVUFCUUFGQUFVQUJRQUNzQUt3QUVBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQ3NBQkFBRUFBUUFLd0FFQUFRQUJBQXJBQ3NBVUFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBQkFBRUFDc0FLd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUI0QUd3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQUJBQUVBQVFBQkFBRUFBUUFLd0FFQUFRQUJBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBVUFCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQVFBQkFBRUFBUUFCQUFyQUNzQUJBQUVBQ3NBS3dBRUFBUUFCQUFyQUNzQUt3QXJBQ3NBS3dBckFBUUFCQUFFQUNzQUt3QXJBQ3NBVUFCUUFDc0FVQUJRQUZBQUJBQUVBQ3NBS3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFCNEFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFBUUFVQUFyQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUZBQVVBQlFBQ3NBVUFCUUFGQUFVQUFyQUNzQUt3QlFBRkFBS3dCUUFDc0FVQUJRQUNzQUt3QXJBRkFBVUFBckFDc0FLd0JRQUZBQVVBQXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQVFBQkFBRUFBUUFCQUFyQUNzQUt3QUVBQVFBQkFBckFBUUFCQUFFQUFRQUt3QXJBRkFBS3dBckFDc0FLd0FyQUNzQUJBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBVUFCUUFGQUFIZ0FlQUI0QUhnQWVBQjRBR3dBZUFDc0FLd0FyQUNzQUt3QUVBQVFBQkFBRUFBUUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUJRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUNzQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUNzQUJBQUVBQVFBS3dBRUFBUUFCQUFFQUNzQUt3QXJBQ3NBS3dBckFDc0FCQUFFQUNzQVVBQlFBRkFBS3dBckFDc0FLd0FyQUZBQVVBQUVBQVFBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QXJBQ3NBS3dBT0FGQUFVQUJRQUZBQVVBQlFBRkFBSGdCUUFBUUFCQUFFQUE0QVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQUt3QXJBQVFBVUFBRUFBUUFCQUFFQUFRQUJBQUVBQ3NBQkFBRUFBUUFLd0FFQUFRQUJBQUVBQ3NBS3dBckFDc0FLd0FyQUNzQUJBQUVBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQXJBRkFBVUFBRUFBUUFLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QlFBRkFBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FFQUFRQUJBQUVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQXJBQVFBQkFBRUFDc0FCQUFFQUFRQUJBQlFBQjRBS3dBckFDc0FLd0JRQUZBQVVBQUVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFDc0FLd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUJvQVVBQlFBRkFBVUFCUUFGQUFLd0FFQUFRQUJBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBRUFDc0FLd0FyQUNzQUJBQUVBQVFBQkFBRUFBUUFLd0FFQUNzQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUNzQUt3QXJBQ3NBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUFRQUJBQWVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQXFBRndBWEFBcUFDb0FLZ0FxQUNvQUtnQXFBQ3NBS3dBckFDc0FHd0JjQUZ3QVhBQmNBRndBWEFCY0FDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBZUFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FEUUFOQUNzQUt3QXJBQ3NBS3dCY0FGd0FLd0JjQUNzQVhBQmNBRndBWEFCY0FDc0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUNzQVhBQXJBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBS2dCY0FGd0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FYQUFyQUNzQVhBQmNBRndBWEFCY0FDc0FYQUFyQUNvQUtnQXFBQ29BS2dBcUFDc0FLd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUNzQUt3QmNBRndBWEFCY0FGQUFEZ0FPQUE0QURnQWVBQTRBRGdBSkFBNEFEZ0FOQUFrQUV3QVRBQk1BRXdBVEFBa0FIZ0FUQUI0QUhnQWVBQVFBQkFBZUFCNEFIZ0FlQUI0QUhnQkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBRFFBRUFCNEFCQUFlQUFRQUZnQVJBQllBRVFBRUFBUUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFDc0FLd0FFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBRFFBRUFBUUFCQUFFQUFRQURRQUVBQVFBVUFCUUFGQUFVQUJRQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQXJBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFyQUEwQURRQWVBQjRBSGdBZUFCNEFIZ0FFQUI0QUhnQWVBQjRBSGdBZUFDc0FIZ0FlQUE0QURnQU5BQTRBSGdBZUFCNEFIZ0FlQUFrQUNRQXJBQ3NBS3dBckFDc0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0JjQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQURRQU5BQjRBSGdBZUFCNEFYQUJjQUZ3QVhBQmNBRndBS2dBcUFDb0FLZ0JjQUZ3QVhBQmNBQ29BS2dBcUFGd0FLZ0FxQUNvQVhBQmNBQ29BS2dBcUFDb0FLZ0FxQUNvQVhBQmNBRndBS2dBcUFDb0FLZ0JjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFGd0FLZ0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUNvQUtnQXFBQ29BS2dBcUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFBckFDc0FLd0FyQUNzQVVBQXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBSGdCUUFGQUFVQUJRQUZnQVdBQllBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWkFGa0FXUUJaQUZrQVdRQlpBRmtBV1FCWkFGa0FXUUJaQUZrQVdRQlpBRmtBV1FCWkFGa0FXUUJaQUZrQVdRQlpBRmtBV1FCWkFGa0FXUUJaQUZrQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUJRQUZBQVVBQXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBS3dCUUFGQUFVQUJRQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFCUUFGQUFLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUZBQVVBQlFBRkFBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFDc0FVQUJRQUZBQVVBQXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QlFBRkFBVUFCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUJBQUVBQVFBSGdBTkFCNEFIZ0FlQUI0QUhnQWVBQjRBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUFyQUNzQURRQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFIZ0FlQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFOQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFXQUJFQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBMEFEUUFOQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUFRQUJBQUVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFOQUEwQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QlFBRkFBVUFBckFBUUFCQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFBMEFEUUFWQUZ3QURRQWVBQTBBR3dCY0FDb0FLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBZUFCNEFFd0FUQUEwQURRQU9BQjRBRXdBVEFCNEFCQUFFQUFRQUNRQXJBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQUVBQVFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQVFBVUFBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBckFDc0FLd0FyQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQ3NBS3dBckFDc0FIZ0FyQUNzQUt3QVRBQk1BU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFBckFDc0FYQUJjQUZ3QVhBQmNBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUFyQUNzQUt3QXJBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBQ3NBS3dBckFDc0FLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVhBQXJBQ3NBS3dBcUFDb0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQVFBQkFBRUFBUUFCQUFyQUNzQUhnQWVBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLd0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUt3QXJBQVFBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dBckFDc0FLd0FyQUNzQUt3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBQ3NBS3dBckFDc0FLd0FyQUNvQUtnQXFBQ29BS2dBcUFDb0FYQUFxQUNvQUtnQXFBQ29BS2dBckFDc0FCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUJBQUVBQVFBQkFBRUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBUUFCQUFFQUFRQUJBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQ3NBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dBTkFBMEFIZ0FOQUEwQURRQU5BQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dBckFDc0FCQUFFQUFRQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUJRQUZBQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBZUFCNEFIZ0FlQUZBQVVBQlFBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFDc0FLd0FyQUEwQURRQU5BQTBBRFFCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFDc0FLd0FyQUZBQVVBQlFBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUEwQURRQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QlFBRkFBVUFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dBckFDc0FLd0FyQUNzQUt3QXJBQVFBQkFBRUFCNEFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQlFBRkFBVUFCUUFBUUFVQUJRQUZBQVVBQlFBRkFBQkFCUUFGQUFCQUFFQUFRQVVBQXJBQ3NBS3dBckFDc0FCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFDc0FCQUFFQUFRQUJBQUVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0FyQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUNzQVVBQXJBRkFBS3dBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUNzQUt3QWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBckFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdCUUFCNEFIZ0FlQUZBQVVBQlFBQ3NBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdCUUFGQUFVQUJRQUNzQUt3QWVBQjRBSGdBZUFCNEFIZ0FyQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUt3QXJBRkFBVUFCUUFDc0FIZ0FlQUI0QUhnQWVBQjRBSGdBT0FCNEFLd0FOQUEwQURRQU5BQTBBRFFBTkFBa0FEUUFOQUEwQUNBQUVBQXNBQkFBRUFBMEFDUUFOQUEwQURBQWRBQjBBSGdBWEFCY0FGZ0FYQUJjQUZ3QVdBQmNBSFFBZEFCNEFIZ0FVQUJRQUZBQU5BQUVBQVFBRUFBUUFCQUFFQUFRQUNRQWFBQm9BR2dBYUFCb0FHZ0FhQUJvQUhnQVhBQmNBSFFBVkFCVUFIZ0FlQUI0QUhnQWVBQjRBR0FBV0FCRUFGUUFWQUJVQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBRFFBZUFBMEFEUUFOQUEwQUhnQU5BQTBBRFFBSEFCNEFIZ0FlQUI0QUt3QUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBRkFBVUFBckFDc0FUd0JRQUZBQVVBQlFBRkFBSGdBZUFCNEFGZ0FSQUU4QVVBQlBBRThBVHdCUEFGQUFVQUJRQUZBQVVBQWVBQjRBSGdBV0FCRUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFCc0FHd0FiQUJzQUd3QWJBQnNBR2dBYkFCc0FHd0FiQUJzQUd3QWJBQnNBR3dBYkFCc0FHd0FiQUJzQUdnQWJBQnNBR3dBYkFCb0FHd0FiQUJvQUd3QWJBQnNBR3dBYkFCc0FHd0FiQUJzQUd3QWJBQnNBR3dBYkFCc0FHd0FiQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFIZ0FlQUZBQUdnQWVBQjBBSGdCUUFCNEFHZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0JQQUI0QVVBQWJBQjRBSGdCUUFGQUFVQUJRQUZBQUhnQWVBQjRBSFFBZEFCNEFVQUFlQUZBQUhnQlFBQjRBVUFCUEFGQUFVQUFlQUI0QUhnQWVBQjRBSGdBZUFGQUFVQUJRQUZBQVVBQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUZBQUhnQlFBRkFBVUFCUUFFOEFUd0JRQUZBQVVBQlFBRkFBVHdCUUFGQUFUd0JRQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRkFBVUFCUUFGQUFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFlQUI0QVVBQlFBRkFBVUFCUEFCNEFIZ0FyQUNzQUt3QXJBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCMEFIZ0FkQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWRBQjRBSFFBZEFCNEFIZ0FlQUIwQUhRQWVBQjRBSFFBZUFCNEFIZ0FkQUI0QUhRQWJBQnNBSGdBZEFCNEFIZ0FlQUI0QUhRQWVBQjRBSFFBZEFCMEFIUUFlQUI0QUhRQWVBQjBBSGdBZEFCMEFIUUFkQUIwQUhRQWVBQjBBSGdBZUFCNEFIZ0FlQUIwQUhRQWRBQjBBSGdBZUFCNEFIZ0FkQUIwQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWRBQjRBSGdBZUFCMEFIZ0FlQUI0QUhnQWVBQjBBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FkQUIwQUhnQWVBQjBBSFFBZEFCMEFIZ0FlQUIwQUhRQWVBQjRBSFFBZEFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCMEFIUUFlQUI0QUhRQWRBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIUUFlQUI0QUhnQWRBQjRBSGdBZUFCNEFIZ0FlQUI0QUhRQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUIwQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFGQUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCWUFFUUFXQUJFQUhnQWVBQjRBSGdBZUFCNEFIUUFlQUI0QUhnQWVBQjRBSGdBZUFDVUFKUUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FXQUJFQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSlFBbEFDVUFKUUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0FkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUZBQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSGdBZUFCNEFIZ0FkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWVBQjRBSFFBZEFCMEFIUUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUIwQUhRQWVBQjBBSFFBZEFCMEFIUUFkQUIwQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUIwQUhRQWVBQjRBSFFBZEFCNEFIZ0FlQUI0QUhRQWRBQjRBSGdBZUFCNEFIUUFkQUIwQUhnQWVBQjBBSGdBZUFCMEFIUUFkQUIwQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FkQUIwQUhRQWRBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjBBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWxBQ1VBSlFBbEFCNEFIUUFkQUI0QUhnQWRBQjRBSGdBZUFCNEFIUUFkQUI0QUhnQWVBQjRBSlFBbEFCMEFIUUFsQUI0QUpRQWxBQ1VBSUFBbEFDVUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBbEFDVUFKUUFlQUI0QUhnQWVBQjBBSGdBZEFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FkQUIwQUhnQWRBQjBBSFFBZUFCMEFKUUFkQUIwQUhnQWRBQjBBSGdBZEFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQ1VBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIUUFkQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBZEFCMEFIUUFkQUNVQUhnQWxBQ1VBSlFBZEFDVUFKUUFkQUIwQUhRQWxBQ1VBSFFBZEFDVUFIUUFkQUNVQUpRQWxBQjRBSFFBZUFCNEFIZ0FlQUIwQUhRQWxBQjBBSFFBZEFCMEFIUUFkQUNVQUpRQWxBQ1VBSlFBZEFDVUFKUUFnQUNVQUhRQWRBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWVBQjRBSGdBbEFDVUFJQUFnQUNBQUlBQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUIwQUhnQWVBQjRBRndBWEFCY0FGd0FYQUJjQUhnQVRBQk1BSlFBZUFCNEFIZ0FXQUJFQUZnQVJBQllBRVFBV0FCRUFGZ0FSQUJZQUVRQVdBQkVBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQllBRVFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBV0FCRUFGZ0FSQUJZQUVRQVdBQkVBRmdBUkFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFGZ0FSQUJZQUVRQVdBQkVBRmdBUkFCWUFFUUFXQUJFQUZnQVJBQllBRVFBV0FCRUFGZ0FSQUJZQUVRQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQVdBQkVBRmdBUkFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFGZ0FSQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZEFCMEFIUUFkQUIwQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBckFDc0FIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFVQUJRQUZBQVVBQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FFQUFRQUJBQWVBQjRBS3dBckFDc0FLd0FyQUJNQURRQU5BQTBBVUFBVEFBMEFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQUt3QXJBQ3NBVUFBTkFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QUVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFBckFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUEwQURRQU5BQTBBRFFBTkFBMEFEUUFlQUEwQUZnQU5BQjRBSGdBWEFCY0FIZ0FlQUJjQUZ3QVdBQkVBRmdBUkFCWUFFUUFXQUJFQURRQU5BQTBBRFFBVEFGQUFEUUFOQUI0QURRQU5BQjRBSGdBZUFCNEFIZ0FNQUF3QURRQU5BQTBBSGdBTkFBMEFGZ0FOQUEwQURRQU5BQTBBRFFBTkFBMEFIZ0FOQUI0QURRQU5BQjRBSGdBZUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNzQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFyQUNzQUt3QXJBQTBBRVFBUkFDVUFKUUJIQUZjQVZ3QVdBQkVBRmdBUkFCWUFFUUFXQUJFQUZnQVJBQ1VBSlFBV0FCRUFGZ0FSQUJZQUVRQVdBQkVBRlFBV0FCRUFFUUFsQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUFRQUJBQUVBQVFBQkFBRUFDVUFWd0JYQUZjQVZ3QTJBQ1VBSlFCWEFGY0FWd0JIQUVjQUpRQWxBQ1VBS3dCUkFGY0FVUUJYQUZFQVZ3QlJBRmNBVVFCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRkVBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JSQUZjQVVRQlhBRkVBVndCWEFGY0FWd0JYQUZjQVVRQlhBRmNBVndCWEFGY0FWd0JSQUZFQUt3QXJBQVFBQkFBVkFCVUFSd0JIQUZjQUZRQlJBRmNBVVFCWEFGRUFWd0JSQUZjQVVRQlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZFQVZ3QlJBRmNBVVFCWEFGY0FWd0JYQUZjQVZ3QlJBRmNBVndCWEFGY0FWd0JYQUZFQVVRQlhBRmNBVndCWEFCVUFVUUJIQUVjQVZ3QXJBQ3NBS3dBckFDc0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FLd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQUt3QWxBQ1VBVndCWEFGY0FWd0FsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRkVBVVFCUkFGRUFVUUJSQUZFQVVRQlJBRkVBVVFCUkFGRUFVUUJSQUZFQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBckFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQlBBRThBVHdCUEFFOEFUd0JQQUU4QUpRQlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0FsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBQ1VBSlFBbEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUVjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FLd0FyQUNzQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQURRQVRBQTBBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBRkFBQkFBRUFBUUFCQUFlQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUhnQlFBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBVUFCUUFBUUFCQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBUUFCQUFlQUEwQURRQU5BQTBBRFFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFVQUFlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdCUUFCNEFIZ0FlQUI0QUhnQWVBRkFBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQXJBQ3NBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FlQUI0QVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQVFBVUFCUUFGQUFCQUJRQUZBQVVBQlFBQVFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFRQUJBQUVBQVFBQkFBZUFCNEFIZ0FlQUFRQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQUhnQWVBQm9BSGdBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBRGdBT0FCTUFFd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FCQUFFQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQVFBQkFBRUFBUUFCQUFFQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FOQUEwQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QXJBQ3NBS3dBckFDc0FLd0FFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUJRQUZBQVVBQlFBRkFBVUFBZUFCNEFIZ0JRQUE0QVVBQlFBQVFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUEwQURRQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUI0QVdBQllBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBRmdBV0FCWUFGZ0FXQUJZQUZnQVdBQllBQ3NBS3dBckFBUUFIZ0FlQUI0QUhnQWVBQjRBRFFBTkFBMEFIZ0FlQUI0QUhnQXJBRkFBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dBckFDc0FLd0FyQUI0QUhnQmNBRndBWEFCY0FGd0FLZ0JjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVhBQmNBRndBWEFCY0FDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFBUUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBUUFCQUFyQUNzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QXJBQ3NBSGdBTkFBMEFEUUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBS2dBcUFDb0FYQUFxQUNvQUtnQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQXFBRndBS2dBcUFDb0FYQUJjQUNvQUtnQmNBRndBWEFCY0FGd0FLZ0FxQUZ3QUtnQmNBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZ3QVhBQmNBQ29BS2dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUFRQUJBQUVBQTBBRFFCUUFGQUFVQUFFQUFRQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUFyQUNzQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBSGdBZUFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQURRQUVBQVFBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QXJBQ3NBVkFCVkFGVUFWUUJWQUZVQVZRQlZBRlVBVlFCVkFGVUFWUUJWQUZVQVZRQlZBRlVBVlFCVkFGVUFWUUJWQUZVQVZRQlZBRlVBVlFCVUFGVUFWUUJWQUZVQVZRQlZBRlVBVlFCVkFGVUFWUUJWQUZVQVZRQlZBRlVBVlFCVkFGVUFWUUJWQUZVQVZRQlZBRlVBVlFCVkFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZrQVdRQlpBRmtBV1FCWkFGa0FXUUJaQUZrQVdRQlpBRmtBV1FCWkFGa0FXUUJaQUZrQUt3QXJBQ3NBS3dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FXZ0JhQUZvQVdnQmFBRm9BV2dCYUFGb0FLd0FyQUNzQUt3QUdBQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBWUFCZ0FHQUFZQUJnQUdBQVlBQmdBR0FBWUFWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBQ1VBSlFCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBSlFBbEFDVUFKUUFsQUNVQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFLd0FyQUNzQUt3QXJBRllBQkFCV0FGWUFWZ0JXQUZZQVZnQldBRllBVmdCV0FCNEFWZ0JXQUZZQVZnQldBRllBVmdCV0FGWUFWZ0JXQUZZQVZnQXJBRllBVmdCV0FGWUFWZ0FyQUZZQUt3QldBRllBS3dCV0FGWUFLd0JXQUZZQVZnQldBRllBVmdCV0FGWUFWZ0JXQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUVRQVdBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFhQUI0QUt3QXJBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUdBQVJBQkVBR0FBWUFCTUFFd0FXQUJFQUZBQXJBQ3NBS3dBckFDc0FLd0FFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFDVUFKUUFsQUNVQUpRQVdBQkVBRmdBUkFCWUFFUUFXQUJFQUZnQVJBQllBRVFBbEFDVUFGZ0FSQUNVQUpRQWxBQ1VBSlFBbEFDVUFFUUFsQUJFQUt3QVZBQlVBRXdBVEFDVUFGZ0FSQUJZQUVRQVdBQkVBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ3NBSlFBYkFCb0FKUUFyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUFyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFBY0FLd0FUQUNVQUpRQWJBQm9BSlFBbEFCWUFFUUFsQUNVQUVRQWxBQkVBSlFCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFCVUFGUUFsQUNVQUpRQVRBQ1VBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBQllBSlFBUkFDVUFKUUFsQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0FXQUNVQUVRQWxBQllBRVFBUkFCWUFFUUFSQUJVQVZ3QlJBRkVBVVFCUkFGRUFVUUJSQUZFQVVRQlJBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUVjQVJ3QXJBQ3NBVndCWEFGY0FWd0JYQUZjQUt3QXJBRmNBVndCWEFGY0FWd0JYQUNzQUt3QlhBRmNBVndCWEFGY0FWd0FyQUNzQVZ3QlhBRmNBS3dBckFDc0FHZ0FiQUNVQUpRQWxBQnNBR3dBckFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBRUFBUUFCQUFRQUIwQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQURRQU5BQTBBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQlFBRkFBSGdBZUFCNEFLd0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUFRQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QUVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUFRQUJBQUVBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQTBBVUFCUUFGQUFVQUFyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQU5BRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QWVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUZBQVVBQXJBQ3NBS3dCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBTkFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQWVBQjRBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUZBQVVBQXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQTBBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0FlQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFBUUFCQUFFQUNzQUJBQUVBQ3NBS3dBckFDc0FLd0FFQUFRQUJBQUVBRkFBVUFCUUFGQUFLd0JRQUZBQVVBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QXJBQVFBQkFBRUFDc0FLd0FyQUNzQUJBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FLd0FyQUEwQURRQU5BQTBBRFFBTkFBMEFEUUFlQUNzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQWVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQWVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFRQUJBQXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQU5BQTBBRFFBTkFBMEFEUUFVQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFDc0FEUUFOQUEwQURRQU5BQTBBRFFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBQjRBSGdBZUFCNEFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBQVFBQkFBRUFBUUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFBUUFCQUFOQUNzQUt3QlFBRkFBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUJRQUZBQVVBQlFBQjRBSGdBZUFCNEFIZ0FyQUNzQUt3QXJBQ3NBS3dBRUFBUUFCQUFFQUFRQUJBQUVBQTBBRFFBZUFCNEFIZ0FlQUI0QUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUJBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQWVBQjRBSGdBTkFBMEFEUUFOQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QWVBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFDc0FLd0FyQUNzQUt3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQ3NBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dBTkFBMEFEUUFOQUZBQUJBQUVBRkFBS3dBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBZUFBNEFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FFQUZBQVVBQlFBRkFBRFFBTkFCNEFEUUFFQUFRQUJBQUVBQjRBQkFBRUFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FVQUFPQUZBQURRQU5BQTBBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFOQUEwQUhnQU5BQTBBSGdBRUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFBckFGQUFLd0JRQUZBQVVBQlFBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQTBBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUt3QXJBQ3NBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QXJBQ3NBQkFBRUFBUUFCQUFyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQVVBQlFBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBQ3NBVUFCUUFGQUFVQUJRQUNzQUJBQUVBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQXJBQ3NBQkFBRUFDc0FLd0FFQUFRQUJBQXJBQ3NBVUFBckFDc0FLd0FyQUNzQUt3QUVBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBQkFBRUFDc0FLd0FFQUFRQUJBQUVBQVFBQkFBRUFDc0FLd0FyQUFRQUJBQUVBQVFBQkFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FCQUFFQUFRQUJBQUVBQVFBQkFCUUFGQUFVQUJRQUEwQURRQU5BQTBBSGdCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFBMEFEUUFyQUI0QUJBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FFQUFRQUJBQUVBRkFBVUFBZUFGQUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFyQUNzQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQURnQU5BQTBBRXdBVEFCNEFIZ0FlQUEwQURRQU5BQTBBRFFBTkFBMEFEUUFOQUEwQURRQU5BQTBBRFFBTkFGQUFVQUJRQUZBQUJBQUVBQ3NBS3dBRUFBMEFEUUFlQUZBQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBS3dBckFDc0FLd0FyQUNzQURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBRkFBS3dBckFDc0FLd0FyQUNzQUt3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FYQUJjQUZ3QVhBQmNBRndBWEFCY0FGd0FLd0FyQUNvQUtnQXFBQ29BS2dBcUFDb0FLZ0FxQUNvQUtnQXFBQ29BS2dBcUFDc0FLd0FyQUNzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QmNBRndBRFFBTkFBMEFLZ0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFlQUNzQUt3QXJBQ3NBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FyQUZBQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFBUUFCQUFFQUFRQUt3QUVBQVFBS3dBckFBUUFCQUFFQUFRQVVBQUVBRkFBQkFBRUFBMEFEUUFOQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQkFBRUFBUUFCQUFFQUFRQUJBQXJBQ3NBQkFBRUFBUUFCQUFFQUFRQUJBQlFBQTRBVUFBRUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUFRQUJBQUVBRkFBQkFBRUFBUUFCQUFPQUI0QURRQU5BQTBBRFFBT0FCNEFCQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FVQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUEwQURRQU5BRkFBRGdBT0FBNEFEUUFOQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUNzQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUZBQURRQU5BQTBBRFFBTkFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FPQUJNQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QXJBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFyQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBVUFCUUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBRUFBUUFCQUFyQUNzQUt3QUVBQ3NBQkFBRUFDc0FCQUFFQUFRQUJBQUVBQVFBQkFCUUFBUUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQUt3QlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBRUFBUUFLd0FFQUFRQUt3QUVBQVFBQkFBRUFBUUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFCQUFFQUFRQUJBQWVBQjRBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBYUFCb0FHZ0FhQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQTBBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFDc0FEUUFOQUEwQURRQU5BQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFTQUJJQUVnQVF3QkRBRU1BVUFCUUFGQUFVQUJEQUZBQVVBQlFBRWdBUXdCSUFFTUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFTQUJEQUVNQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0FKQUFrQUNRQUpBQWtBQ1FBSkFCWUFFUUFyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQklBRU1BVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBS3dBckFDc0FLd0FOQUEwQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFBUUFCQUFFQUFRQUJBQU5BQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUVBQVFBQkFBRUFBUUFCQUFFQUEwQURRQU5BQjRBSGdBZUFCNEFIZ0FlQUZBQVVBQlFBRkFBRFFBZUFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0FyQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQU5BQTBBSGdBZUFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFDc0FLd0FFQUZBQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFLd0FyQUNzQUt3QXJBQ3NBS3dBRUFBUUFCQUFFQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBUndCSEFCVUFSd0FKQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QUVBQVFBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVRQlJBRkVBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0JSQUZFQVVRQlJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUNzQUhnQUVBQVFBRFFBRUFBUUFCQUFFQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dBckFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQVFBQkFBRUFBUUFCQUFlQUI0QUhnQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFCNEFIZ0FFQUFRQUJBQUVBQVFBQkFBRUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUJBQUVBQVFBQkFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFCQUFFQUFRQUhnQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBckFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUt3QlFBRkFBS3dBckFGQUFLd0FyQUZBQVVBQXJBQ3NBVUFCUUFGQUFVQUFyQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQ3NBVUFBckFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0JRQUZBQVVBQlFBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQVVBQlFBQ3NBSGdBZUFGQUFVQUJRQUZBQVVBQXJBRkFBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFBckFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBSGdCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0JRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFDc0FLd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQWVBQjRBSGdBZUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUJBQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQVFBSGdBZUFBMEFEUUFOQUEwQUhnQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FFQUFRQUJBQUVBQVFBS3dBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUFRQUJBQUVBQVFBQkFBRUFBUUFLd0FFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFLd0FyQUFRQUJBQUVBQVFBQkFBRUFBUUFLd0FFQUFRQUt3QUVBQVFBQkFBRUFBUUFLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FFQUFRQUJBQUVBQVFBQkFBRUFGQUFVQUJRQUZBQVVBQlFBRkFBS3dBckFFc0FTd0JMQUVzQVN3QkxBRXNBU3dCTEFFc0FLd0FyQUNzQUt3QlFBQjRBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dBckFCc0FVQUJRQUZBQVVBQlFBQ3NBS3dCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBRUFBUUFCQUFFQUFRQUJBQUVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQjRBSGdBZUFCNEFCQUFFQUFRQUJBQUVBQVFBQkFCUUFDc0FLd0FyQUNzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQVN3QXJBQ3NBS3dBckFCWUFGZ0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBR2dCUUFGQUFVQUFhQUZBQVVBQlFBRkFBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQWVBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUNzQUt3QlFBRkFBVUFCUUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFLd0JRQUZBQUt3QlFBQ3NBS3dCUUFDc0FVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFyQUZBQVVBQlFBRkFBS3dCUUFDc0FVQUFyQUNzQUt3QXJBQ3NBS3dCUUFDc0FLd0FyQUNzQVVBQXJBRkFBS3dCUUFDc0FVQUJRQUZBQUt3QlFBRkFBS3dCUUFDc0FLd0JRQUNzQVVBQXJBRkFBS3dCUUFDc0FVQUFyQUZBQVVBQXJBRkFBS3dBckFGQUFVQUJRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUNzQVVBQlFBRkFBVUFBckFGQUFVQUJRQUZBQUt3QlFBQ3NBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBckFDc0FLd0FyQUNzQVVBQlFBRkFBS3dCUUFGQUFVQUJRQUZBQUt3QlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FlQUI0QUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFFOEFUd0JQQUU4QVR3QlBBRThBVHdCUEFFOEFUd0JQQUU4QUpRQWxBQ1VBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSGdBZUFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCNEFIZ0FlQUNVQUpRQWxBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBcEFDa0FLUUFwQUNrQUtRQXBBQ2tBS1FBcEFDa0FLUUFwQUNrQUtRQXBBQ2tBS1FBcEFDa0FLUUFwQUNrQUtRQXBBQ2tBSlFBbEFDVUFKUUFsQUNBQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBZUFCNEFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQjRBSGdBbEFDVUFKUUFsQUNVQUhnQWxBQ1VBSlFBbEFDVUFJQUFnQUNBQUpRQWxBQ0FBSlFBbEFDQUFJQUFnQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ0VBSVFBaEFDRUFJUUFsQUNVQUlBQWdBQ1VBSlFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFKUUFsQUNVQUlBQWxBQ1VBSlFBbEFDQUFJQUFnQUNVQUlBQWdBQ0FBSlFBbEFDVUFKUUFsQUNVQUpRQWdBQ1VBSUFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUhnQWxBQjRBSlFBZUFDVUFKUUFsQUNVQUpRQWdBQ1VBSlFBbEFDVUFIZ0FsQUI0QUhnQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFCNEFIZ0FlQUI0QUhnQWVBQjRBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNBQUlBQWxBQ1VBSlFBbEFDQUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDQUFKUUFsQUNVQUpRQWdBQ0FBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFlQUI0QUhnQWVBQjRBSGdBbEFDVUFKUUFsQUNVQUpRQWxBQ0FBSUFBZ0FDVUFKUUFsQUNBQUlBQWdBQ0FBSUFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUJjQUZ3QVhBQlVBRlFBVkFCNEFIZ0FlQUI0QUpRQWxBQ1VBSUFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ0FBSUFBZ0FDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDQUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNBQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUpRQWxBQ1VBSlFBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQ1VBSlFBbEFDVUFKUUFsQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FsQUNVQUpRQWxBQ1VBSlFBbEFDVUFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZ0FDVUFKUUFnQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFKUUFsQUNVQUpRQWxBQ1VBSUFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDVUFKUUFnQUNBQUlBQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFnQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ0FBSUFBbEFDQUFJQUFsQUNBQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBZ0FDQUFJQUFsQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSlFBbEFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFLd0FlQUI0QUhnQWVBQjRBSGdBZUFCNEFIZ0FlQUI0QUhnQXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUVzQVN3QkxBRXNBU3dCTEFFc0FTd0JMQUVzQUt3QXJBQ3NBS3dBckFDc0FKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUt3QXJBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFDVUFKUUJYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBVndCWEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQlhBRmNBVndCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FWd0JYQUZjQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFCWEFGY0FWd0JYQUZjQVZ3QlhBRmNBVndCWEFGY0FKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUpRQWxBQ1VBSlFBbEFDVUFKUUFsQUNVQUt3QUVBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFDc0FLd0FyQUNzQUt3QXJBQ3NBS3dBckFBPT0iKSxYPVtrLDM2XSxZPVsxLDIsMyw1XSxKPVt2LDhdLFo9W0ksTF0sJD1ZLmNvbmNhdChKKSxlZT1bRCxSLEssVCxPXSx0ZT1bQyxiXSxBZT1mdW5jdGlvbihlLHQsQSxyKXt2YXIgbj1yW0FdO2lmKEFycmF5LmlzQXJyYXkoZSk/LTEhPT1lLmluZGV4T2Yobik6ZT09PW4pZm9yKHZhciBzPUE7czw9ci5sZW5ndGg7KXtpZigoYT1yWysrc10pPT09dClyZXR1cm4hMDtpZihhIT09dilicmVha31pZihuPT09dilmb3Iocz1BO3M+MDspe3ZhciBpPXJbLS1zXTtpZihBcnJheS5pc0FycmF5KGUpPy0xIT09ZS5pbmRleE9mKGkpOmU9PT1pKWZvcih2YXIgbz1BO288PXIubGVuZ3RoOyl7dmFyIGE7aWYoKGE9clsrK29dKT09PXQpcmV0dXJuITA7aWYoYSE9PXYpYnJlYWt9aWYoaSE9PXYpYnJlYWt9cmV0dXJuITF9LHJlPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBBPWU7QT49MDspe3ZhciByPXRbQV07aWYociE9PXYpcmV0dXJuIHI7QS0tfXJldHVybiAwfSxuZT1mdW5jdGlvbihlLHQsQSxyLG4pe2lmKDA9PT1BW3JdKXJldHVybiB6O3ZhciBzPXItMTtpZihBcnJheS5pc0FycmF5KG4pJiYhMD09PW5bc10pcmV0dXJuIHo7dmFyIGk9cy0xLG89cysxLGE9dFtzXSxsPWk+PTA/dFtpXTowLGM9dFtvXTtpZigyPT09YSYmMz09PWMpcmV0dXJuIHo7aWYoLTEhPT1ZLmluZGV4T2YoYSkpcmV0dXJuIiEiO2lmKC0xIT09WS5pbmRleE9mKGMpKXJldHVybiB6O2lmKC0xIT09Si5pbmRleE9mKGMpKXJldHVybiB6O2lmKDg9PT1yZShzLHQpKXJldHVybiBxO2lmKDExPT09Vy5nZXQoZVtzXSkpcmV0dXJuIHo7aWYoKGE9PT1IfHxhPT09UCkmJjExPT09Vy5nZXQoZVtvXSkpcmV0dXJuIHo7aWYoNz09PWF8fDc9PT1jKXJldHVybiB6O2lmKDk9PT1hKXJldHVybiB6O2lmKC0xPT09W3YsYixDXS5pbmRleE9mKGEpJiY5PT09YylyZXR1cm4gejtpZigtMSE9PVtfLGoseCxFLE5dLmluZGV4T2YoYykpcmV0dXJuIHo7aWYocmUocyx0KT09PVUpcmV0dXJuIHo7aWYoQWUoMjMsVSxzLHQpKXJldHVybiB6O2lmKEFlKFtfLGpdLFEscyx0KSlyZXR1cm4gejtpZihBZSgxMiwxMixzLHQpKXJldHVybiB6O2lmKGE9PT12KXJldHVybiBxO2lmKDIzPT09YXx8MjM9PT1jKXJldHVybiB6O2lmKDE2PT09Y3x8MTY9PT1hKXJldHVybiBxO2lmKC0xIT09W2IsQyxRXS5pbmRleE9mKGMpfHwxND09PWEpcmV0dXJuIHo7aWYoMzY9PT1sJiYtMSE9PXRlLmluZGV4T2YoYSkpcmV0dXJuIHo7aWYoYT09PU4mJjM2PT09YylyZXR1cm4gejtpZihjPT09RilyZXR1cm4gejtpZigtMSE9PVguaW5kZXhPZihjKSYmYT09PVN8fC0xIT09WC5pbmRleE9mKGEpJiZjPT09UylyZXR1cm4gejtpZihhPT09SSYmLTEhPT1bTSxILFBdLmluZGV4T2YoYyl8fC0xIT09W00sSCxQXS5pbmRleE9mKGEpJiZjPT09TClyZXR1cm4gejtpZigtMSE9PVguaW5kZXhPZihhKSYmLTEhPT1aLmluZGV4T2YoYyl8fC0xIT09Wi5pbmRleE9mKGEpJiYtMSE9PVguaW5kZXhPZihjKSlyZXR1cm4gejtpZigtMSE9PVtJLExdLmluZGV4T2YoYSkmJihjPT09U3x8LTEhPT1bVSxDXS5pbmRleE9mKGMpJiZ0W28rMV09PT1TKXx8LTEhPT1bVSxDXS5pbmRleE9mKGEpJiZjPT09U3x8YT09PVMmJi0xIT09W1MsTixFXS5pbmRleE9mKGMpKXJldHVybiB6O2lmKC0xIT09W1MsTixFLF8sal0uaW5kZXhPZihjKSlmb3IodmFyIHU9czt1Pj0wOyl7aWYoKGg9dFt1XSk9PT1TKXJldHVybiB6O2lmKC0xPT09W04sRV0uaW5kZXhPZihoKSlicmVhazt1LS19aWYoLTEhPT1bSSxMXS5pbmRleE9mKGMpKWZvcih1PS0xIT09W18sal0uaW5kZXhPZihhKT9pOnM7dT49MDspe3ZhciBoO2lmKChoPXRbdV0pPT09UylyZXR1cm4gejtpZigtMT09PVtOLEVdLmluZGV4T2YoaCkpYnJlYWs7dS0tfWlmKEQ9PT1hJiYtMSE9PVtELFIsVCxPXS5pbmRleE9mKGMpfHwtMSE9PVtSLFRdLmluZGV4T2YoYSkmJi0xIT09W1IsS10uaW5kZXhPZihjKXx8LTEhPT1bSyxPXS5pbmRleE9mKGEpJiZjPT09SylyZXR1cm4gejtpZigtMSE9PWVlLmluZGV4T2YoYSkmJi0xIT09W0YsTF0uaW5kZXhPZihjKXx8LTEhPT1lZS5pbmRleE9mKGMpJiZhPT09SSlyZXR1cm4gejtpZigtMSE9PVguaW5kZXhPZihhKSYmLTEhPT1YLmluZGV4T2YoYykpcmV0dXJuIHo7aWYoYT09PUUmJi0xIT09WC5pbmRleE9mKGMpKXJldHVybiB6O2lmKC0xIT09WC5jb25jYXQoUykuaW5kZXhPZihhKSYmYz09PVUmJi0xPT09Ry5pbmRleE9mKGVbb10pfHwtMSE9PVguY29uY2F0KFMpLmluZGV4T2YoYykmJmE9PT1qKXJldHVybiB6O2lmKDQxPT09YSYmNDE9PT1jKXtmb3IodmFyIGQ9QVtzXSxmPTE7ZD4wJiY0MT09PXRbLS1kXTspZisrO2lmKGYlMiE9MClyZXR1cm4gen1yZXR1cm4gYT09PUgmJmM9PT1QP3o6cX0sc2U9ZnVuY3Rpb24oZSx0KXt0fHwodD17bGluZUJyZWFrOiJub3JtYWwiLHdvcmRCcmVhazoibm9ybWFsIn0pO3ZhciBBPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9InN0cmljdCIpO3ZhciBBPVtdLHI9W10sbj1bXTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUscyl7dmFyIGk9Vy5nZXQoZSk7aWYoaT41MD8obi5wdXNoKCEwKSxpLT01MCk6bi5wdXNoKCExKSwtMSE9PVsibm9ybWFsIiwiYXV0byIsImxvb3NlIl0uaW5kZXhPZih0KSYmLTEhPT1bODIwOCw4MjExLDEyMzE2LDEyNDQ4XS5pbmRleE9mKGUpKXJldHVybiByLnB1c2gocyksQS5wdXNoKDE2KTtpZig0PT09aXx8MTE9PT1pKXtpZigwPT09cylyZXR1cm4gci5wdXNoKHMpLEEucHVzaChrKTt2YXIgbz1BW3MtMV07cmV0dXJuLTE9PT0kLmluZGV4T2Yobyk/KHIucHVzaChyW3MtMV0pLEEucHVzaChvKSk6KHIucHVzaChzKSxBLnB1c2goaykpfXJldHVybiByLnB1c2gocyksMzE9PT1pP0EucHVzaCgic3RyaWN0Ij09PXQ/UTpNKTppPT09Vnx8Mjk9PT1pP0EucHVzaChrKTo0Mz09PWk/ZT49MTMxMDcyJiZlPD0xOTY2MDV8fGU+PTE5NjYwOCYmZTw9MjYyMTQxP0EucHVzaChNKTpBLnB1c2goayk6dm9pZCBBLnB1c2goaSl9KSxbcixBLG5dfShlLHQubGluZUJyZWFrKSxyPUFbMF0sbj1BWzFdLHM9QVsyXTsiYnJlYWstYWxsIiE9PXQud29yZEJyZWFrJiYiYnJlYWstd29yZCIhPT10LndvcmRCcmVha3x8KG49bi5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuLTEhPT1bUyxrLFZdLmluZGV4T2YoZSk/TTplfSkpO3ZhciBpPSJrZWVwLWFsbCI9PT10LndvcmRCcmVhaz9zLm1hcChmdW5jdGlvbih0LEEpe3JldHVybiB0JiZlW0FdPj0xOTk2OCYmZVtBXTw9NDA5NTl9KTp2b2lkIDA7cmV0dXJuW3IsbixpXX0saWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxBLHIpe3RoaXMuY29kZVBvaW50cz1lLHRoaXMucmVxdWlyZWQ9IiEiPT09dCx0aGlzLnN0YXJ0PUEsdGhpcy5lbmQ9cn1yZXR1cm4gZS5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbC5hcHBseSh2b2lkIDAsdGhpcy5jb2RlUG9pbnRzLnNsaWNlKHRoaXMuc3RhcnQsdGhpcy5lbmQpKX0sZX0oKSxvZT00NSxhZT00MyxsZT0tMSxjZT1mdW5jdGlvbihlKXtyZXR1cm4gZT49NDgmJmU8PTU3fSx1ZT1mdW5jdGlvbihlKXtyZXR1cm4gY2UoZSl8fGU+PTY1JiZlPD03MHx8ZT49OTcmJmU8PTEwMn0saGU9ZnVuY3Rpb24oZSl7cmV0dXJuIDEwPT09ZXx8OT09PWV8fDMyPT09ZX0sZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZT49OTcmJmU8PTEyMn0oZSl8fGZ1bmN0aW9uKGUpe3JldHVybiBlPj02NSYmZTw9OTB9KGUpfShlKXx8ZnVuY3Rpb24oZSl7cmV0dXJuIGU+PTEyOH0oZSl8fDk1PT09ZX0sZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGRlKGUpfHxjZShlKXx8ZT09PW9lfSxwZT1mdW5jdGlvbihlKXtyZXR1cm4gZT49MCYmZTw9OHx8MTE9PT1lfHxlPj0xNCYmZTw9MzF8fDEyNz09PWV9LGdlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDkyPT09ZSYmMTAhPT10fSxtZT1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIGU9PT1vZT9kZSh0KXx8Z2UodCxBKTohIWRlKGUpfHwhKDkyIT09ZXx8IWdlKGUsdCkpfSx3ZT1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIGU9PT1hZXx8ZT09PW9lPyEhY2UodCl8fDQ2PT09dCYmY2UoQSk6Y2UoNDY9PT1lP3Q6ZSl9LEJlPWZ1bmN0aW9uKGUpe3ZhciB0PTAsQT0xO2VbdF0hPT1hZSYmZVt0XSE9PW9lfHwoZVt0XT09PW9lJiYoQT0tMSksdCsrKTtmb3IodmFyIHI9W107Y2UoZVt0XSk7KXIucHVzaChlW3QrK10pO3ZhciBuPXIubGVuZ3RoP3BhcnNlSW50KGwuYXBwbHkodm9pZCAwLHIpLDEwKTowOzQ2PT09ZVt0XSYmdCsrO2Zvcih2YXIgcz1bXTtjZShlW3RdKTspcy5wdXNoKGVbdCsrXSk7dmFyIGk9cy5sZW5ndGgsbz1pP3BhcnNlSW50KGwuYXBwbHkodm9pZCAwLHMpLDEwKTowOzY5IT09ZVt0XSYmMTAxIT09ZVt0XXx8dCsrO3ZhciBhPTE7ZVt0XSE9PWFlJiZlW3RdIT09b2V8fChlW3RdPT09b2UmJihhPS0xKSx0KyspO2Zvcih2YXIgYz1bXTtjZShlW3RdKTspYy5wdXNoKGVbdCsrXSk7dmFyIHU9Yy5sZW5ndGg/cGFyc2VJbnQobC5hcHBseSh2b2lkIDAsYyksMTApOjA7cmV0dXJuIEEqKG4rbypNYXRoLnBvdygxMCwtaSkpKk1hdGgucG93KDEwLGEqdSl9LHllPXt0eXBlOjJ9LHZlPXt0eXBlOjN9LGJlPXt0eXBlOjR9LENlPXt0eXBlOjEzfSxfZT17dHlwZTo4fSxqZT17dHlwZToyMX0seGU9e3R5cGU6OX0sRmU9e3R5cGU6MTB9LFFlPXt0eXBlOjExfSxVZT17dHlwZToxMn0sRWU9e3R5cGU6MTR9LFNlPXt0eXBlOjIzfSxMZT17dHlwZToxfSxJZT17dHlwZToyNX0sTmU9e3R5cGU6MjR9LGtlPXt0eXBlOjI2fSxIZT17dHlwZToyN30sUGU9e3R5cGU6Mjh9LFRlPXt0eXBlOjI5fSxPZT17dHlwZTozMX0sTWU9e3R5cGU6MzJ9LERlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3RoaXMuX3ZhbHVlPVtdfXJldHVybiBlLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlKXt0aGlzLl92YWx1ZT10aGlzLl92YWx1ZS5jb25jYXQoYShlKSl9LGUucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD10aGlzLmNvbnN1bWVUb2tlbigpO3QhPT1NZTspZS5wdXNoKHQpLHQ9dGhpcy5jb25zdW1lVG9rZW4oKTtyZXR1cm4gZX0sZS5wcm90b3R5cGUuY29uc3VtZVRva2VuPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5jb25zdW1lQ29kZVBvaW50KCk7c3dpdGNoKGUpe2Nhc2UgMzQ6cmV0dXJuIHRoaXMuY29uc3VtZVN0cmluZ1Rva2VuKDM0KTtjYXNlIDM1OnZhciB0PXRoaXMucGVla0NvZGVQb2ludCgwKSxBPXRoaXMucGVla0NvZGVQb2ludCgxKSxyPXRoaXMucGVla0NvZGVQb2ludCgyKTtpZihmZSh0KXx8Z2UoQSxyKSl7dmFyIG49bWUodCxBLHIpPzI6MTtyZXR1cm57dHlwZTo1LHZhbHVlOnRoaXMuY29uc3VtZU5hbWUoKSxmbGFnczpufX1icmVhaztjYXNlIDM2OmlmKDYxPT09dGhpcy5wZWVrQ29kZVBvaW50KDApKXJldHVybiB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSxDZTticmVhaztjYXNlIDM5OnJldHVybiB0aGlzLmNvbnN1bWVTdHJpbmdUb2tlbigzOSk7Y2FzZSA0MDpyZXR1cm4geWU7Y2FzZSA0MTpyZXR1cm4gdmU7Y2FzZSA0MjppZig2MT09PXRoaXMucGVla0NvZGVQb2ludCgwKSlyZXR1cm4gdGhpcy5jb25zdW1lQ29kZVBvaW50KCksRWU7YnJlYWs7Y2FzZSBhZTppZih3ZShlLHRoaXMucGVla0NvZGVQb2ludCgwKSx0aGlzLnBlZWtDb2RlUG9pbnQoMSkpKXJldHVybiB0aGlzLnJlY29uc3VtZUNvZGVQb2ludChlKSx0aGlzLmNvbnN1bWVOdW1lcmljVG9rZW4oKTticmVhaztjYXNlIDQ0OnJldHVybiBiZTtjYXNlIG9lOnZhciBzPWUsaT10aGlzLnBlZWtDb2RlUG9pbnQoMCksbz10aGlzLnBlZWtDb2RlUG9pbnQoMSk7aWYod2UocyxpLG8pKXJldHVybiB0aGlzLnJlY29uc3VtZUNvZGVQb2ludChlKSx0aGlzLmNvbnN1bWVOdW1lcmljVG9rZW4oKTtpZihtZShzLGksbykpcmV0dXJuIHRoaXMucmVjb25zdW1lQ29kZVBvaW50KGUpLHRoaXMuY29uc3VtZUlkZW50TGlrZVRva2VuKCk7aWYoaT09PW9lJiY2Mj09PW8pcmV0dXJuIHRoaXMuY29uc3VtZUNvZGVQb2ludCgpLHRoaXMuY29uc3VtZUNvZGVQb2ludCgpLE5lO2JyZWFrO2Nhc2UgNDY6aWYod2UoZSx0aGlzLnBlZWtDb2RlUG9pbnQoMCksdGhpcy5wZWVrQ29kZVBvaW50KDEpKSlyZXR1cm4gdGhpcy5yZWNvbnN1bWVDb2RlUG9pbnQoZSksdGhpcy5jb25zdW1lTnVtZXJpY1Rva2VuKCk7YnJlYWs7Y2FzZSA0NzppZig0Mj09PXRoaXMucGVla0NvZGVQb2ludCgwKSlmb3IodGhpcy5jb25zdW1lQ29kZVBvaW50KCk7Oyl7dmFyIGE9dGhpcy5jb25zdW1lQ29kZVBvaW50KCk7aWYoNDI9PT1hJiY0Nz09PShhPXRoaXMuY29uc3VtZUNvZGVQb2ludCgpKSlyZXR1cm4gdGhpcy5jb25zdW1lVG9rZW4oKTtpZihhPT09bGUpcmV0dXJuIHRoaXMuY29uc3VtZVRva2VuKCl9YnJlYWs7Y2FzZSA1ODpyZXR1cm4ga2U7Y2FzZSA1OTpyZXR1cm4gSGU7Y2FzZSA2MDppZigzMz09PXRoaXMucGVla0NvZGVQb2ludCgwKSYmdGhpcy5wZWVrQ29kZVBvaW50KDEpPT09b2UmJnRoaXMucGVla0NvZGVQb2ludCgyKT09PW9lKXJldHVybiB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSx0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSxJZTticmVhaztjYXNlIDY0OnZhciBjPXRoaXMucGVla0NvZGVQb2ludCgwKSx1PXRoaXMucGVla0NvZGVQb2ludCgxKSxoPXRoaXMucGVla0NvZGVQb2ludCgyKTtpZihtZShjLHUsaCkpcmV0dXJue3R5cGU6Nyx2YWx1ZTp0aGlzLmNvbnN1bWVOYW1lKCl9O2JyZWFrO2Nhc2UgOTE6cmV0dXJuIFBlO2Nhc2UgOTI6aWYoZ2UoZSx0aGlzLnBlZWtDb2RlUG9pbnQoMCkpKXJldHVybiB0aGlzLnJlY29uc3VtZUNvZGVQb2ludChlKSx0aGlzLmNvbnN1bWVJZGVudExpa2VUb2tlbigpO2JyZWFrO2Nhc2UgOTM6cmV0dXJuIFRlO2Nhc2UgNjE6aWYoNjE9PT10aGlzLnBlZWtDb2RlUG9pbnQoMCkpcmV0dXJuIHRoaXMuY29uc3VtZUNvZGVQb2ludCgpLF9lO2JyZWFrO2Nhc2UgMTIzOnJldHVybiBRZTtjYXNlIDEyNTpyZXR1cm4gVWU7Y2FzZSAxMTc6Y2FzZSA4NTp2YXIgZD10aGlzLnBlZWtDb2RlUG9pbnQoMCksZj10aGlzLnBlZWtDb2RlUG9pbnQoMSk7cmV0dXJuIGQhPT1hZXx8IXVlKGYpJiY2MyE9PWZ8fCh0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSx0aGlzLmNvbnN1bWVVbmljb2RlUmFuZ2VUb2tlbigpKSx0aGlzLnJlY29uc3VtZUNvZGVQb2ludChlKSx0aGlzLmNvbnN1bWVJZGVudExpa2VUb2tlbigpO2Nhc2UgMTI0OmlmKDYxPT09dGhpcy5wZWVrQ29kZVBvaW50KDApKXJldHVybiB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSx4ZTtpZigxMjQ9PT10aGlzLnBlZWtDb2RlUG9pbnQoMCkpcmV0dXJuIHRoaXMuY29uc3VtZUNvZGVQb2ludCgpLGplO2JyZWFrO2Nhc2UgMTI2OmlmKDYxPT09dGhpcy5wZWVrQ29kZVBvaW50KDApKXJldHVybiB0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSxGZTticmVhaztjYXNlIGxlOnJldHVybiBNZX1yZXR1cm4gaGUoZSk/KHRoaXMuY29uc3VtZVdoaXRlU3BhY2UoKSxPZSk6Y2UoZSk/KHRoaXMucmVjb25zdW1lQ29kZVBvaW50KGUpLHRoaXMuY29uc3VtZU51bWVyaWNUb2tlbigpKTpkZShlKT8odGhpcy5yZWNvbnN1bWVDb2RlUG9pbnQoZSksdGhpcy5jb25zdW1lSWRlbnRMaWtlVG9rZW4oKSk6e3R5cGU6Nix2YWx1ZTpsKGUpfX0sZS5wcm90b3R5cGUuY29uc3VtZUNvZGVQb2ludD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX3ZhbHVlLnNoaWZ0KCk7cmV0dXJuIHZvaWQgMD09PWU/LTE6ZX0sZS5wcm90b3R5cGUucmVjb25zdW1lQ29kZVBvaW50PWZ1bmN0aW9uKGUpe3RoaXMuX3ZhbHVlLnVuc2hpZnQoZSl9LGUucHJvdG90eXBlLnBlZWtDb2RlUG9pbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGU+PXRoaXMuX3ZhbHVlLmxlbmd0aD8tMTp0aGlzLl92YWx1ZVtlXX0sZS5wcm90b3R5cGUuY29uc3VtZVVuaWNvZGVSYW5nZVRva2VuPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9dGhpcy5jb25zdW1lQ29kZVBvaW50KCk7dWUodCkmJmUubGVuZ3RoPDY7KWUucHVzaCh0KSx0PXRoaXMuY29uc3VtZUNvZGVQb2ludCgpO2Zvcih2YXIgQT0hMTs2Mz09PXQmJmUubGVuZ3RoPDY7KWUucHVzaCh0KSx0PXRoaXMuY29uc3VtZUNvZGVQb2ludCgpLEE9ITA7aWYoQSlyZXR1cm57dHlwZTozMCxzdGFydDpwYXJzZUludChsLmFwcGx5KHZvaWQgMCxlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gNjM9PT1lPzQ4OmV9KSksMTYpLGVuZDpwYXJzZUludChsLmFwcGx5KHZvaWQgMCxlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gNjM9PT1lPzcwOmV9KSksMTYpfTt2YXIgcj1wYXJzZUludChsLmFwcGx5KHZvaWQgMCxlKSwxNik7aWYodGhpcy5wZWVrQ29kZVBvaW50KDApPT09b2UmJnVlKHRoaXMucGVla0NvZGVQb2ludCgxKSkpe3RoaXMuY29uc3VtZUNvZGVQb2ludCgpLHQ9dGhpcy5jb25zdW1lQ29kZVBvaW50KCk7Zm9yKHZhciBuPVtdO3VlKHQpJiZuLmxlbmd0aDw2OyluLnB1c2godCksdD10aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtyZXR1cm57dHlwZTozMCxzdGFydDpyLGVuZDpwYXJzZUludChsLmFwcGx5KHZvaWQgMCxuKSwxNil9fXJldHVybnt0eXBlOjMwLHN0YXJ0OnIsZW5kOnJ9fSxlLnByb3RvdHlwZS5jb25zdW1lSWRlbnRMaWtlVG9rZW49ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmNvbnN1bWVOYW1lKCk7cmV0dXJuInVybCI9PT1lLnRvTG93ZXJDYXNlKCkmJjQwPT09dGhpcy5wZWVrQ29kZVBvaW50KDApPyh0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSx0aGlzLmNvbnN1bWVVcmxUb2tlbigpKTo0MD09PXRoaXMucGVla0NvZGVQb2ludCgwKT8odGhpcy5jb25zdW1lQ29kZVBvaW50KCkse3R5cGU6MTksdmFsdWU6ZX0pOnt0eXBlOjIwLHZhbHVlOmV9fSxlLnByb3RvdHlwZS5jb25zdW1lVXJsVG9rZW49ZnVuY3Rpb24oKXt2YXIgZT1bXTtpZih0aGlzLmNvbnN1bWVXaGl0ZVNwYWNlKCksdGhpcy5wZWVrQ29kZVBvaW50KDApPT09bGUpcmV0dXJue3R5cGU6MjIsdmFsdWU6IiJ9O3ZhciB0PXRoaXMucGVla0NvZGVQb2ludCgwKTtpZigzOT09PXR8fDM0PT09dCl7dmFyIEE9dGhpcy5jb25zdW1lU3RyaW5nVG9rZW4odGhpcy5jb25zdW1lQ29kZVBvaW50KCkpO3JldHVybiAwPT09QS50eXBlJiYodGhpcy5jb25zdW1lV2hpdGVTcGFjZSgpLHRoaXMucGVla0NvZGVQb2ludCgwKT09PWxlfHw0MT09PXRoaXMucGVla0NvZGVQb2ludCgwKSk/KHRoaXMuY29uc3VtZUNvZGVQb2ludCgpLHt0eXBlOjIyLHZhbHVlOkEudmFsdWV9KToodGhpcy5jb25zdW1lQmFkVXJsUmVtbmFudHMoKSxTZSl9Zm9yKDs7KXt2YXIgcj10aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtpZihyPT09bGV8fDQxPT09cilyZXR1cm57dHlwZToyMix2YWx1ZTpsLmFwcGx5KHZvaWQgMCxlKX07aWYoaGUocikpcmV0dXJuIHRoaXMuY29uc3VtZVdoaXRlU3BhY2UoKSx0aGlzLnBlZWtDb2RlUG9pbnQoMCk9PT1sZXx8NDE9PT10aGlzLnBlZWtDb2RlUG9pbnQoMCk/KHRoaXMuY29uc3VtZUNvZGVQb2ludCgpLHt0eXBlOjIyLHZhbHVlOmwuYXBwbHkodm9pZCAwLGUpfSk6KHRoaXMuY29uc3VtZUJhZFVybFJlbW5hbnRzKCksU2UpO2lmKDM0PT09cnx8Mzk9PT1yfHw0MD09PXJ8fHBlKHIpKXJldHVybiB0aGlzLmNvbnN1bWVCYWRVcmxSZW1uYW50cygpLFNlO2lmKDkyPT09cil7aWYoIWdlKHIsdGhpcy5wZWVrQ29kZVBvaW50KDApKSlyZXR1cm4gdGhpcy5jb25zdW1lQmFkVXJsUmVtbmFudHMoKSxTZTtlLnB1c2godGhpcy5jb25zdW1lRXNjYXBlZENvZGVQb2ludCgpKX1lbHNlIGUucHVzaChyKX19LGUucHJvdG90eXBlLmNvbnN1bWVXaGl0ZVNwYWNlPWZ1bmN0aW9uKCl7Zm9yKDtoZSh0aGlzLnBlZWtDb2RlUG9pbnQoMCkpOyl0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKX0sZS5wcm90b3R5cGUuY29uc3VtZUJhZFVybFJlbW5hbnRzPWZ1bmN0aW9uKCl7Zm9yKDs7KXt2YXIgZT10aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTtpZig0MT09PWV8fGU9PT1sZSlyZXR1cm47Z2UoZSx0aGlzLnBlZWtDb2RlUG9pbnQoMCkpJiZ0aGlzLmNvbnN1bWVFc2NhcGVkQ29kZVBvaW50KCl9fSxlLnByb3RvdHlwZS5jb25zdW1lU3RyaW5nU2xpY2U9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PSIiO2U+MDspe3ZhciBBPU1hdGgubWluKDVlNCxlKTt0Kz1sLmFwcGx5KHZvaWQgMCx0aGlzLl92YWx1ZS5zcGxpY2UoMCxBKSksZS09QX1yZXR1cm4gdGhpcy5fdmFsdWUuc2hpZnQoKSx0fSxlLnByb3RvdHlwZS5jb25zdW1lU3RyaW5nVG9rZW49ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PSIiLEE9MDs7KXt2YXIgcj10aGlzLl92YWx1ZVtBXTtpZihyPT09bGV8fHZvaWQgMD09PXJ8fHI9PT1lKXJldHVybnt0eXBlOjAsdmFsdWU6dCs9dGhpcy5jb25zdW1lU3RyaW5nU2xpY2UoQSl9O2lmKDEwPT09cilyZXR1cm4gdGhpcy5fdmFsdWUuc3BsaWNlKDAsQSksTGU7aWYoOTI9PT1yKXt2YXIgbj10aGlzLl92YWx1ZVtBKzFdO24hPT1sZSYmdm9pZCAwIT09biYmKDEwPT09bj8odCs9dGhpcy5jb25zdW1lU3RyaW5nU2xpY2UoQSksQT0tMSx0aGlzLl92YWx1ZS5zaGlmdCgpKTpnZShyLG4pJiYodCs9dGhpcy5jb25zdW1lU3RyaW5nU2xpY2UoQSksdCs9bCh0aGlzLmNvbnN1bWVFc2NhcGVkQ29kZVBvaW50KCkpLEE9LTEpKX1BKyt9fSxlLnByb3RvdHlwZS5jb25zdW1lTnVtYmVyPWZ1bmN0aW9uKCl7dmFyIGU9W10sdD00LEE9dGhpcy5wZWVrQ29kZVBvaW50KDApO2ZvcihBIT09YWUmJkEhPT1vZXx8ZS5wdXNoKHRoaXMuY29uc3VtZUNvZGVQb2ludCgpKTtjZSh0aGlzLnBlZWtDb2RlUG9pbnQoMCkpOyllLnB1c2godGhpcy5jb25zdW1lQ29kZVBvaW50KCkpO0E9dGhpcy5wZWVrQ29kZVBvaW50KDApO3ZhciByPXRoaXMucGVla0NvZGVQb2ludCgxKTtpZig0Nj09PUEmJmNlKHIpKWZvcihlLnB1c2godGhpcy5jb25zdW1lQ29kZVBvaW50KCksdGhpcy5jb25zdW1lQ29kZVBvaW50KCkpLHQ9ODtjZSh0aGlzLnBlZWtDb2RlUG9pbnQoMCkpOyllLnB1c2godGhpcy5jb25zdW1lQ29kZVBvaW50KCkpO0E9dGhpcy5wZWVrQ29kZVBvaW50KDApLHI9dGhpcy5wZWVrQ29kZVBvaW50KDEpO3ZhciBuPXRoaXMucGVla0NvZGVQb2ludCgyKTtpZigoNjk9PT1BfHwxMDE9PT1BKSYmKChyPT09YWV8fHI9PT1vZSkmJmNlKG4pfHxjZShyKSkpZm9yKGUucHVzaCh0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSx0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSksdD04O2NlKHRoaXMucGVla0NvZGVQb2ludCgwKSk7KWUucHVzaCh0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKSk7cmV0dXJuW0JlKGUpLHRdfSxlLnByb3RvdHlwZS5jb25zdW1lTnVtZXJpY1Rva2VuPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5jb25zdW1lTnVtYmVyKCksdD1lWzBdLEE9ZVsxXSxyPXRoaXMucGVla0NvZGVQb2ludCgwKSxuPXRoaXMucGVla0NvZGVQb2ludCgxKSxzPXRoaXMucGVla0NvZGVQb2ludCgyKTtyZXR1cm4gbWUocixuLHMpP3t0eXBlOjE1LG51bWJlcjp0LGZsYWdzOkEsdW5pdDp0aGlzLmNvbnN1bWVOYW1lKCl9OjM3PT09cj8odGhpcy5jb25zdW1lQ29kZVBvaW50KCkse3R5cGU6MTYsbnVtYmVyOnQsZmxhZ3M6QX0pOnt0eXBlOjE3LG51bWJlcjp0LGZsYWdzOkF9fSxlLnByb3RvdHlwZS5jb25zdW1lRXNjYXBlZENvZGVQb2ludD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuY29uc3VtZUNvZGVQb2ludCgpO2lmKHVlKGUpKXtmb3IodmFyIHQ9bChlKTt1ZSh0aGlzLnBlZWtDb2RlUG9pbnQoMCkpJiZ0Lmxlbmd0aDw2Oyl0Kz1sKHRoaXMuY29uc3VtZUNvZGVQb2ludCgpKTtoZSh0aGlzLnBlZWtDb2RlUG9pbnQoMCkpJiZ0aGlzLmNvbnN1bWVDb2RlUG9pbnQoKTt2YXIgQT1wYXJzZUludCh0LDE2KTtyZXR1cm4gMD09PUF8fGZ1bmN0aW9uKGUpe3JldHVybiBlPj01NTI5NiYmZTw9NTczNDN9KEEpfHxBPjExMTQxMTE/NjU1MzM6QX1yZXR1cm4gZT09PWxlPzY1NTMzOmV9LGUucHJvdG90eXBlLmNvbnN1bWVOYW1lPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPSIiOzspe3ZhciB0PXRoaXMuY29uc3VtZUNvZGVQb2ludCgpO2lmKGZlKHQpKWUrPWwodCk7ZWxzZXtpZighZ2UodCx0aGlzLnBlZWtDb2RlUG9pbnQoMCkpKXJldHVybiB0aGlzLnJlY29uc3VtZUNvZGVQb2ludCh0KSxlO2UrPWwodGhpcy5jb25zdW1lRXNjYXBlZENvZGVQb2ludCgpKX19fSxlfSgpLFJlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLl90b2tlbnM9ZX1yZXR1cm4gZS5jcmVhdGU9ZnVuY3Rpb24odCl7dmFyIEE9bmV3IERlO3JldHVybiBBLndyaXRlKHQpLG5ldyBlKEEucmVhZCgpKX0sZS5wYXJzZVZhbHVlPWZ1bmN0aW9uKHQpe3JldHVybiBlLmNyZWF0ZSh0KS5wYXJzZUNvbXBvbmVudFZhbHVlKCl9LGUucGFyc2VWYWx1ZXM9ZnVuY3Rpb24odCl7cmV0dXJuIGUuY3JlYXRlKHQpLnBhcnNlQ29tcG9uZW50VmFsdWVzKCl9LGUucHJvdG90eXBlLnBhcnNlQ29tcG9uZW50VmFsdWU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5jb25zdW1lVG9rZW4oKTszMT09PWUudHlwZTspZT10aGlzLmNvbnN1bWVUb2tlbigpO2lmKDMyPT09ZS50eXBlKXRocm93IG5ldyBTeW50YXhFcnJvcigiRXJyb3IgcGFyc2luZyBDU1MgY29tcG9uZW50IHZhbHVlLCB1bmV4cGVjdGVkIEVPRiIpO3RoaXMucmVjb25zdW1lVG9rZW4oZSk7dmFyIHQ9dGhpcy5jb25zdW1lQ29tcG9uZW50VmFsdWUoKTtkb3tlPXRoaXMuY29uc3VtZVRva2VuKCl9d2hpbGUoMzE9PT1lLnR5cGUpO2lmKDMyPT09ZS50eXBlKXJldHVybiB0O3Rocm93IG5ldyBTeW50YXhFcnJvcigiRXJyb3IgcGFyc2luZyBDU1MgY29tcG9uZW50IHZhbHVlLCBtdWx0aXBsZSB2YWx1ZXMgZm91bmQgd2hlbiBleHBlY3Rpbmcgb25seSBvbmUiKX0sZS5wcm90b3R5cGUucGFyc2VDb21wb25lbnRWYWx1ZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W107Oyl7dmFyIHQ9dGhpcy5jb25zdW1lQ29tcG9uZW50VmFsdWUoKTtpZigzMj09PXQudHlwZSlyZXR1cm4gZTtlLnB1c2godCksZS5wdXNoKCl9fSxlLnByb3RvdHlwZS5jb25zdW1lQ29tcG9uZW50VmFsdWU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmNvbnN1bWVUb2tlbigpO3N3aXRjaChlLnR5cGUpe2Nhc2UgMTE6Y2FzZSAyODpjYXNlIDI6cmV0dXJuIHRoaXMuY29uc3VtZVNpbXBsZUJsb2NrKGUudHlwZSk7Y2FzZSAxOTpyZXR1cm4gdGhpcy5jb25zdW1lRnVuY3Rpb24oZSl9cmV0dXJuIGV9LGUucHJvdG90eXBlLmNvbnN1bWVTaW1wbGVCbG9jaz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9e3R5cGU6ZSx2YWx1ZXM6W119LEE9dGhpcy5jb25zdW1lVG9rZW4oKTs7KXtpZigzMj09PUEudHlwZXx8SmUoQSxlKSlyZXR1cm4gdDt0aGlzLnJlY29uc3VtZVRva2VuKEEpLHQudmFsdWVzLnB1c2godGhpcy5jb25zdW1lQ29tcG9uZW50VmFsdWUoKSksQT10aGlzLmNvbnN1bWVUb2tlbigpfX0sZS5wcm90b3R5cGUuY29uc3VtZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD17bmFtZTplLnZhbHVlLHZhbHVlczpbXSx0eXBlOjE4fTs7KXt2YXIgQT10aGlzLmNvbnN1bWVUb2tlbigpO2lmKDMyPT09QS50eXBlfHwzPT09QS50eXBlKXJldHVybiB0O3RoaXMucmVjb25zdW1lVG9rZW4oQSksdC52YWx1ZXMucHVzaCh0aGlzLmNvbnN1bWVDb21wb25lbnRWYWx1ZSgpKX19LGUucHJvdG90eXBlLmNvbnN1bWVUb2tlbj1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX3Rva2Vucy5zaGlmdCgpO3JldHVybiB2b2lkIDA9PT1lP01lOmV9LGUucHJvdG90eXBlLnJlY29uc3VtZVRva2VuPWZ1bmN0aW9uKGUpe3RoaXMuX3Rva2Vucy51bnNoaWZ0KGUpfSxlfSgpLEtlPWZ1bmN0aW9uKGUpe3JldHVybiAxNT09PWUudHlwZX0sVmU9ZnVuY3Rpb24oZSl7cmV0dXJuIDE3PT09ZS50eXBlfSxHZT1mdW5jdGlvbihlKXtyZXR1cm4gMjA9PT1lLnR5cGV9LHplPWZ1bmN0aW9uKGUpe3JldHVybiAwPT09ZS50eXBlfSxxZT1mdW5jdGlvbihlLHQpe3JldHVybiBHZShlKSYmZS52YWx1ZT09PXR9LFdlPWZ1bmN0aW9uKGUpe3JldHVybiAzMSE9PWUudHlwZX0sWGU9ZnVuY3Rpb24oZSl7cmV0dXJuIDMxIT09ZS50eXBlJiY0IT09ZS50eXBlfSxZZT1mdW5jdGlvbihlKXt2YXIgdD1bXSxBPVtdO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoND09PWUudHlwZSl7aWYoMD09PUEubGVuZ3RoKXRocm93IG5ldyBFcnJvcigiRXJyb3IgcGFyc2luZyBmdW5jdGlvbiBhcmdzLCB6ZXJvIHRva2VucyBmb3IgYXJnIik7cmV0dXJuIHQucHVzaChBKSx2b2lkKEE9W10pfTMxIT09ZS50eXBlJiZBLnB1c2goZSl9KSxBLmxlbmd0aCYmdC5wdXNoKEEpLHR9LEplPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDExPT09dCYmMTI9PT1lLnR5cGV8fDI4PT09dCYmMjk9PT1lLnR5cGV8fDI9PT10JiYzPT09ZS50eXBlfSxaZT1mdW5jdGlvbihlKXtyZXR1cm4gMTc9PT1lLnR5cGV8fDE1PT09ZS50eXBlfSwkZT1mdW5jdGlvbihlKXtyZXR1cm4gMTY9PT1lLnR5cGV8fFplKGUpfSxldD1mdW5jdGlvbihlKXtyZXR1cm4gZS5sZW5ndGg+MT9bZVswXSxlWzFdXTpbZVswXV19LHR0PXt0eXBlOjE3LG51bWJlcjowLGZsYWdzOjR9LEF0PXt0eXBlOjE2LG51bWJlcjo1MCxmbGFnczo0fSxydD17dHlwZToxNixudW1iZXI6MTAwLGZsYWdzOjR9LG50PWZ1bmN0aW9uKGUsdCxBKXt2YXIgcj1lWzBdLG49ZVsxXTtyZXR1cm5bc3Qocix0KSxzdCh2b2lkIDAhPT1uP246cixBKV19LHN0PWZ1bmN0aW9uKGUsdCl7aWYoMTY9PT1lLnR5cGUpcmV0dXJuIGUubnVtYmVyLzEwMCp0O2lmKEtlKGUpKXN3aXRjaChlLnVuaXQpe2Nhc2UicmVtIjpjYXNlImVtIjpyZXR1cm4gMTYqZS5udW1iZXI7ZGVmYXVsdDpyZXR1cm4gZS5udW1iZXJ9cmV0dXJuIGUubnVtYmVyfSxpdD0iZ3JhZCIsb3Q9InR1cm4iLGF0PWZ1bmN0aW9uKGUsdCl7aWYoMTU9PT10LnR5cGUpc3dpdGNoKHQudW5pdCl7Y2FzZSJkZWciOnJldHVybiBNYXRoLlBJKnQubnVtYmVyLzE4MDtjYXNlIGl0OnJldHVybiBNYXRoLlBJLzIwMCp0Lm51bWJlcjtjYXNlInJhZCI6cmV0dXJuIHQubnVtYmVyO2Nhc2Ugb3Q6cmV0dXJuIDIqTWF0aC5QSSp0Lm51bWJlcn10aHJvdyBuZXcgRXJyb3IoIlVuc3VwcG9ydGVkIGFuZ2xlIHR5cGUiKX0sbHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIDE1PT09ZS50eXBlJiYoImRlZyI9PT1lLnVuaXR8fGUudW5pdD09PWl0fHwicmFkIj09PWUudW5pdHx8ZS51bml0PT09b3QpfSxjdD1mdW5jdGlvbihlKXtzd2l0Y2goZS5maWx0ZXIoR2UpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS52YWx1ZX0pLmpvaW4oIiAiKSl7Y2FzZSJ0byBib3R0b20gcmlnaHQiOmNhc2UidG8gcmlnaHQgYm90dG9tIjpjYXNlImxlZnQgdG9wIjpjYXNlInRvcCBsZWZ0IjpyZXR1cm5bdHQsdHRdO2Nhc2UidG8gdG9wIjpjYXNlImJvdHRvbSI6cmV0dXJuIHV0KDApO2Nhc2UidG8gYm90dG9tIGxlZnQiOmNhc2UidG8gbGVmdCBib3R0b20iOmNhc2UicmlnaHQgdG9wIjpjYXNlInRvcCByaWdodCI6cmV0dXJuW3R0LHJ0XTtjYXNlInRvIHJpZ2h0IjpjYXNlImxlZnQiOnJldHVybiB1dCg5MCk7Y2FzZSJ0byB0b3AgbGVmdCI6Y2FzZSJ0byBsZWZ0IHRvcCI6Y2FzZSJyaWdodCBib3R0b20iOmNhc2UiYm90dG9tIHJpZ2h0IjpyZXR1cm5bcnQscnRdO2Nhc2UidG8gYm90dG9tIjpjYXNlInRvcCI6cmV0dXJuIHV0KDE4MCk7Y2FzZSJ0byB0b3AgcmlnaHQiOmNhc2UidG8gcmlnaHQgdG9wIjpjYXNlImxlZnQgYm90dG9tIjpjYXNlImJvdHRvbSBsZWZ0IjpyZXR1cm5bcnQsdHRdO2Nhc2UidG8gbGVmdCI6Y2FzZSJyaWdodCI6cmV0dXJuIHV0KDI3MCl9cmV0dXJuIDB9LHV0PWZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLlBJKmUvMTgwfSxodD1mdW5jdGlvbihlLHQpe2lmKDE4PT09dC50eXBlKXt2YXIgQT15dFt0Lm5hbWVdO2lmKHZvaWQgMD09PUEpdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHBhcnNlIGFuIHVuc3VwcG9ydGVkIGNvbG9yIGZ1bmN0aW9uICInK3QubmFtZSsnIicpO3JldHVybiBBKGUsdC52YWx1ZXMpfWlmKDU9PT10LnR5cGUpe2lmKDM9PT10LnZhbHVlLmxlbmd0aCl7dmFyIHI9dC52YWx1ZS5zdWJzdHJpbmcoMCwxKSxuPXQudmFsdWUuc3Vic3RyaW5nKDEsMikscz10LnZhbHVlLnN1YnN0cmluZygyLDMpO3JldHVybiBwdChwYXJzZUludChyK3IsMTYpLHBhcnNlSW50KG4rbiwxNikscGFyc2VJbnQocytzLDE2KSwxKX1pZig0PT09dC52YWx1ZS5sZW5ndGgpe3I9dC52YWx1ZS5zdWJzdHJpbmcoMCwxKSxuPXQudmFsdWUuc3Vic3RyaW5nKDEsMikscz10LnZhbHVlLnN1YnN0cmluZygyLDMpO3ZhciBpPXQudmFsdWUuc3Vic3RyaW5nKDMsNCk7cmV0dXJuIHB0KHBhcnNlSW50KHIrciwxNikscGFyc2VJbnQobituLDE2KSxwYXJzZUludChzK3MsMTYpLHBhcnNlSW50KGkraSwxNikvMjU1KX1pZig2PT09dC52YWx1ZS5sZW5ndGgpcmV0dXJuIHI9dC52YWx1ZS5zdWJzdHJpbmcoMCwyKSxuPXQudmFsdWUuc3Vic3RyaW5nKDIsNCkscz10LnZhbHVlLnN1YnN0cmluZyg0LDYpLHB0KHBhcnNlSW50KHIsMTYpLHBhcnNlSW50KG4sMTYpLHBhcnNlSW50KHMsMTYpLDEpO2lmKDg9PT10LnZhbHVlLmxlbmd0aClyZXR1cm4gcj10LnZhbHVlLnN1YnN0cmluZygwLDIpLG49dC52YWx1ZS5zdWJzdHJpbmcoMiw0KSxzPXQudmFsdWUuc3Vic3RyaW5nKDQsNiksaT10LnZhbHVlLnN1YnN0cmluZyg2LDgpLHB0KHBhcnNlSW50KHIsMTYpLHBhcnNlSW50KG4sMTYpLHBhcnNlSW50KHMsMTYpLHBhcnNlSW50KGksMTYpLzI1NSl9aWYoMjA9PT10LnR5cGUpe3ZhciBvPWJ0W3QudmFsdWUudG9VcHBlckNhc2UoKV07aWYodm9pZCAwIT09bylyZXR1cm4gb31yZXR1cm4gYnQuVFJBTlNQQVJFTlR9LGR0PWZ1bmN0aW9uKGUpe3JldHVybiEoMjU1JmUpfSxmdD1mdW5jdGlvbihlKXt2YXIgdD0yNTUmZSxBPTI1NSZlPj44LHI9MjU1JmU+PjE2LG49MjU1JmU+PjI0O3JldHVybiB0PDI1NT8icmdiYSgiK24rIiwiK3IrIiwiK0ErIiwiK3QvMjU1KyIpIjoicmdiKCIrbisiLCIrcisiLCIrQSsiKSJ9LHB0PWZ1bmN0aW9uKGUsdCxBLHIpe3JldHVybihlPDwyNHx0PDwxNnxBPDw4fE1hdGgucm91bmQoMjU1KnIpKT4+PjB9LGd0PWZ1bmN0aW9uKGUsdCl7aWYoMTc9PT1lLnR5cGUpcmV0dXJuIGUubnVtYmVyO2lmKDE2PT09ZS50eXBlKXt2YXIgQT0zPT09dD8xOjI1NTtyZXR1cm4gMz09PXQ/ZS5udW1iZXIvMTAwKkE6TWF0aC5yb3VuZChlLm51bWJlci8xMDAqQSl9cmV0dXJuIDB9LG10PWZ1bmN0aW9uKGUsdCl7dmFyIEE9dC5maWx0ZXIoWGUpO2lmKDM9PT1BLmxlbmd0aCl7dmFyIHI9QS5tYXAoZ3QpLG49clswXSxzPXJbMV0saT1yWzJdO3JldHVybiBwdChuLHMsaSwxKX1pZig0PT09QS5sZW5ndGgpe3ZhciBvPUEubWFwKGd0KSxhPShuPW9bMF0scz1vWzFdLGk9b1syXSxvWzNdKTtyZXR1cm4gcHQobixzLGksYSl9cmV0dXJuIDB9O2Z1bmN0aW9uIHd0KGUsdCxBKXtyZXR1cm4gQTwwJiYoQSs9MSksQT49MSYmKEEtPTEpLEE8MS82Pyh0LWUpKkEqNitlOkE8LjU/dDpBPDIvMz82Kih0LWUpKigyLzMtQSkrZTplfXZhciBCdD1mdW5jdGlvbihlLHQpe3ZhciBBPXQuZmlsdGVyKFhlKSxyPUFbMF0sbj1BWzFdLHM9QVsyXSxpPUFbM10sbz0oMTc9PT1yLnR5cGU/dXQoci5udW1iZXIpOmF0KGUscikpLygyKk1hdGguUEkpLGE9JGUobik/bi5udW1iZXIvMTAwOjAsbD0kZShzKT9zLm51bWJlci8xMDA6MCxjPXZvaWQgMCE9PWkmJiRlKGkpP3N0KGksMSk6MTtpZigwPT09YSlyZXR1cm4gcHQoMjU1KmwsMjU1KmwsMjU1KmwsMSk7dmFyIHU9bDw9LjU/bCooYSsxKTpsK2EtbCphLGg9MipsLXUsZD13dChoLHUsbysxLzMpLGY9d3QoaCx1LG8pLHA9d3QoaCx1LG8tMS8zKTtyZXR1cm4gcHQoMjU1KmQsMjU1KmYsMjU1KnAsYyl9LHl0PXtoc2w6QnQsaHNsYTpCdCxyZ2I6bXQscmdiYTptdH0sdnQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaHQoZSxSZS5jcmVhdGUodCkucGFyc2VDb21wb25lbnRWYWx1ZSgpKX0sYnQ9e0FMSUNFQkxVRTo0MDQyODUwMzAzLEFOVElRVUVXSElURTo0MjA5NzYwMjU1LEFRVUE6MTY3NzcyMTUsQVFVQU1BUklORToyMTQ3NDcyNjM5LEFaVVJFOjQwNDMzMDkwNTUsQkVJR0U6NDEyNjUzMDgxNSxCSVNRVUU6NDI5MzE4MjcxOSxCTEFDSzoyNTUsQkxBTkNIRURBTE1PTkQ6NDI5MzY0Mzc3NSxCTFVFOjY1NTM1LEJMVUVWSU9MRVQ6MjMxODEzMTk2NyxCUk9XTjoyNzcxMDA0MTU5LEJVUkxZV09PRDozNzM2NjM1MzkxLENBREVUQkxVRToxNjA0MjMxNDIzLENIQVJUUkVVU0U6MjE0NzQxODM2NyxDSE9DT0xBVEU6MzUzMDEwNDU3NSxDT1JBTDo0Mjg2NTMzODg3LENPUk5GTE9XRVJCTFVFOjE2ODc1NDczOTEsQ09STlNJTEs6NDI5NDQ5OTU4MyxDUklNU09OOjM2OTIzMTM4NTUsQ1lBTjoxNjc3NzIxNSxEQVJLQkxVRTozNTgzOSxEQVJLQ1lBTjo5MTQ1MzQzLERBUktHT0xERU5ST0Q6MzA5NTgzNzY5NSxEQVJLR1JBWToyODQ2NDY4NjA3LERBUktHUkVFTjo2NTUzODU1LERBUktHUkVZOjI4NDY0Njg2MDcsREFSS0tIQUtJOjMxODI5MTQ1NTksREFSS01BR0VOVEE6MjMzMjA2ODg2MyxEQVJLT0xJVkVHUkVFTjoxNDMzMDg3OTk5LERBUktPUkFOR0U6NDI4NzM2NTM3NSxEQVJLT1JDSElEOjI1NzAyNDMzMjcsREFSS1JFRDoyMzMyMDMzMjc5LERBUktTQUxNT046MzkxODk1MzIxNSxEQVJLU0VBR1JFRU46MjQxMTQ5OTUxOSxEQVJLU0xBVEVCTFVFOjEyMTE5OTMwODcsREFSS1NMQVRFR1JBWTo3OTM3MjY5NzUsREFSS1NMQVRFR1JFWTo3OTM3MjY5NzUsREFSS1RVUlFVT0lTRToxMzU1NDE3NSxEQVJLVklPTEVUOjI0ODMwODIyMzksREVFUFBJTks6NDI3OTUzODY4NyxERUVQU0tZQkxVRToxMjU4MjkxMSxESU1HUkFZOjE3Njg1MTYwOTUsRElNR1JFWToxNzY4NTE2MDk1LERPREdFUkJMVUU6NTEyODE5MTk5LEZJUkVCUklDSzoyOTg4NTgxNjMxLEZMT1JBTFdISVRFOjQyOTQ2MzU3NzUsRk9SRVNUR1JFRU46NTc5NTQzODA3LEZVQ0hTSUE6NDI3ODI1NTYxNSxHQUlOU0JPUk86MzcwNTQ2MjAxNSxHSE9TVFdISVRFOjQxNzcwNjgwMzEsR09MRDo0MjkyMjgwNTc1LEdPTERFTlJPRDozNjY4MjU0OTc1LEdSQVk6MjE1NTkwNTI3OSxHUkVFTjo4Mzg4ODYzLEdSRUVOWUVMTE9XOjI5MTkxODIzMzUsR1JFWToyMTU1OTA1Mjc5LEhPTkVZREVXOjQwNDMzMDUyMTUsSE9UUElOSzo0Mjg1MTE3Njk1LElORElBTlJFRDozNDQ1MzgyMzk5LElORElHTzoxMjU4MzI0NzM1LElWT1JZOjQyOTQ5NjM0NTUsS0hBS0k6NDA0MTY0MTIxNSxMQVZFTkRFUjozODczODk3MjE1LExBVkVOREVSQkxVU0g6NDI5Mzk4MTY5NSxMQVdOR1JFRU46MjA5Njg5MDExMSxMRU1PTkNISUZGT046NDI5NDYyNjgxNSxMSUdIVEJMVUU6MjkxNjY3MzI3OSxMSUdIVENPUkFMOjQwMzQ5NTM0NzEsTElHSFRDWUFOOjM3NzQ4NzM1OTksTElHSFRHT0xERU5ST0RZRUxMT1c6NDIxMDc0MjAxNSxMSUdIVEdSQVk6MzU1Mzg3NDk0MyxMSUdIVEdSRUVOOjI0MzE1NTM3OTEsTElHSFRHUkVZOjM1NTM4NzQ5NDMsTElHSFRQSU5LOjQyOTAxNjcyOTUsTElHSFRTQUxNT046NDI4ODcwNzMyNyxMSUdIVFNFQUdSRUVOOjU0ODU4MDA5NSxMSUdIVFNLWUJMVUU6MjI3ODQ4ODgzMSxMSUdIVFNMQVRFR1JBWToyMDA1NDQxMDIzLExJR0hUU0xBVEVHUkVZOjIwMDU0NDEwMjMsTElHSFRTVEVFTEJMVUU6Mjk2NTY5MjE1OSxMSUdIVFlFTExPVzo0Mjk0OTU5MzU5LExJTUU6MTY3MTE5MzUsTElNRUdSRUVOOjg1MjMwODczNSxMSU5FTjo0MjEwMDkxNzc1LE1BR0VOVEE6NDI3ODI1NTYxNSxNQVJPT046MjE0NzQ4MzkwMyxNRURJVU1BUVVBTUFSSU5FOjE3MjQ3NTQ2ODcsTUVESVVNQkxVRTo1MjczNSxNRURJVU1PUkNISUQ6MzEyNjE4NzAwNyxNRURJVU1QVVJQTEU6MjQ3MzY0NzEwMyxNRURJVU1TRUFHUkVFTjoxMDE4MzkzMDg3LE1FRElVTVNMQVRFQkxVRToyMDcwNDc0NDk1LE1FRElVTVNQUklOR0dSRUVOOjE2NDIzNjc5LE1FRElVTVRVUlFVT0lTRToxMjIxNzA5MDU1LE1FRElVTVZJT0xFVFJFRDozMzQwMDc2NTQzLE1JRE5JR0hUQkxVRTo0MjEwOTc3MjcsTUlOVENSRUFNOjQxMjcxOTM4NTUsTUlTVFlST1NFOjQyOTMxOTAxNDMsTU9DQ0FTSU46NDI5MzE3ODg3OSxOQVZBSk9XSElURTo0MjkyNzgzNjE1LE5BVlk6MzMwMjMsT0xETEFDRTo0MjYwNzUxMTAzLE9MSVZFOjIxNTU4NzI1MTEsT0xJVkVEUkFCOjE4MDQ0Nzc0MzksT1JBTkdFOjQyODkwMDM3NzUsT1JBTkdFUkVEOjQyODI3MTIzMTksT1JDSElEOjM2NjQ4MjgxNTksUEFMRUdPTERFTlJPRDo0MDA4MjI1NTM1LFBBTEVHUkVFTjoyNTY2NjI1NTM1LFBBTEVUVVJRVU9JU0U6Mjk1MTY3MTU1MSxQQUxFVklPTEVUUkVEOjM2ODE1ODgyMjMsUEFQQVlBV0hJUDo0MjkzOTA3OTY3LFBFQUNIUFVGRjo0MjkyNTI0NTQzLFBFUlU6MzQ0ODA2MTk1MSxQSU5LOjQyOTA4MjUyMTUsUExVTTozNzE4MzA3MzI3LFBPV0RFUkJMVUU6Mjk2NzUyOTIxNSxQVVJQTEU6MjE0NzUxNjY3MSxSRUJFQ0NBUFVSUExFOjE3MTQ2NTc3OTEsUkVEOjQyNzgxOTAzMzUsUk9TWUJST1dOOjMxNjM1MjUxMTksUk9ZQUxCTFVFOjEwOTc0NTgxNzUsU0FERExFQlJPV046MjMzNjU2MDEyNyxTQUxNT046NDIwMjcyMjA0NyxTQU5EWUJST1dOOjQxMDQ0MTM0MzksU0VBR1JFRU46NzgwODgzOTY3LFNFQVNIRUxMOjQyOTQzMDc1ODMsU0lFTk5BOjI2ODk3NDAyODcsU0lMVkVSOjMyMzM4NTc3OTEsU0tZQkxVRToyMjc4NDg0OTkxLFNMQVRFQkxVRToxNzg0MzM1ODcxLFNMQVRFR1JBWToxODg3NDczOTE5LFNMQVRFR1JFWToxODg3NDczOTE5LFNOT1c6NDI5NDYzODMzNSxTUFJJTkdHUkVFTjoxNjc0NDQ0NyxTVEVFTEJMVUU6MTE4Mjk3MTEzNSxUQU46MzUzNTA0NzkzNSxURUFMOjg0MjE2MzEsVEhJU1RMRTozNjM2NDUxNTgzLFRPTUFUTzo0Mjg0Njk2NTc1LFRSQU5TUEFSRU5UOjAsVFVSUVVPSVNFOjEwODg0NzUzOTEsVklPTEVUOjQwMDE1NTgyNzEsV0hFQVQ6NDEyNTAxMjk5MSxXSElURTo0Mjk0OTY3Mjk1LFdISVRFU01PS0U6NDEyNjUzNzIxNSxZRUxMT1c6NDI5NDkwMjAxNSxZRUxMT1dHUkVFTjoyNTk3MTM5MTk5fSxDdD17bmFtZToiYmFja2dyb3VuZC1jbGlwIixpbml0aWFsVmFsdWU6ImJvcmRlci1ib3giLHByZWZpeDohMSx0eXBlOjEscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24oZSl7aWYoR2UoZSkpc3dpdGNoKGUudmFsdWUpe2Nhc2UicGFkZGluZy1ib3giOnJldHVybiAxO2Nhc2UiY29udGVudC1ib3giOnJldHVybiAyfXJldHVybiAwfSl9fSxfdD17bmFtZToiYmFja2dyb3VuZC1jb2xvciIsaW5pdGlhbFZhbHVlOiJ0cmFuc3BhcmVudCIscHJlZml4OiExLHR5cGU6Myxmb3JtYXQ6ImNvbG9yIn0sanQ9ZnVuY3Rpb24oZSx0KXt2YXIgQT1odChlLHRbMF0pLHI9dFsxXTtyZXR1cm4gciYmJGUocik/e2NvbG9yOkEsc3RvcDpyfTp7Y29sb3I6QSxzdG9wOm51bGx9fSx4dD1mdW5jdGlvbihlLHQpe3ZhciBBPWVbMF0scj1lW2UubGVuZ3RoLTFdO251bGw9PT1BLnN0b3AmJihBLnN0b3A9dHQpLG51bGw9PT1yLnN0b3AmJihyLnN0b3A9cnQpO2Zvcih2YXIgbj1bXSxzPTAsaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbz1lW2ldLnN0b3A7aWYobnVsbCE9PW8pe3ZhciBhPXN0KG8sdCk7YT5zP24ucHVzaChhKTpuLnB1c2gocykscz1hfWVsc2Ugbi5wdXNoKG51bGwpfXZhciBsPW51bGw7Zm9yKGk9MDtpPG4ubGVuZ3RoO2krKyl7dmFyIGM9bltpXTtpZihudWxsPT09YyludWxsPT09bCYmKGw9aSk7ZWxzZSBpZihudWxsIT09bCl7Zm9yKHZhciB1PWktbCxoPShjLW5bbC0xXSkvKHUrMSksZD0xO2Q8PXU7ZCsrKW5bbCtkLTFdPWgqZDtsPW51bGx9fXJldHVybiBlLm1hcChmdW5jdGlvbihlLEEpe3JldHVybntjb2xvcjplLmNvbG9yLHN0b3A6TWF0aC5tYXgoTWF0aC5taW4oMSxuW0FdL3QpLDApfX0pfSxGdD1mdW5jdGlvbihlLHQsQSl7dmFyIHI9Im51bWJlciI9PXR5cGVvZiBlP2U6ZnVuY3Rpb24oZSx0LEEpe3ZhciByPXQvMixuPUEvMixzPXN0KGVbMF0sdCktcixpPW4tc3QoZVsxXSxBKTtyZXR1cm4oTWF0aC5hdGFuMihpLHMpKzIqTWF0aC5QSSklKDIqTWF0aC5QSSl9KGUsdCxBKSxuPU1hdGguYWJzKHQqTWF0aC5zaW4ocikpK01hdGguYWJzKEEqTWF0aC5jb3MocikpLHM9dC8yLGk9QS8yLG89bi8yLGE9TWF0aC5zaW4oci1NYXRoLlBJLzIpKm8sbD1NYXRoLmNvcyhyLU1hdGguUEkvMikqbztyZXR1cm5bbixzLWwscytsLGktYSxpK2FdfSxRdD1mdW5jdGlvbihlLHQpe3JldHVybiBNYXRoLnNxcnQoZSplK3QqdCl9LFV0PWZ1bmN0aW9uKGUsdCxBLHIsbil7cmV0dXJuW1swLDBdLFswLHRdLFtlLDBdLFtlLHRdXS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXt2YXIgcz10WzBdLGk9dFsxXSxvPVF0KEEtcyxyLWkpO3JldHVybihuP288ZS5vcHRpbXVtRGlzdGFuY2U6bz5lLm9wdGltdW1EaXN0YW5jZSk/e29wdGltdW1Db3JuZXI6dCxvcHRpbXVtRGlzdGFuY2U6b306ZX0se29wdGltdW1EaXN0YW5jZTpuPzEvMDotMS8wLG9wdGltdW1Db3JuZXI6bnVsbH0pLm9wdGltdW1Db3JuZXJ9LEV0PWZ1bmN0aW9uKGUsdCl7dmFyIEE9dXQoMTgwKSxyPVtdO3JldHVybiBZZSh0KS5mb3JFYWNoKGZ1bmN0aW9uKHQsbil7aWYoMD09PW4pe3ZhciBzPXRbMF07aWYoMjA9PT1zLnR5cGUmJi0xIT09WyJ0b3AiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iXS5pbmRleE9mKHMudmFsdWUpKXJldHVybiB2b2lkKEE9Y3QodCkpO2lmKGx0KHMpKXJldHVybiB2b2lkKEE9KGF0KGUscykrdXQoMjcwKSkldXQoMzYwKSl9dmFyIGk9anQoZSx0KTtyLnB1c2goaSl9KSx7YW5nbGU6QSxzdG9wczpyLHR5cGU6MX19LFN0PSJjbG9zZXN0LXNpZGUiLEx0PSJmYXJ0aGVzdC1zaWRlIixJdD0iY2xvc2VzdC1jb3JuZXIiLE50PSJmYXJ0aGVzdC1jb3JuZXIiLGt0PSJjaXJjbGUiLEh0PSJlbGxpcHNlIixQdD0iY292ZXIiLFR0PSJjb250YWluIixPdD1mdW5jdGlvbihlLHQpe3ZhciBBPTAscj0zLG49W10scz1bXTtyZXR1cm4gWWUodCkuZm9yRWFjaChmdW5jdGlvbih0LGkpe3ZhciBvPSEwO2lmKDA9PT1pP289dC5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtpZihHZSh0KSlzd2l0Y2godC52YWx1ZSl7Y2FzZSJjZW50ZXIiOnJldHVybiBzLnB1c2goQXQpLCExO2Nhc2UidG9wIjpjYXNlImxlZnQiOnJldHVybiBzLnB1c2godHQpLCExO2Nhc2UicmlnaHQiOmNhc2UiYm90dG9tIjpyZXR1cm4gcy5wdXNoKHJ0KSwhMX1lbHNlIGlmKCRlKHQpfHxaZSh0KSlyZXR1cm4gcy5wdXNoKHQpLCExO3JldHVybiBlfSxvKToxPT09aSYmKG89dC5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtpZihHZSh0KSlzd2l0Y2godC52YWx1ZSl7Y2FzZSBrdDpyZXR1cm4gQT0wLCExO2Nhc2UgSHQ6cmV0dXJuIEE9MSwhMTtjYXNlIFR0OmNhc2UgU3Q6cmV0dXJuIHI9MCwhMTtjYXNlIEx0OnJldHVybiByPTEsITE7Y2FzZSBJdDpyZXR1cm4gcj0yLCExO2Nhc2UgUHQ6Y2FzZSBOdDpyZXR1cm4gcj0zLCExfWVsc2UgaWYoWmUodCl8fCRlKHQpKXJldHVybiBBcnJheS5pc0FycmF5KHIpfHwocj1bXSksci5wdXNoKHQpLCExO3JldHVybiBlfSxvKSksbyl7dmFyIGE9anQoZSx0KTtuLnB1c2goYSl9fSkse3NpemU6cixzaGFwZTpBLHN0b3BzOm4scG9zaXRpb246cyx0eXBlOjJ9fSxNdD1mdW5jdGlvbihlLHQpe2lmKDIyPT09dC50eXBlKXt2YXIgQT17dXJsOnQudmFsdWUsdHlwZTowfTtyZXR1cm4gZS5jYWNoZS5hZGRJbWFnZSh0LnZhbHVlKSxBfWlmKDE4PT09dC50eXBlKXt2YXIgcj1SdFt0Lm5hbWVdO2lmKHZvaWQgMD09PXIpdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHBhcnNlIGFuIHVuc3VwcG9ydGVkIGltYWdlIGZ1bmN0aW9uICInK3QubmFtZSsnIicpO3JldHVybiByKGUsdC52YWx1ZXMpfXRocm93IG5ldyBFcnJvcigiVW5zdXBwb3J0ZWQgaW1hZ2UgdHlwZSAiK3QudHlwZSl9O3ZhciBEdCxSdD17ImxpbmVhci1ncmFkaWVudCI6ZnVuY3Rpb24oZSx0KXt2YXIgQT11dCgxODApLHI9W107cmV0dXJuIFllKHQpLmZvckVhY2goZnVuY3Rpb24odCxuKXtpZigwPT09bil7dmFyIHM9dFswXTtpZigyMD09PXMudHlwZSYmInRvIj09PXMudmFsdWUpcmV0dXJuIHZvaWQoQT1jdCh0KSk7aWYobHQocykpcmV0dXJuIHZvaWQoQT1hdChlLHMpKX12YXIgaT1qdChlLHQpO3IucHVzaChpKX0pLHthbmdsZTpBLHN0b3BzOnIsdHlwZToxfX0sIi1tb3otbGluZWFyLWdyYWRpZW50IjpFdCwiLW1zLWxpbmVhci1ncmFkaWVudCI6RXQsIi1vLWxpbmVhci1ncmFkaWVudCI6RXQsIi13ZWJraXQtbGluZWFyLWdyYWRpZW50IjpFdCwicmFkaWFsLWdyYWRpZW50IjpmdW5jdGlvbihlLHQpe3ZhciBBPTAscj0zLG49W10scz1bXTtyZXR1cm4gWWUodCkuZm9yRWFjaChmdW5jdGlvbih0LGkpe3ZhciBvPSEwO2lmKDA9PT1pKXt2YXIgYT0hMTtvPXQucmVkdWNlKGZ1bmN0aW9uKGUsdCl7aWYoYSlpZihHZSh0KSlzd2l0Y2godC52YWx1ZSl7Y2FzZSJjZW50ZXIiOnJldHVybiBzLnB1c2goQXQpLGU7Y2FzZSJ0b3AiOmNhc2UibGVmdCI6cmV0dXJuIHMucHVzaCh0dCksZTtjYXNlInJpZ2h0IjpjYXNlImJvdHRvbSI6cmV0dXJuIHMucHVzaChydCksZX1lbHNlKCRlKHQpfHxaZSh0KSkmJnMucHVzaCh0KTtlbHNlIGlmKEdlKHQpKXN3aXRjaCh0LnZhbHVlKXtjYXNlIGt0OnJldHVybiBBPTAsITE7Y2FzZSBIdDpyZXR1cm4gQT0xLCExO2Nhc2UiYXQiOnJldHVybiBhPSEwLCExO2Nhc2UgU3Q6cmV0dXJuIHI9MCwhMTtjYXNlIFB0OmNhc2UgTHQ6cmV0dXJuIHI9MSwhMTtjYXNlIFR0OmNhc2UgSXQ6cmV0dXJuIHI9MiwhMTtjYXNlIE50OnJldHVybiByPTMsITF9ZWxzZSBpZihaZSh0KXx8JGUodCkpcmV0dXJuIEFycmF5LmlzQXJyYXkocil8fChyPVtdKSxyLnB1c2godCksITE7cmV0dXJuIGV9LG8pfWlmKG8pe3ZhciBsPWp0KGUsdCk7bi5wdXNoKGwpfX0pLHtzaXplOnIsc2hhcGU6QSxzdG9wczpuLHBvc2l0aW9uOnMsdHlwZToyfX0sIi1tb3otcmFkaWFsLWdyYWRpZW50IjpPdCwiLW1zLXJhZGlhbC1ncmFkaWVudCI6T3QsIi1vLXJhZGlhbC1ncmFkaWVudCI6T3QsIi13ZWJraXQtcmFkaWFsLWdyYWRpZW50IjpPdCwiLXdlYmtpdC1ncmFkaWVudCI6ZnVuY3Rpb24oZSx0KXt2YXIgQT11dCgxODApLHI9W10sbj0xO3JldHVybiBZZSh0KS5mb3JFYWNoKGZ1bmN0aW9uKHQsQSl7dmFyIHM9dFswXTtpZigwPT09QSl7aWYoR2UocykmJiJsaW5lYXIiPT09cy52YWx1ZSlyZXR1cm4gdm9pZChuPTEpO2lmKEdlKHMpJiYicmFkaWFsIj09PXMudmFsdWUpcmV0dXJuIHZvaWQobj0yKX1pZigxOD09PXMudHlwZSlpZigiZnJvbSI9PT1zLm5hbWUpe3ZhciBpPWh0KGUscy52YWx1ZXNbMF0pO3IucHVzaCh7c3RvcDp0dCxjb2xvcjppfSl9ZWxzZSBpZigidG8iPT09cy5uYW1lKWk9aHQoZSxzLnZhbHVlc1swXSksci5wdXNoKHtzdG9wOnJ0LGNvbG9yOml9KTtlbHNlIGlmKCJjb2xvci1zdG9wIj09PXMubmFtZSl7dmFyIG89cy52YWx1ZXMuZmlsdGVyKFhlKTtpZigyPT09by5sZW5ndGgpe2k9aHQoZSxvWzFdKTt2YXIgYT1vWzBdO1ZlKGEpJiZyLnB1c2goe3N0b3A6e3R5cGU6MTYsbnVtYmVyOjEwMCphLm51bWJlcixmbGFnczphLmZsYWdzfSxjb2xvcjppfSl9fX0pLDE9PT1uP3thbmdsZTooQSt1dCgxODApKSV1dCgzNjApLHN0b3BzOnIsdHlwZTpufTp7c2l6ZTozLHNoYXBlOjAsc3RvcHM6cixwb3NpdGlvbjpbXSx0eXBlOm59fX0sS3Q9e25hbWU6ImJhY2tncm91bmQtaW1hZ2UiLGluaXRpYWxWYWx1ZToibm9uZSIsdHlwZToxLHByZWZpeDohMSxwYXJzZTpmdW5jdGlvbihlLHQpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm5bXTt2YXIgQT10WzBdO3JldHVybiAyMD09PUEudHlwZSYmIm5vbmUiPT09QS52YWx1ZT9bXTp0LmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gWGUoZSkmJmZ1bmN0aW9uKGUpe3JldHVybiEoMjA9PT1lLnR5cGUmJiJub25lIj09PWUudmFsdWV8fDE4PT09ZS50eXBlJiYhUnRbZS5uYW1lXSl9KGUpfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBNdChlLHQpfSl9fSxWdD17bmFtZToiYmFja2dyb3VuZC1vcmlnaW4iLGluaXRpYWxWYWx1ZToiYm9yZGVyLWJveCIscHJlZml4OiExLHR5cGU6MSxwYXJzZTpmdW5jdGlvbihlLHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbihlKXtpZihHZShlKSlzd2l0Y2goZS52YWx1ZSl7Y2FzZSJwYWRkaW5nLWJveCI6cmV0dXJuIDE7Y2FzZSJjb250ZW50LWJveCI6cmV0dXJuIDJ9cmV0dXJuIDB9KX19LEd0PXtuYW1lOiJiYWNrZ3JvdW5kLXBvc2l0aW9uIixpbml0aWFsVmFsdWU6IjAlIDAlIix0eXBlOjEscHJlZml4OiExLHBhcnNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIFllKHQpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5maWx0ZXIoJGUpfSkubWFwKGV0KX19LHp0PXtuYW1lOiJiYWNrZ3JvdW5kLXJlcGVhdCIsaW5pdGlhbFZhbHVlOiJyZXBlYXQiLHByZWZpeDohMSx0eXBlOjEscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gWWUodCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmZpbHRlcihHZSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnZhbHVlfSkuam9pbigiICIpfSkubWFwKHF0KX19LHF0PWZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlIm5vLXJlcGVhdCI6cmV0dXJuIDE7Y2FzZSJyZXBlYXQteCI6Y2FzZSJyZXBlYXQgbm8tcmVwZWF0IjpyZXR1cm4gMjtjYXNlInJlcGVhdC15IjpjYXNlIm5vLXJlcGVhdCByZXBlYXQiOnJldHVybiAzO2RlZmF1bHQ6cmV0dXJuIDB9fTshZnVuY3Rpb24oZSl7ZS5BVVRPPSJhdXRvIixlLkNPTlRBSU49ImNvbnRhaW4iLGUuQ09WRVI9ImNvdmVyIn0oRHR8fChEdD17fSkpO3ZhciBXdCxYdD17bmFtZToiYmFja2dyb3VuZC1zaXplIixpbml0aWFsVmFsdWU6IjAiLHByZWZpeDohMSx0eXBlOjEscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gWWUodCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmZpbHRlcihZdCl9KX19LFl0PWZ1bmN0aW9uKGUpe3JldHVybiBHZShlKXx8JGUoZSl9LEp0PWZ1bmN0aW9uKGUpe3JldHVybntuYW1lOiJib3JkZXItIitlKyItY29sb3IiLGluaXRpYWxWYWx1ZToidHJhbnNwYXJlbnQiLHByZWZpeDohMSx0eXBlOjMsZm9ybWF0OiJjb2xvciJ9fSxadD1KdCgidG9wIiksJHQ9SnQoInJpZ2h0IiksZUE9SnQoImJvdHRvbSIpLHRBPUp0KCJsZWZ0IiksQUE9ZnVuY3Rpb24oZSl7cmV0dXJue25hbWU6ImJvcmRlci1yYWRpdXMtIitlLGluaXRpYWxWYWx1ZToiMCAwIixwcmVmaXg6ITEsdHlwZToxLHBhcnNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGV0KHQuZmlsdGVyKCRlKSl9fX0sckE9QUEoInRvcC1sZWZ0IiksbkE9QUEoInRvcC1yaWdodCIpLHNBPUFBKCJib3R0b20tcmlnaHQiKSxpQT1BQSgiYm90dG9tLWxlZnQiKSxvQT1mdW5jdGlvbihlKXtyZXR1cm57bmFtZToiYm9yZGVyLSIrZSsiLXN0eWxlIixpbml0aWFsVmFsdWU6InNvbGlkIixwcmVmaXg6ITEsdHlwZToyLHBhcnNlOmZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2Uibm9uZSI6cmV0dXJuIDA7Y2FzZSJkYXNoZWQiOnJldHVybiAyO2Nhc2UiZG90dGVkIjpyZXR1cm4gMztjYXNlImRvdWJsZSI6cmV0dXJuIDR9cmV0dXJuIDF9fX0sYUE9b0EoInRvcCIpLGxBPW9BKCJyaWdodCIpLGNBPW9BKCJib3R0b20iKSx1QT1vQSgibGVmdCIpLGhBPWZ1bmN0aW9uKGUpe3JldHVybntuYW1lOiJib3JkZXItIitlKyItd2lkdGgiLGluaXRpYWxWYWx1ZToiMCIsdHlwZTowLHByZWZpeDohMSxwYXJzZTpmdW5jdGlvbihlLHQpe3JldHVybiBLZSh0KT90Lm51bWJlcjowfX19LGRBPWhBKCJ0b3AiKSxmQT1oQSgicmlnaHQiKSxwQT1oQSgiYm90dG9tIiksZ0E9aEEoImxlZnQiKSxtQT17bmFtZToiY29sb3IiLGluaXRpYWxWYWx1ZToidHJhbnNwYXJlbnQiLHByZWZpeDohMSx0eXBlOjMsZm9ybWF0OiJjb2xvciJ9LHdBPXtuYW1lOiJkaXJlY3Rpb24iLGluaXRpYWxWYWx1ZToibHRyIixwcmVmaXg6ITEsdHlwZToyLHBhcnNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuInJ0bCI9PT10PzE6MH19LEJBPXtuYW1lOiJkaXNwbGF5Iixpbml0aWFsVmFsdWU6ImlubGluZS1ibG9jayIscHJlZml4OiExLHR5cGU6MSxwYXJzZTpmdW5jdGlvbihlLHQpe3JldHVybiB0LmZpbHRlcihHZSkucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGV8eUEodC52YWx1ZSl9LDApfX0seUE9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2UiYmxvY2siOmNhc2UiLXdlYmtpdC1ib3giOnJldHVybiAyO2Nhc2UiaW5saW5lIjpyZXR1cm4gNDtjYXNlInJ1bi1pbiI6cmV0dXJuIDg7Y2FzZSJmbG93IjpyZXR1cm4gMTY7Y2FzZSJmbG93LXJvb3QiOnJldHVybiAzMjtjYXNlInRhYmxlIjpyZXR1cm4gNjQ7Y2FzZSJmbGV4IjpjYXNlIi13ZWJraXQtZmxleCI6cmV0dXJuIDEyODtjYXNlImdyaWQiOmNhc2UiLW1zLWdyaWQiOnJldHVybiAyNTY7Y2FzZSJydWJ5IjpyZXR1cm4gNTEyO2Nhc2Uic3ViZ3JpZCI6cmV0dXJuIDEwMjQ7Y2FzZSJsaXN0LWl0ZW0iOnJldHVybiAyMDQ4O2Nhc2UidGFibGUtcm93LWdyb3VwIjpyZXR1cm4gNDA5NjtjYXNlInRhYmxlLWhlYWRlci1ncm91cCI6cmV0dXJuIDgxOTI7Y2FzZSJ0YWJsZS1mb290ZXItZ3JvdXAiOnJldHVybiAxNjM4NDtjYXNlInRhYmxlLXJvdyI6cmV0dXJuIDMyNzY4O2Nhc2UidGFibGUtY2VsbCI6cmV0dXJuIDY1NTM2O2Nhc2UidGFibGUtY29sdW1uLWdyb3VwIjpyZXR1cm4gMTMxMDcyO2Nhc2UidGFibGUtY29sdW1uIjpyZXR1cm4gMjYyMTQ0O2Nhc2UidGFibGUtY2FwdGlvbiI6cmV0dXJuIDUyNDI4ODtjYXNlInJ1YnktYmFzZSI6cmV0dXJuIDEwNDg1NzY7Y2FzZSJydWJ5LXRleHQiOnJldHVybiAyMDk3MTUyO2Nhc2UicnVieS1iYXNlLWNvbnRhaW5lciI6cmV0dXJuIDQxOTQzMDQ7Y2FzZSJydWJ5LXRleHQtY29udGFpbmVyIjpyZXR1cm4gODM4ODYwODtjYXNlImNvbnRlbnRzIjpyZXR1cm4gMTY3NzcyMTY7Y2FzZSJpbmxpbmUtYmxvY2siOnJldHVybiAzMzU1NDQzMjtjYXNlImlubGluZS1saXN0LWl0ZW0iOnJldHVybiA2NzEwODg2NDtjYXNlImlubGluZS10YWJsZSI6cmV0dXJuIDEzNDIxNzcyODtjYXNlImlubGluZS1mbGV4IjpyZXR1cm4gMjY4NDM1NDU2O2Nhc2UiaW5saW5lLWdyaWQiOnJldHVybiA1MzY4NzA5MTJ9cmV0dXJuIDB9LHZBPXtuYW1lOiJmbG9hdCIsaW5pdGlhbFZhbHVlOiJub25lIixwcmVmaXg6ITEsdHlwZToyLHBhcnNlOmZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2UibGVmdCI6cmV0dXJuIDE7Y2FzZSJyaWdodCI6cmV0dXJuIDI7Y2FzZSJpbmxpbmUtc3RhcnQiOnJldHVybiAzO2Nhc2UiaW5saW5lLWVuZCI6cmV0dXJuIDR9cmV0dXJuIDB9fSxiQT17bmFtZToibGV0dGVyLXNwYWNpbmciLGluaXRpYWxWYWx1ZToiMCIscHJlZml4OiExLHR5cGU6MCxwYXJzZTpmdW5jdGlvbihlLHQpe3JldHVybiAyMD09PXQudHlwZSYmIm5vcm1hbCI9PT10LnZhbHVlPzA6MTc9PT10LnR5cGV8fDE1PT09dC50eXBlP3QubnVtYmVyOjB9fTshZnVuY3Rpb24oZSl7ZS5OT1JNQUw9Im5vcm1hbCIsZS5TVFJJQ1Q9InN0cmljdCJ9KFd0fHwoV3Q9e30pKTt2YXIgQ0EsX0E9e25hbWU6ImxpbmUtYnJlYWsiLGluaXRpYWxWYWx1ZToibm9ybWFsIixwcmVmaXg6ITEsdHlwZToyLHBhcnNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuInN0cmljdCI9PT10P1d0LlNUUklDVDpXdC5OT1JNQUx9fSxqQT17bmFtZToibGluZS1oZWlnaHQiLGluaXRpYWxWYWx1ZToibm9ybWFsIixwcmVmaXg6ITEsdHlwZTo0fSx4QT1mdW5jdGlvbihlLHQpe3JldHVybiBHZShlKSYmIm5vcm1hbCI9PT1lLnZhbHVlPzEuMip0OjE3PT09ZS50eXBlP3QqZS5udW1iZXI6JGUoZSk/c3QoZSx0KTp0fSxGQT17bmFtZToibGlzdC1zdHlsZS1pbWFnZSIsaW5pdGlhbFZhbHVlOiJub25lIix0eXBlOjAscHJlZml4OiExLHBhcnNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIDIwPT09dC50eXBlJiYibm9uZSI9PT10LnZhbHVlP251bGw6TXQoZSx0KX19LFFBPXtuYW1lOiJsaXN0LXN0eWxlLXBvc2l0aW9uIixpbml0aWFsVmFsdWU6Im91dHNpZGUiLHByZWZpeDohMSx0eXBlOjIscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4iaW5zaWRlIj09PXQ/MDoxfX0sVUE9e25hbWU6Imxpc3Qtc3R5bGUtdHlwZSIsaW5pdGlhbFZhbHVlOiJub25lIixwcmVmaXg6ITEsdHlwZToyLHBhcnNlOmZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2UiZGlzYyI6cmV0dXJuIDA7Y2FzZSJjaXJjbGUiOnJldHVybiAxO2Nhc2Uic3F1YXJlIjpyZXR1cm4gMjtjYXNlImRlY2ltYWwiOnJldHVybiAzO2Nhc2UiY2prLWRlY2ltYWwiOnJldHVybiA0O2Nhc2UiZGVjaW1hbC1sZWFkaW5nLXplcm8iOnJldHVybiA1O2Nhc2UibG93ZXItcm9tYW4iOnJldHVybiA2O2Nhc2UidXBwZXItcm9tYW4iOnJldHVybiA3O2Nhc2UibG93ZXItZ3JlZWsiOnJldHVybiA4O2Nhc2UibG93ZXItYWxwaGEiOnJldHVybiA5O2Nhc2UidXBwZXItYWxwaGEiOnJldHVybiAxMDtjYXNlImFyYWJpYy1pbmRpYyI6cmV0dXJuIDExO2Nhc2UiYXJtZW5pYW4iOnJldHVybiAxMjtjYXNlImJlbmdhbGkiOnJldHVybiAxMztjYXNlImNhbWJvZGlhbiI6cmV0dXJuIDE0O2Nhc2UiY2prLWVhcnRobHktYnJhbmNoIjpyZXR1cm4gMTU7Y2FzZSJjamstaGVhdmVubHktc3RlbSI6cmV0dXJuIDE2O2Nhc2UiY2prLWlkZW9ncmFwaGljIjpyZXR1cm4gMTc7Y2FzZSJkZXZhbmFnYXJpIjpyZXR1cm4gMTg7Y2FzZSJldGhpb3BpYy1udW1lcmljIjpyZXR1cm4gMTk7Y2FzZSJnZW9yZ2lhbiI6cmV0dXJuIDIwO2Nhc2UiZ3VqYXJhdGkiOnJldHVybiAyMTtjYXNlImd1cm11a2hpIjpjYXNlImhlYnJldyI6cmV0dXJuIDIyO2Nhc2UiaGlyYWdhbmEiOnJldHVybiAyMztjYXNlImhpcmFnYW5hLWlyb2hhIjpyZXR1cm4gMjQ7Y2FzZSJqYXBhbmVzZS1mb3JtYWwiOnJldHVybiAyNTtjYXNlImphcGFuZXNlLWluZm9ybWFsIjpyZXR1cm4gMjY7Y2FzZSJrYW5uYWRhIjpyZXR1cm4gMjc7Y2FzZSJrYXRha2FuYSI6cmV0dXJuIDI4O2Nhc2Uia2F0YWthbmEtaXJvaGEiOnJldHVybiAyOTtjYXNlImtobWVyIjpyZXR1cm4gMzA7Y2FzZSJrb3JlYW4taGFuZ3VsLWZvcm1hbCI6cmV0dXJuIDMxO2Nhc2Uia29yZWFuLWhhbmphLWZvcm1hbCI6cmV0dXJuIDMyO2Nhc2Uia29yZWFuLWhhbmphLWluZm9ybWFsIjpyZXR1cm4gMzM7Y2FzZSJsYW8iOnJldHVybiAzNDtjYXNlImxvd2VyLWFybWVuaWFuIjpyZXR1cm4gMzU7Y2FzZSJtYWxheWFsYW0iOnJldHVybiAzNjtjYXNlIm1vbmdvbGlhbiI6cmV0dXJuIDM3O2Nhc2UibXlhbm1hciI6cmV0dXJuIDM4O2Nhc2Uib3JpeWEiOnJldHVybiAzOTtjYXNlInBlcnNpYW4iOnJldHVybiA0MDtjYXNlInNpbXAtY2hpbmVzZS1mb3JtYWwiOnJldHVybiA0MTtjYXNlInNpbXAtY2hpbmVzZS1pbmZvcm1hbCI6cmV0dXJuIDQyO2Nhc2UidGFtaWwiOnJldHVybiA0MztjYXNlInRlbHVndSI6cmV0dXJuIDQ0O2Nhc2UidGhhaSI6cmV0dXJuIDQ1O2Nhc2UidGliZXRhbiI6cmV0dXJuIDQ2O2Nhc2UidHJhZC1jaGluZXNlLWZvcm1hbCI6cmV0dXJuIDQ3O2Nhc2UidHJhZC1jaGluZXNlLWluZm9ybWFsIjpyZXR1cm4gNDg7Y2FzZSJ1cHBlci1hcm1lbmlhbiI6cmV0dXJuIDQ5O2Nhc2UiZGlzY2xvc3VyZS1vcGVuIjpyZXR1cm4gNTA7Y2FzZSJkaXNjbG9zdXJlLWNsb3NlZCI6cmV0dXJuIDUxO2RlZmF1bHQ6cmV0dXJuLTF9fX0sRUE9ZnVuY3Rpb24oZSl7cmV0dXJue25hbWU6Im1hcmdpbi0iK2UsaW5pdGlhbFZhbHVlOiIwIixwcmVmaXg6ITEsdHlwZTo0fX0sU0E9RUEoInRvcCIpLExBPUVBKCJyaWdodCIpLElBPUVBKCJib3R0b20iKSxOQT1FQSgibGVmdCIpLGtBPXtuYW1lOiJvdmVyZmxvdyIsaW5pdGlhbFZhbHVlOiJ2aXNpYmxlIixwcmVmaXg6ITEsdHlwZToxLHBhcnNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQuZmlsdGVyKEdlKS5tYXAoZnVuY3Rpb24oZSl7c3dpdGNoKGUudmFsdWUpe2Nhc2UiaGlkZGVuIjpyZXR1cm4gMTtjYXNlInNjcm9sbCI6cmV0dXJuIDI7Y2FzZSJjbGlwIjpyZXR1cm4gMztjYXNlImF1dG8iOnJldHVybiA0O2RlZmF1bHQ6cmV0dXJuIDB9fSl9fSxIQT17bmFtZToib3ZlcmZsb3ctd3JhcCIsaW5pdGlhbFZhbHVlOiJub3JtYWwiLHByZWZpeDohMSx0eXBlOjIscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4iYnJlYWstd29yZCI9PT10PyJicmVhay13b3JkIjoibm9ybWFsIn19LFBBPWZ1bmN0aW9uKGUpe3JldHVybntuYW1lOiJwYWRkaW5nLSIrZSxpbml0aWFsVmFsdWU6IjAiLHByZWZpeDohMSx0eXBlOjMsZm9ybWF0OiJsZW5ndGgtcGVyY2VudGFnZSJ9fSxUQT1QQSgidG9wIiksT0E9UEEoInJpZ2h0IiksTUE9UEEoImJvdHRvbSIpLERBPVBBKCJsZWZ0IiksUkE9e25hbWU6InRleHQtYWxpZ24iLGluaXRpYWxWYWx1ZToibGVmdCIscHJlZml4OiExLHR5cGU6MixwYXJzZTpmdW5jdGlvbihlLHQpe3N3aXRjaCh0KXtjYXNlInJpZ2h0IjpyZXR1cm4gMjtjYXNlImNlbnRlciI6Y2FzZSJqdXN0aWZ5IjpyZXR1cm4gMTtkZWZhdWx0OnJldHVybiAwfX19LEtBPXtuYW1lOiJwb3NpdGlvbiIsaW5pdGlhbFZhbHVlOiJzdGF0aWMiLHByZWZpeDohMSx0eXBlOjIscGFyc2U6ZnVuY3Rpb24oZSx0KXtzd2l0Y2godCl7Y2FzZSJyZWxhdGl2ZSI6cmV0dXJuIDE7Y2FzZSJhYnNvbHV0ZSI6cmV0dXJuIDI7Y2FzZSJmaXhlZCI6cmV0dXJuIDM7Y2FzZSJzdGlja3kiOnJldHVybiA0fXJldHVybiAwfX0sVkE9e25hbWU6InRleHQtc2hhZG93Iixpbml0aWFsVmFsdWU6Im5vbmUiLHR5cGU6MSxwcmVmaXg6ITEscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMT09PXQubGVuZ3RoJiZxZSh0WzBdLCJub25lIik/W106WWUodCkubWFwKGZ1bmN0aW9uKHQpe2Zvcih2YXIgQT17Y29sb3I6YnQuVFJBTlNQQVJFTlQsb2Zmc2V0WDp0dCxvZmZzZXRZOnR0LGJsdXI6dHR9LHI9MCxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBzPXRbbl07WmUocyk/KDA9PT1yP0Eub2Zmc2V0WD1zOjE9PT1yP0Eub2Zmc2V0WT1zOkEuYmx1cj1zLHIrKyk6QS5jb2xvcj1odChlLHMpfXJldHVybiBBfSl9fSxHQT17bmFtZToidGV4dC10cmFuc2Zvcm0iLGluaXRpYWxWYWx1ZToibm9uZSIscHJlZml4OiExLHR5cGU6MixwYXJzZTpmdW5jdGlvbihlLHQpe3N3aXRjaCh0KXtjYXNlInVwcGVyY2FzZSI6cmV0dXJuIDI7Y2FzZSJsb3dlcmNhc2UiOnJldHVybiAxO2Nhc2UiY2FwaXRhbGl6ZSI6cmV0dXJuIDN9cmV0dXJuIDB9fSx6QT17bmFtZToidHJhbnNmb3JtIixpbml0aWFsVmFsdWU6Im5vbmUiLHByZWZpeDohMCx0eXBlOjAscGFyc2U6ZnVuY3Rpb24oZSx0KXtpZigyMD09PXQudHlwZSYmIm5vbmUiPT09dC52YWx1ZSlyZXR1cm4gbnVsbDtpZigxOD09PXQudHlwZSl7dmFyIEE9cUFbdC5uYW1lXTtpZih2b2lkIDA9PT1BKXRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBwYXJzZSBhbiB1bnN1cHBvcnRlZCB0cmFuc2Zvcm0gZnVuY3Rpb24gIicrdC5uYW1lKyciJyk7cmV0dXJuIEEodC52YWx1ZXMpfXJldHVybiBudWxsfX0scUE9e21hdHJpeDpmdW5jdGlvbihlKXt2YXIgdD1lLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gMTc9PT1lLnR5cGV9KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubnVtYmVyfSk7cmV0dXJuIDY9PT10Lmxlbmd0aD90Om51bGx9LG1hdHJpeDNkOmZ1bmN0aW9uKGUpe3ZhciB0PWUuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiAxNz09PWUudHlwZX0pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5udW1iZXJ9KSxBPXRbMF0scj10WzFdO3RbMl0sdFszXTt2YXIgbj10WzRdLHM9dFs1XTt0WzZdLHRbN10sdFs4XSx0WzldLHRbMTBdLHRbMTFdO3ZhciBpPXRbMTJdLG89dFsxM107cmV0dXJuIHRbMTRdLHRbMTVdLDE2PT09dC5sZW5ndGg/W0EscixuLHMsaSxvXTpudWxsfX0sV0E9e3R5cGU6MTYsbnVtYmVyOjUwLGZsYWdzOjR9LFhBPVtXQSxXQV0sWUE9e25hbWU6InRyYW5zZm9ybS1vcmlnaW4iLGluaXRpYWxWYWx1ZToiNTAlIDUwJSIscHJlZml4OiEwLHR5cGU6MSxwYXJzZTpmdW5jdGlvbihlLHQpe3ZhciBBPXQuZmlsdGVyKCRlKTtyZXR1cm4gMiE9PUEubGVuZ3RoP1hBOltBWzBdLEFbMV1dfX0sSkE9e25hbWU6InZpc2libGUiLGluaXRpYWxWYWx1ZToibm9uZSIscHJlZml4OiExLHR5cGU6MixwYXJzZTpmdW5jdGlvbihlLHQpe3N3aXRjaCh0KXtjYXNlImhpZGRlbiI6cmV0dXJuIDE7Y2FzZSJjb2xsYXBzZSI6cmV0dXJuIDI7ZGVmYXVsdDpyZXR1cm4gMH19fTshZnVuY3Rpb24oZSl7ZS5OT1JNQUw9Im5vcm1hbCIsZS5CUkVBS19BTEw9ImJyZWFrLWFsbCIsZS5LRUVQX0FMTD0ia2VlcC1hbGwifShDQXx8KENBPXt9KSk7Zm9yKHZhciBaQT17bmFtZToid29yZC1icmVhayIsaW5pdGlhbFZhbHVlOiJub3JtYWwiLHByZWZpeDohMSx0eXBlOjIscGFyc2U6ZnVuY3Rpb24oZSx0KXtzd2l0Y2godCl7Y2FzZSJicmVhay1hbGwiOnJldHVybiBDQS5CUkVBS19BTEw7Y2FzZSJrZWVwLWFsbCI6cmV0dXJuIENBLktFRVBfQUxMO2RlZmF1bHQ6cmV0dXJuIENBLk5PUk1BTH19fSwkQT17bmFtZToiei1pbmRleCIsaW5pdGlhbFZhbHVlOiJhdXRvIixwcmVmaXg6ITEsdHlwZTowLHBhcnNlOmZ1bmN0aW9uKGUsdCl7aWYoMjA9PT10LnR5cGUpcmV0dXJue2F1dG86ITAsb3JkZXI6MH07aWYoVmUodCkpcmV0dXJue2F1dG86ITEsb3JkZXI6dC5udW1iZXJ9O3Rocm93IG5ldyBFcnJvcigiSW52YWxpZCB6LWluZGV4IG51bWJlciBwYXJzZWQiKX19LGVyPXtuYW1lOiJ0aW1lIixwYXJzZTpmdW5jdGlvbihlLHQpe2lmKDE1PT09dC50eXBlKXN3aXRjaCh0LnVuaXQudG9Mb3dlckNhc2UoKSl7Y2FzZSJzIjpyZXR1cm4gMWUzKnQubnVtYmVyO2Nhc2UibXMiOnJldHVybiB0Lm51bWJlcn10aHJvdyBuZXcgRXJyb3IoIlVuc3VwcG9ydGVkIHRpbWUgdHlwZSIpfX0sdHI9e25hbWU6Im9wYWNpdHkiLGluaXRpYWxWYWx1ZToiMSIsdHlwZTowLHByZWZpeDohMSxwYXJzZTpmdW5jdGlvbihlLHQpe3JldHVybiBWZSh0KT90Lm51bWJlcjoxfX0sQXI9e25hbWU6InRleHQtZGVjb3JhdGlvbi1jb2xvciIsaW5pdGlhbFZhbHVlOiJ0cmFuc3BhcmVudCIscHJlZml4OiExLHR5cGU6Myxmb3JtYXQ6ImNvbG9yIn0scnI9e25hbWU6InRleHQtZGVjb3JhdGlvbi1saW5lIixpbml0aWFsVmFsdWU6Im5vbmUiLHByZWZpeDohMSx0eXBlOjEscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5maWx0ZXIoR2UpLm1hcChmdW5jdGlvbihlKXtzd2l0Y2goZS52YWx1ZSl7Y2FzZSJ1bmRlcmxpbmUiOnJldHVybiAxO2Nhc2Uib3ZlcmxpbmUiOnJldHVybiAyO2Nhc2UibGluZS10aHJvdWdoIjpyZXR1cm4gMztjYXNlIm5vbmUiOnJldHVybiA0fXJldHVybiAwfSkuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiAwIT09ZX0pfX0sbnI9e25hbWU6ImZvbnQtZmFtaWx5Iixpbml0aWFsVmFsdWU6IiIscHJlZml4OiExLHR5cGU6MSxwYXJzZTpmdW5jdGlvbihlLHQpe3ZhciBBPVtdLHI9W107cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbihlKXtzd2l0Y2goZS50eXBlKXtjYXNlIDIwOmNhc2UgMDpBLnB1c2goZS52YWx1ZSk7YnJlYWs7Y2FzZSAxNzpBLnB1c2goZS5udW1iZXIudG9TdHJpbmcoKSk7YnJlYWs7Y2FzZSA0OnIucHVzaChBLmpvaW4oIiAiKSksQS5sZW5ndGg9MH19KSxBLmxlbmd0aCYmci5wdXNoKEEuam9pbigiICIpKSxyLm1hcChmdW5jdGlvbihlKXtyZXR1cm4tMT09PWUuaW5kZXhPZigiICIpP2U6IiciK2UrIicifSl9fSxzcj17bmFtZToiZm9udC1zaXplIixpbml0aWFsVmFsdWU6IjAiLHByZWZpeDohMSx0eXBlOjMsZm9ybWF0OiJsZW5ndGgifSxpcj17bmFtZToiZm9udC13ZWlnaHQiLGluaXRpYWxWYWx1ZToibm9ybWFsIix0eXBlOjAscHJlZml4OiExLHBhcnNlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIFZlKHQpP3QubnVtYmVyOkdlKHQpJiYiYm9sZCI9PT10LnZhbHVlPzcwMDo0MDB9fSxvcj17bmFtZToiZm9udC12YXJpYW50Iixpbml0aWFsVmFsdWU6Im5vbmUiLHR5cGU6MSxwcmVmaXg6ITEscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5maWx0ZXIoR2UpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS52YWx1ZX0pfX0sYXI9e25hbWU6ImZvbnQtc3R5bGUiLGluaXRpYWxWYWx1ZToibm9ybWFsIixwcmVmaXg6ITEsdHlwZToyLHBhcnNlOmZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2Uib2JsaXF1ZSI6cmV0dXJuIm9ibGlxdWUiO2Nhc2UiaXRhbGljIjpyZXR1cm4iaXRhbGljIjtkZWZhdWx0OnJldHVybiJub3JtYWwifX19LGxyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDAhPT0oZSZ0KX0sY3I9e25hbWU6ImNvbnRlbnQiLGluaXRpYWxWYWx1ZToibm9uZSIsdHlwZToxLHByZWZpeDohMSxwYXJzZTpmdW5jdGlvbihlLHQpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm5bXTt2YXIgQT10WzBdO3JldHVybiAyMD09PUEudHlwZSYmIm5vbmUiPT09QS52YWx1ZT9bXTp0fX0sdXI9e25hbWU6ImNvdW50ZXItaW5jcmVtZW50Iixpbml0aWFsVmFsdWU6Im5vbmUiLHByZWZpeDohMCx0eXBlOjEscGFyc2U6ZnVuY3Rpb24oZSx0KXtpZigwPT09dC5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIEE9dFswXTtpZigyMD09PUEudHlwZSYmIm5vbmUiPT09QS52YWx1ZSlyZXR1cm4gbnVsbDtmb3IodmFyIHI9W10sbj10LmZpbHRlcihXZSkscz0wO3M8bi5sZW5ndGg7cysrKXt2YXIgaT1uW3NdLG89bltzKzFdO2lmKDIwPT09aS50eXBlKXt2YXIgYT1vJiZWZShvKT9vLm51bWJlcjoxO3IucHVzaCh7Y291bnRlcjppLnZhbHVlLGluY3JlbWVudDphfSl9fXJldHVybiByfX0saHI9e25hbWU6ImNvdW50ZXItcmVzZXQiLGluaXRpYWxWYWx1ZToibm9uZSIscHJlZml4OiEwLHR5cGU6MSxwYXJzZTpmdW5jdGlvbihlLHQpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm5bXTtmb3IodmFyIEE9W10scj10LmZpbHRlcihXZSksbj0wO248ci5sZW5ndGg7bisrKXt2YXIgcz1yW25dLGk9cltuKzFdO2lmKEdlKHMpJiYibm9uZSIhPT1zLnZhbHVlKXt2YXIgbz1pJiZWZShpKT9pLm51bWJlcjowO0EucHVzaCh7Y291bnRlcjpzLnZhbHVlLHJlc2V0Om99KX19cmV0dXJuIEF9fSxkcj17bmFtZToiZHVyYXRpb24iLGluaXRpYWxWYWx1ZToiMHMiLHByZWZpeDohMSx0eXBlOjEscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5maWx0ZXIoS2UpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZXIucGFyc2UoZSx0KX0pfX0sZnI9e25hbWU6InF1b3RlcyIsaW5pdGlhbFZhbHVlOiJub25lIixwcmVmaXg6ITAsdHlwZToxLHBhcnNlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiBudWxsO3ZhciBBPXRbMF07aWYoMjA9PT1BLnR5cGUmJiJub25lIj09PUEudmFsdWUpcmV0dXJuIG51bGw7dmFyIHI9W10sbj10LmZpbHRlcih6ZSk7aWYobi5sZW5ndGglMiE9MClyZXR1cm4gbnVsbDtmb3IodmFyIHM9MDtzPG4ubGVuZ3RoO3MrPTIpe3ZhciBpPW5bc10udmFsdWUsbz1uW3MrMV0udmFsdWU7ci5wdXNoKHtvcGVuOmksY2xvc2U6b30pfXJldHVybiByfX0scHI9ZnVuY3Rpb24oZSx0LEEpe2lmKCFlKXJldHVybiIiO3ZhciByPWVbTWF0aC5taW4odCxlLmxlbmd0aC0xKV07cmV0dXJuIHI/QT9yLm9wZW46ci5jbG9zZToiIn0sZ3I9e25hbWU6ImJveC1zaGFkb3ciLGluaXRpYWxWYWx1ZToibm9uZSIsdHlwZToxLHByZWZpeDohMSxwYXJzZTpmdW5jdGlvbihlLHQpe3JldHVybiAxPT09dC5sZW5ndGgmJnFlKHRbMF0sIm5vbmUiKT9bXTpZZSh0KS5tYXAoZnVuY3Rpb24odCl7Zm9yKHZhciBBPXtjb2xvcjoyNTUsb2Zmc2V0WDp0dCxvZmZzZXRZOnR0LGJsdXI6dHQsc3ByZWFkOnR0LGluc2V0OiExfSxyPTAsbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcz10W25dO3FlKHMsImluc2V0Iik/QS5pbnNldD0hMDpaZShzKT8oMD09PXI/QS5vZmZzZXRYPXM6MT09PXI/QS5vZmZzZXRZPXM6Mj09PXI/QS5ibHVyPXM6QS5zcHJlYWQ9cyxyKyspOkEuY29sb3I9aHQoZSxzKX1yZXR1cm4gQX0pfX0sbXI9e25hbWU6InBhaW50LW9yZGVyIixpbml0aWFsVmFsdWU6Im5vcm1hbCIscHJlZml4OiExLHR5cGU6MSxwYXJzZTpmdW5jdGlvbihlLHQpe3ZhciBBPVtdO3JldHVybiB0LmZpbHRlcihHZSkuZm9yRWFjaChmdW5jdGlvbihlKXtzd2l0Y2goZS52YWx1ZSl7Y2FzZSJzdHJva2UiOkEucHVzaCgxKTticmVhaztjYXNlImZpbGwiOkEucHVzaCgwKTticmVhaztjYXNlIm1hcmtlcnMiOkEucHVzaCgyKX19KSxbMCwxLDJdLmZvckVhY2goZnVuY3Rpb24oZSl7LTE9PT1BLmluZGV4T2YoZSkmJkEucHVzaChlKX0pLEF9fSx3cj17bmFtZToiLXdlYmtpdC10ZXh0LXN0cm9rZS1jb2xvciIsaW5pdGlhbFZhbHVlOiJjdXJyZW50Y29sb3IiLHByZWZpeDohMSx0eXBlOjMsZm9ybWF0OiJjb2xvciJ9LEJyPXtuYW1lOiItd2Via2l0LXRleHQtc3Ryb2tlLXdpZHRoIixpbml0aWFsVmFsdWU6IjAiLHR5cGU6MCxwcmVmaXg6ITEscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gS2UodCk/dC5udW1iZXI6MH19LHlyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZhciBBLHI7dGhpcy5hbmltYXRpb25EdXJhdGlvbj1DcihlLGRyLHQuYW5pbWF0aW9uRHVyYXRpb24pLHRoaXMuYmFja2dyb3VuZENsaXA9Q3IoZSxDdCx0LmJhY2tncm91bmRDbGlwKSx0aGlzLmJhY2tncm91bmRDb2xvcj1DcihlLF90LHQuYmFja2dyb3VuZENvbG9yKSx0aGlzLmJhY2tncm91bmRJbWFnZT1DcihlLEt0LHQuYmFja2dyb3VuZEltYWdlKSx0aGlzLmJhY2tncm91bmRPcmlnaW49Q3IoZSxWdCx0LmJhY2tncm91bmRPcmlnaW4pLHRoaXMuYmFja2dyb3VuZFBvc2l0aW9uPUNyKGUsR3QsdC5iYWNrZ3JvdW5kUG9zaXRpb24pLHRoaXMuYmFja2dyb3VuZFJlcGVhdD1DcihlLHp0LHQuYmFja2dyb3VuZFJlcGVhdCksdGhpcy5iYWNrZ3JvdW5kU2l6ZT1DcihlLFh0LHQuYmFja2dyb3VuZFNpemUpLHRoaXMuYm9yZGVyVG9wQ29sb3I9Q3IoZSxadCx0LmJvcmRlclRvcENvbG9yKSx0aGlzLmJvcmRlclJpZ2h0Q29sb3I9Q3IoZSwkdCx0LmJvcmRlclJpZ2h0Q29sb3IpLHRoaXMuYm9yZGVyQm90dG9tQ29sb3I9Q3IoZSxlQSx0LmJvcmRlckJvdHRvbUNvbG9yKSx0aGlzLmJvcmRlckxlZnRDb2xvcj1DcihlLHRBLHQuYm9yZGVyTGVmdENvbG9yKSx0aGlzLmJvcmRlclRvcExlZnRSYWRpdXM9Q3IoZSxyQSx0LmJvcmRlclRvcExlZnRSYWRpdXMpLHRoaXMuYm9yZGVyVG9wUmlnaHRSYWRpdXM9Q3IoZSxuQSx0LmJvcmRlclRvcFJpZ2h0UmFkaXVzKSx0aGlzLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzPUNyKGUsc0EsdC5ib3JkZXJCb3R0b21SaWdodFJhZGl1cyksdGhpcy5ib3JkZXJCb3R0b21MZWZ0UmFkaXVzPUNyKGUsaUEsdC5ib3JkZXJCb3R0b21MZWZ0UmFkaXVzKSx0aGlzLmJvcmRlclRvcFN0eWxlPUNyKGUsYUEsdC5ib3JkZXJUb3BTdHlsZSksdGhpcy5ib3JkZXJSaWdodFN0eWxlPUNyKGUsbEEsdC5ib3JkZXJSaWdodFN0eWxlKSx0aGlzLmJvcmRlckJvdHRvbVN0eWxlPUNyKGUsY0EsdC5ib3JkZXJCb3R0b21TdHlsZSksdGhpcy5ib3JkZXJMZWZ0U3R5bGU9Q3IoZSx1QSx0LmJvcmRlckxlZnRTdHlsZSksdGhpcy5ib3JkZXJUb3BXaWR0aD1DcihlLGRBLHQuYm9yZGVyVG9wV2lkdGgpLHRoaXMuYm9yZGVyUmlnaHRXaWR0aD1DcihlLGZBLHQuYm9yZGVyUmlnaHRXaWR0aCksdGhpcy5ib3JkZXJCb3R0b21XaWR0aD1DcihlLHBBLHQuYm9yZGVyQm90dG9tV2lkdGgpLHRoaXMuYm9yZGVyTGVmdFdpZHRoPUNyKGUsZ0EsdC5ib3JkZXJMZWZ0V2lkdGgpLHRoaXMuYm94U2hhZG93PUNyKGUsZ3IsdC5ib3hTaGFkb3cpLHRoaXMuY29sb3I9Q3IoZSxtQSx0LmNvbG9yKSx0aGlzLmRpcmVjdGlvbj1DcihlLHdBLHQuZGlyZWN0aW9uKSx0aGlzLmRpc3BsYXk9Q3IoZSxCQSx0LmRpc3BsYXkpLHRoaXMuZmxvYXQ9Q3IoZSx2QSx0LmNzc0Zsb2F0KSx0aGlzLmZvbnRGYW1pbHk9Q3IoZSxucix0LmZvbnRGYW1pbHkpLHRoaXMuZm9udFNpemU9Q3IoZSxzcix0LmZvbnRTaXplKSx0aGlzLmZvbnRTdHlsZT1DcihlLGFyLHQuZm9udFN0eWxlKSx0aGlzLmZvbnRWYXJpYW50PUNyKGUsb3IsdC5mb250VmFyaWFudCksdGhpcy5mb250V2VpZ2h0PUNyKGUsaXIsdC5mb250V2VpZ2h0KSx0aGlzLmxldHRlclNwYWNpbmc9Q3IoZSxiQSx0LmxldHRlclNwYWNpbmcpLHRoaXMubGluZUJyZWFrPUNyKGUsX0EsdC5saW5lQnJlYWspLHRoaXMubGluZUhlaWdodD1DcihlLGpBLHQubGluZUhlaWdodCksdGhpcy5saXN0U3R5bGVJbWFnZT1DcihlLEZBLHQubGlzdFN0eWxlSW1hZ2UpLHRoaXMubGlzdFN0eWxlUG9zaXRpb249Q3IoZSxRQSx0Lmxpc3RTdHlsZVBvc2l0aW9uKSx0aGlzLmxpc3RTdHlsZVR5cGU9Q3IoZSxVQSx0Lmxpc3RTdHlsZVR5cGUpLHRoaXMubWFyZ2luVG9wPUNyKGUsU0EsdC5tYXJnaW5Ub3ApLHRoaXMubWFyZ2luUmlnaHQ9Q3IoZSxMQSx0Lm1hcmdpblJpZ2h0KSx0aGlzLm1hcmdpbkJvdHRvbT1DcihlLElBLHQubWFyZ2luQm90dG9tKSx0aGlzLm1hcmdpbkxlZnQ9Q3IoZSxOQSx0Lm1hcmdpbkxlZnQpLHRoaXMub3BhY2l0eT1DcihlLHRyLHQub3BhY2l0eSk7dmFyIG49Q3IoZSxrQSx0Lm92ZXJmbG93KTt0aGlzLm92ZXJmbG93WD1uWzBdLHRoaXMub3ZlcmZsb3dZPW5bbi5sZW5ndGg+MT8xOjBdLHRoaXMub3ZlcmZsb3dXcmFwPUNyKGUsSEEsdC5vdmVyZmxvd1dyYXApLHRoaXMucGFkZGluZ1RvcD1DcihlLFRBLHQucGFkZGluZ1RvcCksdGhpcy5wYWRkaW5nUmlnaHQ9Q3IoZSxPQSx0LnBhZGRpbmdSaWdodCksdGhpcy5wYWRkaW5nQm90dG9tPUNyKGUsTUEsdC5wYWRkaW5nQm90dG9tKSx0aGlzLnBhZGRpbmdMZWZ0PUNyKGUsREEsdC5wYWRkaW5nTGVmdCksdGhpcy5wYWludE9yZGVyPUNyKGUsbXIsdC5wYWludE9yZGVyKSx0aGlzLnBvc2l0aW9uPUNyKGUsS0EsdC5wb3NpdGlvbiksdGhpcy50ZXh0QWxpZ249Q3IoZSxSQSx0LnRleHRBbGlnbiksdGhpcy50ZXh0RGVjb3JhdGlvbkNvbG9yPUNyKGUsQXIsbnVsbCE9PShBPXQudGV4dERlY29yYXRpb25Db2xvcikmJnZvaWQgMCE9PUE/QTp0LmNvbG9yKSx0aGlzLnRleHREZWNvcmF0aW9uTGluZT1DcihlLHJyLG51bGwhPT0ocj10LnRleHREZWNvcmF0aW9uTGluZSkmJnZvaWQgMCE9PXI/cjp0LnRleHREZWNvcmF0aW9uKSx0aGlzLnRleHRTaGFkb3c9Q3IoZSxWQSx0LnRleHRTaGFkb3cpLHRoaXMudGV4dFRyYW5zZm9ybT1DcihlLEdBLHQudGV4dFRyYW5zZm9ybSksdGhpcy50cmFuc2Zvcm09Q3IoZSx6QSx0LnRyYW5zZm9ybSksdGhpcy50cmFuc2Zvcm1PcmlnaW49Q3IoZSxZQSx0LnRyYW5zZm9ybU9yaWdpbiksdGhpcy52aXNpYmlsaXR5PUNyKGUsSkEsdC52aXNpYmlsaXR5KSx0aGlzLndlYmtpdFRleHRTdHJva2VDb2xvcj1DcihlLHdyLHQud2Via2l0VGV4dFN0cm9rZUNvbG9yKSx0aGlzLndlYmtpdFRleHRTdHJva2VXaWR0aD1DcihlLEJyLHQud2Via2l0VGV4dFN0cm9rZVdpZHRoKSx0aGlzLndvcmRCcmVhaz1DcihlLFpBLHQud29yZEJyZWFrKSx0aGlzLnpJbmRleD1DcihlLCRBLHQuekluZGV4KX1yZXR1cm4gZS5wcm90b3R5cGUuaXNWaXNpYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheT4wJiZ0aGlzLm9wYWNpdHk+MCYmMD09PXRoaXMudmlzaWJpbGl0eX0sZS5wcm90b3R5cGUuaXNUcmFuc3BhcmVudD1mdW5jdGlvbigpe3JldHVybiBkdCh0aGlzLmJhY2tncm91bmRDb2xvcil9LGUucHJvdG90eXBlLmlzVHJhbnNmb3JtZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMudHJhbnNmb3JtfSxlLnByb3RvdHlwZS5pc1Bvc2l0aW9uZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PXRoaXMucG9zaXRpb259LGUucHJvdG90eXBlLmlzUG9zaXRpb25lZFdpdGhaSW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1Bvc2l0aW9uZWQoKSYmIXRoaXMuekluZGV4LmF1dG99LGUucHJvdG90eXBlLmlzRmxvYXRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PXRoaXMuZmxvYXR9LGUucHJvdG90eXBlLmlzSW5saW5lTGV2ZWw9ZnVuY3Rpb24oKXtyZXR1cm4gbHIodGhpcy5kaXNwbGF5LDQpfHxscih0aGlzLmRpc3BsYXksMzM1NTQ0MzIpfHxscih0aGlzLmRpc3BsYXksMjY4NDM1NDU2KXx8bHIodGhpcy5kaXNwbGF5LDUzNjg3MDkxMil8fGxyKHRoaXMuZGlzcGxheSw2NzEwODg2NCl8fGxyKHRoaXMuZGlzcGxheSwxMzQyMTc3MjgpfSxlfSgpLHZyPWZ1bmN0aW9uKGUsdCl7dGhpcy5jb250ZW50PUNyKGUsY3IsdC5jb250ZW50KSx0aGlzLnF1b3Rlcz1DcihlLGZyLHQucXVvdGVzKX0sYnI9ZnVuY3Rpb24oZSx0KXt0aGlzLmNvdW50ZXJJbmNyZW1lbnQ9Q3IoZSx1cix0LmNvdW50ZXJJbmNyZW1lbnQpLHRoaXMuY291bnRlclJlc2V0PUNyKGUsaHIsdC5jb3VudGVyUmVzZXQpfSxDcj1mdW5jdGlvbihlLHQsQSl7dmFyIHI9bmV3IERlLG49bnVsbCE9QT9BLnRvU3RyaW5nKCk6dC5pbml0aWFsVmFsdWU7ci53cml0ZShuKTt2YXIgcz1uZXcgUmUoci5yZWFkKCkpO3N3aXRjaCh0LnR5cGUpe2Nhc2UgMjp2YXIgaT1zLnBhcnNlQ29tcG9uZW50VmFsdWUoKTtyZXR1cm4gdC5wYXJzZShlLEdlKGkpP2kudmFsdWU6dC5pbml0aWFsVmFsdWUpO2Nhc2UgMDpyZXR1cm4gdC5wYXJzZShlLHMucGFyc2VDb21wb25lbnRWYWx1ZSgpKTtjYXNlIDE6cmV0dXJuIHQucGFyc2UoZSxzLnBhcnNlQ29tcG9uZW50VmFsdWVzKCkpO2Nhc2UgNDpyZXR1cm4gcy5wYXJzZUNvbXBvbmVudFZhbHVlKCk7Y2FzZSAzOnN3aXRjaCh0LmZvcm1hdCl7Y2FzZSJhbmdsZSI6cmV0dXJuIGF0KGUscy5wYXJzZUNvbXBvbmVudFZhbHVlKCkpO2Nhc2UiY29sb3IiOnJldHVybiBodChlLHMucGFyc2VDb21wb25lbnRWYWx1ZSgpKTtjYXNlImltYWdlIjpyZXR1cm4gTXQoZSxzLnBhcnNlQ29tcG9uZW50VmFsdWUoKSk7Y2FzZSJsZW5ndGgiOnZhciBvPXMucGFyc2VDb21wb25lbnRWYWx1ZSgpO3JldHVybiBaZShvKT9vOnR0O2Nhc2UibGVuZ3RoLXBlcmNlbnRhZ2UiOnZhciBhPXMucGFyc2VDb21wb25lbnRWYWx1ZSgpO3JldHVybiAkZShhKT9hOnR0O2Nhc2UidGltZSI6cmV0dXJuIGVyLnBhcnNlKGUscy5wYXJzZUNvbXBvbmVudFZhbHVlKCkpfX19LF9yPWZ1bmN0aW9uKGUsdCl7dmFyIEE9ZnVuY3Rpb24oZSl7c3dpdGNoKGUuZ2V0QXR0cmlidXRlKCJkYXRhLWh0bWwyY2FudmFzLWRlYnVnIikpe2Nhc2UiYWxsIjpyZXR1cm4gMTtjYXNlImNsb25lIjpyZXR1cm4gMjtjYXNlInBhcnNlIjpyZXR1cm4gMztjYXNlInJlbmRlciI6cmV0dXJuIDQ7ZGVmYXVsdDpyZXR1cm4gMH19KGUpO3JldHVybiAxPT09QXx8dD09PUF9LGpyPWZ1bmN0aW9uKGUsdCl7dGhpcy5jb250ZXh0PWUsdGhpcy50ZXh0Tm9kZXM9W10sdGhpcy5lbGVtZW50cz1bXSx0aGlzLmZsYWdzPTAsX3IodCwzKSx0aGlzLnN0eWxlcz1uZXcgeXIoZSx3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0LG51bGwpKSxFbih0KSYmKHRoaXMuc3R5bGVzLmFuaW1hdGlvbkR1cmF0aW9uLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuIGU+MH0pJiYodC5zdHlsZS5hbmltYXRpb25EdXJhdGlvbj0iMHMiKSxudWxsIT09dGhpcy5zdHlsZXMudHJhbnNmb3JtJiYodC5zdHlsZS50cmFuc2Zvcm09Im5vbmUiKSksdGhpcy5ib3VuZHM9byh0aGlzLmNvbnRleHQsdCksX3IodCw0KSYmKHRoaXMuZmxhZ3N8PTE2KX0seHI9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLEZyPSJ1bmRlZmluZWQiPT10eXBlb2YgVWludDhBcnJheT9bXTpuZXcgVWludDhBcnJheSgyNTYpLFFyPTA7UXI8NjQ7UXIrKylGclt4ci5jaGFyQ29kZUF0KFFyKV09UXI7Zm9yKHZhciBVcj1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIGUuc2xpY2U/ZS5zbGljZSh0LEEpOm5ldyBVaW50MTZBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLHQsQSkpfSxFcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LEEscixuLHMpe3RoaXMuaW5pdGlhbFZhbHVlPWUsdGhpcy5lcnJvclZhbHVlPXQsdGhpcy5oaWdoU3RhcnQ9QSx0aGlzLmhpZ2hWYWx1ZUluZGV4PXIsdGhpcy5pbmRleD1uLHRoaXMuZGF0YT1zfXJldHVybiBlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oZSl7dmFyIHQ7aWYoZT49MCl7aWYoZTw1NTI5Nnx8ZT41NjMxOSYmZTw9NjU1MzUpcmV0dXJuIHQ9KCh0PXRoaXMuaW5kZXhbZT4+NV0pPDwyKSsoMzEmZSksdGhpcy5kYXRhW3RdO2lmKGU8PTY1NTM1KXJldHVybiB0PSgodD10aGlzLmluZGV4WzIwNDgrKGUtNTUyOTY+PjUpXSk8PDIpKygzMSZlKSx0aGlzLmRhdGFbdF07aWYoZTx0aGlzLmhpZ2hTdGFydClyZXR1cm4gdD0yMDgwKyhlPj4xMSksdD10aGlzLmluZGV4W3RdLHQrPWU+PjUmNjMsdD0oKHQ9dGhpcy5pbmRleFt0XSk8PDIpKygzMSZlKSx0aGlzLmRhdGFbdF07aWYoZTw9MTExNDExMSlyZXR1cm4gdGhpcy5kYXRhW3RoaXMuaGlnaFZhbHVlSW5kZXhdfXJldHVybiB0aGlzLmVycm9yVmFsdWV9LGV9KCksU3I9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLExyPSJ1bmRlZmluZWQiPT10eXBlb2YgVWludDhBcnJheT9bXTpuZXcgVWludDhBcnJheSgyNTYpLElyPTA7SXI8NjQ7SXIrKylMcltTci5jaGFyQ29kZUF0KElyKV09SXI7dmFyIE5yLGtyPTgsSHI9OSxQcj0xMSxUcj0xMixPcj1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllW3RdPWFyZ3VtZW50c1t0XTtpZihTdHJpbmcuZnJvbUNvZGVQb2ludClyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLGUpO3ZhciBBPWUubGVuZ3RoO2lmKCFBKXJldHVybiIiO2Zvcih2YXIgcj1bXSxuPS0xLHM9IiI7KytuPEE7KXt2YXIgaT1lW25dO2k8PTY1NTM1P3IucHVzaChpKTooaS09NjU1MzYsci5wdXNoKDU1Mjk2KyhpPj4xMCksaSUxMDI0KzU2MzIwKSksKG4rMT09PUF8fHIubGVuZ3RoPjE2Mzg0KSYmKHMrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLHIpLHIubGVuZ3RoPTApfXJldHVybiBzfSxNcj1mdW5jdGlvbihlKXt2YXIgdCxBLHIsbj1mdW5jdGlvbihlKXt2YXIgdCxBLHIsbixzLGk9Ljc1KmUubGVuZ3RoLG89ZS5sZW5ndGgsYT0wOyI9Ij09PWVbZS5sZW5ndGgtMV0mJihpLS0sIj0iPT09ZVtlLmxlbmd0aC0yXSYmaS0tKTt2YXIgbD0idW5kZWZpbmVkIiE9dHlwZW9mIEFycmF5QnVmZmVyJiYidW5kZWZpbmVkIiE9dHlwZW9mIFVpbnQ4QXJyYXkmJnZvaWQgMCE9PVVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlP25ldyBBcnJheUJ1ZmZlcihpKTpuZXcgQXJyYXkoaSksYz1BcnJheS5pc0FycmF5KGwpP2w6bmV3IFVpbnQ4QXJyYXkobCk7Zm9yKHQ9MDt0PG87dCs9NClBPUZyW2UuY2hhckNvZGVBdCh0KV0scj1GcltlLmNoYXJDb2RlQXQodCsxKV0sbj1GcltlLmNoYXJDb2RlQXQodCsyKV0scz1GcltlLmNoYXJDb2RlQXQodCszKV0sY1thKytdPUE8PDJ8cj4+NCxjW2ErK109KDE1JnIpPDw0fG4+PjIsY1thKytdPSgzJm4pPDw2fDYzJnM7cmV0dXJuIGx9KGUpLHM9QXJyYXkuaXNBcnJheShuKT9mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5sZW5ndGgsQT1bXSxyPTA7cjx0O3IrPTQpQS5wdXNoKGVbciszXTw8MjR8ZVtyKzJdPDwxNnxlW3IrMV08PDh8ZVtyXSk7cmV0dXJuIEF9KG4pOm5ldyBVaW50MzJBcnJheShuKSxpPUFycmF5LmlzQXJyYXkobik/ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUubGVuZ3RoLEE9W10scj0wO3I8dDtyKz0yKUEucHVzaChlW3IrMV08PDh8ZVtyXSk7cmV0dXJuIEF9KG4pOm5ldyBVaW50MTZBcnJheShuKSxvPVVyKGksMTIsc1s0XS8yKSxhPTI9PT1zWzVdP1VyKGksKDI0K3NbNF0pLzIpOih0PXMsQT1NYXRoLmNlaWwoKDI0K3NbNF0pLzQpLHQuc2xpY2U/dC5zbGljZShBLHIpOm5ldyBVaW50MzJBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LEEscikpKTtyZXR1cm4gbmV3IEVyKHNbMF0sc1sxXSxzWzJdLHNbM10sbyxhKX0oIkFBQUFBQUFBQUFBQUVBNEFHQmtBQUZBYUFBQUNBQUFBQUFBSUFCQUFHQUF3QURnQUNBQVFBQWdBRUFBSUFCQUFDQUFRQUFnQUVBQUlBQkFBQ0FBUUFBZ0FFQUFJQUJBQVFBQklBRVFBVEFBSUFCQUFDQUFRQUFnQUVBQUlBQkFBVkFCY0FBZ0FFQUFJQUJBQUNBQVFBR0FBYUFCd0FIZ0FnQUNJQUk0QWxnQUlBQkFBbXdDakFLZ0FzQUMyQUw0QXZRREZBTW9BMGdCUEFWWUJXZ0VJQUFnQUNBQ01BTm9BWWdGa0FXd0JkQUY4QVgwQmhRR05BWlVCbGdHZUFhTUJsUUdXQWFzQnN3RjhBYnNCd3dGMEFjc0JZd0hUQVFnQTJ3Ry9BT01CZEFGOEFla0I4UUYwQWZrQit3SGlBSFFCZkFFSUFBTUM1Z1FJQUFzQ0VnSUlBQWdBRmdJZUFnZ0FJZ0lwQWdnQU1RSTVBa0FDeWdFSUFBZ0FTQUpRQWxnQ1lBSUlBQWdBQ0FBS0JRb0ZDZ1VUQlJNRkdRVXJCU3NGQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FCZEFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUJvQW1nQ3J3R3ZBUWdBYmdKMkFnZ0FIZ0VJQUFnQUNBRG5BWHNDQ0FBSUFBZ0Fnd0lJQUFnQUNBQUlBQWdBQ0FDS0FnZ0FrUUtaQWdnQVBBREpBQWdBb1FLa0Fxd0NzZ0s2QXNJQ0NBREpBZ2dBMEFJSUFBZ0FDQUFJQU5ZQzNnSUlBQWdBQ0FBSUFBZ0FDQUJBQU9ZQ0NBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFrQVNvQitRSUVBQWdBQ0FBOEFFTUNDQUJDQlFnQUNBQkpCVkFGQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FCVEJWb0ZDQUFJQUZvRkNBQmZCV1VGQ0FBSUFBZ0FDQUFJQUFnQWJRVUlBQWdBQ0FBSUFBZ0FDQUJ6QlhzRmZRV0ZCWW9GaWdXS0JaRUZpZ1dLQllvRm1BV2ZCYVlGcmdXeEJia0ZDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQU1FRkNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFNZ0ZDQURRQlFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBTzRDQ0FBSUFBZ0FpUUFJQUFnQUNBQkFBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBRDBBZ2dBQ0FEOEFnZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBTllGQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQU1EdndBSUFBZ0FKQUlJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDd01UQXdnQUNBQjlCT3NFR3dNakF3Z0FLd015QXdzRllnRTNBL01FUHdNSUFFVURUUU5SQXdnQVdRT3NBR0VEQ0FBSUFBZ0FDQUFJQUFnQUNBQnBBelFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRk9nVTBCVFVGTmdVM0JUZ0ZPUVU2QlRRRk5RVTJCVGNGT0FVNUJUb0ZOQVUxQlRZRk53VTRCVGtGT2dVMEJUVUZOZ1UzQlRnRk9RVTZCVFFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRk9nVTBCVFVGTmdVM0JUZ0ZPUVU2QlRRRk5RVTJCVGNGT0FVNUJUb0ZOQVUxQlRZRk53VTRCVGtGT2dVMEJUVUZOZ1UzQlRnRk9RVTZCVFFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRk9nVTBCVFVGTmdVM0JUZ0ZPUVU2QlRRRk5RVTJCVGNGT0FVNUJUb0ZOQVUxQlRZRk53VTRCVGtGT2dVMEJUVUZOZ1UzQlRnRk9RVTZCVFFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRk9nVTBCVFVGTmdVM0JUZ0ZPUVU2QlRRRk5RVTJCVGNGT0FVNUJUb0ZOQVUxQlRZRk53VTRCVGtGT2dVMEJUVUZOZ1UzQlRnRk9RVTZCVFFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRk9nVTBCVFVGTmdVM0JUZ0ZPUVU2QlRRRk5RVTJCVGNGT0FVNUJUb0ZOQVUxQlRZRk53VTRCVGtGT2dVMEJUVUZOZ1UzQlRnRk9RVTZCVFFGTlFVMkJUY0ZPQVU1QlRvRk5BVTFCVFlGTndVNEJUa0ZPZ1UwQlRVRk5nVTNCVGdGT1FVNkJUUUZOUVUyQlRjRk9BVTVCVG9GTkFVMUJUWUZOd1U0QlRrRklRVW9CU3dGQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FCdEF3Z0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQk1BRXdBQ0FBSUFBZ0FDQUFJQUJnQUNBQUlBQWdBQ0FDL0FBZ0FDQUF5QVFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FDQUFJQUF3QUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFBQVJBQklBQWdBQ0FBSUFCUUFTQUFJQUFnQUlBQndBRUFBamdDSUFCc0FxQUMyQUwwQWlnRFFBdHdDK0lKSVFxVkFaVUJXUXFWQVpVQmxRR1ZBWlVCbFFHckM1VUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFYc0tsUUdWQWJBSzZ3c3JER1VNcFF6bERKVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBWlVCbFFHVkFaVUJsUUdWQVpVQmxRR1ZBZkFLQUF1WkE2NEF0d0NKQUxvQzZBRHdBQWdBdUFDZ0Evb0VwZ082QXFzRCtBQUlBQWdBc3dNSUFBZ0FDQUFJQUlrQXV3UDVBZnNCd3dQTEF3Z0FDQUFJQUFnQUNBRFJBOWtEQ0FBSUFPRUQ2UU1JQUFnQUNBQUlBQWdBQ0FEdUEvWURDQUFJQVA0RHlRQUlBQWdBQmdRSUFBZ0FYUUFPQkFnQUNBQUlBQWdBQ0FBSUFCTUVDQUFJQUFnQUNBQUlBQWdBQ0FEOEFBUUJDQUFJQUFnQUdnUWlCQ29FQ0FFeEJBZ0FFQUVJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQTRCQWdBQ0FCQUJFWUVDQUFJQUFnQVRBUVlBUWdBVkFRSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFGb0VDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBT1FFSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FCK0JBY0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFFQUJoZ1NNQkFnQUNBQUlBQWdBbEFRSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBd0FFQUFRQUJBQURBQU1BQXdBREFBUUFCQUFFQUFRQUJBQUVBQVFBQkhBVEFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQWRRTUlBQWdBQ0FBSUFBZ0FDQUFJQU1rQUNBQUlBQWdBZlFNSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FDRkE0a0RDQUFJQUFnQUNBQUlBT2NCQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBSWNEQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFKRURDQUFJQUFnQUNBREZBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUJnQkFnQVpnUUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FiQVFDQlhJRUNBQUlBSGtFQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQkFBSndFUUFDakJLb0VzZ1FJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FDNkJNSUVDQUFJQUFnQUNBQUlBQWdBQ0FCbUJBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQXh3UUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFHWUVDQUFJQUFnQXpnUUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQWlnV0tCWW9GaWdXS0JZb0ZpZ1dLQmQwRlh3VUlBT0lGNmdYeEJZb0YzZ1Q1QlFBR0NBYUtCWW9GaWdXS0JZb0ZpZ1dLQllvRmlnV0tCWW9GaWdYV0JJb0ZpZ1dLQllvRmlnV0tCWW9GaWdXS0JZc0ZFQWFLQllvRmlnV0tCWW9GaWdXS0JSUUdDQUNLQllvRmlnV0tCUWdBQ0FBSUFORUVDQUFJQUJnR2lnVWdCZ2dBSmdZSUFDNEdNd2FLQllvRjB3UTNCajRHaWdXS0JZb0ZpZ1dLQllvRmlnV0tCWW9GaWdXS0JZb0ZpZ1VJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FpZ1dLQllvRmlnV0tCWW9GaWdXS0JZb0ZpZ1dLQllvRmlnV0tCWW9GaWdXS0JZb0ZpZ1dLQllvRmlnV0tCWW9GaWdXS0JZb0ZpZ1dLQllvRmlnV0xCZi8vLy8vLy93UUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFBd0FFQUFRQUFnQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FBQUFBQUFBQUFRQURnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQVVBQUFBRkFBVUFBQUFGQUFVQUFBQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBRUFBUUFCQUFFQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFBUUFBQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFGQUFVQUFBQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQUFBQUFBRkFBVUFBUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJ3QUZBQVVBQlFBRkFBQUFCd0FIQUFjQUFBQUhBQWNBQndBRkFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSEFBY0FCd0FGQUFVQUJRQUZBQWNBQndBRkFBVUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIQUFBQUFRQUJBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQUFBQndBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBSEFBY0FCd0FIQUFjQUFBQUhBQWNBQUFBQUFBVUFCUUFIQUFVQUFRQUhBQUVBQndBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBRkFBVUFCd0FCQUFVQUJRQUZBQVVBQUFBQUFBQUFBQUFBQUFFQUFRQUJBQUVBQVFBQkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJ3QUZBQVVBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBRkFBVUFBUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFCUUFOQUFRQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUJBQUVBQVFBQkFBRUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBSEFBVUFCUUFGQUFBQUFBQUFBQWNBQlFBRkFBVUFCUUFGQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCQUFFQUFRQUJBQUVBQVFBQkFBRUFBUUFCQUFFQUFRQUJBQUVBQVFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQUFBRkFBVUFCUUFGQUFVQUFBQUZBQVVBQlFBQUFBVUFCUUFGQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBQUFBQUFBQUFBQUFVQUJRQUZBQWNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFIQUFVQUFBQUhBQWNBQndBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQndBSEFBY0FCd0FGQUFjQUJ3QUFBQVVBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCd0FIQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQVVBQndBSEFBVUFCUUFGQUFVQUFBQUFBQWNBQndBQUFBQUFCd0FIQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBQUFBQUFCUUFGQUFjQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQUFBQndBSEFBY0FCUUFGQUFBQUFBQUFBQUFBQlFBRkFBQUFBQUFGQUFVQUJRQUFBQUFBQUFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFBQUFBQUFBQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQndBRkFBVUFCUUFGQUFVQUFBQUZBQVVBQndBQUFBY0FCd0FGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFBQUFGQUFVQUJ3QUZBQVVBQlFBRkFBQUFBQUFIQUFjQUFBQUFBQWNBQndBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQWNBQndBQUFBQUFBQUFIQUFjQUJ3QUFBQWNBQndBSEFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFIQUFjQUJ3QUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQndBSEFBY0FCd0FBQUFVQUJRQUZBQUFBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQWNBQlFBSEFBY0FCUUFIQUFjQUFBQUZBQWNBQndBQUFBY0FCd0FGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQWNBQndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUFBQVVBQndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFBQUFBQUFBQUFBQUZBQWNBQndBRkFBVUFCUUFBQUFVQUFBQUhBQWNBQndBSEFBY0FCd0FIQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUFBQUhBQVVBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFBQUJ3QUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFVQUFBQUZBQUFBQUFBQUFBQUFCd0FIQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQndBRkFBVUFCUUFGQUFVQUFBQUZBQVVBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFGQUFVQUJ3QUZBQVVBQlFBRkFBVUFCUUFBQUFVQUJRQUhBQWNBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhBQWNBQlFBRkFBQUFBQUFBQUFBQUJRQUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQWNBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBSEFBVUFCUUFGQUFVQUJRQUZBQVVBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQVVBQndBSEFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCd0FIQUFjQUJ3QUZBQVVBQndBSEFBY0FBQUFBQUFBQUFBQUhBQWNBQlFBSEFBY0FCd0FIQUFjQUJ3QUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQWNBQndBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJRQUhBQVVBQlFBRkFBVUFCUUFGQUFVQUFBQUZBQUFBQlFBQUFBQUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBY0FCd0FIQUFjQUJ3QUhBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUFBQUFBVUFCUUFGQUFVQUJRQUhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBRkFBVUFCUUFGQUFVQUJ3QUZBQWNBQndBSEFBY0FCd0FGQUFjQUJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSEFBVUFCUUFGQUFVQUJ3QUhBQVVBQlFBSEFBVUFCUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQWNBQlFBRkFBY0FCd0FIQUFVQUJ3QUZBQVVBQlFBSEFBY0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFIQUFjQUJRQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQUFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFjQUJRQUZBQVVBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQVVBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQndBRkFBVUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUFBQlFBRkFBVUFCUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFGQUFVQUJRQUZBQVVBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQUFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBRkFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCd0FIQUFVQUJRQUhBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJ3QUhBQWNBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUFBQUFBQUFBQUFBQUFBQUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUhBQWNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBY0FCd0FGQUFVQUJRQUZBQWNBQndBRkFBVUFCd0FIQUFBQUFBQUFBQUFBQUFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFGQUFVQUJRQUZBQWNBQndBRkFBVUFCd0FIQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBY0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQUFBRkFBVUFCUUFBQUFBQUJRQUZBQUFBQUFBQUFBQUFBQUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNBQlFBRkFBY0FCd0FBQUFBQUFBQUFBQUFBQndBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJ3QUZBQWNBQndBRkFBY0FCd0FBQUFjQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBQUFBVUFCUUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBVUFCUUFBQUFBQUFBQUFBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJRQUhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQVVBQndBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJ3QUhBQWNBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIQUFjQUJ3QUZBQVVBQlFBSEFBY0FCUUFIQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFGQUFBQUJ3QUhBQWNBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCd0FIQUFjQUJ3QUFBQUFBQndBSEFBQUFBQUFIQUFjQUJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQndBSEFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhBQWNBQndBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQndBSEFBVUFCUUFGQUFjQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFIQUFjQUJRQUZBQVVBQlFBRkFBVUFCd0FGQUFjQUJ3QUZBQWNBQlFBRkFBY0FCUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBSEFBY0FCUUFGQUFVQUJRQUFBQUFBQndBSEFBY0FCd0FGQUFVQUJ3QUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBY0FCd0FIQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFIQUFjQUJRQUhBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUFCd0FGQUFjQUJ3QUZBQVVBQlFBRkFBVUFCUUFIQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJ3QUZBQVVBQlFBRkFBY0FCUUFGQUFVQUJRQUZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSEFBY0FCd0FGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFIQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhBQWNBQndBRkFBVUFCUUFGQUFBQUFBQUZBQVVBQndBSEFBY0FCd0FGQUFBQUFBQUFBQWNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUJ3QUhBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQVVBQlFBRkFBVUFCUUFGQUFjQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFBQUFIQUFVQUJRQUZBQVVBQlFBRkFBVUFCd0FGQUFVQUJ3QUZBQVVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUFBQUFBQUFBQlFBQUFBVUFCUUFBQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhBQWNBQndBSEFBY0FBQUFGQUFVQUFBQUhBQWNBQlFBSEFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJ3QUhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZBQVVBQlFBRkFBVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBQUFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNBQndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVQUJRQUFBQVVBQlFBRkFBQUFBQUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFGQUFVQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVBQlFBRkFBVUFCUUFBQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUZBQVVBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQUFBQlFBRkFBVUFCUUFGQUFVQUJRQUFBQVVBQlFBQUFBVUFCUUFGQUFVQUJRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRkFBVUFCUUFGQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCUUFGQUFVQUJRQUZBQVVBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FGQUFVQUJRQUZBQVVBRGdBT0FBNEFEZ0FPQUE0QUR3QVBBQThBRHdBUEFBOEFEd0FQQUE4QUR3QVBBQThBRHdBUEFBOEFEd0FQQUE4QUR3QVBBQThBRHdBUEFBOEFEd0FQQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQUJ3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQndBSEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFjQUJ3QUhBQWNBQndBSEFBY0FCd0FIQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBQUFBQUFBQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBS0FBb0FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBb0FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBb0FDZ0FLQUFvQUNnQU1BQXdBREFBTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUFBQUFBQUFBQUFBS0FBb0FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBb0FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBb0FDZ0FLQUFvQUNnQUtBQW9BQ2dBS0FBb0FDZ0FLQUFvQUNnQUFBQUFBQUFBQUFBc0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FDd0FNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFNQUF3QURBQU1BQXdBREFBTUFBd0FEQUFBQUFBQURnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQTRBRGdBT0FBNEFEZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBQUFBQUFBQUFBQURnQU9BQTRBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQU9BQTRBRGdBQUFBNEFEZ0FPQUE0QURnQU9BQUFBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFBQUFPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFBQUFBQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQUFBQTRBQUFBT0FBQUFBQUFBQUFBQUFBQUFBQTRBQUFBQUFBQUFBQUFBQUFBQURnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FBQUFBQURnQUFBQUFBQUFBQUFBNEFBQUFPQUFBQUFBQUFBQUFBRGdBT0FBNEFBQUFPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQTRBRGdBT0FBNEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FBNEFEZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FBNEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE0QURnQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdBT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FBQUFBQUFBQUFBQTRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQUFBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9BQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBRGdBT0FBNEFEZ0FPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQUFBQUFBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQUFBQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE0QUFBQUFBQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQUFBRGdBT0FBNEFEZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBQUFBQUFBQUFBQUFBQUFBQURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQUE0QURnQU9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQU9BQTRBRGdBT0FBNEFEZ0FPQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnQU9BQTRBRGdBT0FBNEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNEFEZ0FPQUE0QURnQU9BQTRBRGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFBQUFPQUE0QURnQU9BQTRBRGdBQUFBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBRGdBT0FBNEFEZ0FPQUE0QURnQU9BQTRBQUFBQUFBQUFBQUE9IiksRHI9IsOXIixScj1mdW5jdGlvbihlKXtyZXR1cm4gTXIuZ2V0KGUpfSxLcj1mdW5jdGlvbihlLHQsQSl7dmFyIHI9QS0yLG49dFtyXSxzPXRbQS0xXSxpPXRbQV07aWYoMj09PXMmJjM9PT1pKXJldHVybiBEcjtpZigyPT09c3x8Mz09PXN8fDQ9PT1zKXJldHVybiLDtyI7aWYoMj09PWl8fDM9PT1pfHw0PT09aSlyZXR1cm4iw7ciO2lmKHM9PT1rciYmLTEhPT1ba3IsSHIsUHIsVHJdLmluZGV4T2YoaSkpcmV0dXJuIERyO2lmKCEocyE9PVByJiZzIT09SHJ8fGkhPT1IciYmMTAhPT1pKSlyZXR1cm4gRHI7aWYoKHM9PT1Ucnx8MTA9PT1zKSYmMTA9PT1pKXJldHVybiBEcjtpZigxMz09PWl8fDU9PT1pKXJldHVybiBEcjtpZig3PT09aSlyZXR1cm4gRHI7aWYoMT09PXMpcmV0dXJuIERyO2lmKDEzPT09cyYmMTQ9PT1pKXtmb3IoOzU9PT1uOyluPXRbLS1yXTtpZigxND09PW4pcmV0dXJuIERyfWlmKDE1PT09cyYmMTU9PT1pKXtmb3IodmFyIG89MDsxNT09PW47KW8rKyxuPXRbLS1yXTtpZihvJTI9PTApcmV0dXJuIERyfXJldHVybiLDtyJ9LFZyPWZ1bmN0aW9uKGUpe3ZhciB0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxBPTAscj1lLmxlbmd0aDtBPHI7KXt2YXIgbj1lLmNoYXJDb2RlQXQoQSsrKTtpZihuPj01NTI5NiYmbjw9NTYzMTkmJkE8cil7dmFyIHM9ZS5jaGFyQ29kZUF0KEErKyk7NTYzMjA9PSg2NDUxMiZzKT90LnB1c2goKCgxMDIzJm4pPDwxMCkrKDEwMjMmcykrNjU1MzYpOih0LnB1c2gobiksQS0tKX1lbHNlIHQucHVzaChuKX1yZXR1cm4gdH0oZSksQT10Lmxlbmd0aCxyPTAsbj0wLHM9dC5tYXAoUnIpO3JldHVybntuZXh0OmZ1bmN0aW9uKCl7aWYocj49QSlyZXR1cm57ZG9uZTohMCx2YWx1ZTpudWxsfTtmb3IodmFyIGU9RHI7cjxBJiYoZT1LcigwLHMsKytyKSk9PT1EcjspO2lmKGUhPT1Ecnx8cj09PUEpe3ZhciBpPU9yLmFwcGx5KG51bGwsdC5zbGljZShuLHIpKTtyZXR1cm4gbj1yLHt2YWx1ZTppLGRvbmU6ITF9fXJldHVybntkb25lOiEwLHZhbHVlOm51bGx9fX19LEdyPWZ1bmN0aW9uKGUpe3JldHVybiAwPT09ZVswXSYmMjU1PT09ZVsxXSYmMD09PWVbMl0mJjI1NT09PWVbM119LHpyPWZ1bmN0aW9uKGUsdCxBLHIsbil7dmFyIHM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIixpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzLCJzdmciKSxvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzLCJmb3JlaWduT2JqZWN0Iik7cmV0dXJuIGkuc2V0QXR0cmlidXRlTlMobnVsbCwid2lkdGgiLGUudG9TdHJpbmcoKSksaS5zZXRBdHRyaWJ1dGVOUyhudWxsLCJoZWlnaHQiLHQudG9TdHJpbmcoKSksby5zZXRBdHRyaWJ1dGVOUyhudWxsLCJ3aWR0aCIsIjEwMCUiKSxvLnNldEF0dHJpYnV0ZU5TKG51bGwsImhlaWdodCIsIjEwMCUiKSxvLnNldEF0dHJpYnV0ZU5TKG51bGwsIngiLEEudG9TdHJpbmcoKSksby5zZXRBdHRyaWJ1dGVOUyhudWxsLCJ5IixyLnRvU3RyaW5nKCkpLG8uc2V0QXR0cmlidXRlTlMobnVsbCwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCIsInRydWUiKSxpLmFwcGVuZENoaWxkKG8pLG8uYXBwZW5kQ2hpbGQobiksaX0scXI9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQsQSl7dmFyIHI9bmV3IEltYWdlO3Iub25sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIHQocil9LHIub25lcnJvcj1BLHIuc3JjPSJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwiK2VuY29kZVVSSUNvbXBvbmVudCgobmV3IFhNTFNlcmlhbGl6ZXIpLnNlcmlhbGl6ZVRvU3RyaW5nKGUpKX0pfSxXcj17Z2V0IFNVUFBPUlRfUkFOR0VfQk9VTkRTKCl7dmFyIGU9ZnVuY3Rpb24oZSl7aWYoZS5jcmVhdGVSYW5nZSl7dmFyIHQ9ZS5jcmVhdGVSYW5nZSgpO2lmKHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KXt2YXIgQT1lLmNyZWF0ZUVsZW1lbnQoImJvdW5kdGVzdCIpO0Euc3R5bGUuaGVpZ2h0PSIxMjNweCIsQS5zdHlsZS5kaXNwbGF5PSJibG9jayIsZS5ib2R5LmFwcGVuZENoaWxkKEEpLHQuc2VsZWN0Tm9kZShBKTt2YXIgcj10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG49TWF0aC5yb3VuZChyLmhlaWdodCk7aWYoZS5ib2R5LnJlbW92ZUNoaWxkKEEpLDEyMz09PW4pcmV0dXJuITB9fXJldHVybiExfShkb2N1bWVudCk7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXciwiU1VQUE9SVF9SQU5HRV9CT1VORFMiLHt2YWx1ZTplfSksZX0sZ2V0IFNVUFBPUlRfV09SRF9CUkVBS0lORygpe3ZhciBlPVdyLlNVUFBPUlRfUkFOR0VfQk9VTkRTJiZmdW5jdGlvbihlKXt2YXIgdD1lLmNyZWF0ZUVsZW1lbnQoImJvdW5kdGVzdCIpO3Quc3R5bGUud2lkdGg9IjUwcHgiLHQuc3R5bGUuZGlzcGxheT0iYmxvY2siLHQuc3R5bGUuZm9udFNpemU9IjEycHgiLHQuc3R5bGUubGV0dGVyU3BhY2luZz0iMHB4Iix0LnN0eWxlLndvcmRTcGFjaW5nPSIwcHgiLGUuYm9keS5hcHBlbmRDaGlsZCh0KTt2YXIgQT1lLmNyZWF0ZVJhbmdlKCk7dC5pbm5lckhUTUw9ImZ1bmN0aW9uIj09dHlwZW9mIiIucmVwZWF0PyImIzEyODEwNDsiLnJlcGVhdCgxMCk6IiI7dmFyIHI9dC5maXJzdENoaWxkLG49YShyLmRhdGEpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbChlKX0pLHM9MCxpPXt9LG89bi5ldmVyeShmdW5jdGlvbihlLHQpe0Euc2V0U3RhcnQocixzKSxBLnNldEVuZChyLHMrZS5sZW5ndGgpO3ZhciBuPUEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cys9ZS5sZW5ndGg7dmFyIG89bi54PmkueHx8bi55PmkueTtyZXR1cm4gaT1uLDA9PT10fHxvfSk7cmV0dXJuIGUuYm9keS5yZW1vdmVDaGlsZCh0KSxvfShkb2N1bWVudCk7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXciwiU1VQUE9SVF9XT1JEX0JSRUFLSU5HIix7dmFsdWU6ZX0pLGV9LGdldCBTVVBQT1JUX1NWR19EUkFXSU5HKCl7dmFyIGU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEltYWdlLEE9ZS5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxyPUEuZ2V0Q29udGV4dCgiMmQiKTtpZighcilyZXR1cm4hMTt0LnNyYz0iZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJz48L3N2Zz4iO3RyeXtyLmRyYXdJbWFnZSh0LDAsMCksQS50b0RhdGFVUkwoKX1jYXRjaChlKXtyZXR1cm4hMX1yZXR1cm4hMH0oZG9jdW1lbnQpO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3IsIlNVUFBPUlRfU1ZHX0RSQVdJTkciLHt2YWx1ZTplfSksZX0sZ2V0IFNVUFBPUlRfRk9SRUlHTk9CSkVDVF9EUkFXSU5HKCl7dmFyIGU9ImZ1bmN0aW9uIj09dHlwZW9mIEFycmF5LmZyb20mJiJmdW5jdGlvbiI9PXR5cGVvZiB3aW5kb3cuZmV0Y2g/ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxBPTEwMDt0LndpZHRoPUEsdC5oZWlnaHQ9QTt2YXIgcj10LmdldENvbnRleHQoIjJkIik7aWYoIXIpcmV0dXJuIFByb21pc2UucmVqZWN0KCExKTtyLmZpbGxTdHlsZT0icmdiKDAsIDI1NSwgMCkiLHIuZmlsbFJlY3QoMCwwLEEsQSk7dmFyIG49bmV3IEltYWdlLHM9dC50b0RhdGFVUkwoKTtuLnNyYz1zO3ZhciBpPXpyKEEsQSwwLDAsbik7cmV0dXJuIHIuZmlsbFN0eWxlPSJyZWQiLHIuZmlsbFJlY3QoMCwwLEEsQSkscXIoaSkudGhlbihmdW5jdGlvbih0KXtyLmRyYXdJbWFnZSh0LDAsMCk7dmFyIG49ci5nZXRJbWFnZURhdGEoMCwwLEEsQSkuZGF0YTtyLmZpbGxTdHlsZT0icmVkIixyLmZpbGxSZWN0KDAsMCxBLEEpO3ZhciBpPWUuY3JlYXRlRWxlbWVudCgiZGl2Iik7cmV0dXJuIGkuc3R5bGUuYmFja2dyb3VuZEltYWdlPSJ1cmwoIitzKyIpIixpLnN0eWxlLmhlaWdodD1BKyJweCIsR3Iobik/cXIoenIoQSxBLDAsMCxpKSk6UHJvbWlzZS5yZWplY3QoITEpfSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gci5kcmF3SW1hZ2UoZSwwLDApLEdyKHIuZ2V0SW1hZ2VEYXRhKDAsMCxBLEEpLmRhdGEpfSkuY2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4hMX0pfShkb2N1bWVudCk6UHJvbWlzZS5yZXNvbHZlKCExKTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyLCJTVVBQT1JUX0ZPUkVJR05PQkpFQ1RfRFJBV0lORyIse3ZhbHVlOmV9KSxlfSxnZXQgU1VQUE9SVF9DT1JTX0lNQUdFUygpe3ZhciBlPXZvaWQgMCE9PShuZXcgSW1hZ2UpLmNyb3NzT3JpZ2luO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3IsIlNVUFBPUlRfQ09SU19JTUFHRVMiLHt2YWx1ZTplfSksZX0sZ2V0IFNVUFBPUlRfUkVTUE9OU0VfVFlQRSgpe3ZhciBlPSJzdHJpbmciPT10eXBlb2YobmV3IFhNTEh0dHBSZXF1ZXN0KS5yZXNwb25zZVR5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXciwiU1VQUE9SVF9SRVNQT05TRV9UWVBFIix7dmFsdWU6ZX0pLGV9LGdldCBTVVBQT1JUX0NPUlNfWEhSKCl7dmFyIGU9IndpdGhDcmVkZW50aWFscyJpbiBuZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXciwiU1VQUE9SVF9DT1JTX1hIUiIse3ZhbHVlOmV9KSxlfSxnZXQgU1VQUE9SVF9OQVRJVkVfVEVYVF9TRUdNRU5UQVRJT04oKXt2YXIgZT0hKCJ1bmRlZmluZWQiPT10eXBlb2YgSW50bHx8IUludGwuU2VnbWVudGVyKTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyLCJTVVBQT1JUX05BVElWRV9URVhUX1NFR01FTlRBVElPTiIse3ZhbHVlOmV9KSxlfX0sWHI9ZnVuY3Rpb24oZSx0KXt0aGlzLnRleHQ9ZSx0aGlzLmJvdW5kcz10fSxZcj1mdW5jdGlvbihlLHQpe3ZhciBBPXQub3duZXJEb2N1bWVudDtpZihBKXt2YXIgcj1BLmNyZWF0ZUVsZW1lbnQoImh0bWwyY2FudmFzd3JhcHBlciIpO3IuYXBwZW5kQ2hpbGQodC5jbG9uZU5vZGUoITApKTt2YXIgbj10LnBhcmVudE5vZGU7aWYobil7bi5yZXBsYWNlQ2hpbGQocix0KTt2YXIgcz1vKGUscik7cmV0dXJuIHIuZmlyc3RDaGlsZCYmbi5yZXBsYWNlQ2hpbGQoci5maXJzdENoaWxkLHIpLHN9fXJldHVybiBpLkVNUFRZfSxKcj1mdW5jdGlvbihlLHQsQSl7dmFyIHI9ZS5vd25lckRvY3VtZW50O2lmKCFyKXRocm93IG5ldyBFcnJvcigiTm9kZSBoYXMgbm8gb3duZXIgZG9jdW1lbnQiKTt2YXIgbj1yLmNyZWF0ZVJhbmdlKCk7cmV0dXJuIG4uc2V0U3RhcnQoZSx0KSxuLnNldEVuZChlLHQrQSksbn0sWnI9ZnVuY3Rpb24oZSl7aWYoV3IuU1VQUE9SVF9OQVRJVkVfVEVYVF9TRUdNRU5UQVRJT04pe3ZhciB0PW5ldyBJbnRsLlNlZ21lbnRlcih2b2lkIDAse2dyYW51bGFyaXR5OiJncmFwaGVtZSJ9KTtyZXR1cm4gQXJyYXkuZnJvbSh0LnNlZ21lbnQoZSkpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zZWdtZW50fSl9cmV0dXJuIGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxBPVZyKGUpLHI9W107ISh0PUEubmV4dCgpKS5kb25lOyl0LnZhbHVlJiZyLnB1c2godC52YWx1ZS5zbGljZSgpKTtyZXR1cm4gcn0oZSl9LCRyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDAhPT10LmxldHRlclNwYWNpbmc/WnIoZSk6ZnVuY3Rpb24oZSx0KXtpZihXci5TVVBQT1JUX05BVElWRV9URVhUX1NFR01FTlRBVElPTil7dmFyIEE9bmV3IEludGwuU2VnbWVudGVyKHZvaWQgMCx7Z3JhbnVsYXJpdHk6IndvcmQifSk7cmV0dXJuIEFycmF5LmZyb20oQS5zZWdtZW50KGUpKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2VnbWVudH0pfXJldHVybiB0bihlLHQpfShlLHQpfSxlbj1bMzIsMTYwLDQ5NjEsNjU3OTIsNjU3OTMsNDE1Myw0MjQxXSx0bj1mdW5jdGlvbihlLHQpe2Zvcih2YXIgQSxyPWZ1bmN0aW9uKGUsdCl7dmFyIEE9YShlKSxyPXNlKEEsdCksbj1yWzBdLHM9clsxXSxpPXJbMl0sbz1BLmxlbmd0aCxsPTAsYz0wO3JldHVybntuZXh0OmZ1bmN0aW9uKCl7aWYoYz49bylyZXR1cm57ZG9uZTohMCx2YWx1ZTpudWxsfTtmb3IodmFyIGU9ejtjPG8mJihlPW5lKEEscyxuLCsrYyxpKSk9PT16Oyk7aWYoZSE9PXp8fGM9PT1vKXt2YXIgdD1uZXcgaWUoQSxlLGwsYyk7cmV0dXJuIGw9Yyx7dmFsdWU6dCxkb25lOiExfX1yZXR1cm57ZG9uZTohMCx2YWx1ZTpudWxsfX19fShlLHtsaW5lQnJlYWs6dC5saW5lQnJlYWssd29yZEJyZWFrOiJicmVhay13b3JkIj09PXQub3ZlcmZsb3dXcmFwPyJicmVhay13b3JkIjp0LndvcmRCcmVha30pLG49W10scz1mdW5jdGlvbigpe2lmKEEudmFsdWUpe3ZhciBlPUEudmFsdWUuc2xpY2UoKSx0PWEoZSkscj0iIjt0LmZvckVhY2goZnVuY3Rpb24oZSl7LTE9PT1lbi5pbmRleE9mKGUpP3IrPWwoZSk6KHIubGVuZ3RoJiZuLnB1c2gociksbi5wdXNoKGwoZSkpLHI9IiIpfSksci5sZW5ndGgmJm4ucHVzaChyKX19OyEoQT1yLm5leHQoKSkuZG9uZTspcygpO3JldHVybiBufSxBbj1mdW5jdGlvbihlLHQsQSl7dGhpcy50ZXh0PXJuKHQuZGF0YSxBLnRleHRUcmFuc2Zvcm0pLHRoaXMudGV4dEJvdW5kcz1mdW5jdGlvbihlLHQsQSxyKXt2YXIgbj0kcih0LEEpLHM9W10sbz0wO3JldHVybiBuLmZvckVhY2goZnVuY3Rpb24odCl7aWYoQS50ZXh0RGVjb3JhdGlvbkxpbmUubGVuZ3RofHx0LnRyaW0oKS5sZW5ndGg+MClpZihXci5TVVBQT1JUX1JBTkdFX0JPVU5EUyl7dmFyIG49SnIocixvLHQubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO2lmKG4ubGVuZ3RoPjEpe3ZhciBhPVpyKHQpLGw9MDthLmZvckVhY2goZnVuY3Rpb24odCl7cy5wdXNoKG5ldyBYcih0LGkuZnJvbURPTVJlY3RMaXN0KGUsSnIocixsK28sdC5sZW5ndGgpLmdldENsaWVudFJlY3RzKCkpKSksbCs9dC5sZW5ndGh9KX1lbHNlIHMucHVzaChuZXcgWHIodCxpLmZyb21ET01SZWN0TGlzdChlLG4pKSl9ZWxzZXt2YXIgYz1yLnNwbGl0VGV4dCh0Lmxlbmd0aCk7cy5wdXNoKG5ldyBYcih0LFlyKGUscikpKSxyPWN9ZWxzZSBXci5TVVBQT1JUX1JBTkdFX0JPVU5EU3x8KHI9ci5zcGxpdFRleHQodC5sZW5ndGgpKTtvKz10Lmxlbmd0aH0pLHN9KGUsdGhpcy50ZXh0LEEsdCl9LHJuPWZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2UgMTpyZXR1cm4gZS50b0xvd2VyQ2FzZSgpO2Nhc2UgMzpyZXR1cm4gZS5yZXBsYWNlKG5uLHNuKTtjYXNlIDI6cmV0dXJuIGUudG9VcHBlckNhc2UoKTtkZWZhdWx0OnJldHVybiBlfX0sbm49LyhefFxzfDp8LXxcKHxcKSkoW2Etel0pL2csc249ZnVuY3Rpb24oZSx0LEEpe3JldHVybiBlLmxlbmd0aD4wP3QrQS50b1VwcGVyQ2FzZSgpOmV9LG9uPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIEEodCxBKXt2YXIgcj1lLmNhbGwodGhpcyx0LEEpfHx0aGlzO3JldHVybiByLnNyYz1BLmN1cnJlbnRTcmN8fEEuc3JjLHIuaW50cmluc2ljV2lkdGg9QS5uYXR1cmFsV2lkdGgsci5pbnRyaW5zaWNIZWlnaHQ9QS5uYXR1cmFsSGVpZ2h0LHIuY29udGV4dC5jYWNoZS5hZGRJbWFnZShyLnNyYykscn1yZXR1cm4gdChBLGUpLEF9KGpyKSxhbj1mdW5jdGlvbihlKXtmdW5jdGlvbiBBKHQsQSl7dmFyIHI9ZS5jYWxsKHRoaXMsdCxBKXx8dGhpcztyZXR1cm4gci5jYW52YXM9QSxyLmludHJpbnNpY1dpZHRoPUEud2lkdGgsci5pbnRyaW5zaWNIZWlnaHQ9QS5oZWlnaHQscn1yZXR1cm4gdChBLGUpLEF9KGpyKSxsbj1mdW5jdGlvbihlKXtmdW5jdGlvbiBBKHQsQSl7dmFyIHI9ZS5jYWxsKHRoaXMsdCxBKXx8dGhpcyxuPW5ldyBYTUxTZXJpYWxpemVyLHM9byh0LEEpO3JldHVybiBBLnNldEF0dHJpYnV0ZSgid2lkdGgiLHMud2lkdGgrInB4IiksQS5zZXRBdHRyaWJ1dGUoImhlaWdodCIscy5oZWlnaHQrInB4Iiksci5zdmc9ImRhdGE6aW1hZ2Uvc3ZnK3htbCwiK2VuY29kZVVSSUNvbXBvbmVudChuLnNlcmlhbGl6ZVRvU3RyaW5nKEEpKSxyLmludHJpbnNpY1dpZHRoPUEud2lkdGguYmFzZVZhbC52YWx1ZSxyLmludHJpbnNpY0hlaWdodD1BLmhlaWdodC5iYXNlVmFsLnZhbHVlLHIuY29udGV4dC5jYWNoZS5hZGRJbWFnZShyLnN2Zykscn1yZXR1cm4gdChBLGUpLEF9KGpyKSxjbj1mdW5jdGlvbihlKXtmdW5jdGlvbiBBKHQsQSl7dmFyIHI9ZS5jYWxsKHRoaXMsdCxBKXx8dGhpcztyZXR1cm4gci52YWx1ZT1BLnZhbHVlLHJ9cmV0dXJuIHQoQSxlKSxBfShqciksdW49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gQSh0LEEpe3ZhciByPWUuY2FsbCh0aGlzLHQsQSl8fHRoaXM7cmV0dXJuIHIuc3RhcnQ9QS5zdGFydCxyLnJldmVyc2VkPSJib29sZWFuIj09dHlwZW9mIEEucmV2ZXJzZWQmJiEwPT09QS5yZXZlcnNlZCxyfXJldHVybiB0KEEsZSksQX0oanIpLGhuPVt7dHlwZToxNSxmbGFnczowLHVuaXQ6InB4IixudW1iZXI6M31dLGRuPVt7dHlwZToxNixmbGFnczowLG51bWJlcjo1MH1dLGZuPSJjaGVja2JveCIscG49InJhZGlvIixnbj0icGFzc3dvcmQiLG1uPTcwNzQwNjU5MSx3bj1mdW5jdGlvbihlKXtmdW5jdGlvbiBBKHQsQSl7dmFyIHIsbixzLG89ZS5jYWxsKHRoaXMsdCxBKXx8dGhpcztzd2l0Y2goby50eXBlPUEudHlwZS50b0xvd2VyQ2FzZSgpLG8uY2hlY2tlZD1BLmNoZWNrZWQsby52YWx1ZT0wPT09KHM9KG49QSkudHlwZT09PWduP25ldyBBcnJheShuLnZhbHVlLmxlbmd0aCsxKS5qb2luKCLigKIiKTpuLnZhbHVlKS5sZW5ndGg/bi5wbGFjZWhvbGRlcnx8IiI6cyxvLnR5cGUhPT1mbiYmby50eXBlIT09cG58fChvLnN0eWxlcy5iYWNrZ3JvdW5kQ29sb3I9MzczOTE0ODAzMSxvLnN0eWxlcy5ib3JkZXJUb3BDb2xvcj1vLnN0eWxlcy5ib3JkZXJSaWdodENvbG9yPW8uc3R5bGVzLmJvcmRlckJvdHRvbUNvbG9yPW8uc3R5bGVzLmJvcmRlckxlZnRDb2xvcj0yNzc5MDk2NTc1LG8uc3R5bGVzLmJvcmRlclRvcFdpZHRoPW8uc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGg9by5zdHlsZXMuYm9yZGVyQm90dG9tV2lkdGg9by5zdHlsZXMuYm9yZGVyTGVmdFdpZHRoPTEsby5zdHlsZXMuYm9yZGVyVG9wU3R5bGU9by5zdHlsZXMuYm9yZGVyUmlnaHRTdHlsZT1vLnN0eWxlcy5ib3JkZXJCb3R0b21TdHlsZT1vLnN0eWxlcy5ib3JkZXJMZWZ0U3R5bGU9MSxvLnN0eWxlcy5iYWNrZ3JvdW5kQ2xpcD1bMF0sby5zdHlsZXMuYmFja2dyb3VuZE9yaWdpbj1bMF0sby5ib3VuZHM9KHI9by5ib3VuZHMpLndpZHRoPnIuaGVpZ2h0P25ldyBpKHIubGVmdCsoci53aWR0aC1yLmhlaWdodCkvMixyLnRvcCxyLmhlaWdodCxyLmhlaWdodCk6ci53aWR0aDxyLmhlaWdodD9uZXcgaShyLmxlZnQsci50b3ArKHIuaGVpZ2h0LXIud2lkdGgpLzIsci53aWR0aCxyLndpZHRoKTpyKSxvLnR5cGUpe2Nhc2UgZm46by5zdHlsZXMuYm9yZGVyVG9wUmlnaHRSYWRpdXM9by5zdHlsZXMuYm9yZGVyVG9wTGVmdFJhZGl1cz1vLnN0eWxlcy5ib3JkZXJCb3R0b21SaWdodFJhZGl1cz1vLnN0eWxlcy5ib3JkZXJCb3R0b21MZWZ0UmFkaXVzPWhuO2JyZWFrO2Nhc2UgcG46by5zdHlsZXMuYm9yZGVyVG9wUmlnaHRSYWRpdXM9by5zdHlsZXMuYm9yZGVyVG9wTGVmdFJhZGl1cz1vLnN0eWxlcy5ib3JkZXJCb3R0b21SaWdodFJhZGl1cz1vLnN0eWxlcy5ib3JkZXJCb3R0b21MZWZ0UmFkaXVzPWRufXJldHVybiBvfXJldHVybiB0KEEsZSksQX0oanIpLEJuPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIEEodCxBKXt2YXIgcj1lLmNhbGwodGhpcyx0LEEpfHx0aGlzLG49QS5vcHRpb25zW0Euc2VsZWN0ZWRJbmRleHx8MF07cmV0dXJuIHIudmFsdWU9biYmbi50ZXh0fHwiIixyfXJldHVybiB0KEEsZSksQX0oanIpLHluPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIEEodCxBKXt2YXIgcj1lLmNhbGwodGhpcyx0LEEpfHx0aGlzO3JldHVybiByLnZhbHVlPUEudmFsdWUscn1yZXR1cm4gdChBLGUpLEF9KGpyKSx2bj1mdW5jdGlvbihlKXtmdW5jdGlvbiBBKHQsQSl7dmFyIHI9ZS5jYWxsKHRoaXMsdCxBKXx8dGhpcztyLnNyYz1BLnNyYyxyLndpZHRoPXBhcnNlSW50KEEud2lkdGgsMTApfHwwLHIuaGVpZ2h0PXBhcnNlSW50KEEuaGVpZ2h0LDEwKXx8MCxyLmJhY2tncm91bmRDb2xvcj1yLnN0eWxlcy5iYWNrZ3JvdW5kQ29sb3I7dHJ5e2lmKEEuY29udGVudFdpbmRvdyYmQS5jb250ZW50V2luZG93LmRvY3VtZW50JiZBLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KXtyLnRyZWU9am4odCxBLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTt2YXIgbj1BLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50P3Z0KHQsZ2V0Q29tcHV0ZWRTdHlsZShBLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5iYWNrZ3JvdW5kQ29sb3IpOmJ0LlRSQU5TUEFSRU5ULHM9QS5jb250ZW50V2luZG93LmRvY3VtZW50LmJvZHk/dnQodCxnZXRDb21wdXRlZFN0eWxlKEEuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5KS5iYWNrZ3JvdW5kQ29sb3IpOmJ0LlRSQU5TUEFSRU5UO3IuYmFja2dyb3VuZENvbG9yPWR0KG4pP2R0KHMpP3Iuc3R5bGVzLmJhY2tncm91bmRDb2xvcjpzOm59fWNhdGNoKGUpe31yZXR1cm4gcn1yZXR1cm4gdChBLGUpLEF9KGpyKSxibj1bIk9MIiwiVUwiLCJNRU5VIl0sQ249ZnVuY3Rpb24oZSx0LEEscil7Zm9yKHZhciBuPXQuZmlyc3RDaGlsZCxzPXZvaWQgMDtuO249cylpZihzPW4ubmV4dFNpYmxpbmcsUW4obikmJm4uZGF0YS50cmltKCkubGVuZ3RoPjApQS50ZXh0Tm9kZXMucHVzaChuZXcgQW4oZSxuLEEuc3R5bGVzKSk7ZWxzZSBpZihVbihuKSlpZihWbihuKSYmbi5hc3NpZ25lZE5vZGVzKW4uYXNzaWduZWROb2RlcygpLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIENuKGUsdCxBLHIpfSk7ZWxzZXt2YXIgaT1fbihlLG4pO2kuc3R5bGVzLmlzVmlzaWJsZSgpJiYoeG4obixpLHIpP2kuZmxhZ3N8PTQ6Rm4oaS5zdHlsZXMpJiYoaS5mbGFnc3w9MiksLTEhPT1ibi5pbmRleE9mKG4udGFnTmFtZSkmJihpLmZsYWdzfD04KSxBLmVsZW1lbnRzLnB1c2goaSksbi5zbG90LG4uc2hhZG93Um9vdD9DbihlLG4uc2hhZG93Um9vdCxpLHIpOlJuKG4pfHxrbihuKXx8S24obil8fENuKGUsbixpLHIpKX19LF9uPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9uKHQpP25ldyBvbihlLHQpOlBuKHQpP25ldyBhbihlLHQpOmtuKHQpP25ldyBsbihlLHQpOkxuKHQpP25ldyBjbihlLHQpOkluKHQpP25ldyB1bihlLHQpOk5uKHQpP25ldyB3bihlLHQpOktuKHQpP25ldyBCbihlLHQpOlJuKHQpP25ldyB5bihlLHQpOk1uKHQpP25ldyB2bihlLHQpOm5ldyBqcihlLHQpfSxqbj1mdW5jdGlvbihlLHQpe3ZhciBBPV9uKGUsdCk7cmV0dXJuIEEuZmxhZ3N8PTQsQ24oZSx0LEEsQSksQX0seG49ZnVuY3Rpb24oZSx0LEEpe3JldHVybiB0LnN0eWxlcy5pc1Bvc2l0aW9uZWRXaXRoWkluZGV4KCl8fHQuc3R5bGVzLm9wYWNpdHk8MXx8dC5zdHlsZXMuaXNUcmFuc2Zvcm1lZCgpfHxIbihlKSYmQS5zdHlsZXMuaXNUcmFuc3BhcmVudCgpfSxGbj1mdW5jdGlvbihlKXtyZXR1cm4gZS5pc1Bvc2l0aW9uZWQoKXx8ZS5pc0Zsb2F0aW5nKCl9LFFuPWZ1bmN0aW9uKGUpe3JldHVybiBlLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREV9LFVuPWZ1bmN0aW9uKGUpe3JldHVybiBlLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREV9LEVuPWZ1bmN0aW9uKGUpe3JldHVybiBVbihlKSYmdm9pZCAwIT09ZS5zdHlsZSYmIVNuKGUpfSxTbj1mdW5jdGlvbihlKXtyZXR1cm4ib2JqZWN0Ij09dHlwZW9mIGUuY2xhc3NOYW1lfSxMbj1mdW5jdGlvbihlKXtyZXR1cm4iTEkiPT09ZS50YWdOYW1lfSxJbj1mdW5jdGlvbihlKXtyZXR1cm4iT0wiPT09ZS50YWdOYW1lfSxObj1mdW5jdGlvbihlKXtyZXR1cm4iSU5QVVQiPT09ZS50YWdOYW1lfSxrbj1mdW5jdGlvbihlKXtyZXR1cm4ic3ZnIj09PWUudGFnTmFtZX0sSG49ZnVuY3Rpb24oZSl7cmV0dXJuIkJPRFkiPT09ZS50YWdOYW1lfSxQbj1mdW5jdGlvbihlKXtyZXR1cm4iQ0FOVkFTIj09PWUudGFnTmFtZX0sVG49ZnVuY3Rpb24oZSl7cmV0dXJuIlZJREVPIj09PWUudGFnTmFtZX0sT249ZnVuY3Rpb24oZSl7cmV0dXJuIklNRyI9PT1lLnRhZ05hbWV9LE1uPWZ1bmN0aW9uKGUpe3JldHVybiJJRlJBTUUiPT09ZS50YWdOYW1lfSxEbj1mdW5jdGlvbihlKXtyZXR1cm4iU1RZTEUiPT09ZS50YWdOYW1lfSxSbj1mdW5jdGlvbihlKXtyZXR1cm4iVEVYVEFSRUEiPT09ZS50YWdOYW1lfSxLbj1mdW5jdGlvbihlKXtyZXR1cm4iU0VMRUNUIj09PWUudGFnTmFtZX0sVm49ZnVuY3Rpb24oZSl7cmV0dXJuIlNMT1QiPT09ZS50YWdOYW1lfSxHbj1mdW5jdGlvbihlKXtyZXR1cm4gZS50YWdOYW1lLmluZGV4T2YoIi0iKT4wfSx6bj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0aGlzLmNvdW50ZXJzPXt9fXJldHVybiBlLnByb3RvdHlwZS5nZXRDb3VudGVyVmFsdWU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5jb3VudGVyc1tlXTtyZXR1cm4gdCYmdC5sZW5ndGg/dFt0Lmxlbmd0aC0xXToxfSxlLnByb3RvdHlwZS5nZXRDb3VudGVyVmFsdWVzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNvdW50ZXJzW2VdfHxbXX0sZS5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmNvdW50ZXJzW2VdLnBvcCgpfSl9LGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsQT1lLmNvdW50ZXJJbmNyZW1lbnQscj1lLmNvdW50ZXJSZXNldCxuPSEwO251bGwhPT1BJiZBLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIEE9dC5jb3VudGVyc1tlLmNvdW50ZXJdO0EmJjAhPT1lLmluY3JlbWVudCYmKG49ITEsQS5sZW5ndGh8fEEucHVzaCgxKSxBW01hdGgubWF4KDAsQS5sZW5ndGgtMSldKz1lLmluY3JlbWVudCl9KTt2YXIgcz1bXTtyZXR1cm4gbiYmci5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBBPXQuY291bnRlcnNbZS5jb3VudGVyXTtzLnB1c2goZS5jb3VudGVyKSxBfHwoQT10LmNvdW50ZXJzW2UuY291bnRlcl09W10pLEEucHVzaChlLnJlc2V0KX0pLHN9LGV9KCkscW49e2ludGVnZXJzOlsxZTMsOTAwLDUwMCw0MDAsMTAwLDkwLDUwLDQwLDEwLDksNSw0LDFdLHZhbHVlczpbIk0iLCJDTSIsIkQiLCJDRCIsIkMiLCJYQyIsIkwiLCJYTCIsIlgiLCJJWCIsIlYiLCJJViIsIkkiXX0sV249e2ludGVnZXJzOls5ZTMsOGUzLDdlMyw2ZTMsNWUzLDRlMywzZTMsMmUzLDFlMyw5MDAsODAwLDcwMCw2MDAsNTAwLDQwMCwzMDAsMjAwLDEwMCw5MCw4MCw3MCw2MCw1MCw0MCwzMCwyMCwxMCw5LDgsNyw2LDUsNCwzLDIsMV0sdmFsdWVzOlsi1ZQiLCLVkyIsItWSIiwi1ZEiLCLVkCIsItWPIiwi1Y4iLCLVjSIsItWMIiwi1YsiLCLViiIsItWJIiwi1YgiLCLVhyIsItWGIiwi1YUiLCLVhCIsItWDIiwi1YIiLCLVgSIsItWAIiwi1L8iLCLUviIsItS9Iiwi1LwiLCLUuyIsItS6Iiwi1LkiLCLUuCIsItS3Iiwi1LYiLCLUtSIsItS0Iiwi1LMiLCLUsiIsItSxIl19LFhuPXtpbnRlZ2VyczpbMWU0LDllMyw4ZTMsN2UzLDZlMyw1ZTMsNGUzLDNlMywyZTMsMWUzLDQwMCwzMDAsMjAwLDEwMCw5MCw4MCw3MCw2MCw1MCw0MCwzMCwyMCwxOSwxOCwxNywxNiwxNSwxMCw5LDgsNyw2LDUsNCwzLDIsMV0sdmFsdWVzOlsi15nXsyIsIteY17MiLCLXl9ezIiwi15bXsyIsIteV17MiLCLXlNezIiwi15PXsyIsIteS17MiLCLXkdezIiwi15DXsyIsIteqIiwi16kiLCLXqCIsItenIiwi16YiLCLXpCIsIteiIiwi16EiLCLXoCIsIteeIiwi15wiLCLXmyIsIteZ15giLCLXmdeXIiwi15nXliIsIteY15YiLCLXmNeVIiwi15kiLCLXmCIsIteXIiwi15YiLCLXlSIsIteUIiwi15MiLCLXkiIsIteRIiwi15AiXX0sWW49e2ludGVnZXJzOlsxZTQsOWUzLDhlMyw3ZTMsNmUzLDVlMyw0ZTMsM2UzLDJlMywxZTMsOTAwLDgwMCw3MDAsNjAwLDUwMCw0MDAsMzAwLDIwMCwxMDAsOTAsODAsNzAsNjAsNTAsNDAsMzAsMjAsMTAsOSw4LDcsNiw1LDQsMywyLDFdLHZhbHVlczpbIuGDtSIsIuGDsCIsIuGDryIsIuGDtCIsIuGDriIsIuGDrSIsIuGDrCIsIuGDqyIsIuGDqiIsIuGDqSIsIuGDqCIsIuGDpyIsIuGDpiIsIuGDpSIsIuGDpCIsIuGDsyIsIuGDoiIsIuGDoSIsIuGDoCIsIuGDnyIsIuGDniIsIuGDnSIsIuGDsiIsIuGDnCIsIuGDmyIsIuGDmiIsIuGDmSIsIuGDmCIsIuGDlyIsIuGDsSIsIuGDliIsIuGDlSIsIuGDlCIsIuGDkyIsIuGDkiIsIuGDkSIsIuGDkCJdfSxKbj1mdW5jdGlvbihlLHQsQSxyLG4scyl7cmV0dXJuIGU8dHx8ZT5BP2lzKGUsbixzLmxlbmd0aD4wKTpyLmludGVnZXJzLnJlZHVjZShmdW5jdGlvbih0LEEsbil7Zm9yKDtlPj1BOyllLT1BLHQrPXIudmFsdWVzW25dO3JldHVybiB0fSwiIikrc30sWm49ZnVuY3Rpb24oZSx0LEEscil7dmFyIG49IiI7ZG97QXx8ZS0tLG49cihlKStuLGUvPXR9d2hpbGUoZSp0Pj10KTtyZXR1cm4gbn0sJG49ZnVuY3Rpb24oZSx0LEEscixuKXt2YXIgcz1BLXQrMTtyZXR1cm4oZTwwPyItIjoiIikrKFpuKE1hdGguYWJzKGUpLHMscixmdW5jdGlvbihlKXtyZXR1cm4gbChNYXRoLmZsb29yKGUlcykrdCl9KStuKX0sZXM9ZnVuY3Rpb24oZSx0LEEpe3ZvaWQgMD09PUEmJihBPSIuICIpO3ZhciByPXQubGVuZ3RoO3JldHVybiBabihNYXRoLmFicyhlKSxyLCExLGZ1bmN0aW9uKGUpe3JldHVybiB0W01hdGguZmxvb3IoZSVyKV19KStBfSx0cz1mdW5jdGlvbihlLHQsQSxyLG4scyl7aWYoZTwtOTk5OXx8ZT45OTk5KXJldHVybiBpcyhlLDQsbi5sZW5ndGg+MCk7dmFyIGk9TWF0aC5hYnMoZSksbz1uO2lmKDA9PT1pKXJldHVybiB0WzBdK287Zm9yKHZhciBhPTA7aT4wJiZhPD00O2ErKyl7dmFyIGw9aSUxMDswPT09bCYmbHIocywxKSYmIiIhPT1vP289dFtsXStvOmw+MXx8MT09PWwmJjA9PT1hfHwxPT09bCYmMT09PWEmJmxyKHMsMil8fDE9PT1sJiYxPT09YSYmbHIocyw0KSYmZT4xMDB8fDE9PT1sJiZhPjEmJmxyKHMsOCk/bz10W2xdKyhhPjA/QVthLTFdOiIiKStvOjE9PT1sJiZhPjAmJihvPUFbYS0xXStvKSxpPU1hdGguZmxvb3IoaS8xMCl9cmV0dXJuKGU8MD9yOiIiKStvfSxBcz0i5Y2B55m+5Y2D6JCsIixycz0i5ou+5L2w5Luf6JCsIixucz0i44Oe44Kk44OK44K5Iixzcz0i66eI7J2064SI7IqkIixpcz1mdW5jdGlvbihlLHQsQSl7dmFyIHI9QT8iLiAiOiIiLG49QT8i44CBIjoiIixzPUE/IiwgIjoiIixpPUE/IiAiOiIiO3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIuKAoiIraTtjYXNlIDE6cmV0dXJuIuKXpiIraTtjYXNlIDI6cmV0dXJuIuKXviIraTtjYXNlIDU6dmFyIG89JG4oZSw0OCw1NywhMCxyKTtyZXR1cm4gby5sZW5ndGg8ND8iMCIrbzpvO2Nhc2UgNDpyZXR1cm4gZXMoZSwi44CH5LiA5LqM5LiJ5Zub5LqU5YWt5LiD5YWr5LmdIixuKTtjYXNlIDY6cmV0dXJuIEpuKGUsMSwzOTk5LHFuLDMscikudG9Mb3dlckNhc2UoKTtjYXNlIDc6cmV0dXJuIEpuKGUsMSwzOTk5LHFuLDMscik7Y2FzZSA4OnJldHVybiAkbihlLDk0NSw5NjksITEscik7Y2FzZSA5OnJldHVybiAkbihlLDk3LDEyMiwhMSxyKTtjYXNlIDEwOnJldHVybiAkbihlLDY1LDkwLCExLHIpO2Nhc2UgMTE6cmV0dXJuICRuKGUsMTYzMiwxNjQxLCEwLHIpO2Nhc2UgMTI6Y2FzZSA0OTpyZXR1cm4gSm4oZSwxLDk5OTksV24sMyxyKTtjYXNlIDM1OnJldHVybiBKbihlLDEsOTk5OSxXbiwzLHIpLnRvTG93ZXJDYXNlKCk7Y2FzZSAxMzpyZXR1cm4gJG4oZSwyNTM0LDI1NDMsITAscik7Y2FzZSAxNDpjYXNlIDMwOnJldHVybiAkbihlLDYxMTIsNjEyMSwhMCxyKTtjYXNlIDE1OnJldHVybiBlcyhlLCLlrZDkuJHlr4Xlja/ovrDlt7PljYjmnKrnlLPphYnmiIzkuqUiLG4pO2Nhc2UgMTY6cmV0dXJuIGVzKGUsIueUsuS5meS4meS4geaIiuW3seW6mui+m+WjrOeZuCIsbik7Y2FzZSAxNzpjYXNlIDQ4OnJldHVybiB0cyhlLCLpm7bkuIDkuozkuInlm5vkupTlha3kuIPlhavkuZ0iLEFzLCLosqAiLG4sMTQpO2Nhc2UgNDc6cmV0dXJuIHRzKGUsIumbtuWjueiys+WPg+iChuS8jemZuOafkuaNjOeOliIscnMsIuiyoCIsbiwxNSk7Y2FzZSA0MjpyZXR1cm4gdHMoZSwi6Zu25LiA5LqM5LiJ5Zub5LqU5YWt5LiD5YWr5LmdIixBcywi6LSfIixuLDE0KTtjYXNlIDQxOnJldHVybiB0cyhlLCLpm7blo7notLDlj4HogobkvI3pmYbmn5LmjYznjpYiLHJzLCLotJ8iLG4sMTUpO2Nhc2UgMjY6cmV0dXJuIHRzKGUsIuOAh+S4gOS6jOS4ieWbm+S6lOWFreS4g+WFq+S5nSIsIuWNgeeZvuWNg+S4hyIsbnMsbiwwKTtjYXNlIDI1OnJldHVybiB0cyhlLCLpm7blo7HlvJDlj4Llm5vkvI3lha3kuIPlhavkuZ0iLCLmi77nmb7ljYPkuIciLG5zLG4sNyk7Y2FzZSAzMTpyZXR1cm4gdHMoZSwi7JiB7J287J207IK87IKs7Jik7Jyh7Lmg7YyU6rWsIiwi7Iut67Cx7LKc66eMIixzcyxzLDcpO2Nhc2UgMzM6cmV0dXJuIHRzKGUsIumbtuS4gOS6jOS4ieWbm+S6lOWFreS4g+WFq+S5nSIsIuWNgeeZvuWNg+iQrCIsc3MscywwKTtjYXNlIDMyOnJldHVybiB0cyhlLCLpm7blo7nosrPlj4Plm5vkupTlha3kuIPlhavkuZ0iLCLmi77nmb7ljYMiLHNzLHMsNyk7Y2FzZSAxODpyZXR1cm4gJG4oZSwyNDA2LDI0MTUsITAscik7Y2FzZSAyMDpyZXR1cm4gSm4oZSwxLDE5OTk5LFluLDMscik7Y2FzZSAyMTpyZXR1cm4gJG4oZSwyNzkwLDI3OTksITAscik7Y2FzZSAyMjpyZXR1cm4gJG4oZSwyNjYyLDI2NzEsITAscik7Y2FzZSAyMjpyZXR1cm4gSm4oZSwxLDEwOTk5LFhuLDMscik7Y2FzZSAyMzpyZXR1cm4gZXMoZSwi44GC44GE44GG44GI44GK44GL44GN44GP44GR44GT44GV44GX44GZ44Gb44Gd44Gf44Gh44Gk44Gm44Go44Gq44Gr44Gs44Gt44Gu44Gv44Gy44G144G444G744G+44G/44KA44KB44KC44KE44KG44KI44KJ44KK44KL44KM44KN44KP44KQ44KR44KS44KTIik7Y2FzZSAyNDpyZXR1cm4gZXMoZSwi44GE44KN44Gv44Gr44G744G444Go44Gh44KK44Gs44KL44KS44KP44GL44KI44Gf44KM44Gd44Gk44Gt44Gq44KJ44KA44GG44KQ44Gu44GK44GP44KE44G+44GR44G144GT44GI44Gm44GC44GV44GN44KG44KB44G/44GX44KR44Gy44KC44Gb44GZIik7Y2FzZSAyNzpyZXR1cm4gJG4oZSwzMzAyLDMzMTEsITAscik7Y2FzZSAyODpyZXR1cm4gZXMoZSwi44Ki44Kk44Km44Ko44Kq44Kr44Kt44Kv44Kx44Kz44K144K344K544K744K944K/44OB44OE44OG44OI44OK44OL44OM44ON44OO44OP44OS44OV44OY44Ob44Oe44Of44Og44Oh44Oi44Ok44Om44Oo44Op44Oq44Or44Os44Ot44Ov44Ow44Ox44Oy44OzIixuKTtjYXNlIDI5OnJldHVybiBlcyhlLCLjgqTjg63jg4/jg4vjg5vjg5jjg4jjg4Hjg6rjg4zjg6vjg7Ljg6/jgqvjg6jjgr/jg6zjgr3jg4Tjg43jg4rjg6njg6Djgqbjg7Djg47jgqrjgq/jg6Tjg57jgrHjg5XjgrPjgqjjg4bjgqLjgrXjgq3jg6bjg6Hjg5/jgrfjg7Hjg5Ljg6LjgrvjgrkiLG4pO2Nhc2UgMzQ6cmV0dXJuICRuKGUsMzc5MiwzODAxLCEwLHIpO2Nhc2UgMzc6cmV0dXJuICRuKGUsNjE2MCw2MTY5LCEwLHIpO2Nhc2UgMzg6cmV0dXJuICRuKGUsNDE2MCw0MTY5LCEwLHIpO2Nhc2UgMzk6cmV0dXJuICRuKGUsMjkxOCwyOTI3LCEwLHIpO2Nhc2UgNDA6cmV0dXJuICRuKGUsMTc3NiwxNzg1LCEwLHIpO2Nhc2UgNDM6cmV0dXJuICRuKGUsMzA0NiwzMDU1LCEwLHIpO2Nhc2UgNDQ6cmV0dXJuICRuKGUsMzE3NCwzMTgzLCEwLHIpO2Nhc2UgNDU6cmV0dXJuICRuKGUsMzY2NCwzNjczLCEwLHIpO2Nhc2UgNDY6cmV0dXJuICRuKGUsMzg3MiwzODgxLCEwLHIpO2RlZmF1bHQ6cmV0dXJuICRuKGUsNDgsNTcsITAscil9fSxvcz0iZGF0YS1odG1sMmNhbnZhcy1pZ25vcmUiLGFzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQsQSl7aWYodGhpcy5jb250ZXh0PWUsdGhpcy5vcHRpb25zPUEsdGhpcy5zY3JvbGxlZEVsZW1lbnRzPVtdLHRoaXMucmVmZXJlbmNlRWxlbWVudD10LHRoaXMuY291bnRlcnM9bmV3IHpuLHRoaXMucXVvdGVEZXB0aD0wLCF0Lm93bmVyRG9jdW1lbnQpdGhyb3cgbmV3IEVycm9yKCJDbG9uZWQgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGFuIG93bmVyIGRvY3VtZW50Iik7dGhpcy5kb2N1bWVudEVsZW1lbnQ9dGhpcy5jbG9uZU5vZGUodC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwhMSl9cmV0dXJuIGUucHJvdG90eXBlLnRvSUZyYW1lPWZ1bmN0aW9uKGUsdCl7dmFyIEE9dGhpcyxzPWNzKGUsdCk7aWYoIXMuY29udGVudFdpbmRvdylyZXR1cm4gUHJvbWlzZS5yZWplY3QoIlVuYWJsZSB0byBmaW5kIGlmcmFtZSB3aW5kb3ciKTt2YXIgaT1lLmRlZmF1bHRWaWV3LnBhZ2VYT2Zmc2V0LG89ZS5kZWZhdWx0Vmlldy5wYWdlWU9mZnNldCxhPXMuY29udGVudFdpbmRvdyxsPWEuZG9jdW1lbnQsYz1kcyhzKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHIoQSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsQTtyZXR1cm4gbih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuc2Nyb2xsZWRFbGVtZW50cy5mb3JFYWNoKHdzKSxhJiYoYS5zY3JvbGxUbyh0LmxlZnQsdC50b3ApLCEvKGlQYWR8aVBob25lfGlQb2QpL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KXx8YS5zY3JvbGxZPT09dC50b3AmJmEuc2Nyb2xsWD09PXQubGVmdHx8KHRoaXMuY29udGV4dC5sb2dnZXIud2FybigiVW5hYmxlIHRvIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9uIGZvciBjbG9uZWQgZG9jdW1lbnQiKSx0aGlzLmNvbnRleHQud2luZG93Qm91bmRzPXRoaXMuY29udGV4dC53aW5kb3dCb3VuZHMuYWRkKGEuc2Nyb2xsWC10LmxlZnQsYS5zY3JvbGxZLXQudG9wLDAsMCkpKSxlPXRoaXMub3B0aW9ucy5vbmNsb25lLHZvaWQgMD09PShBPXRoaXMuY2xvbmVkUmVmZXJlbmNlRWxlbWVudCk/WzIsUHJvbWlzZS5yZWplY3QoIkVycm9yIGZpbmRpbmcgdGhlICIrdGhpcy5yZWZlcmVuY2VFbGVtZW50Lm5vZGVOYW1lKyIgaW4gdGhlIGNsb25lZCBkb2N1bWVudCIpXTpsLmZvbnRzJiZsLmZvbnRzLnJlYWR5P1s0LGwuZm9udHMucmVhZHldOlszLDJdO2Nhc2UgMTpyLnNlbnQoKSxyLmxhYmVsPTI7Y2FzZSAyOnJldHVybi8oQXBwbGVXZWJLaXQpL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KT9bNCxocyhsKV06WzMsNF07Y2FzZSAzOnIuc2VudCgpLHIubGFiZWw9NDtjYXNlIDQ6cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIGU/WzIsUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBlKGwsQSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHN9KV06WzIsc119fSl9KX0pO3JldHVybiBsLm9wZW4oKSxsLndyaXRlKGdzKGRvY3VtZW50LmRvY3R5cGUpKyI8aHRtbD48L2h0bWw+IiksbXModGhpcy5yZWZlcmVuY2VFbGVtZW50Lm93bmVyRG9jdW1lbnQsaSxvKSxsLnJlcGxhY2VDaGlsZChsLmFkb3B0Tm9kZSh0aGlzLmRvY3VtZW50RWxlbWVudCksbC5kb2N1bWVudEVsZW1lbnQpLGwuY2xvc2UoKSxjfSxlLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50Q2xvbmU9ZnVuY3Rpb24oZSl7aWYoX3IoZSwyKSxQbihlKSlyZXR1cm4gdGhpcy5jcmVhdGVDYW52YXNDbG9uZShlKTtpZihUbihlKSlyZXR1cm4gdGhpcy5jcmVhdGVWaWRlb0Nsb25lKGUpO2lmKERuKGUpKXJldHVybiB0aGlzLmNyZWF0ZVN0eWxlQ2xvbmUoZSk7dmFyIHQ9ZS5jbG9uZU5vZGUoITEpO3JldHVybiBPbih0KSYmKE9uKGUpJiZlLmN1cnJlbnRTcmMmJmUuY3VycmVudFNyYyE9PWUuc3JjJiYodC5zcmM9ZS5jdXJyZW50U3JjLHQuc3Jjc2V0PSIiKSwibGF6eSI9PT10LmxvYWRpbmcmJih0LmxvYWRpbmc9ImVhZ2VyIikpLEduKHQpP3RoaXMuY3JlYXRlQ3VzdG9tRWxlbWVudENsb25lKHQpOnR9LGUucHJvdG90eXBlLmNyZWF0ZUN1c3RvbUVsZW1lbnRDbG9uZT1mdW5jdGlvbihlKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJodG1sMmNhbnZhc2N1c3RvbWVsZW1lbnQiKTtyZXR1cm4gcHMoZS5zdHlsZSx0KSx0fSxlLnByb3RvdHlwZS5jcmVhdGVTdHlsZUNsb25lPWZ1bmN0aW9uKGUpe3RyeXt2YXIgdD1lLnNoZWV0O2lmKHQmJnQuY3NzUnVsZXMpe3ZhciBBPVtdLnNsaWNlLmNhbGwodC5jc3NSdWxlcywwKS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdCYmInN0cmluZyI9PXR5cGVvZiB0LmNzc1RleHQ/ZSt0LmNzc1RleHQ6ZX0sIiIpLHI9ZS5jbG9uZU5vZGUoITEpO3JldHVybiByLnRleHRDb250ZW50PUEscn19Y2F0Y2goZSl7aWYodGhpcy5jb250ZXh0LmxvZ2dlci5lcnJvcigiVW5hYmxlIHRvIGFjY2VzcyBjc3NSdWxlcyBwcm9wZXJ0eSIsZSksIlNlY3VyaXR5RXJyb3IiIT09ZS5uYW1lKXRocm93IGV9cmV0dXJuIGUuY2xvbmVOb2RlKCExKX0sZS5wcm90b3R5cGUuY3JlYXRlQ2FudmFzQ2xvbmU9ZnVuY3Rpb24oZSl7dmFyIHQ7aWYodGhpcy5vcHRpb25zLmlubGluZUltYWdlcyYmZS5vd25lckRvY3VtZW50KXt2YXIgQT1lLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIik7dHJ5e3JldHVybiBBLnNyYz1lLnRvRGF0YVVSTCgpLEF9Y2F0Y2godCl7dGhpcy5jb250ZXh0LmxvZ2dlci5pbmZvKCJVbmFibGUgdG8gaW5saW5lIGNhbnZhcyBjb250ZW50cywgY2FudmFzIGlzIHRhaW50ZWQiLGUpfX12YXIgcj1lLmNsb25lTm9kZSghMSk7dHJ5e3Iud2lkdGg9ZS53aWR0aCxyLmhlaWdodD1lLmhlaWdodDt2YXIgbj1lLmdldENvbnRleHQoIjJkIikscz1yLmdldENvbnRleHQoIjJkIik7aWYocylpZighdGhpcy5vcHRpb25zLmFsbG93VGFpbnQmJm4pcy5wdXRJbWFnZURhdGEobi5nZXRJbWFnZURhdGEoMCwwLGUud2lkdGgsZS5oZWlnaHQpLDAsMCk7ZWxzZXt2YXIgaT1udWxsIT09KHQ9ZS5nZXRDb250ZXh0KCJ3ZWJnbDIiKSkmJnZvaWQgMCE9PXQ/dDplLmdldENvbnRleHQoIndlYmdsIik7aWYoaSl7dmFyIG89aS5nZXRDb250ZXh0QXR0cmlidXRlcygpOyExPT09KG51bGw9PW8/dm9pZCAwOm8ucHJlc2VydmVEcmF3aW5nQnVmZmVyKSYmdGhpcy5jb250ZXh0LmxvZ2dlci53YXJuKCJVbmFibGUgdG8gY2xvbmUgV2ViR0wgY29udGV4dCBhcyBpdCBoYXMgcHJlc2VydmVEcmF3aW5nQnVmZmVyPWZhbHNlIixlKX1zLmRyYXdJbWFnZShlLDAsMCl9cmV0dXJuIHJ9Y2F0Y2godCl7dGhpcy5jb250ZXh0LmxvZ2dlci5pbmZvKCJVbmFibGUgdG8gY2xvbmUgY2FudmFzIGFzIGl0IGlzIHRhaW50ZWQiLGUpfXJldHVybiByfSxlLnByb3RvdHlwZS5jcmVhdGVWaWRlb0Nsb25lPWZ1bmN0aW9uKGUpe3ZhciB0PWUub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKTt0LndpZHRoPWUub2Zmc2V0V2lkdGgsdC5oZWlnaHQ9ZS5vZmZzZXRIZWlnaHQ7dmFyIEE9dC5nZXRDb250ZXh0KCIyZCIpO3RyeXtyZXR1cm4gQSYmKEEuZHJhd0ltYWdlKGUsMCwwLHQud2lkdGgsdC5oZWlnaHQpLHRoaXMub3B0aW9ucy5hbGxvd1RhaW50fHxBLmdldEltYWdlRGF0YSgwLDAsdC53aWR0aCx0LmhlaWdodCkpLHR9Y2F0Y2godCl7dGhpcy5jb250ZXh0LmxvZ2dlci5pbmZvKCJVbmFibGUgdG8gY2xvbmUgdmlkZW8gYXMgaXQgaXMgdGFpbnRlZCIsZSl9dmFyIHI9ZS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpO3JldHVybiByLndpZHRoPWUub2Zmc2V0V2lkdGgsci5oZWlnaHQ9ZS5vZmZzZXRIZWlnaHQscn0sZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGROb2RlPWZ1bmN0aW9uKGUsdCxBKXtVbih0KSYmKCJTQ1JJUFQiPT09dC50YWdOYW1lfHx0Lmhhc0F0dHJpYnV0ZShvcyl8fCJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlRWxlbWVudHMmJnRoaXMub3B0aW9ucy5pZ25vcmVFbGVtZW50cyh0KSl8fHRoaXMub3B0aW9ucy5jb3B5U3R5bGVzJiZVbih0KSYmRG4odCl8fGUuYXBwZW5kQ2hpbGQodGhpcy5jbG9uZU5vZGUodCxBKSl9LGUucHJvdG90eXBlLmNsb25lQ2hpbGROb2Rlcz1mdW5jdGlvbihlLHQsQSl7Zm9yKHZhciByPXRoaXMsbj1lLnNoYWRvd1Jvb3Q/ZS5zaGFkb3dSb290LmZpcnN0Q2hpbGQ6ZS5maXJzdENoaWxkO247bj1uLm5leHRTaWJsaW5nKWlmKFVuKG4pJiZWbihuKSYmImZ1bmN0aW9uIj09dHlwZW9mIG4uYXNzaWduZWROb2Rlcyl7dmFyIHM9bi5hc3NpZ25lZE5vZGVzKCk7cy5sZW5ndGgmJnMuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gci5hcHBlbmRDaGlsZE5vZGUodCxlLEEpfSl9ZWxzZSB0aGlzLmFwcGVuZENoaWxkTm9kZSh0LG4sQSl9LGUucHJvdG90eXBlLmNsb25lTm9kZT1mdW5jdGlvbihlLHQpe2lmKFFuKGUpKXJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlLmRhdGEpO2lmKCFlLm93bmVyRG9jdW1lbnQpcmV0dXJuIGUuY2xvbmVOb2RlKCExKTt2YXIgQT1lLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7aWYoQSYmVW4oZSkmJihFbihlKXx8U24oZSkpKXt2YXIgcj10aGlzLmNyZWF0ZUVsZW1lbnRDbG9uZShlKTtyLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eT0ibm9uZSI7dmFyIG49QS5nZXRDb21wdXRlZFN0eWxlKGUpLHM9QS5nZXRDb21wdXRlZFN0eWxlKGUsIjpiZWZvcmUiKSxpPUEuZ2V0Q29tcHV0ZWRTdHlsZShlLCI6YWZ0ZXIiKTt0aGlzLnJlZmVyZW5jZUVsZW1lbnQ9PT1lJiZFbihyKSYmKHRoaXMuY2xvbmVkUmVmZXJlbmNlRWxlbWVudD1yKSxIbihyKSYmYnMocik7dmFyIG89dGhpcy5jb3VudGVycy5wYXJzZShuZXcgYnIodGhpcy5jb250ZXh0LG4pKSxhPXRoaXMucmVzb2x2ZVBzZXVkb0NvbnRlbnQoZSxyLHMsTnIuQkVGT1JFKTtHbihlKSYmKHQ9ITApLFRuKGUpfHx0aGlzLmNsb25lQ2hpbGROb2RlcyhlLHIsdCksYSYmci5pbnNlcnRCZWZvcmUoYSxyLmZpcnN0Q2hpbGQpO3ZhciBsPXRoaXMucmVzb2x2ZVBzZXVkb0NvbnRlbnQoZSxyLGksTnIuQUZURVIpO3JldHVybiBsJiZyLmFwcGVuZENoaWxkKGwpLHRoaXMuY291bnRlcnMucG9wKG8pLChuJiYodGhpcy5vcHRpb25zLmNvcHlTdHlsZXN8fFNuKGUpKSYmIU1uKGUpfHx0KSYmcHMobixyKSwwPT09ZS5zY3JvbGxUb3AmJjA9PT1lLnNjcm9sbExlZnR8fHRoaXMuc2Nyb2xsZWRFbGVtZW50cy5wdXNoKFtyLGUuc2Nyb2xsTGVmdCxlLnNjcm9sbFRvcF0pLChSbihlKXx8S24oZSkpJiYoUm4ocil8fEtuKHIpKSYmKHIudmFsdWU9ZS52YWx1ZSkscn1yZXR1cm4gZS5jbG9uZU5vZGUoITEpfSxlLnByb3RvdHlwZS5yZXNvbHZlUHNldWRvQ29udGVudD1mdW5jdGlvbihlLHQsQSxyKXt2YXIgbj10aGlzO2lmKEEpe3ZhciBzPUEuY29udGVudCxpPXQub3duZXJEb2N1bWVudDtpZihpJiZzJiYibm9uZSIhPT1zJiYiLW1vei1hbHQtY29udGVudCIhPT1zJiYibm9uZSIhPT1BLmRpc3BsYXkpe3RoaXMuY291bnRlcnMucGFyc2UobmV3IGJyKHRoaXMuY29udGV4dCxBKSk7dmFyIG89bmV3IHZyKHRoaXMuY29udGV4dCxBKSxhPWkuY3JlYXRlRWxlbWVudCgiaHRtbDJjYW52YXNwc2V1ZG9lbGVtZW50Iik7cHMoQSxhKSxvLmNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbih0KXtpZigwPT09dC50eXBlKWEuYXBwZW5kQ2hpbGQoaS5jcmVhdGVUZXh0Tm9kZSh0LnZhbHVlKSk7ZWxzZSBpZigyMj09PXQudHlwZSl7dmFyIEE9aS5jcmVhdGVFbGVtZW50KCJpbWciKTtBLnNyYz10LnZhbHVlLEEuc3R5bGUub3BhY2l0eT0iMSIsYS5hcHBlbmRDaGlsZChBKX1lbHNlIGlmKDE4PT09dC50eXBlKXtpZigiYXR0ciI9PT10Lm5hbWUpe3ZhciByPXQudmFsdWVzLmZpbHRlcihHZSk7ci5sZW5ndGgmJmEuYXBwZW5kQ2hpbGQoaS5jcmVhdGVUZXh0Tm9kZShlLmdldEF0dHJpYnV0ZShyWzBdLnZhbHVlKXx8IiIpKX1lbHNlIGlmKCJjb3VudGVyIj09PXQubmFtZSl7dmFyIHM9dC52YWx1ZXMuZmlsdGVyKFhlKSxsPXNbMF0sYz1zWzFdO2lmKGwmJkdlKGwpKXt2YXIgdT1uLmNvdW50ZXJzLmdldENvdW50ZXJWYWx1ZShsLnZhbHVlKSxoPWMmJkdlKGMpP1VBLnBhcnNlKG4uY29udGV4dCxjLnZhbHVlKTozO2EuYXBwZW5kQ2hpbGQoaS5jcmVhdGVUZXh0Tm9kZShpcyh1LGgsITEpKSl9fWVsc2UgaWYoImNvdW50ZXJzIj09PXQubmFtZSl7dmFyIGQ9dC52YWx1ZXMuZmlsdGVyKFhlKSxmPShsPWRbMF0sZFsxXSk7aWYoYz1kWzJdLGwmJkdlKGwpKXt2YXIgcD1uLmNvdW50ZXJzLmdldENvdW50ZXJWYWx1ZXMobC52YWx1ZSksZz1jJiZHZShjKT9VQS5wYXJzZShuLmNvbnRleHQsYy52YWx1ZSk6MyxtPWYmJjA9PT1mLnR5cGU/Zi52YWx1ZToiIix3PXAubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBpcyhlLGcsITEpfSkuam9pbihtKTthLmFwcGVuZENoaWxkKGkuY3JlYXRlVGV4dE5vZGUodykpfX19ZWxzZSBpZigyMD09PXQudHlwZSlzd2l0Y2godC52YWx1ZSl7Y2FzZSJvcGVuLXF1b3RlIjphLmFwcGVuZENoaWxkKGkuY3JlYXRlVGV4dE5vZGUocHIoby5xdW90ZXMsbi5xdW90ZURlcHRoKyssITApKSk7YnJlYWs7Y2FzZSJjbG9zZS1xdW90ZSI6YS5hcHBlbmRDaGlsZChpLmNyZWF0ZVRleHROb2RlKHByKG8ucXVvdGVzLC0tbi5xdW90ZURlcHRoLCExKSkpO2JyZWFrO2RlZmF1bHQ6YS5hcHBlbmRDaGlsZChpLmNyZWF0ZVRleHROb2RlKHQudmFsdWUpKX19KSxhLmNsYXNzTmFtZT1CcysiICIreXM7dmFyIGw9cj09PU5yLkJFRk9SRT8iICIrQnM6IiAiK3lzO3JldHVybiBTbih0KT90LmNsYXNzTmFtZS5iYXNlVmFsdWUrPWw6dC5jbGFzc05hbWUrPWwsYX19fSxlLmRlc3Ryb3k9ZnVuY3Rpb24oZSl7cmV0dXJuISFlLnBhcmVudE5vZGUmJihlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSksITApfSxlfSgpOyFmdW5jdGlvbihlKXtlW2UuQkVGT1JFPTBdPSJCRUZPUkUiLGVbZS5BRlRFUj0xXT0iQUZURVIifShOcnx8KE5yPXt9KSk7dmFyIGxzLGNzPWZ1bmN0aW9uKGUsdCl7dmFyIEE9ZS5jcmVhdGVFbGVtZW50KCJpZnJhbWUiKTtyZXR1cm4gQS5jbGFzc05hbWU9Imh0bWwyY2FudmFzLWNvbnRhaW5lciIsQS5zdHlsZS52aXNpYmlsaXR5PSJoaWRkZW4iLEEuc3R5bGUucG9zaXRpb249ImZpeGVkIixBLnN0eWxlLmxlZnQ9Ii0xMDAwMHB4IixBLnN0eWxlLnRvcD0iMHB4IixBLnN0eWxlLmJvcmRlcj0iMCIsQS53aWR0aD10LndpZHRoLnRvU3RyaW5nKCksQS5oZWlnaHQ9dC5oZWlnaHQudG9TdHJpbmcoKSxBLnNjcm9sbGluZz0ibm8iLEEuc2V0QXR0cmlidXRlKG9zLCJ0cnVlIiksZS5ib2R5LmFwcGVuZENoaWxkKEEpLEF9LHVzPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0KXtlLmNvbXBsZXRlP3QoKTplLnNyYz8oZS5vbmxvYWQ9dCxlLm9uZXJyb3I9dCk6dCgpfSl9LGhzPWZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLmFsbChbXS5zbGljZS5jYWxsKGUuaW1hZ2VzLDApLm1hcCh1cykpfSxkcz1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odCxBKXt2YXIgcj1lLmNvbnRlbnRXaW5kb3c7aWYoIXIpcmV0dXJuIEEoIk5vIHdpbmRvdyBhc3NpZ25lZCBmb3IgaWZyYW1lIik7dmFyIG49ci5kb2N1bWVudDtyLm9ubG9hZD1lLm9ubG9hZD1mdW5jdGlvbigpe3Iub25sb2FkPWUub25sb2FkPW51bGw7dmFyIEE9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtuLmJvZHkuY2hpbGROb2Rlcy5sZW5ndGg+MCYmImNvbXBsZXRlIj09PW4ucmVhZHlTdGF0ZSYmKGNsZWFySW50ZXJ2YWwoQSksdChlKSl9LDUwKX19KX0sZnM9WyJhbGwiLCJkIiwiY29udGVudCJdLHBzPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBBPWUubGVuZ3RoLTE7QT49MDtBLS0pe3ZhciByPWUuaXRlbShBKTstMT09PWZzLmluZGV4T2YocikmJnQuc3R5bGUuc2V0UHJvcGVydHkocixlLmdldFByb3BlcnR5VmFsdWUocikpfXJldHVybiB0fSxncz1mdW5jdGlvbihlKXt2YXIgdD0iIjtyZXR1cm4gZSYmKHQrPSI8IURPQ1RZUEUgIixlLm5hbWUmJih0Kz1lLm5hbWUpLGUuaW50ZXJuYWxTdWJzZXQmJih0Kz1lLmludGVybmFsU3Vic2V0KSxlLnB1YmxpY0lkJiYodCs9JyInK2UucHVibGljSWQrJyInKSxlLnN5c3RlbUlkJiYodCs9JyInK2Uuc3lzdGVtSWQrJyInKSx0Kz0iPiIpLHR9LG1zPWZ1bmN0aW9uKGUsdCxBKXtlJiZlLmRlZmF1bHRWaWV3JiYodCE9PWUuZGVmYXVsdFZpZXcucGFnZVhPZmZzZXR8fEEhPT1lLmRlZmF1bHRWaWV3LnBhZ2VZT2Zmc2V0KSYmZS5kZWZhdWx0Vmlldy5zY3JvbGxUbyh0LEEpfSx3cz1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLEE9ZVsxXSxyPWVbMl07dC5zY3JvbGxMZWZ0PUEsdC5zY3JvbGxUb3A9cn0sQnM9Il9fX2h0bWwyY2FudmFzX19fcHNldWRvZWxlbWVudF9iZWZvcmUiLHlzPSJfX19odG1sMmNhbnZhc19fX3BzZXVkb2VsZW1lbnRfYWZ0ZXIiLHZzPSd7XG4gICAgY29udGVudDogIiIgIWltcG9ydGFudDtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG59Jyxicz1mdW5jdGlvbihlKXtDcyhlLCIuIitCcysiOmJlZm9yZSIrdnMrIlxuICAgICAgICAgLiIreXMrIjphZnRlciIrdnMpfSxDcz1mdW5jdGlvbihlLHQpe3ZhciBBPWUub3duZXJEb2N1bWVudDtpZihBKXt2YXIgcj1BLmNyZWF0ZUVsZW1lbnQoInN0eWxlIik7ci50ZXh0Q29udGVudD10LGUuYXBwZW5kQ2hpbGQocil9fSxfcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUuZ2V0T3JpZ2luPWZ1bmN0aW9uKHQpe3ZhciBBPWUuX2xpbms7cmV0dXJuIEE/KEEuaHJlZj10LEEuaHJlZj1BLmhyZWYsQS5wcm90b2NvbCtBLmhvc3RuYW1lK0EucG9ydCk6ImFib3V0OmJsYW5rIn0sZS5pc1NhbWVPcmlnaW49ZnVuY3Rpb24odCl7cmV0dXJuIGUuZ2V0T3JpZ2luKHQpPT09ZS5fb3JpZ2lufSxlLnNldENvbnRleHQ9ZnVuY3Rpb24odCl7ZS5fbGluaz10LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKSxlLl9vcmlnaW49ZS5nZXRPcmlnaW4odC5sb2NhdGlvbi5ocmVmKX0sZS5fb3JpZ2luPSJhYm91dDpibGFuayIsZX0oKSxqcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLmNvbnRleHQ9ZSx0aGlzLl9vcHRpb25zPXQsdGhpcy5fY2FjaGU9e319cmV0dXJuIGUucHJvdG90eXBlLmFkZEltYWdlPWZ1bmN0aW9uKGUpe3ZhciB0PVByb21pc2UucmVzb2x2ZSgpO3JldHVybiB0aGlzLmhhcyhlKT90OkxzKGUpfHxVcyhlKT8oKHRoaXMuX2NhY2hlW2VdPXRoaXMubG9hZEltYWdlKGUpKS5jYXRjaChmdW5jdGlvbigpe30pLHQpOnR9LGUucHJvdG90eXBlLm1hdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9jYWNoZVtlXX0sZS5wcm90b3R5cGUubG9hZEltYWdlPWZ1bmN0aW9uKGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LEEscixzLGk9dGhpcztyZXR1cm4gbih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9X3MuaXNTYW1lT3JpZ2luKGUpLEE9IUVzKGUpJiYhMD09PXRoaXMuX29wdGlvbnMudXNlQ09SUyYmV3IuU1VQUE9SVF9DT1JTX0lNQUdFUyYmIXQscj0hRXMoZSkmJiF0JiYhTHMoZSkmJiJzdHJpbmciPT10eXBlb2YgdGhpcy5fb3B0aW9ucy5wcm94eSYmV3IuU1VQUE9SVF9DT1JTX1hIUiYmIUEsdHx8ITEhPT10aGlzLl9vcHRpb25zLmFsbG93VGFpbnR8fEVzKGUpfHxMcyhlKXx8cnx8QT8ocz1lLHI/WzQsdGhpcy5wcm94eShzKV06WzMsMl0pOlsyXTtjYXNlIDE6cz1uLnNlbnQoKSxuLmxhYmVsPTI7Y2FzZSAyOnJldHVybiB0aGlzLmNvbnRleHQubG9nZ2VyLmRlYnVnKCJBZGRlZCBpbWFnZSAiK2Uuc3Vic3RyaW5nKDAsMjU2KSksWzQsbmV3IFByb21pc2UoZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgSW1hZ2U7ci5vbmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gZShyKX0sci5vbmVycm9yPXQsKFNzKHMpfHxBKSYmKHIuY3Jvc3NPcmlnaW49ImFub255bW91cyIpLHIuc3JjPXMsITA9PT1yLmNvbXBsZXRlJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGUocil9LDUwMCksaS5fb3B0aW9ucy5pbWFnZVRpbWVvdXQ+MCYmc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiB0KCJUaW1lZCBvdXQgKCIraS5fb3B0aW9ucy5pbWFnZVRpbWVvdXQrIm1zKSBsb2FkaW5nIGltYWdlIil9LGkuX29wdGlvbnMuaW1hZ2VUaW1lb3V0KX0pXTtjYXNlIDM6cmV0dXJuWzIsbi5zZW50KCldfX0pfSl9LGUucHJvdG90eXBlLmhhcz1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fY2FjaGVbZV19LGUucHJvdG90eXBlLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKE9iamVjdC5rZXlzKHRoaXMuX2NhY2hlKSl9LGUucHJvdG90eXBlLnByb3h5PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsQT10aGlzLl9vcHRpb25zLnByb3h5O2lmKCFBKXRocm93IG5ldyBFcnJvcigiTm8gcHJveHkgZGVmaW5lZCIpO3ZhciByPWUuc3Vic3RyaW5nKDAsMjU2KTtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obixzKXt2YXIgaT1Xci5TVVBQT1JUX1JFU1BPTlNFX1RZUEU/ImJsb2IiOiJ0ZXh0IixvPW5ldyBYTUxIdHRwUmVxdWVzdDtvLm9ubG9hZD1mdW5jdGlvbigpe2lmKDIwMD09PW8uc3RhdHVzKWlmKCJ0ZXh0Ij09PWkpbihvLnJlc3BvbnNlKTtlbHNle3ZhciBlPW5ldyBGaWxlUmVhZGVyO2UuYWRkRXZlbnRMaXN0ZW5lcigibG9hZCIsZnVuY3Rpb24oKXtyZXR1cm4gbihlLnJlc3VsdCl9LCExKSxlLmFkZEV2ZW50TGlzdGVuZXIoImVycm9yIixmdW5jdGlvbihlKXtyZXR1cm4gcyhlKX0sITEpLGUucmVhZEFzRGF0YVVSTChvLnJlc3BvbnNlKX1lbHNlIHMoIkZhaWxlZCB0byBwcm94eSByZXNvdXJjZSAiK3IrIiB3aXRoIHN0YXR1cyBjb2RlICIrby5zdGF0dXMpfSxvLm9uZXJyb3I9czt2YXIgYT1BLmluZGV4T2YoIj8iKT4tMT8iJiI6Ij8iO2lmKG8ub3BlbigiR0VUIiwiIitBK2ErInVybD0iK2VuY29kZVVSSUNvbXBvbmVudChlKSsiJnJlc3BvbnNlVHlwZT0iK2kpLCJ0ZXh0IiE9PWkmJm8gaW5zdGFuY2VvZiBYTUxIdHRwUmVxdWVzdCYmKG8ucmVzcG9uc2VUeXBlPWkpLHQuX29wdGlvbnMuaW1hZ2VUaW1lb3V0KXt2YXIgbD10Ll9vcHRpb25zLmltYWdlVGltZW91dDtvLnRpbWVvdXQ9bCxvLm9udGltZW91dD1mdW5jdGlvbigpe3JldHVybiBzKCJUaW1lZCBvdXQgKCIrbCsibXMpIHByb3h5aW5nICIrcil9fW8uc2VuZCgpfSl9LGV9KCkseHM9L15kYXRhOmltYWdlXC9zdmdcK3htbC9pLEZzPS9eZGF0YTppbWFnZVwvLio7YmFzZTY0LC9pLFFzPS9eZGF0YTppbWFnZVwvLiovaSxVcz1mdW5jdGlvbihlKXtyZXR1cm4gV3IuU1VQUE9SVF9TVkdfRFJBV0lOR3x8IUlzKGUpfSxFcz1mdW5jdGlvbihlKXtyZXR1cm4gUXMudGVzdChlKX0sU3M9ZnVuY3Rpb24oZSl7cmV0dXJuIEZzLnRlc3QoZSl9LExzPWZ1bmN0aW9uKGUpe3JldHVybiJibG9iIj09PWUuc3Vic3RyKDAsNCl9LElzPWZ1bmN0aW9uKGUpe3JldHVybiJzdmciPT09ZS5zdWJzdHIoLTMpLnRvTG93ZXJDYXNlKCl8fHhzLnRlc3QoZSl9LE5zPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3RoaXMudHlwZT0wLHRoaXMueD1lLHRoaXMueT10fXJldHVybiBlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCxBKXtyZXR1cm4gbmV3IGUodGhpcy54K3QsdGhpcy55K0EpfSxlfSgpLGtzPWZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gbmV3IE5zKGUueCsodC54LWUueCkqQSxlLnkrKHQueS1lLnkpKkEpfSxIcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LEEscil7dGhpcy50eXBlPTEsdGhpcy5zdGFydD1lLHRoaXMuc3RhcnRDb250cm9sPXQsdGhpcy5lbmRDb250cm9sPUEsdGhpcy5lbmQ9cn1yZXR1cm4gZS5wcm90b3R5cGUuc3ViZGl2aWRlPWZ1bmN0aW9uKHQsQSl7dmFyIHI9a3ModGhpcy5zdGFydCx0aGlzLnN0YXJ0Q29udHJvbCx0KSxuPWtzKHRoaXMuc3RhcnRDb250cm9sLHRoaXMuZW5kQ29udHJvbCx0KSxzPWtzKHRoaXMuZW5kQ29udHJvbCx0aGlzLmVuZCx0KSxpPWtzKHIsbix0KSxvPWtzKG4scyx0KSxhPWtzKGksbyx0KTtyZXR1cm4gQT9uZXcgZSh0aGlzLnN0YXJ0LHIsaSxhKTpuZXcgZShhLG8scyx0aGlzLmVuZCl9LGUucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0LEEpe3JldHVybiBuZXcgZSh0aGlzLnN0YXJ0LmFkZCh0LEEpLHRoaXMuc3RhcnRDb250cm9sLmFkZCh0LEEpLHRoaXMuZW5kQ29udHJvbC5hZGQodCxBKSx0aGlzLmVuZC5hZGQodCxBKSl9LGUucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGUodGhpcy5lbmQsdGhpcy5lbmRDb250cm9sLHRoaXMuc3RhcnRDb250cm9sLHRoaXMuc3RhcnQpfSxlfSgpLFBzPWZ1bmN0aW9uKGUpe3JldHVybiAxPT09ZS50eXBlfSxUcz1mdW5jdGlvbihlKXt2YXIgdD1lLnN0eWxlcyxBPWUuYm91bmRzLHI9bnQodC5ib3JkZXJUb3BMZWZ0UmFkaXVzLEEud2lkdGgsQS5oZWlnaHQpLG49clswXSxzPXJbMV0saT1udCh0LmJvcmRlclRvcFJpZ2h0UmFkaXVzLEEud2lkdGgsQS5oZWlnaHQpLG89aVswXSxhPWlbMV0sbD1udCh0LmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLEEud2lkdGgsQS5oZWlnaHQpLGM9bFswXSx1PWxbMV0saD1udCh0LmJvcmRlckJvdHRvbUxlZnRSYWRpdXMsQS53aWR0aCxBLmhlaWdodCksZD1oWzBdLGY9aFsxXSxwPVtdO3AucHVzaCgobitvKS9BLndpZHRoKSxwLnB1c2goKGQrYykvQS53aWR0aCkscC5wdXNoKChzK2YpL0EuaGVpZ2h0KSxwLnB1c2goKGErdSkvQS5oZWlnaHQpO3ZhciBnPU1hdGgubWF4LmFwcGx5KE1hdGgscCk7Zz4xJiYobi89ZyxzLz1nLG8vPWcsYS89ZyxjLz1nLHUvPWcsZC89ZyxmLz1nKTt2YXIgbT1BLndpZHRoLW8sdz1BLmhlaWdodC11LEI9QS53aWR0aC1jLHk9QS5oZWlnaHQtZix2PXQuYm9yZGVyVG9wV2lkdGgsYj10LmJvcmRlclJpZ2h0V2lkdGgsQz10LmJvcmRlckJvdHRvbVdpZHRoLF89dC5ib3JkZXJMZWZ0V2lkdGgsaj1zdCh0LnBhZGRpbmdUb3AsZS5ib3VuZHMud2lkdGgpLHg9c3QodC5wYWRkaW5nUmlnaHQsZS5ib3VuZHMud2lkdGgpLEY9c3QodC5wYWRkaW5nQm90dG9tLGUuYm91bmRzLndpZHRoKSxRPXN0KHQucGFkZGluZ0xlZnQsZS5ib3VuZHMud2lkdGgpO3RoaXMudG9wTGVmdEJvcmRlckRvdWJsZU91dGVyQm94PW4+MHx8cz4wP09zKEEubGVmdCtfLzMsQS50b3Ardi8zLG4tXy8zLHMtdi8zLGxzLlRPUF9MRUZUKTpuZXcgTnMoQS5sZWZ0K18vMyxBLnRvcCt2LzMpLHRoaXMudG9wUmlnaHRCb3JkZXJEb3VibGVPdXRlckJveD1uPjB8fHM+MD9PcyhBLmxlZnQrbSxBLnRvcCt2LzMsby1iLzMsYS12LzMsbHMuVE9QX1JJR0hUKTpuZXcgTnMoQS5sZWZ0K0Eud2lkdGgtYi8zLEEudG9wK3YvMyksdGhpcy5ib3R0b21SaWdodEJvcmRlckRvdWJsZU91dGVyQm94PWM+MHx8dT4wP09zKEEubGVmdCtCLEEudG9wK3csYy1iLzMsdS1DLzMsbHMuQk9UVE9NX1JJR0hUKTpuZXcgTnMoQS5sZWZ0K0Eud2lkdGgtYi8zLEEudG9wK0EuaGVpZ2h0LUMvMyksdGhpcy5ib3R0b21MZWZ0Qm9yZGVyRG91YmxlT3V0ZXJCb3g9ZD4wfHxmPjA/T3MoQS5sZWZ0K18vMyxBLnRvcCt5LGQtXy8zLGYtQy8zLGxzLkJPVFRPTV9MRUZUKTpuZXcgTnMoQS5sZWZ0K18vMyxBLnRvcCtBLmhlaWdodC1DLzMpLHRoaXMudG9wTGVmdEJvcmRlckRvdWJsZUlubmVyQm94PW4+MHx8cz4wP09zKEEubGVmdCsyKl8vMyxBLnRvcCsyKnYvMyxuLTIqXy8zLHMtMip2LzMsbHMuVE9QX0xFRlQpOm5ldyBOcyhBLmxlZnQrMipfLzMsQS50b3ArMip2LzMpLHRoaXMudG9wUmlnaHRCb3JkZXJEb3VibGVJbm5lckJveD1uPjB8fHM+MD9PcyhBLmxlZnQrbSxBLnRvcCsyKnYvMyxvLTIqYi8zLGEtMip2LzMsbHMuVE9QX1JJR0hUKTpuZXcgTnMoQS5sZWZ0K0Eud2lkdGgtMipiLzMsQS50b3ArMip2LzMpLHRoaXMuYm90dG9tUmlnaHRCb3JkZXJEb3VibGVJbm5lckJveD1jPjB8fHU+MD9PcyhBLmxlZnQrQixBLnRvcCt3LGMtMipiLzMsdS0yKkMvMyxscy5CT1RUT01fUklHSFQpOm5ldyBOcyhBLmxlZnQrQS53aWR0aC0yKmIvMyxBLnRvcCtBLmhlaWdodC0yKkMvMyksdGhpcy5ib3R0b21MZWZ0Qm9yZGVyRG91YmxlSW5uZXJCb3g9ZD4wfHxmPjA/T3MoQS5sZWZ0KzIqXy8zLEEudG9wK3ksZC0yKl8vMyxmLTIqQy8zLGxzLkJPVFRPTV9MRUZUKTpuZXcgTnMoQS5sZWZ0KzIqXy8zLEEudG9wK0EuaGVpZ2h0LTIqQy8zKSx0aGlzLnRvcExlZnRCb3JkZXJTdHJva2U9bj4wfHxzPjA/T3MoQS5sZWZ0K18vMixBLnRvcCt2LzIsbi1fLzIscy12LzIsbHMuVE9QX0xFRlQpOm5ldyBOcyhBLmxlZnQrXy8yLEEudG9wK3YvMiksdGhpcy50b3BSaWdodEJvcmRlclN0cm9rZT1uPjB8fHM+MD9PcyhBLmxlZnQrbSxBLnRvcCt2LzIsby1iLzIsYS12LzIsbHMuVE9QX1JJR0hUKTpuZXcgTnMoQS5sZWZ0K0Eud2lkdGgtYi8yLEEudG9wK3YvMiksdGhpcy5ib3R0b21SaWdodEJvcmRlclN0cm9rZT1jPjB8fHU+MD9PcyhBLmxlZnQrQixBLnRvcCt3LGMtYi8yLHUtQy8yLGxzLkJPVFRPTV9SSUdIVCk6bmV3IE5zKEEubGVmdCtBLndpZHRoLWIvMixBLnRvcCtBLmhlaWdodC1DLzIpLHRoaXMuYm90dG9tTGVmdEJvcmRlclN0cm9rZT1kPjB8fGY+MD9PcyhBLmxlZnQrXy8yLEEudG9wK3ksZC1fLzIsZi1DLzIsbHMuQk9UVE9NX0xFRlQpOm5ldyBOcyhBLmxlZnQrXy8yLEEudG9wK0EuaGVpZ2h0LUMvMiksdGhpcy50b3BMZWZ0Qm9yZGVyQm94PW4+MHx8cz4wP09zKEEubGVmdCxBLnRvcCxuLHMsbHMuVE9QX0xFRlQpOm5ldyBOcyhBLmxlZnQsQS50b3ApLHRoaXMudG9wUmlnaHRCb3JkZXJCb3g9bz4wfHxhPjA/T3MoQS5sZWZ0K20sQS50b3AsbyxhLGxzLlRPUF9SSUdIVCk6bmV3IE5zKEEubGVmdCtBLndpZHRoLEEudG9wKSx0aGlzLmJvdHRvbVJpZ2h0Qm9yZGVyQm94PWM+MHx8dT4wP09zKEEubGVmdCtCLEEudG9wK3csYyx1LGxzLkJPVFRPTV9SSUdIVCk6bmV3IE5zKEEubGVmdCtBLndpZHRoLEEudG9wK0EuaGVpZ2h0KSx0aGlzLmJvdHRvbUxlZnRCb3JkZXJCb3g9ZD4wfHxmPjA/T3MoQS5sZWZ0LEEudG9wK3ksZCxmLGxzLkJPVFRPTV9MRUZUKTpuZXcgTnMoQS5sZWZ0LEEudG9wK0EuaGVpZ2h0KSx0aGlzLnRvcExlZnRQYWRkaW5nQm94PW4+MHx8cz4wP09zKEEubGVmdCtfLEEudG9wK3YsTWF0aC5tYXgoMCxuLV8pLE1hdGgubWF4KDAscy12KSxscy5UT1BfTEVGVCk6bmV3IE5zKEEubGVmdCtfLEEudG9wK3YpLHRoaXMudG9wUmlnaHRQYWRkaW5nQm94PW8+MHx8YT4wP09zKEEubGVmdCtNYXRoLm1pbihtLEEud2lkdGgtYiksQS50b3ArdixtPkEud2lkdGgrYj8wOk1hdGgubWF4KDAsby1iKSxNYXRoLm1heCgwLGEtdiksbHMuVE9QX1JJR0hUKTpuZXcgTnMoQS5sZWZ0K0Eud2lkdGgtYixBLnRvcCt2KSx0aGlzLmJvdHRvbVJpZ2h0UGFkZGluZ0JveD1jPjB8fHU+MD9PcyhBLmxlZnQrTWF0aC5taW4oQixBLndpZHRoLV8pLEEudG9wK01hdGgubWluKHcsQS5oZWlnaHQtQyksTWF0aC5tYXgoMCxjLWIpLE1hdGgubWF4KDAsdS1DKSxscy5CT1RUT01fUklHSFQpOm5ldyBOcyhBLmxlZnQrQS53aWR0aC1iLEEudG9wK0EuaGVpZ2h0LUMpLHRoaXMuYm90dG9tTGVmdFBhZGRpbmdCb3g9ZD4wfHxmPjA/T3MoQS5sZWZ0K18sQS50b3ArTWF0aC5taW4oeSxBLmhlaWdodC1DKSxNYXRoLm1heCgwLGQtXyksTWF0aC5tYXgoMCxmLUMpLGxzLkJPVFRPTV9MRUZUKTpuZXcgTnMoQS5sZWZ0K18sQS50b3ArQS5oZWlnaHQtQyksdGhpcy50b3BMZWZ0Q29udGVudEJveD1uPjB8fHM+MD9PcyhBLmxlZnQrXytRLEEudG9wK3YraixNYXRoLm1heCgwLG4tKF8rUSkpLE1hdGgubWF4KDAscy0oditqKSksbHMuVE9QX0xFRlQpOm5ldyBOcyhBLmxlZnQrXytRLEEudG9wK3YraiksdGhpcy50b3BSaWdodENvbnRlbnRCb3g9bz4wfHxhPjA/T3MoQS5sZWZ0K01hdGgubWluKG0sQS53aWR0aCtfK1EpLEEudG9wK3YraixtPkEud2lkdGgrXytRPzA6by1fK1EsYS0oditqKSxscy5UT1BfUklHSFQpOm5ldyBOcyhBLmxlZnQrQS53aWR0aC0oYit4KSxBLnRvcCt2K2opLHRoaXMuYm90dG9tUmlnaHRDb250ZW50Qm94PWM+MHx8dT4wP09zKEEubGVmdCtNYXRoLm1pbihCLEEud2lkdGgtKF8rUSkpLEEudG9wK01hdGgubWluKHcsQS5oZWlnaHQrditqKSxNYXRoLm1heCgwLGMtKGIreCkpLHUtKEMrRiksbHMuQk9UVE9NX1JJR0hUKTpuZXcgTnMoQS5sZWZ0K0Eud2lkdGgtKGIreCksQS50b3ArQS5oZWlnaHQtKEMrRikpLHRoaXMuYm90dG9tTGVmdENvbnRlbnRCb3g9ZD4wfHxmPjA/T3MoQS5sZWZ0K18rUSxBLnRvcCt5LE1hdGgubWF4KDAsZC0oXytRKSksZi0oQytGKSxscy5CT1RUT01fTEVGVCk6bmV3IE5zKEEubGVmdCtfK1EsQS50b3ArQS5oZWlnaHQtKEMrRikpfTshZnVuY3Rpb24oZSl7ZVtlLlRPUF9MRUZUPTBdPSJUT1BfTEVGVCIsZVtlLlRPUF9SSUdIVD0xXT0iVE9QX1JJR0hUIixlW2UuQk9UVE9NX1JJR0hUPTJdPSJCT1RUT01fUklHSFQiLGVbZS5CT1RUT01fTEVGVD0zXT0iQk9UVE9NX0xFRlQifShsc3x8KGxzPXt9KSk7dmFyIE9zPWZ1bmN0aW9uKGUsdCxBLHIsbil7dmFyIHM9KE1hdGguc3FydCgyKS0xKS8zKjQsaT1BKnMsbz1yKnMsYT1lK0EsbD10K3I7c3dpdGNoKG4pe2Nhc2UgbHMuVE9QX0xFRlQ6cmV0dXJuIG5ldyBIcyhuZXcgTnMoZSxsKSxuZXcgTnMoZSxsLW8pLG5ldyBOcyhhLWksdCksbmV3IE5zKGEsdCkpO2Nhc2UgbHMuVE9QX1JJR0hUOnJldHVybiBuZXcgSHMobmV3IE5zKGUsdCksbmV3IE5zKGUraSx0KSxuZXcgTnMoYSxsLW8pLG5ldyBOcyhhLGwpKTtjYXNlIGxzLkJPVFRPTV9SSUdIVDpyZXR1cm4gbmV3IEhzKG5ldyBOcyhhLHQpLG5ldyBOcyhhLHQrbyksbmV3IE5zKGUraSxsKSxuZXcgTnMoZSxsKSk7Y2FzZSBscy5CT1RUT01fTEVGVDpkZWZhdWx0OnJldHVybiBuZXcgSHMobmV3IE5zKGEsbCksbmV3IE5zKGEtaSxsKSxuZXcgTnMoZSx0K28pLG5ldyBOcyhlLHQpKX19LE1zPWZ1bmN0aW9uKGUpe3JldHVybltlLnRvcExlZnRCb3JkZXJCb3gsZS50b3BSaWdodEJvcmRlckJveCxlLmJvdHRvbVJpZ2h0Qm9yZGVyQm94LGUuYm90dG9tTGVmdEJvcmRlckJveF19LERzPWZ1bmN0aW9uKGUpe3JldHVybltlLnRvcExlZnRQYWRkaW5nQm94LGUudG9wUmlnaHRQYWRkaW5nQm94LGUuYm90dG9tUmlnaHRQYWRkaW5nQm94LGUuYm90dG9tTGVmdFBhZGRpbmdCb3hdfSxScz1mdW5jdGlvbihlLHQsQSl7dGhpcy5vZmZzZXRYPWUsdGhpcy5vZmZzZXRZPXQsdGhpcy5tYXRyaXg9QSx0aGlzLnR5cGU9MCx0aGlzLnRhcmdldD02fSxLcz1mdW5jdGlvbihlLHQpe3RoaXMucGF0aD1lLHRoaXMudGFyZ2V0PXQsdGhpcy50eXBlPTF9LFZzPWZ1bmN0aW9uKGUpe3RoaXMub3BhY2l0eT1lLHRoaXMudHlwZT0yLHRoaXMudGFyZ2V0PTZ9LEdzPWZ1bmN0aW9uKGUpe3JldHVybiAxPT09ZS50eXBlfSx6cz1mdW5jdGlvbihlLHQpe3JldHVybiBlLmxlbmd0aD09PXQubGVuZ3RoJiZlLnNvbWUoZnVuY3Rpb24oZSxBKXtyZXR1cm4gZT09PXRbQV19KX0scXM9ZnVuY3Rpb24oZSl7dGhpcy5lbGVtZW50PWUsdGhpcy5pbmxpbmVMZXZlbD1bXSx0aGlzLm5vbklubGluZUxldmVsPVtdLHRoaXMubmVnYXRpdmVaSW5kZXg9W10sdGhpcy56ZXJvT3JBdXRvWkluZGV4T3JUcmFuc2Zvcm1lZE9yT3BhY2l0eT1bXSx0aGlzLnBvc2l0aXZlWkluZGV4PVtdLHRoaXMubm9uUG9zaXRpb25lZEZsb2F0cz1bXSx0aGlzLm5vblBvc2l0aW9uZWRJbmxpbmVMZXZlbD1bXX0sV3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7aWYodGhpcy5jb250YWluZXI9ZSx0aGlzLnBhcmVudD10LHRoaXMuZWZmZWN0cz1bXSx0aGlzLmN1cnZlcz1uZXcgVHModGhpcy5jb250YWluZXIpLHRoaXMuY29udGFpbmVyLnN0eWxlcy5vcGFjaXR5PDEmJnRoaXMuZWZmZWN0cy5wdXNoKG5ldyBWcyh0aGlzLmNvbnRhaW5lci5zdHlsZXMub3BhY2l0eSkpLG51bGwhPT10aGlzLmNvbnRhaW5lci5zdHlsZXMudHJhbnNmb3JtKXt2YXIgQT10aGlzLmNvbnRhaW5lci5ib3VuZHMubGVmdCt0aGlzLmNvbnRhaW5lci5zdHlsZXMudHJhbnNmb3JtT3JpZ2luWzBdLm51bWJlcixyPXRoaXMuY29udGFpbmVyLmJvdW5kcy50b3ArdGhpcy5jb250YWluZXIuc3R5bGVzLnRyYW5zZm9ybU9yaWdpblsxXS5udW1iZXIsbj10aGlzLmNvbnRhaW5lci5zdHlsZXMudHJhbnNmb3JtO3RoaXMuZWZmZWN0cy5wdXNoKG5ldyBScyhBLHIsbikpfWlmKDAhPT10aGlzLmNvbnRhaW5lci5zdHlsZXMub3ZlcmZsb3dYKXt2YXIgcz1Ncyh0aGlzLmN1cnZlcyksaT1Ecyh0aGlzLmN1cnZlcyk7enMocyxpKT90aGlzLmVmZmVjdHMucHVzaChuZXcgS3Mocyw2KSk6KHRoaXMuZWZmZWN0cy5wdXNoKG5ldyBLcyhzLDIpKSx0aGlzLmVmZmVjdHMucHVzaChuZXcgS3MoaSw0KSkpfX1yZXR1cm4gZS5wcm90b3R5cGUuZ2V0RWZmZWN0cz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9LTE9PT1bMiwzXS5pbmRleE9mKHRoaXMuY29udGFpbmVyLnN0eWxlcy5wb3NpdGlvbiksQT10aGlzLnBhcmVudCxyPXRoaXMuZWZmZWN0cy5zbGljZSgwKTtBOyl7dmFyIG49QS5lZmZlY3RzLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4hR3MoZSl9KTtpZih0fHwwIT09QS5jb250YWluZXIuc3R5bGVzLnBvc2l0aW9ufHwhQS5wYXJlbnQpe2lmKHIudW5zaGlmdC5hcHBseShyLG4pLHQ9LTE9PT1bMiwzXS5pbmRleE9mKEEuY29udGFpbmVyLnN0eWxlcy5wb3NpdGlvbiksMCE9PUEuY29udGFpbmVyLnN0eWxlcy5vdmVyZmxvd1gpe3ZhciBzPU1zKEEuY3VydmVzKSxpPURzKEEuY3VydmVzKTt6cyhzLGkpfHxyLnVuc2hpZnQobmV3IEtzKGksNikpfX1lbHNlIHIudW5zaGlmdC5hcHBseShyLG4pO0E9QS5wYXJlbnR9cmV0dXJuIHIuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBscih0LnRhcmdldCxlKX0pfSxlfSgpLFhzPWZ1bmN0aW9uKGUsdCxBLHIpe2UuY29udGFpbmVyLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24obil7dmFyIHM9bHIobi5mbGFncyw0KSxpPWxyKG4uZmxhZ3MsMiksbz1uZXcgV3MobixlKTtscihuLnN0eWxlcy5kaXNwbGF5LDIwNDgpJiZyLnB1c2gobyk7dmFyIGE9bHIobi5mbGFncyw4KT9bXTpyO2lmKHN8fGkpe3ZhciBsPXN8fG4uc3R5bGVzLmlzUG9zaXRpb25lZCgpP0E6dCxjPW5ldyBxcyhvKTtpZihuLnN0eWxlcy5pc1Bvc2l0aW9uZWQoKXx8bi5zdHlsZXMub3BhY2l0eTwxfHxuLnN0eWxlcy5pc1RyYW5zZm9ybWVkKCkpe3ZhciB1PW4uc3R5bGVzLnpJbmRleC5vcmRlcjtpZih1PDApe3ZhciBoPTA7bC5uZWdhdGl2ZVpJbmRleC5zb21lKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHU+ZS5lbGVtZW50LmNvbnRhaW5lci5zdHlsZXMuekluZGV4Lm9yZGVyPyhoPXQsITEpOmg+MH0pLGwubmVnYXRpdmVaSW5kZXguc3BsaWNlKGgsMCxjKX1lbHNlIGlmKHU+MCl7dmFyIGQ9MDtsLnBvc2l0aXZlWkluZGV4LnNvbWUoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdT49ZS5lbGVtZW50LmNvbnRhaW5lci5zdHlsZXMuekluZGV4Lm9yZGVyPyhkPXQrMSwhMSk6ZD4wfSksbC5wb3NpdGl2ZVpJbmRleC5zcGxpY2UoZCwwLGMpfWVsc2UgbC56ZXJvT3JBdXRvWkluZGV4T3JUcmFuc2Zvcm1lZE9yT3BhY2l0eS5wdXNoKGMpfWVsc2Ugbi5zdHlsZXMuaXNGbG9hdGluZygpP2wubm9uUG9zaXRpb25lZEZsb2F0cy5wdXNoKGMpOmwubm9uUG9zaXRpb25lZElubGluZUxldmVsLnB1c2goYyk7WHMobyxjLHM/YzpBLGEpfWVsc2Ugbi5zdHlsZXMuaXNJbmxpbmVMZXZlbCgpP3QuaW5saW5lTGV2ZWwucHVzaChvKTp0Lm5vbklubGluZUxldmVsLnB1c2gobyksWHMobyx0LEEsYSk7bHIobi5mbGFncyw4KSYmWXMobixhKX0pfSxZcz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgQT1lIGluc3RhbmNlb2YgdW4/ZS5zdGFydDoxLHI9ZSBpbnN0YW5jZW9mIHVuJiZlLnJldmVyc2VkLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHM9dFtuXTtzLmNvbnRhaW5lciBpbnN0YW5jZW9mIGNuJiYibnVtYmVyIj09dHlwZW9mIHMuY29udGFpbmVyLnZhbHVlJiYwIT09cy5jb250YWluZXIudmFsdWUmJihBPXMuY29udGFpbmVyLnZhbHVlKSxzLmxpc3RWYWx1ZT1pcyhBLHMuY29udGFpbmVyLnN0eWxlcy5saXN0U3R5bGVUeXBlLCEwKSxBKz1yPy0xOjF9fSxKcz1mdW5jdGlvbihlLHQpe3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuICRzKGUudG9wTGVmdEJvcmRlckJveCxlLnRvcExlZnRQYWRkaW5nQm94LGUudG9wUmlnaHRCb3JkZXJCb3gsZS50b3BSaWdodFBhZGRpbmdCb3gpO2Nhc2UgMTpyZXR1cm4gJHMoZS50b3BSaWdodEJvcmRlckJveCxlLnRvcFJpZ2h0UGFkZGluZ0JveCxlLmJvdHRvbVJpZ2h0Qm9yZGVyQm94LGUuYm90dG9tUmlnaHRQYWRkaW5nQm94KTtjYXNlIDI6cmV0dXJuICRzKGUuYm90dG9tUmlnaHRCb3JkZXJCb3gsZS5ib3R0b21SaWdodFBhZGRpbmdCb3gsZS5ib3R0b21MZWZ0Qm9yZGVyQm94LGUuYm90dG9tTGVmdFBhZGRpbmdCb3gpO2RlZmF1bHQ6cmV0dXJuICRzKGUuYm90dG9tTGVmdEJvcmRlckJveCxlLmJvdHRvbUxlZnRQYWRkaW5nQm94LGUudG9wTGVmdEJvcmRlckJveCxlLnRvcExlZnRQYWRkaW5nQm94KX19LFpzPWZ1bmN0aW9uKGUsdCl7dmFyIEE9W107cmV0dXJuIFBzKGUpP0EucHVzaChlLnN1YmRpdmlkZSguNSwhMSkpOkEucHVzaChlKSxQcyh0KT9BLnB1c2godC5zdWJkaXZpZGUoLjUsITApKTpBLnB1c2godCksQX0sJHM9ZnVuY3Rpb24oZSx0LEEscil7dmFyIG49W107cmV0dXJuIFBzKGUpP24ucHVzaChlLnN1YmRpdmlkZSguNSwhMSkpOm4ucHVzaChlKSxQcyhBKT9uLnB1c2goQS5zdWJkaXZpZGUoLjUsITApKTpuLnB1c2goQSksUHMocik/bi5wdXNoKHIuc3ViZGl2aWRlKC41LCEwKS5yZXZlcnNlKCkpOm4ucHVzaChyKSxQcyh0KT9uLnB1c2godC5zdWJkaXZpZGUoLjUsITEpLnJldmVyc2UoKSk6bi5wdXNoKHQpLG59LGVpPWZ1bmN0aW9uKGUpe3ZhciB0PWUuYm91bmRzLEE9ZS5zdHlsZXM7cmV0dXJuIHQuYWRkKEEuYm9yZGVyTGVmdFdpZHRoLEEuYm9yZGVyVG9wV2lkdGgsLShBLmJvcmRlclJpZ2h0V2lkdGgrQS5ib3JkZXJMZWZ0V2lkdGgpLC0oQS5ib3JkZXJUb3BXaWR0aCtBLmJvcmRlckJvdHRvbVdpZHRoKSl9LHRpPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3R5bGVzLEE9ZS5ib3VuZHMscj1zdCh0LnBhZGRpbmdMZWZ0LEEud2lkdGgpLG49c3QodC5wYWRkaW5nUmlnaHQsQS53aWR0aCkscz1zdCh0LnBhZGRpbmdUb3AsQS53aWR0aCksaT1zdCh0LnBhZGRpbmdCb3R0b20sQS53aWR0aCk7cmV0dXJuIEEuYWRkKHIrdC5ib3JkZXJMZWZ0V2lkdGgscyt0LmJvcmRlclRvcFdpZHRoLC0odC5ib3JkZXJSaWdodFdpZHRoK3QuYm9yZGVyTGVmdFdpZHRoK3IrbiksLSh0LmJvcmRlclRvcFdpZHRoK3QuYm9yZGVyQm90dG9tV2lkdGgrcytpKSl9LEFpPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcj1mdW5jdGlvbihlLHQpe3JldHVybiAwPT09ZT90LmJvdW5kczoyPT09ZT90aSh0KTplaSh0KX0oaWkoZS5zdHlsZXMuYmFja2dyb3VuZE9yaWdpbix0KSxlKSxuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDA9PT1lP3QuYm91bmRzOjI9PT1lP3RpKHQpOmVpKHQpfShpaShlLnN0eWxlcy5iYWNrZ3JvdW5kQ2xpcCx0KSxlKSxzPXNpKGlpKGUuc3R5bGVzLmJhY2tncm91bmRTaXplLHQpLEEsciksaT1zWzBdLG89c1sxXSxhPW50KGlpKGUuc3R5bGVzLmJhY2tncm91bmRQb3NpdGlvbix0KSxyLndpZHRoLWksci5oZWlnaHQtbyk7cmV0dXJuW29pKGlpKGUuc3R5bGVzLmJhY2tncm91bmRSZXBlYXQsdCksYSxzLHIsbiksTWF0aC5yb3VuZChyLmxlZnQrYVswXSksTWF0aC5yb3VuZChyLnRvcCthWzFdKSxpLG9dfSxyaT1mdW5jdGlvbihlKXtyZXR1cm4gR2UoZSkmJmUudmFsdWU9PT1EdC5BVVRPfSxuaT1mdW5jdGlvbihlKXtyZXR1cm4ibnVtYmVyIj09dHlwZW9mIGV9LHNpPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcj10WzBdLG49dFsxXSxzPXRbMl0saT1lWzBdLG89ZVsxXTtpZighaSlyZXR1cm5bMCwwXTtpZigkZShpKSYmbyYmJGUobykpcmV0dXJuW3N0KGksQS53aWR0aCksc3QobyxBLmhlaWdodCldO3ZhciBhPW5pKHMpO2lmKEdlKGkpJiYoaS52YWx1ZT09PUR0LkNPTlRBSU58fGkudmFsdWU9PT1EdC5DT1ZFUikpcmV0dXJuIG5pKHMpP0Eud2lkdGgvQS5oZWlnaHQ8cyE9KGkudmFsdWU9PT1EdC5DT1ZFUik/W0Eud2lkdGgsQS53aWR0aC9zXTpbQS5oZWlnaHQqcyxBLmhlaWdodF06W0Eud2lkdGgsQS5oZWlnaHRdO3ZhciBsPW5pKHIpLGM9bmkobiksdT1sfHxjO2lmKHJpKGkpJiYoIW98fHJpKG8pKSlyZXR1cm4gbCYmYz9bcixuXTphfHx1P3UmJmE/W2w/cjpuKnMsYz9uOnIvc106W2w/cjpBLndpZHRoLGM/bjpBLmhlaWdodF06W0Eud2lkdGgsQS5oZWlnaHRdO2lmKGEpe3ZhciBoPTAsZD0wO3JldHVybiAkZShpKT9oPXN0KGksQS53aWR0aCk6JGUobykmJihkPXN0KG8sQS5oZWlnaHQpKSxyaShpKT9oPWQqczpvJiYhcmkobyl8fChkPWgvcyksW2gsZF19dmFyIGY9bnVsbCxwPW51bGw7aWYoJGUoaSk/Zj1zdChpLEEud2lkdGgpOm8mJiRlKG8pJiYocD1zdChvLEEuaGVpZ2h0KSksbnVsbD09PWZ8fG8mJiFyaShvKXx8KHA9bCYmYz9mL3IqbjpBLmhlaWdodCksbnVsbCE9PXAmJnJpKGkpJiYoZj1sJiZjP3AvbipyOkEud2lkdGgpLG51bGwhPT1mJiZudWxsIT09cClyZXR1cm5bZixwXTt0aHJvdyBuZXcgRXJyb3IoIlVuYWJsZSB0byBjYWxjdWxhdGUgYmFja2dyb3VuZC1zaXplIGZvciBlbGVtZW50Iil9LGlpPWZ1bmN0aW9uKGUsdCl7dmFyIEE9ZVt0XTtyZXR1cm4gdm9pZCAwPT09QT9lWzBdOkF9LG9pPWZ1bmN0aW9uKGUsdCxBLHIsbil7dmFyIHM9dFswXSxpPXRbMV0sbz1BWzBdLGE9QVsxXTtzd2l0Y2goZSl7Y2FzZSAyOnJldHVybltuZXcgTnMoTWF0aC5yb3VuZChyLmxlZnQpLE1hdGgucm91bmQoci50b3AraSkpLG5ldyBOcyhNYXRoLnJvdW5kKHIubGVmdCtyLndpZHRoKSxNYXRoLnJvdW5kKHIudG9wK2kpKSxuZXcgTnMoTWF0aC5yb3VuZChyLmxlZnQrci53aWR0aCksTWF0aC5yb3VuZChhK3IudG9wK2kpKSxuZXcgTnMoTWF0aC5yb3VuZChyLmxlZnQpLE1hdGgucm91bmQoYStyLnRvcCtpKSldO2Nhc2UgMzpyZXR1cm5bbmV3IE5zKE1hdGgucm91bmQoci5sZWZ0K3MpLE1hdGgucm91bmQoci50b3ApKSxuZXcgTnMoTWF0aC5yb3VuZChyLmxlZnQrcytvKSxNYXRoLnJvdW5kKHIudG9wKSksbmV3IE5zKE1hdGgucm91bmQoci5sZWZ0K3MrbyksTWF0aC5yb3VuZChyLmhlaWdodCtyLnRvcCkpLG5ldyBOcyhNYXRoLnJvdW5kKHIubGVmdCtzKSxNYXRoLnJvdW5kKHIuaGVpZ2h0K3IudG9wKSldO2Nhc2UgMTpyZXR1cm5bbmV3IE5zKE1hdGgucm91bmQoci5sZWZ0K3MpLE1hdGgucm91bmQoci50b3AraSkpLG5ldyBOcyhNYXRoLnJvdW5kKHIubGVmdCtzK28pLE1hdGgucm91bmQoci50b3AraSkpLG5ldyBOcyhNYXRoLnJvdW5kKHIubGVmdCtzK28pLE1hdGgucm91bmQoci50b3AraSthKSksbmV3IE5zKE1hdGgucm91bmQoci5sZWZ0K3MpLE1hdGgucm91bmQoci50b3AraSthKSldO2RlZmF1bHQ6cmV0dXJuW25ldyBOcyhNYXRoLnJvdW5kKG4ubGVmdCksTWF0aC5yb3VuZChuLnRvcCkpLG5ldyBOcyhNYXRoLnJvdW5kKG4ubGVmdCtuLndpZHRoKSxNYXRoLnJvdW5kKG4udG9wKSksbmV3IE5zKE1hdGgucm91bmQobi5sZWZ0K24ud2lkdGgpLE1hdGgucm91bmQobi5oZWlnaHQrbi50b3ApKSxuZXcgTnMoTWF0aC5yb3VuZChuLmxlZnQpLE1hdGgucm91bmQobi5oZWlnaHQrbi50b3ApKV19fSxhaT0iSGlkZGVuIFRleHQiLGxpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLl9kYXRhPXt9LHRoaXMuX2RvY3VtZW50PWV9cmV0dXJuIGUucHJvdG90eXBlLnBhcnNlTWV0cmljcz1mdW5jdGlvbihlLHQpe3ZhciBBPXRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLHI9dGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIiksbj10aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIikscz10aGlzLl9kb2N1bWVudC5ib2R5O0Euc3R5bGUudmlzaWJpbGl0eT0iaGlkZGVuIixBLnN0eWxlLmZvbnRGYW1pbHk9ZSxBLnN0eWxlLmZvbnRTaXplPXQsQS5zdHlsZS5tYXJnaW49IjAiLEEuc3R5bGUucGFkZGluZz0iMCIsQS5zdHlsZS53aGl0ZVNwYWNlPSJub3dyYXAiLHMuYXBwZW5kQ2hpbGQoQSksci5zcmM9ImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNyIsci53aWR0aD0xLHIuaGVpZ2h0PTEsci5zdHlsZS5tYXJnaW49IjAiLHIuc3R5bGUucGFkZGluZz0iMCIsci5zdHlsZS52ZXJ0aWNhbEFsaWduPSJiYXNlbGluZSIsbi5zdHlsZS5mb250RmFtaWx5PWUsbi5zdHlsZS5mb250U2l6ZT10LG4uc3R5bGUubWFyZ2luPSIwIixuLnN0eWxlLnBhZGRpbmc9IjAiLG4uYXBwZW5kQ2hpbGQodGhpcy5fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYWkpKSxBLmFwcGVuZENoaWxkKG4pLEEuYXBwZW5kQ2hpbGQocik7dmFyIGk9ci5vZmZzZXRUb3Atbi5vZmZzZXRUb3ArMjtBLnJlbW92ZUNoaWxkKG4pLEEuYXBwZW5kQ2hpbGQodGhpcy5fZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYWkpKSxBLnN0eWxlLmxpbmVIZWlnaHQ9Im5vcm1hbCIsci5zdHlsZS52ZXJ0aWNhbEFsaWduPSJzdXBlciI7dmFyIG89ci5vZmZzZXRUb3AtQS5vZmZzZXRUb3ArMjtyZXR1cm4gcy5yZW1vdmVDaGlsZChBKSx7YmFzZWxpbmU6aSxtaWRkbGU6b319LGUucHJvdG90eXBlLmdldE1ldHJpY3M9ZnVuY3Rpb24oZSx0KXt2YXIgQT1lKyIgIit0O3JldHVybiB2b2lkIDA9PT10aGlzLl9kYXRhW0FdJiYodGhpcy5fZGF0YVtBXT10aGlzLnBhcnNlTWV0cmljcyhlLHQpKSx0aGlzLl9kYXRhW0FdfSxlfSgpLGNpPWZ1bmN0aW9uKGUsdCl7dGhpcy5jb250ZXh0PWUsdGhpcy5vcHRpb25zPXR9LHVpPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIEEodCxBKXt2YXIgcj1lLmNhbGwodGhpcyx0LEEpfHx0aGlzO3JldHVybiByLl9hY3RpdmVFZmZlY3RzPVtdLHIuY2FudmFzPUEuY2FudmFzP0EuY2FudmFzOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpLHIuY3R4PXIuY2FudmFzLmdldENvbnRleHQoIjJkIiksQS5jYW52YXN8fChyLmNhbnZhcy53aWR0aD1NYXRoLmZsb29yKEEud2lkdGgqQS5zY2FsZSksci5jYW52YXMuaGVpZ2h0PU1hdGguZmxvb3IoQS5oZWlnaHQqQS5zY2FsZSksci5jYW52YXMuc3R5bGUud2lkdGg9QS53aWR0aCsicHgiLHIuY2FudmFzLnN0eWxlLmhlaWdodD1BLmhlaWdodCsicHgiKSxyLmZvbnRNZXRyaWNzPW5ldyBsaShkb2N1bWVudCksci5jdHguc2NhbGUoci5vcHRpb25zLnNjYWxlLHIub3B0aW9ucy5zY2FsZSksci5jdHgudHJhbnNsYXRlKC1BLngsLUEueSksci5jdHgudGV4dEJhc2VsaW5lPSJib3R0b20iLHIuX2FjdGl2ZUVmZmVjdHM9W10sci5jb250ZXh0LmxvZ2dlci5kZWJ1ZygiQ2FudmFzIHJlbmRlcmVyIGluaXRpYWxpemVkICgiK0Eud2lkdGgrIngiK0EuaGVpZ2h0KyIpIHdpdGggc2NhbGUgIitBLnNjYWxlKSxyfXJldHVybiB0KEEsZSksQS5wcm90b3R5cGUuYXBwbHlFZmZlY3RzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD10aGlzO3RoaXMuX2FjdGl2ZUVmZmVjdHMubGVuZ3RoOyl0aGlzLnBvcEVmZmVjdCgpO2UuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hcHBseUVmZmVjdChlKX0pfSxBLnByb3RvdHlwZS5hcHBseUVmZmVjdD1mdW5jdGlvbihlKXt0aGlzLmN0eC5zYXZlKCksZnVuY3Rpb24oZSl7cmV0dXJuIDI9PT1lLnR5cGV9KGUpJiYodGhpcy5jdHguZ2xvYmFsQWxwaGE9ZS5vcGFjaXR5KSxmdW5jdGlvbihlKXtyZXR1cm4gMD09PWUudHlwZX0oZSkmJih0aGlzLmN0eC50cmFuc2xhdGUoZS5vZmZzZXRYLGUub2Zmc2V0WSksdGhpcy5jdHgudHJhbnNmb3JtKGUubWF0cml4WzBdLGUubWF0cml4WzFdLGUubWF0cml4WzJdLGUubWF0cml4WzNdLGUubWF0cml4WzRdLGUubWF0cml4WzVdKSx0aGlzLmN0eC50cmFuc2xhdGUoLWUub2Zmc2V0WCwtZS5vZmZzZXRZKSksR3MoZSkmJih0aGlzLnBhdGgoZS5wYXRoKSx0aGlzLmN0eC5jbGlwKCkpLHRoaXMuX2FjdGl2ZUVmZmVjdHMucHVzaChlKX0sQS5wcm90b3R5cGUucG9wRWZmZWN0PWZ1bmN0aW9uKCl7dGhpcy5fYWN0aXZlRWZmZWN0cy5wb3AoKSx0aGlzLmN0eC5yZXN0b3JlKCl9LEEucHJvdG90eXBlLnJlbmRlclN0YWNrPWZ1bmN0aW9uKGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBuKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gZS5lbGVtZW50LmNvbnRhaW5lci5zdHlsZXMuaXNWaXNpYmxlKCk/WzQsdGhpcy5yZW5kZXJTdGFja0NvbnRlbnQoZSldOlszLDJdO2Nhc2UgMTp0LnNlbnQoKSx0LmxhYmVsPTI7Y2FzZSAyOnJldHVyblsyXX19KX0pfSxBLnByb3RvdHlwZS5yZW5kZXJOb2RlPWZ1bmN0aW9uKGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBuKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbHIoZS5jb250YWluZXIuZmxhZ3MsMTYpLGUuY29udGFpbmVyLnN0eWxlcy5pc1Zpc2libGUoKT9bNCx0aGlzLnJlbmRlck5vZGVCYWNrZ3JvdW5kQW5kQm9yZGVycyhlKV06WzMsM107Y2FzZSAxOnJldHVybiB0LnNlbnQoKSxbNCx0aGlzLnJlbmRlck5vZGVDb250ZW50KGUpXTtjYXNlIDI6dC5zZW50KCksdC5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bMl19fSl9KX0sQS5wcm90b3R5cGUucmVuZGVyVGV4dFdpdGhMZXR0ZXJTcGFjaW5nPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcj10aGlzOzA9PT10P3RoaXMuY3R4LmZpbGxUZXh0KGUudGV4dCxlLmJvdW5kcy5sZWZ0LGUuYm91bmRzLnRvcCtBKTpacihlLnRleHQpLnJlZHVjZShmdW5jdGlvbih0LG4pe3JldHVybiByLmN0eC5maWxsVGV4dChuLHQsZS5ib3VuZHMudG9wK0EpLHQrci5jdHgubWVhc3VyZVRleHQobikud2lkdGh9LGUuYm91bmRzLmxlZnQpfSxBLnByb3RvdHlwZS5jcmVhdGVGb250U3R5bGU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5mb250VmFyaWFudC5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIm5vcm1hbCI9PT1lfHwic21hbGwtY2FwcyI9PT1lfSkuam9pbigiIiksQT1naShlLmZvbnRGYW1pbHkpLmpvaW4oIiwgIikscj1LZShlLmZvbnRTaXplKT8iIitlLmZvbnRTaXplLm51bWJlcitlLmZvbnRTaXplLnVuaXQ6ZS5mb250U2l6ZS5udW1iZXIrInB4IjtyZXR1cm5bW2UuZm9udFN0eWxlLHQsZS5mb250V2VpZ2h0LHIsQV0uam9pbigiICIpLEEscl19LEEucHJvdG90eXBlLnJlbmRlclRleHROb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIEEscixzLGksbyxhLGwsYyx1PXRoaXM7cmV0dXJuIG4odGhpcyxmdW5jdGlvbihuKXtyZXR1cm4gQT10aGlzLmNyZWF0ZUZvbnRTdHlsZSh0KSxyPUFbMF0scz1BWzFdLGk9QVsyXSx0aGlzLmN0eC5mb250PXIsdGhpcy5jdHguZGlyZWN0aW9uPTE9PT10LmRpcmVjdGlvbj8icnRsIjoibHRyIix0aGlzLmN0eC50ZXh0QWxpZ249ImxlZnQiLHRoaXMuY3R4LnRleHRCYXNlbGluZT0iYWxwaGFiZXRpYyIsbz10aGlzLmZvbnRNZXRyaWNzLmdldE1ldHJpY3MocyxpKSxhPW8uYmFzZWxpbmUsbD1vLm1pZGRsZSxjPXQucGFpbnRPcmRlcixlLnRleHRCb3VuZHMuZm9yRWFjaChmdW5jdGlvbihlKXtjLmZvckVhY2goZnVuY3Rpb24oQSl7c3dpdGNoKEEpe2Nhc2UgMDp1LmN0eC5maWxsU3R5bGU9ZnQodC5jb2xvciksdS5yZW5kZXJUZXh0V2l0aExldHRlclNwYWNpbmcoZSx0LmxldHRlclNwYWNpbmcsYSk7dmFyIHI9dC50ZXh0U2hhZG93O3IubGVuZ3RoJiZlLnRleHQudHJpbSgpLmxlbmd0aCYmKHIuc2xpY2UoMCkucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24oQSl7dS5jdHguc2hhZG93Q29sb3I9ZnQoQS5jb2xvciksdS5jdHguc2hhZG93T2Zmc2V0WD1BLm9mZnNldFgubnVtYmVyKnUub3B0aW9ucy5zY2FsZSx1LmN0eC5zaGFkb3dPZmZzZXRZPUEub2Zmc2V0WS5udW1iZXIqdS5vcHRpb25zLnNjYWxlLHUuY3R4LnNoYWRvd0JsdXI9QS5ibHVyLm51bWJlcix1LnJlbmRlclRleHRXaXRoTGV0dGVyU3BhY2luZyhlLHQubGV0dGVyU3BhY2luZyxhKX0pLHUuY3R4LnNoYWRvd0NvbG9yPSIiLHUuY3R4LnNoYWRvd09mZnNldFg9MCx1LmN0eC5zaGFkb3dPZmZzZXRZPTAsdS5jdHguc2hhZG93Qmx1cj0wKSx0LnRleHREZWNvcmF0aW9uTGluZS5sZW5ndGgmJih1LmN0eC5maWxsU3R5bGU9ZnQodC50ZXh0RGVjb3JhdGlvbkNvbG9yfHx0LmNvbG9yKSx0LnRleHREZWNvcmF0aW9uTGluZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIDE6dS5jdHguZmlsbFJlY3QoZS5ib3VuZHMubGVmdCxNYXRoLnJvdW5kKGUuYm91bmRzLnRvcCthKSxlLmJvdW5kcy53aWR0aCwxKTticmVhaztjYXNlIDI6dS5jdHguZmlsbFJlY3QoZS5ib3VuZHMubGVmdCxNYXRoLnJvdW5kKGUuYm91bmRzLnRvcCksZS5ib3VuZHMud2lkdGgsMSk7YnJlYWs7Y2FzZSAzOnUuY3R4LmZpbGxSZWN0KGUuYm91bmRzLmxlZnQsTWF0aC5jZWlsKGUuYm91bmRzLnRvcCtsKSxlLmJvdW5kcy53aWR0aCwxKX19KSk7YnJlYWs7Y2FzZSAxOnQud2Via2l0VGV4dFN0cm9rZVdpZHRoJiZlLnRleHQudHJpbSgpLmxlbmd0aCYmKHUuY3R4LnN0cm9rZVN0eWxlPWZ0KHQud2Via2l0VGV4dFN0cm9rZUNvbG9yKSx1LmN0eC5saW5lV2lkdGg9dC53ZWJraXRUZXh0U3Ryb2tlV2lkdGgsdS5jdHgubGluZUpvaW49d2luZG93LmNocm9tZT8ibWl0ZXIiOiJyb3VuZCIsdS5jdHguc3Ryb2tlVGV4dChlLnRleHQsZS5ib3VuZHMubGVmdCxlLmJvdW5kcy50b3ArYSkpLHUuY3R4LnN0cm9rZVN0eWxlPSIiLHUuY3R4LmxpbmVXaWR0aD0wLHUuY3R4LmxpbmVKb2luPSJtaXRlciJ9fSl9KSxbMl19KX0pfSxBLnByb3RvdHlwZS5yZW5kZXJSZXBsYWNlZEVsZW1lbnQ9ZnVuY3Rpb24oZSx0LEEpe2lmKEEmJmUuaW50cmluc2ljV2lkdGg+MCYmZS5pbnRyaW5zaWNIZWlnaHQ+MCl7dmFyIHI9dGkoZSksbj1Ecyh0KTt0aGlzLnBhdGgobiksdGhpcy5jdHguc2F2ZSgpLHRoaXMuY3R4LmNsaXAoKSx0aGlzLmN0eC5kcmF3SW1hZ2UoQSwwLDAsZS5pbnRyaW5zaWNXaWR0aCxlLmludHJpbnNpY0hlaWdodCxyLmxlZnQsci50b3Asci53aWR0aCxyLmhlaWdodCksdGhpcy5jdHgucmVzdG9yZSgpfX0sQS5wcm90b3R5cGUucmVuZGVyTm9kZUNvbnRlbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQscixzLG8sYSxsLGMsdSxoLGQsZixwLGcsbSx3LEIseSx2O3JldHVybiBuKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDp0aGlzLmFwcGx5RWZmZWN0cyhlLmdldEVmZmVjdHMoNCkpLHQ9ZS5jb250YWluZXIscj1lLmN1cnZlcyxzPXQuc3R5bGVzLG89MCxhPXQudGV4dE5vZGVzLG4ubGFiZWw9MTtjYXNlIDE6cmV0dXJuIG88YS5sZW5ndGg/KGw9YVtvXSxbNCx0aGlzLnJlbmRlclRleHROb2RlKGwscyldKTpbMyw0XTtjYXNlIDI6bi5zZW50KCksbi5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gbysrLFszLDFdO2Nhc2UgNDppZighKHQgaW5zdGFuY2VvZiBvbikpcmV0dXJuWzMsOF07bi5sYWJlbD01O2Nhc2UgNTpyZXR1cm4gbi50cnlzLnB1c2goWzUsNywsOF0pLFs0LHRoaXMuY29udGV4dC5jYWNoZS5tYXRjaCh0LnNyYyldO2Nhc2UgNjpyZXR1cm4gdz1uLnNlbnQoKSx0aGlzLnJlbmRlclJlcGxhY2VkRWxlbWVudCh0LHIsdyksWzMsOF07Y2FzZSA3OnJldHVybiBuLnNlbnQoKSx0aGlzLmNvbnRleHQubG9nZ2VyLmVycm9yKCJFcnJvciBsb2FkaW5nIGltYWdlICIrdC5zcmMpLFszLDhdO2Nhc2UgODppZih0IGluc3RhbmNlb2YgYW4mJnRoaXMucmVuZGVyUmVwbGFjZWRFbGVtZW50KHQscix0LmNhbnZhcyksISh0IGluc3RhbmNlb2YgbG4pKXJldHVyblszLDEyXTtuLmxhYmVsPTk7Y2FzZSA5OnJldHVybiBuLnRyeXMucHVzaChbOSwxMSwsMTJdKSxbNCx0aGlzLmNvbnRleHQuY2FjaGUubWF0Y2godC5zdmcpXTtjYXNlIDEwOnJldHVybiB3PW4uc2VudCgpLHRoaXMucmVuZGVyUmVwbGFjZWRFbGVtZW50KHQscix3KSxbMywxMl07Y2FzZSAxMTpyZXR1cm4gbi5zZW50KCksdGhpcy5jb250ZXh0LmxvZ2dlci5lcnJvcigiRXJyb3IgbG9hZGluZyBzdmcgIit0LnN2Zy5zdWJzdHJpbmcoMCwyNTUpKSxbMywxMl07Y2FzZSAxMjpyZXR1cm4gdCBpbnN0YW5jZW9mIHZuJiZ0LnRyZWU/WzQsbmV3IEEodGhpcy5jb250ZXh0LHtzY2FsZTp0aGlzLm9wdGlvbnMuc2NhbGUsYmFja2dyb3VuZENvbG9yOnQuYmFja2dyb3VuZENvbG9yLHg6MCx5OjAsd2lkdGg6dC53aWR0aCxoZWlnaHQ6dC5oZWlnaHR9KS5yZW5kZXIodC50cmVlKV06WzMsMTRdO2Nhc2UgMTM6Yz1uLnNlbnQoKSx0LndpZHRoJiZ0LmhlaWdodCYmdGhpcy5jdHguZHJhd0ltYWdlKGMsMCwwLHQud2lkdGgsdC5oZWlnaHQsdC5ib3VuZHMubGVmdCx0LmJvdW5kcy50b3AsdC5ib3VuZHMud2lkdGgsdC5ib3VuZHMuaGVpZ2h0KSxuLmxhYmVsPTE0O2Nhc2UgMTQ6aWYodCBpbnN0YW5jZW9mIHduJiYodT1NYXRoLm1pbih0LmJvdW5kcy53aWR0aCx0LmJvdW5kcy5oZWlnaHQpLHQudHlwZT09PWZuP3QuY2hlY2tlZCYmKHRoaXMuY3R4LnNhdmUoKSx0aGlzLnBhdGgoW25ldyBOcyh0LmJvdW5kcy5sZWZ0Ky4zOTM2Myp1LHQuYm91bmRzLnRvcCsuNzkqdSksbmV3IE5zKHQuYm91bmRzLmxlZnQrLjE2KnUsdC5ib3VuZHMudG9wKy41NTQ5KnUpLG5ldyBOcyh0LmJvdW5kcy5sZWZ0Ky4yNzM0Nyp1LHQuYm91bmRzLnRvcCsuNDQwNzEqdSksbmV3IE5zKHQuYm91bmRzLmxlZnQrLjM5Njk0KnUsdC5ib3VuZHMudG9wKy41NjQ5KnUpLG5ldyBOcyh0LmJvdW5kcy5sZWZ0Ky43Mjk4Myp1LHQuYm91bmRzLnRvcCsuMjMqdSksbmV3IE5zKHQuYm91bmRzLmxlZnQrLjg0KnUsdC5ib3VuZHMudG9wKy4zNDA4NSp1KSxuZXcgTnModC5ib3VuZHMubGVmdCsuMzkzNjMqdSx0LmJvdW5kcy50b3ArLjc5KnUpXSksdGhpcy5jdHguZmlsbFN0eWxlPWZ0KG1uKSx0aGlzLmN0eC5maWxsKCksdGhpcy5jdHgucmVzdG9yZSgpKTp0LnR5cGU9PT1wbiYmdC5jaGVja2VkJiYodGhpcy5jdHguc2F2ZSgpLHRoaXMuY3R4LmJlZ2luUGF0aCgpLHRoaXMuY3R4LmFyYyh0LmJvdW5kcy5sZWZ0K3UvMix0LmJvdW5kcy50b3ArdS8yLHUvNCwwLDIqTWF0aC5QSSwhMCksdGhpcy5jdHguZmlsbFN0eWxlPWZ0KG1uKSx0aGlzLmN0eC5maWxsKCksdGhpcy5jdHgucmVzdG9yZSgpKSksaGkodCkmJnQudmFsdWUubGVuZ3RoKXtzd2l0Y2goaD10aGlzLmNyZWF0ZUZvbnRTdHlsZShzKSx5PWhbMF0sZD1oWzFdLGY9dGhpcy5mb250TWV0cmljcy5nZXRNZXRyaWNzKHksZCkuYmFzZWxpbmUsdGhpcy5jdHguZm9udD15LHRoaXMuY3R4LmZpbGxTdHlsZT1mdChzLmNvbG9yKSx0aGlzLmN0eC50ZXh0QmFzZWxpbmU9ImFscGhhYmV0aWMiLHRoaXMuY3R4LnRleHRBbGlnbj1maSh0LnN0eWxlcy50ZXh0QWxpZ24pLHY9dGkodCkscD0wLHQuc3R5bGVzLnRleHRBbGlnbil7Y2FzZSAxOnArPXYud2lkdGgvMjticmVhaztjYXNlIDI6cCs9di53aWR0aH1nPXYuYWRkKHAsMCwwLC12LmhlaWdodC8yKzEpLHRoaXMuY3R4LnNhdmUoKSx0aGlzLnBhdGgoW25ldyBOcyh2LmxlZnQsdi50b3ApLG5ldyBOcyh2LmxlZnQrdi53aWR0aCx2LnRvcCksbmV3IE5zKHYubGVmdCt2LndpZHRoLHYudG9wK3YuaGVpZ2h0KSxuZXcgTnModi5sZWZ0LHYudG9wK3YuaGVpZ2h0KV0pLHRoaXMuY3R4LmNsaXAoKSx0aGlzLnJlbmRlclRleHRXaXRoTGV0dGVyU3BhY2luZyhuZXcgWHIodC52YWx1ZSxnKSxzLmxldHRlclNwYWNpbmcsZiksdGhpcy5jdHgucmVzdG9yZSgpLHRoaXMuY3R4LnRleHRCYXNlbGluZT0iYWxwaGFiZXRpYyIsdGhpcy5jdHgudGV4dEFsaWduPSJsZWZ0In1pZighbHIodC5zdHlsZXMuZGlzcGxheSwyMDQ4KSlyZXR1cm5bMywyMF07aWYobnVsbD09PXQuc3R5bGVzLmxpc3RTdHlsZUltYWdlKXJldHVyblszLDE5XTtpZigwIT09KG09dC5zdHlsZXMubGlzdFN0eWxlSW1hZ2UpLnR5cGUpcmV0dXJuWzMsMThdO3c9dm9pZCAwLEI9bS51cmwsbi5sYWJlbD0xNTtjYXNlIDE1OnJldHVybiBuLnRyeXMucHVzaChbMTUsMTcsLDE4XSksWzQsdGhpcy5jb250ZXh0LmNhY2hlLm1hdGNoKEIpXTtjYXNlIDE2OnJldHVybiB3PW4uc2VudCgpLHRoaXMuY3R4LmRyYXdJbWFnZSh3LHQuYm91bmRzLmxlZnQtKHcud2lkdGgrMTApLHQuYm91bmRzLnRvcCksWzMsMThdO2Nhc2UgMTc6cmV0dXJuIG4uc2VudCgpLHRoaXMuY29udGV4dC5sb2dnZXIuZXJyb3IoIkVycm9yIGxvYWRpbmcgbGlzdC1zdHlsZS1pbWFnZSAiK0IpLFszLDE4XTtjYXNlIDE4OnJldHVyblszLDIwXTtjYXNlIDE5OmUubGlzdFZhbHVlJiYtMSE9PXQuc3R5bGVzLmxpc3RTdHlsZVR5cGUmJih5PXRoaXMuY3JlYXRlRm9udFN0eWxlKHMpWzBdLHRoaXMuY3R4LmZvbnQ9eSx0aGlzLmN0eC5maWxsU3R5bGU9ZnQocy5jb2xvciksdGhpcy5jdHgudGV4dEJhc2VsaW5lPSJtaWRkbGUiLHRoaXMuY3R4LnRleHRBbGlnbj0icmlnaHQiLHY9bmV3IGkodC5ib3VuZHMubGVmdCx0LmJvdW5kcy50b3Arc3QodC5zdHlsZXMucGFkZGluZ1RvcCx0LmJvdW5kcy53aWR0aCksdC5ib3VuZHMud2lkdGgseEEocy5saW5lSGVpZ2h0LHMuZm9udFNpemUubnVtYmVyKS8yKzEpLHRoaXMucmVuZGVyVGV4dFdpdGhMZXR0ZXJTcGFjaW5nKG5ldyBYcihlLmxpc3RWYWx1ZSx2KSxzLmxldHRlclNwYWNpbmcseEEocy5saW5lSGVpZ2h0LHMuZm9udFNpemUubnVtYmVyKS8yKzIpLHRoaXMuY3R4LnRleHRCYXNlbGluZT0iYm90dG9tIix0aGlzLmN0eC50ZXh0QWxpZ249ImxlZnQiKSxuLmxhYmVsPTIwO2Nhc2UgMjA6cmV0dXJuWzJdfX0pfSl9LEEucHJvdG90eXBlLnJlbmRlclN0YWNrQ29udGVudD1mdW5jdGlvbihlKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxBLHIscyxpLG8sYSxsLGMsdSxoLGQsZixwLGc7cmV0dXJuIG4odGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybiBscihlLmVsZW1lbnQuY29udGFpbmVyLmZsYWdzLDE2KSxbNCx0aGlzLnJlbmRlck5vZGVCYWNrZ3JvdW5kQW5kQm9yZGVycyhlLmVsZW1lbnQpXTtjYXNlIDE6bi5zZW50KCksdD0wLEE9ZS5uZWdhdGl2ZVpJbmRleCxuLmxhYmVsPTI7Y2FzZSAyOnJldHVybiB0PEEubGVuZ3RoPyhnPUFbdF0sWzQsdGhpcy5yZW5kZXJTdGFjayhnKV0pOlszLDVdO2Nhc2UgMzpuLnNlbnQoKSxuLmxhYmVsPTQ7Y2FzZSA0OnJldHVybiB0KyssWzMsMl07Y2FzZSA1OnJldHVybls0LHRoaXMucmVuZGVyTm9kZUNvbnRlbnQoZS5lbGVtZW50KV07Y2FzZSA2Om4uc2VudCgpLHI9MCxzPWUubm9uSW5saW5lTGV2ZWwsbi5sYWJlbD03O2Nhc2UgNzpyZXR1cm4gcjxzLmxlbmd0aD8oZz1zW3JdLFs0LHRoaXMucmVuZGVyTm9kZShnKV0pOlszLDEwXTtjYXNlIDg6bi5zZW50KCksbi5sYWJlbD05O2Nhc2UgOTpyZXR1cm4gcisrLFszLDddO2Nhc2UgMTA6aT0wLG89ZS5ub25Qb3NpdGlvbmVkRmxvYXRzLG4ubGFiZWw9MTE7Y2FzZSAxMTpyZXR1cm4gaTxvLmxlbmd0aD8oZz1vW2ldLFs0LHRoaXMucmVuZGVyU3RhY2soZyldKTpbMywxNF07Y2FzZSAxMjpuLnNlbnQoKSxuLmxhYmVsPTEzO2Nhc2UgMTM6cmV0dXJuIGkrKyxbMywxMV07Y2FzZSAxNDphPTAsbD1lLm5vblBvc2l0aW9uZWRJbmxpbmVMZXZlbCxuLmxhYmVsPTE1O2Nhc2UgMTU6cmV0dXJuIGE8bC5sZW5ndGg/KGc9bFthXSxbNCx0aGlzLnJlbmRlclN0YWNrKGcpXSk6WzMsMThdO2Nhc2UgMTY6bi5zZW50KCksbi5sYWJlbD0xNztjYXNlIDE3OnJldHVybiBhKyssWzMsMTVdO2Nhc2UgMTg6Yz0wLHU9ZS5pbmxpbmVMZXZlbCxuLmxhYmVsPTE5O2Nhc2UgMTk6cmV0dXJuIGM8dS5sZW5ndGg/KGc9dVtjXSxbNCx0aGlzLnJlbmRlck5vZGUoZyldKTpbMywyMl07Y2FzZSAyMDpuLnNlbnQoKSxuLmxhYmVsPTIxO2Nhc2UgMjE6cmV0dXJuIGMrKyxbMywxOV07Y2FzZSAyMjpoPTAsZD1lLnplcm9PckF1dG9aSW5kZXhPclRyYW5zZm9ybWVkT3JPcGFjaXR5LG4ubGFiZWw9MjM7Y2FzZSAyMzpyZXR1cm4gaDxkLmxlbmd0aD8oZz1kW2hdLFs0LHRoaXMucmVuZGVyU3RhY2soZyldKTpbMywyNl07Y2FzZSAyNDpuLnNlbnQoKSxuLmxhYmVsPTI1O2Nhc2UgMjU6cmV0dXJuIGgrKyxbMywyM107Y2FzZSAyNjpmPTAscD1lLnBvc2l0aXZlWkluZGV4LG4ubGFiZWw9Mjc7Y2FzZSAyNzpyZXR1cm4gZjxwLmxlbmd0aD8oZz1wW2ZdLFs0LHRoaXMucmVuZGVyU3RhY2soZyldKTpbMywzMF07Y2FzZSAyODpuLnNlbnQoKSxuLmxhYmVsPTI5O2Nhc2UgMjk6cmV0dXJuIGYrKyxbMywyN107Y2FzZSAzMDpyZXR1cm5bMl19fSl9KX0sQS5wcm90b3R5cGUubWFzaz1mdW5jdGlvbihlKXt0aGlzLmN0eC5iZWdpblBhdGgoKSx0aGlzLmN0eC5tb3ZlVG8oMCwwKSx0aGlzLmN0eC5saW5lVG8odGhpcy5jYW52YXMud2lkdGgsMCksdGhpcy5jdHgubGluZVRvKHRoaXMuY2FudmFzLndpZHRoLHRoaXMuY2FudmFzLmhlaWdodCksdGhpcy5jdHgubGluZVRvKDAsdGhpcy5jYW52YXMuaGVpZ2h0KSx0aGlzLmN0eC5saW5lVG8oMCwwKSx0aGlzLmZvcm1hdFBhdGgoZS5zbGljZSgwKS5yZXZlcnNlKCkpLHRoaXMuY3R4LmNsb3NlUGF0aCgpfSxBLnByb3RvdHlwZS5wYXRoPWZ1bmN0aW9uKGUpe3RoaXMuY3R4LmJlZ2luUGF0aCgpLHRoaXMuZm9ybWF0UGF0aChlKSx0aGlzLmN0eC5jbG9zZVBhdGgoKX0sQS5wcm90b3R5cGUuZm9ybWF0UGF0aD1mdW5jdGlvbihlKXt2YXIgdD10aGlzO2UuZm9yRWFjaChmdW5jdGlvbihlLEEpe3ZhciByPVBzKGUpP2Uuc3RhcnQ6ZTswPT09QT90LmN0eC5tb3ZlVG8oci54LHIueSk6dC5jdHgubGluZVRvKHIueCxyLnkpLFBzKGUpJiZ0LmN0eC5iZXppZXJDdXJ2ZVRvKGUuc3RhcnRDb250cm9sLngsZS5zdGFydENvbnRyb2wueSxlLmVuZENvbnRyb2wueCxlLmVuZENvbnRyb2wueSxlLmVuZC54LGUuZW5kLnkpfSl9LEEucHJvdG90eXBlLnJlbmRlclJlcGVhdD1mdW5jdGlvbihlLHQsQSxyKXt0aGlzLnBhdGgoZSksdGhpcy5jdHguZmlsbFN0eWxlPXQsdGhpcy5jdHgudHJhbnNsYXRlKEEsciksdGhpcy5jdHguZmlsbCgpLHRoaXMuY3R4LnRyYW5zbGF0ZSgtQSwtcil9LEEucHJvdG90eXBlLnJlc2l6ZUltYWdlPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcjtpZihlLndpZHRoPT09dCYmZS5oZWlnaHQ9PT1BKXJldHVybiBlO3ZhciBuPShudWxsIT09KHI9dGhpcy5jYW52YXMub3duZXJEb2N1bWVudCkmJnZvaWQgMCE9PXI/cjpkb2N1bWVudCkuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7cmV0dXJuIG4ud2lkdGg9TWF0aC5tYXgoMSx0KSxuLmhlaWdodD1NYXRoLm1heCgxLEEpLG4uZ2V0Q29udGV4dCgiMmQiKS5kcmF3SW1hZ2UoZSwwLDAsZS53aWR0aCxlLmhlaWdodCwwLDAsdCxBKSxufSxBLnByb3RvdHlwZS5yZW5kZXJCYWNrZ3JvdW5kSW1hZ2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsQSxyLHMsaSxvO3JldHVybiBuKHRoaXMsZnVuY3Rpb24oYSl7c3dpdGNoKGEubGFiZWwpe2Nhc2UgMDp0PWUuc3R5bGVzLmJhY2tncm91bmRJbWFnZS5sZW5ndGgtMSxBPWZ1bmN0aW9uKEEpe3ZhciBzLGksbyxhLGwsYyx1LGgsZCxmLHAsZyxtLHcsQix5LHYsYixDLF8saix4LEYsUSxVLEUsUyxMLEksTixrO3JldHVybiBuKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDppZigwIT09QS50eXBlKXJldHVyblszLDVdO3M9dm9pZCAwLGk9QS51cmwsbi5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbi50cnlzLnB1c2goWzEsMywsNF0pLFs0LHIuY29udGV4dC5jYWNoZS5tYXRjaChpKV07Y2FzZSAyOnJldHVybiBzPW4uc2VudCgpLFszLDRdO2Nhc2UgMzpyZXR1cm4gbi5zZW50KCksci5jb250ZXh0LmxvZ2dlci5lcnJvcigiRXJyb3IgbG9hZGluZyBiYWNrZ3JvdW5kLWltYWdlICIraSksWzMsNF07Y2FzZSA0OnJldHVybiBzJiYobz1BaShlLHQsW3Mud2lkdGgscy5oZWlnaHQscy53aWR0aC9zLmhlaWdodF0pLHk9b1swXSx4PW9bMV0sRj1vWzJdLEM9b1szXSxfPW9bNF0sdz1yLmN0eC5jcmVhdGVQYXR0ZXJuKHIucmVzaXplSW1hZ2UocyxDLF8pLCJyZXBlYXQiKSxyLnJlbmRlclJlcGVhdCh5LHcseCxGKSksWzMsNl07Y2FzZSA1OjE9PT1BLnR5cGU/KGE9QWkoZSx0LFtudWxsLG51bGwsbnVsbF0pLHk9YVswXSx4PWFbMV0sRj1hWzJdLEM9YVszXSxfPWFbNF0sbD1GdChBLmFuZ2xlLEMsXyksYz1sWzBdLHU9bFsxXSxoPWxbMl0sZD1sWzNdLGY9bFs0XSwocD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSkud2lkdGg9QyxwLmhlaWdodD1fLGc9cC5nZXRDb250ZXh0KCIyZCIpLG09Zy5jcmVhdGVMaW5lYXJHcmFkaWVudCh1LGQsaCxmKSx4dChBLnN0b3BzLGMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIG0uYWRkQ29sb3JTdG9wKGUuc3RvcCxmdChlLmNvbG9yKSl9KSxnLmZpbGxTdHlsZT1tLGcuZmlsbFJlY3QoMCwwLEMsXyksQz4wJiZfPjAmJih3PXIuY3R4LmNyZWF0ZVBhdHRlcm4ocCwicmVwZWF0Iiksci5yZW5kZXJSZXBlYXQoeSx3LHgsRikpKTpmdW5jdGlvbihlKXtyZXR1cm4gMj09PWUudHlwZX0oQSkmJihCPUFpKGUsdCxbbnVsbCxudWxsLG51bGxdKSx5PUJbMF0sdj1CWzFdLGI9QlsyXSxDPUJbM10sXz1CWzRdLGo9MD09PUEucG9zaXRpb24ubGVuZ3RoP1tBdF06QS5wb3NpdGlvbix4PXN0KGpbMF0sQyksRj1zdChqW2oubGVuZ3RoLTFdLF8pLFE9ZnVuY3Rpb24oZSx0LEEscixuKXt2YXIgcz0wLGk9MDtzd2l0Y2goZS5zaXplKXtjYXNlIDA6MD09PWUuc2hhcGU/cz1pPU1hdGgubWluKE1hdGguYWJzKHQpLE1hdGguYWJzKHQtciksTWF0aC5hYnMoQSksTWF0aC5hYnMoQS1uKSk6MT09PWUuc2hhcGUmJihzPU1hdGgubWluKE1hdGguYWJzKHQpLE1hdGguYWJzKHQtcikpLGk9TWF0aC5taW4oTWF0aC5hYnMoQSksTWF0aC5hYnMoQS1uKSkpO2JyZWFrO2Nhc2UgMjppZigwPT09ZS5zaGFwZSlzPWk9TWF0aC5taW4oUXQodCxBKSxRdCh0LEEtbiksUXQodC1yLEEpLFF0KHQtcixBLW4pKTtlbHNlIGlmKDE9PT1lLnNoYXBlKXt2YXIgbz1NYXRoLm1pbihNYXRoLmFicyhBKSxNYXRoLmFicyhBLW4pKS9NYXRoLm1pbihNYXRoLmFicyh0KSxNYXRoLmFicyh0LXIpKSxhPVV0KHIsbix0LEEsITApLGw9YVswXSxjPWFbMV07aT1vKihzPVF0KGwtdCwoYy1BKS9vKSl9YnJlYWs7Y2FzZSAxOjA9PT1lLnNoYXBlP3M9aT1NYXRoLm1heChNYXRoLmFicyh0KSxNYXRoLmFicyh0LXIpLE1hdGguYWJzKEEpLE1hdGguYWJzKEEtbikpOjE9PT1lLnNoYXBlJiYocz1NYXRoLm1heChNYXRoLmFicyh0KSxNYXRoLmFicyh0LXIpKSxpPU1hdGgubWF4KE1hdGguYWJzKEEpLE1hdGguYWJzKEEtbikpKTticmVhaztjYXNlIDM6aWYoMD09PWUuc2hhcGUpcz1pPU1hdGgubWF4KFF0KHQsQSksUXQodCxBLW4pLFF0KHQtcixBKSxRdCh0LXIsQS1uKSk7ZWxzZSBpZigxPT09ZS5zaGFwZSl7bz1NYXRoLm1heChNYXRoLmFicyhBKSxNYXRoLmFicyhBLW4pKS9NYXRoLm1heChNYXRoLmFicyh0KSxNYXRoLmFicyh0LXIpKTt2YXIgdT1VdChyLG4sdCxBLCExKTtsPXVbMF0sYz11WzFdLGk9byoocz1RdChsLXQsKGMtQSkvbykpfX1yZXR1cm4gQXJyYXkuaXNBcnJheShlLnNpemUpJiYocz1zdChlLnNpemVbMF0sciksaT0yPT09ZS5zaXplLmxlbmd0aD9zdChlLnNpemVbMV0sbik6cyksW3MsaV19KEEseCxGLEMsXyksVT1RWzBdLEU9UVsxXSxVPjAmJkU+MCYmKFM9ci5jdHguY3JlYXRlUmFkaWFsR3JhZGllbnQodit4LGIrRiwwLHYreCxiK0YsVSkseHQoQS5zdG9wcywyKlUpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIFMuYWRkQ29sb3JTdG9wKGUuc3RvcCxmdChlLmNvbG9yKSl9KSxyLnBhdGgoeSksci5jdHguZmlsbFN0eWxlPVMsVSE9PUU/KEw9ZS5ib3VuZHMubGVmdCsuNSplLmJvdW5kcy53aWR0aCxJPWUuYm91bmRzLnRvcCsuNSplLmJvdW5kcy5oZWlnaHQsaz0xLyhOPUUvVSksci5jdHguc2F2ZSgpLHIuY3R4LnRyYW5zbGF0ZShMLEkpLHIuY3R4LnRyYW5zZm9ybSgxLDAsMCxOLDAsMCksci5jdHgudHJhbnNsYXRlKC1MLC1JKSxyLmN0eC5maWxsUmVjdCh2LGsqKGItSSkrSSxDLF8qayksci5jdHgucmVzdG9yZSgpKTpyLmN0eC5maWxsKCkpKSxuLmxhYmVsPTY7Y2FzZSA2OnJldHVybiB0LS0sWzJdfX0pfSxyPXRoaXMscz0wLGk9ZS5zdHlsZXMuYmFja2dyb3VuZEltYWdlLnNsaWNlKDApLnJldmVyc2UoKSxhLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBzPGkubGVuZ3RoPyhvPWlbc10sWzUsQShvKV0pOlszLDRdO2Nhc2UgMjphLnNlbnQoKSxhLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBzKyssWzMsMV07Y2FzZSA0OnJldHVyblsyXX19KX0pfSxBLnByb3RvdHlwZS5yZW5kZXJTb2xpZEJvcmRlcj1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyxmdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5wYXRoKEpzKEEsdCkpLHRoaXMuY3R4LmZpbGxTdHlsZT1mdChlKSx0aGlzLmN0eC5maWxsKCksWzJdfSl9KX0sQS5wcm90b3R5cGUucmVuZGVyRG91YmxlQm9yZGVyPWZ1bmN0aW9uKGUsdCxBLHMpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLGk7cmV0dXJuIG4odGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybiB0PDM/WzQsdGhpcy5yZW5kZXJTb2xpZEJvcmRlcihlLEEscyldOlszLDJdO2Nhc2UgMTpyZXR1cm4gbi5zZW50KCksWzJdO2Nhc2UgMjpyZXR1cm4gcj1mdW5jdGlvbihlLHQpe3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuICRzKGUudG9wTGVmdEJvcmRlckJveCxlLnRvcExlZnRCb3JkZXJEb3VibGVPdXRlckJveCxlLnRvcFJpZ2h0Qm9yZGVyQm94LGUudG9wUmlnaHRCb3JkZXJEb3VibGVPdXRlckJveCk7Y2FzZSAxOnJldHVybiAkcyhlLnRvcFJpZ2h0Qm9yZGVyQm94LGUudG9wUmlnaHRCb3JkZXJEb3VibGVPdXRlckJveCxlLmJvdHRvbVJpZ2h0Qm9yZGVyQm94LGUuYm90dG9tUmlnaHRCb3JkZXJEb3VibGVPdXRlckJveCk7Y2FzZSAyOnJldHVybiAkcyhlLmJvdHRvbVJpZ2h0Qm9yZGVyQm94LGUuYm90dG9tUmlnaHRCb3JkZXJEb3VibGVPdXRlckJveCxlLmJvdHRvbUxlZnRCb3JkZXJCb3gsZS5ib3R0b21MZWZ0Qm9yZGVyRG91YmxlT3V0ZXJCb3gpO2RlZmF1bHQ6cmV0dXJuICRzKGUuYm90dG9tTGVmdEJvcmRlckJveCxlLmJvdHRvbUxlZnRCb3JkZXJEb3VibGVPdXRlckJveCxlLnRvcExlZnRCb3JkZXJCb3gsZS50b3BMZWZ0Qm9yZGVyRG91YmxlT3V0ZXJCb3gpfX0ocyxBKSx0aGlzLnBhdGgociksdGhpcy5jdHguZmlsbFN0eWxlPWZ0KGUpLHRoaXMuY3R4LmZpbGwoKSxpPWZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gJHMoZS50b3BMZWZ0Qm9yZGVyRG91YmxlSW5uZXJCb3gsZS50b3BMZWZ0UGFkZGluZ0JveCxlLnRvcFJpZ2h0Qm9yZGVyRG91YmxlSW5uZXJCb3gsZS50b3BSaWdodFBhZGRpbmdCb3gpO2Nhc2UgMTpyZXR1cm4gJHMoZS50b3BSaWdodEJvcmRlckRvdWJsZUlubmVyQm94LGUudG9wUmlnaHRQYWRkaW5nQm94LGUuYm90dG9tUmlnaHRCb3JkZXJEb3VibGVJbm5lckJveCxlLmJvdHRvbVJpZ2h0UGFkZGluZ0JveCk7Y2FzZSAyOnJldHVybiAkcyhlLmJvdHRvbVJpZ2h0Qm9yZGVyRG91YmxlSW5uZXJCb3gsZS5ib3R0b21SaWdodFBhZGRpbmdCb3gsZS5ib3R0b21MZWZ0Qm9yZGVyRG91YmxlSW5uZXJCb3gsZS5ib3R0b21MZWZ0UGFkZGluZ0JveCk7ZGVmYXVsdDpyZXR1cm4gJHMoZS5ib3R0b21MZWZ0Qm9yZGVyRG91YmxlSW5uZXJCb3gsZS5ib3R0b21MZWZ0UGFkZGluZ0JveCxlLnRvcExlZnRCb3JkZXJEb3VibGVJbm5lckJveCxlLnRvcExlZnRQYWRkaW5nQm94KX19KHMsQSksdGhpcy5wYXRoKGkpLHRoaXMuY3R4LmZpbGwoKSxbMl19fSl9KX0sQS5wcm90b3R5cGUucmVuZGVyTm9kZUJhY2tncm91bmRBbmRCb3JkZXJzPWZ1bmN0aW9uKGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LEEscixzLGksbyxhLGwsYz10aGlzO3JldHVybiBuKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy5hcHBseUVmZmVjdHMoZS5nZXRFZmZlY3RzKDIpKSx0PWUuY29udGFpbmVyLnN0eWxlcyxBPSFkdCh0LmJhY2tncm91bmRDb2xvcil8fHQuYmFja2dyb3VuZEltYWdlLmxlbmd0aCxyPVt7c3R5bGU6dC5ib3JkZXJUb3BTdHlsZSxjb2xvcjp0LmJvcmRlclRvcENvbG9yLHdpZHRoOnQuYm9yZGVyVG9wV2lkdGh9LHtzdHlsZTp0LmJvcmRlclJpZ2h0U3R5bGUsY29sb3I6dC5ib3JkZXJSaWdodENvbG9yLHdpZHRoOnQuYm9yZGVyUmlnaHRXaWR0aH0se3N0eWxlOnQuYm9yZGVyQm90dG9tU3R5bGUsY29sb3I6dC5ib3JkZXJCb3R0b21Db2xvcix3aWR0aDp0LmJvcmRlckJvdHRvbVdpZHRofSx7c3R5bGU6dC5ib3JkZXJMZWZ0U3R5bGUsY29sb3I6dC5ib3JkZXJMZWZ0Q29sb3Isd2lkdGg6dC5ib3JkZXJMZWZ0V2lkdGh9XSxzPWRpKGlpKHQuYmFja2dyb3VuZENsaXAsMCksZS5jdXJ2ZXMpLEF8fHQuYm94U2hhZG93Lmxlbmd0aD8odGhpcy5jdHguc2F2ZSgpLHRoaXMucGF0aChzKSx0aGlzLmN0eC5jbGlwKCksZHQodC5iYWNrZ3JvdW5kQ29sb3IpfHwodGhpcy5jdHguZmlsbFN0eWxlPWZ0KHQuYmFja2dyb3VuZENvbG9yKSx0aGlzLmN0eC5maWxsKCkpLFs0LHRoaXMucmVuZGVyQmFja2dyb3VuZEltYWdlKGUuY29udGFpbmVyKV0pOlszLDJdO2Nhc2UgMTpuLnNlbnQoKSx0aGlzLmN0eC5yZXN0b3JlKCksdC5ib3hTaGFkb3cuc2xpY2UoMCkucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24odCl7Yy5jdHguc2F2ZSgpO3ZhciBBLHIsbixzLGksbz1NcyhlLmN1cnZlcyksYT10Lmluc2V0PzA6MWU0LGw9KEE9byxyPS1hKyh0Lmluc2V0PzE6LTEpKnQuc3ByZWFkLm51bWJlcixuPSh0Lmluc2V0PzE6LTEpKnQuc3ByZWFkLm51bWJlcixzPXQuc3ByZWFkLm51bWJlcioodC5pbnNldD8tMjoyKSxpPXQuc3ByZWFkLm51bWJlcioodC5pbnNldD8tMjoyKSxBLm1hcChmdW5jdGlvbihlLHQpe3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIGUuYWRkKHIsbik7Y2FzZSAxOnJldHVybiBlLmFkZChyK3Msbik7Y2FzZSAyOnJldHVybiBlLmFkZChyK3MsbitpKTtjYXNlIDM6cmV0dXJuIGUuYWRkKHIsbitpKX1yZXR1cm4gZX0pKTt0Lmluc2V0PyhjLnBhdGgobyksYy5jdHguY2xpcCgpLGMubWFzayhsKSk6KGMubWFzayhvKSxjLmN0eC5jbGlwKCksYy5wYXRoKGwpKSxjLmN0eC5zaGFkb3dPZmZzZXRYPXQub2Zmc2V0WC5udW1iZXIrYSxjLmN0eC5zaGFkb3dPZmZzZXRZPXQub2Zmc2V0WS5udW1iZXIsYy5jdHguc2hhZG93Q29sb3I9ZnQodC5jb2xvciksYy5jdHguc2hhZG93Qmx1cj10LmJsdXIubnVtYmVyLGMuY3R4LmZpbGxTdHlsZT10Lmluc2V0P2Z0KHQuY29sb3IpOiJyZ2JhKDAsMCwwLDEpIixjLmN0eC5maWxsKCksYy5jdHgucmVzdG9yZSgpfSksbi5sYWJlbD0yO2Nhc2UgMjppPTAsbz0wLGE9cixuLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBvPGEubGVuZ3RoPzAhPT0obD1hW29dKS5zdHlsZSYmIWR0KGwuY29sb3IpJiZsLndpZHRoPjA/MiE9PWwuc3R5bGU/WzMsNV06WzQsdGhpcy5yZW5kZXJEYXNoZWREb3R0ZWRCb3JkZXIobC5jb2xvcixsLndpZHRoLGksZS5jdXJ2ZXMsMildOlszLDExXTpbMywxM107Y2FzZSA0OnJldHVybiBuLnNlbnQoKSxbMywxMV07Y2FzZSA1OnJldHVybiAzIT09bC5zdHlsZT9bMyw3XTpbNCx0aGlzLnJlbmRlckRhc2hlZERvdHRlZEJvcmRlcihsLmNvbG9yLGwud2lkdGgsaSxlLmN1cnZlcywzKV07Y2FzZSA2OnJldHVybiBuLnNlbnQoKSxbMywxMV07Y2FzZSA3OnJldHVybiA0IT09bC5zdHlsZT9bMyw5XTpbNCx0aGlzLnJlbmRlckRvdWJsZUJvcmRlcihsLmNvbG9yLGwud2lkdGgsaSxlLmN1cnZlcyldO2Nhc2UgODpyZXR1cm4gbi5zZW50KCksWzMsMTFdO2Nhc2UgOTpyZXR1cm5bNCx0aGlzLnJlbmRlclNvbGlkQm9yZGVyKGwuY29sb3IsaSxlLmN1cnZlcyldO2Nhc2UgMTA6bi5zZW50KCksbi5sYWJlbD0xMTtjYXNlIDExOmkrKyxuLmxhYmVsPTEyO2Nhc2UgMTI6cmV0dXJuIG8rKyxbMywzXTtjYXNlIDEzOnJldHVyblsyXX19KX0pfSxBLnByb3RvdHlwZS5yZW5kZXJEYXNoZWREb3R0ZWRCb3JkZXI9ZnVuY3Rpb24oZSx0LEEscyxpKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixvLGEsbCxjLHUsaCxkLGYscCxnLG0sdyxCLHksdjtyZXR1cm4gbih0aGlzLGZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmN0eC5zYXZlKCkscj1mdW5jdGlvbihlLHQpe3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIFpzKGUudG9wTGVmdEJvcmRlclN0cm9rZSxlLnRvcFJpZ2h0Qm9yZGVyU3Ryb2tlKTtjYXNlIDE6cmV0dXJuIFpzKGUudG9wUmlnaHRCb3JkZXJTdHJva2UsZS5ib3R0b21SaWdodEJvcmRlclN0cm9rZSk7Y2FzZSAyOnJldHVybiBacyhlLmJvdHRvbVJpZ2h0Qm9yZGVyU3Ryb2tlLGUuYm90dG9tTGVmdEJvcmRlclN0cm9rZSk7ZGVmYXVsdDpyZXR1cm4gWnMoZS5ib3R0b21MZWZ0Qm9yZGVyU3Ryb2tlLGUudG9wTGVmdEJvcmRlclN0cm9rZSl9fShzLEEpLG89SnMocyxBKSwyPT09aSYmKHRoaXMucGF0aChvKSx0aGlzLmN0eC5jbGlwKCkpLFBzKG9bMF0pPyhhPW9bMF0uc3RhcnQueCxsPW9bMF0uc3RhcnQueSk6KGE9b1swXS54LGw9b1swXS55KSxQcyhvWzFdKT8oYz1vWzFdLmVuZC54LHU9b1sxXS5lbmQueSk6KGM9b1sxXS54LHU9b1sxXS55KSxoPTA9PT1BfHwyPT09QT9NYXRoLmFicyhhLWMpOk1hdGguYWJzKGwtdSksdGhpcy5jdHguYmVnaW5QYXRoKCksMz09PWk/dGhpcy5mb3JtYXRQYXRoKHIpOnRoaXMuZm9ybWF0UGF0aChvLnNsaWNlKDAsMikpLGQ9dDwzPzMqdDoyKnQsZj10PDM/Mip0OnQsMz09PWkmJihkPXQsZj10KSxwPSEwLGg8PTIqZD9wPSExOmg8PTIqZCtmPyhkKj1nPWgvKDIqZCtmKSxmKj1nKToobT1NYXRoLmZsb29yKChoK2YpLyhkK2YpKSx3PShoLW0qZCkvKG0tMSksZj0oQj0oaC0obSsxKSpkKS9tKTw9MHx8TWF0aC5hYnMoZi13KTxNYXRoLmFicyhmLUIpP3c6QikscCYmKDM9PT1pP3RoaXMuY3R4LnNldExpbmVEYXNoKFswLGQrZl0pOnRoaXMuY3R4LnNldExpbmVEYXNoKFtkLGZdKSksMz09PWk/KHRoaXMuY3R4LmxpbmVDYXA9InJvdW5kIix0aGlzLmN0eC5saW5lV2lkdGg9dCk6dGhpcy5jdHgubGluZVdpZHRoPTIqdCsxLjEsdGhpcy5jdHguc3Ryb2tlU3R5bGU9ZnQoZSksdGhpcy5jdHguc3Ryb2tlKCksdGhpcy5jdHguc2V0TGluZURhc2goW10pLDI9PT1pJiYoUHMob1swXSkmJih5PW9bM10sdj1vWzBdLHRoaXMuY3R4LmJlZ2luUGF0aCgpLHRoaXMuZm9ybWF0UGF0aChbbmV3IE5zKHkuZW5kLngseS5lbmQueSksbmV3IE5zKHYuc3RhcnQueCx2LnN0YXJ0LnkpXSksdGhpcy5jdHguc3Ryb2tlKCkpLFBzKG9bMV0pJiYoeT1vWzFdLHY9b1syXSx0aGlzLmN0eC5iZWdpblBhdGgoKSx0aGlzLmZvcm1hdFBhdGgoW25ldyBOcyh5LmVuZC54LHkuZW5kLnkpLG5ldyBOcyh2LnN0YXJ0Lngsdi5zdGFydC55KV0pLHRoaXMuY3R4LnN0cm9rZSgpKSksdGhpcy5jdHgucmVzdG9yZSgpLFsyXX0pfSl9LEEucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihlKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbih0aGlzLGZ1bmN0aW9uKEEpe3N3aXRjaChBLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3ImJih0aGlzLmN0eC5maWxsU3R5bGU9ZnQodGhpcy5vcHRpb25zLmJhY2tncm91bmRDb2xvciksdGhpcy5jdHguZmlsbFJlY3QodGhpcy5vcHRpb25zLngsdGhpcy5vcHRpb25zLnksdGhpcy5vcHRpb25zLndpZHRoLHRoaXMub3B0aW9ucy5oZWlnaHQpKSxyPW5ldyBXcyhlLG51bGwpLG49bmV3IHFzKHIpLFhzKHIsbixuLHM9W10pLFlzKHIuY29udGFpbmVyLHMpLHQ9bixbNCx0aGlzLnJlbmRlclN0YWNrKHQpXTtjYXNlIDE6cmV0dXJuIEEuc2VudCgpLHRoaXMuYXBwbHlFZmZlY3RzKFtdKSxbMix0aGlzLmNhbnZhc119dmFyIHIsbixzfSl9KX0sQX0oY2kpLGhpPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgeW58fGUgaW5zdGFuY2VvZiBCbnx8ZSBpbnN0YW5jZW9mIHduJiZlLnR5cGUhPT1wbiYmZS50eXBlIT09Zm59LGRpPWZ1bmN0aW9uKGUsdCl7c3dpdGNoKGUpe2Nhc2UgMDpyZXR1cm4gTXModCk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbihlKXtyZXR1cm5bZS50b3BMZWZ0Q29udGVudEJveCxlLnRvcFJpZ2h0Q29udGVudEJveCxlLmJvdHRvbVJpZ2h0Q29udGVudEJveCxlLmJvdHRvbUxlZnRDb250ZW50Qm94XX0odCk7ZGVmYXVsdDpyZXR1cm4gRHModCl9fSxmaT1mdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiJjZW50ZXIiO2Nhc2UgMjpyZXR1cm4icmlnaHQiO2RlZmF1bHQ6cmV0dXJuImxlZnQifX0scGk9WyItYXBwbGUtc3lzdGVtIiwic3lzdGVtLXVpIl0sZ2k9ZnVuY3Rpb24oZSl7cmV0dXJuL2lQaG9uZSBPUyAxNV8oMHwxKS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk/ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuLTE9PT1waS5pbmRleE9mKGUpfSk6ZX0sbWk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gQSh0LEEpe3ZhciByPWUuY2FsbCh0aGlzLHQsQSl8fHRoaXM7cmV0dXJuIHIuY2FudmFzPUEuY2FudmFzP0EuY2FudmFzOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpLHIuY3R4PXIuY2FudmFzLmdldENvbnRleHQoIjJkIiksci5vcHRpb25zPUEsci5jYW52YXMud2lkdGg9TWF0aC5mbG9vcihBLndpZHRoKkEuc2NhbGUpLHIuY2FudmFzLmhlaWdodD1NYXRoLmZsb29yKEEuaGVpZ2h0KkEuc2NhbGUpLHIuY2FudmFzLnN0eWxlLndpZHRoPUEud2lkdGgrInB4IixyLmNhbnZhcy5zdHlsZS5oZWlnaHQ9QS5oZWlnaHQrInB4IixyLmN0eC5zY2FsZShyLm9wdGlvbnMuc2NhbGUsci5vcHRpb25zLnNjYWxlKSxyLmN0eC50cmFuc2xhdGUoLUEueCwtQS55KSxyLmNvbnRleHQubG9nZ2VyLmRlYnVnKCJFWFBFUklNRU5UQUwgRm9yZWlnbk9iamVjdCByZW5kZXJlciBpbml0aWFsaXplZCAoIitBLndpZHRoKyJ4IitBLmhlaWdodCsiIGF0ICIrQS54KyIsIitBLnkrIikgd2l0aCBzY2FsZSAiK0Euc2NhbGUpLHJ9cmV0dXJuIHQoQSxlKSxBLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsQTtyZXR1cm4gbih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9enIodGhpcy5vcHRpb25zLndpZHRoKnRoaXMub3B0aW9ucy5zY2FsZSx0aGlzLm9wdGlvbnMuaGVpZ2h0KnRoaXMub3B0aW9ucy5zY2FsZSx0aGlzLm9wdGlvbnMuc2NhbGUsdGhpcy5vcHRpb25zLnNjYWxlLGUpLFs0LHdpKHQpXTtjYXNlIDE6cmV0dXJuIEE9ci5zZW50KCksdGhpcy5vcHRpb25zLmJhY2tncm91bmRDb2xvciYmKHRoaXMuY3R4LmZpbGxTdHlsZT1mdCh0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSx0aGlzLmN0eC5maWxsUmVjdCgwLDAsdGhpcy5vcHRpb25zLndpZHRoKnRoaXMub3B0aW9ucy5zY2FsZSx0aGlzLm9wdGlvbnMuaGVpZ2h0KnRoaXMub3B0aW9ucy5zY2FsZSkpLHRoaXMuY3R4LmRyYXdJbWFnZShBLC10aGlzLm9wdGlvbnMueCp0aGlzLm9wdGlvbnMuc2NhbGUsLXRoaXMub3B0aW9ucy55KnRoaXMub3B0aW9ucy5zY2FsZSksWzIsdGhpcy5jYW52YXNdfX0pfSl9LEF9KGNpKSx3aT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odCxBKXt2YXIgcj1uZXcgSW1hZ2U7ci5vbmxvYWQ9ZnVuY3Rpb24oKXt0KHIpfSxyLm9uZXJyb3I9QSxyLnNyYz0iZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsIitlbmNvZGVVUklDb21wb25lbnQoKG5ldyBYTUxTZXJpYWxpemVyKS5zZXJpYWxpemVUb1N0cmluZyhlKSl9KX0sQmk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3ZhciB0PWUuaWQsQT1lLmVuYWJsZWQ7dGhpcy5pZD10LHRoaXMuZW5hYmxlZD1BLHRoaXMuc3RhcnQ9RGF0ZS5ub3coKX1yZXR1cm4gZS5wcm90b3R5cGUuZGVidWc9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dGhpcy5lbmFibGVkJiYoInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5jb25zb2xlJiYiZnVuY3Rpb24iPT10eXBlb2YgY29uc29sZS5kZWJ1Zz9jb25zb2xlLmRlYnVnLmFwcGx5KGNvbnNvbGUscyhbdGhpcy5pZCx0aGlzLmdldFRpbWUoKSsibXMiXSxlKSk6dGhpcy5pbmZvLmFwcGx5KHRoaXMsZSkpfSxlLnByb3RvdHlwZS5nZXRUaW1lPWZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCktdGhpcy5zdGFydH0sZS5wcm90b3R5cGUuaW5mbz1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllW3RdPWFyZ3VtZW50c1t0XTt0aGlzLmVuYWJsZWQmJiJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuY29uc29sZSYmImZ1bmN0aW9uIj09dHlwZW9mIGNvbnNvbGUuaW5mbyYmY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUscyhbdGhpcy5pZCx0aGlzLmdldFRpbWUoKSsibXMiXSxlKSl9LGUucHJvdG90eXBlLndhcm49ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dGhpcy5lbmFibGVkJiYoInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5jb25zb2xlJiYiZnVuY3Rpb24iPT10eXBlb2YgY29uc29sZS53YXJuP2NvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLHMoW3RoaXMuaWQsdGhpcy5nZXRUaW1lKCkrIm1zIl0sZSkpOnRoaXMuaW5mby5hcHBseSh0aGlzLGUpKX0sZS5wcm90b3R5cGUuZXJyb3I9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dGhpcy5lbmFibGVkJiYoInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5jb25zb2xlJiYiZnVuY3Rpb24iPT10eXBlb2YgY29uc29sZS5lcnJvcj9jb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUscyhbdGhpcy5pZCx0aGlzLmdldFRpbWUoKSsibXMiXSxlKSk6dGhpcy5pbmZvLmFwcGx5KHRoaXMsZSkpfSxlLmluc3RhbmNlcz17fSxlfSgpLHlpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LEEpe3ZhciByO3RoaXMud2luZG93Qm91bmRzPUEsdGhpcy5pbnN0YW5jZU5hbWU9IiMiK2UuaW5zdGFuY2VDb3VudCsrLHRoaXMubG9nZ2VyPW5ldyBCaSh7aWQ6dGhpcy5pbnN0YW5jZU5hbWUsZW5hYmxlZDp0LmxvZ2dpbmd9KSx0aGlzLmNhY2hlPW51bGwhPT0ocj10LmNhY2hlKSYmdm9pZCAwIT09cj9yOm5ldyBqcyh0aGlzLHQpfXJldHVybiBlLmluc3RhbmNlQ291bnQ9MSxlfSgpOyJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93JiZfcy5zZXRDb250ZXh0KHdpbmRvdyk7dmFyIHZpPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHIodm9pZCAwLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixzLGEsbCxjLHUsaCxkLGYscCxnLG0sdyxCLHksdixiLEMsXyxqLHgsRixRLFUsRSxTLEwsSSxOLGssSCxQLFQsTyxNLEQsUixLO3JldHVybiBuKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDppZighZXx8Im9iamVjdCIhPXR5cGVvZiBlKXJldHVyblsyLFByb21pc2UucmVqZWN0KCJJbnZhbGlkIGVsZW1lbnQgcHJvdmlkZWQgYXMgZmlyc3QgYXJndW1lbnQiKV07aWYoIShyPWUub3duZXJEb2N1bWVudCkpdGhyb3cgbmV3IEVycm9yKCJFbGVtZW50IGlzIG5vdCBhdHRhY2hlZCB0byBhIERvY3VtZW50Iik7aWYoIShzPXIuZGVmYXVsdFZpZXcpKXRocm93IG5ldyBFcnJvcigiRG9jdW1lbnQgaXMgbm90IGF0dGFjaGVkIHRvIGEgV2luZG93Iik7cmV0dXJuIGE9e2FsbG93VGFpbnQ6bnVsbCE9PShGPXQuYWxsb3dUYWludCkmJnZvaWQgMCE9PUYmJkYsaW1hZ2VUaW1lb3V0Om51bGwhPT0oUT10LmltYWdlVGltZW91dCkmJnZvaWQgMCE9PVE/UToxNWUzLHByb3h5OnQucHJveHksdXNlQ09SUzpudWxsIT09KFU9dC51c2VDT1JTKSYmdm9pZCAwIT09VSYmVX0sbD1BKHtsb2dnaW5nOm51bGw9PT0oRT10LmxvZ2dpbmcpfHx2b2lkIDA9PT1FfHxFLGNhY2hlOnQuY2FjaGV9LGEpLGM9e3dpbmRvd1dpZHRoOm51bGwhPT0oUz10LndpbmRvd1dpZHRoKSYmdm9pZCAwIT09Uz9TOnMuaW5uZXJXaWR0aCx3aW5kb3dIZWlnaHQ6bnVsbCE9PShMPXQud2luZG93SGVpZ2h0KSYmdm9pZCAwIT09TD9MOnMuaW5uZXJIZWlnaHQsc2Nyb2xsWDpudWxsIT09KEk9dC5zY3JvbGxYKSYmdm9pZCAwIT09ST9JOnMucGFnZVhPZmZzZXQsc2Nyb2xsWTpudWxsIT09KE49dC5zY3JvbGxZKSYmdm9pZCAwIT09Tj9OOnMucGFnZVlPZmZzZXR9LHU9bmV3IGkoYy5zY3JvbGxYLGMuc2Nyb2xsWSxjLndpbmRvd1dpZHRoLGMud2luZG93SGVpZ2h0KSxoPW5ldyB5aShsLHUpLGQ9bnVsbCE9PShrPXQuZm9yZWlnbk9iamVjdFJlbmRlcmluZykmJnZvaWQgMCE9PWsmJmssZj17YWxsb3dUYWludDpudWxsIT09KEg9dC5hbGxvd1RhaW50KSYmdm9pZCAwIT09SCYmSCxvbmNsb25lOnQub25jbG9uZSxpZ25vcmVFbGVtZW50czp0Lmlnbm9yZUVsZW1lbnRzLGlubGluZUltYWdlczpkLGNvcHlTdHlsZXM6ZH0saC5sb2dnZXIuZGVidWcoIlN0YXJ0aW5nIGRvY3VtZW50IGNsb25lIHdpdGggc2l6ZSAiK3Uud2lkdGgrIngiK3UuaGVpZ2h0KyIgc2Nyb2xsZWQgdG8gIistdS5sZWZ0KyIsIistdS50b3ApLHA9bmV3IGFzKGgsZSxmKSwoZz1wLmNsb25lZFJlZmVyZW5jZUVsZW1lbnQpP1s0LHAudG9JRnJhbWUocix1KV06WzIsUHJvbWlzZS5yZWplY3QoIlVuYWJsZSB0byBmaW5kIGVsZW1lbnQgaW4gY2xvbmVkIGlmcmFtZSIpXTtjYXNlIDE6cmV0dXJuIG09bi5zZW50KCksdz1IbihnKXx8IkhUTUwiPT09Zy50YWdOYW1lP2Z1bmN0aW9uKGUpe3ZhciB0PWUuYm9keSxBPWUuZG9jdW1lbnRFbGVtZW50O2lmKCF0fHwhQSl0aHJvdyBuZXcgRXJyb3IoIlVuYWJsZSB0byBnZXQgZG9jdW1lbnQgc2l6ZSIpO3ZhciByPU1hdGgubWF4KE1hdGgubWF4KHQuc2Nyb2xsV2lkdGgsQS5zY3JvbGxXaWR0aCksTWF0aC5tYXgodC5vZmZzZXRXaWR0aCxBLm9mZnNldFdpZHRoKSxNYXRoLm1heCh0LmNsaWVudFdpZHRoLEEuY2xpZW50V2lkdGgpKSxuPU1hdGgubWF4KE1hdGgubWF4KHQuc2Nyb2xsSGVpZ2h0LEEuc2Nyb2xsSGVpZ2h0KSxNYXRoLm1heCh0Lm9mZnNldEhlaWdodCxBLm9mZnNldEhlaWdodCksTWF0aC5tYXgodC5jbGllbnRIZWlnaHQsQS5jbGllbnRIZWlnaHQpKTtyZXR1cm4gbmV3IGkoMCwwLHIsbil9KGcub3duZXJEb2N1bWVudCk6byhoLGcpLEI9dy53aWR0aCx5PXcuaGVpZ2h0LHY9dy5sZWZ0LGI9dy50b3AsQz1iaShoLGcsdC5iYWNrZ3JvdW5kQ29sb3IpLF89e2NhbnZhczp0LmNhbnZhcyxiYWNrZ3JvdW5kQ29sb3I6QyxzY2FsZTpudWxsIT09KFQ9bnVsbCE9PShQPXQuc2NhbGUpJiZ2b2lkIDAhPT1QP1A6cy5kZXZpY2VQaXhlbFJhdGlvKSYmdm9pZCAwIT09VD9UOjEseDoobnVsbCE9PShPPXQueCkmJnZvaWQgMCE9PU8/TzowKSt2LHk6KG51bGwhPT0oTT10LnkpJiZ2b2lkIDAhPT1NP006MCkrYix3aWR0aDpudWxsIT09KEQ9dC53aWR0aCkmJnZvaWQgMCE9PUQ/RDpNYXRoLmNlaWwoQiksaGVpZ2h0Om51bGwhPT0oUj10LmhlaWdodCkmJnZvaWQgMCE9PVI/UjpNYXRoLmNlaWwoeSl9LGQ/KGgubG9nZ2VyLmRlYnVnKCJEb2N1bWVudCBjbG9uZWQsIHVzaW5nIGZvcmVpZ24gb2JqZWN0IHJlbmRlcmluZyIpLFs0LG5ldyBtaShoLF8pLnJlbmRlcihnKV0pOlszLDNdO2Nhc2UgMjpyZXR1cm4gaj1uLnNlbnQoKSxbMyw1XTtjYXNlIDM6cmV0dXJuIGgubG9nZ2VyLmRlYnVnKCJEb2N1bWVudCBjbG9uZWQsIGVsZW1lbnQgbG9jYXRlZCBhdCAiK3YrIiwiK2IrIiB3aXRoIHNpemUgIitCKyJ4Iit5KyIgdXNpbmcgY29tcHV0ZWQgcmVuZGVyaW5nIiksaC5sb2dnZXIuZGVidWcoIlN0YXJ0aW5nIERPTSBwYXJzaW5nIikseD1qbihoLGcpLEM9PT14LnN0eWxlcy5iYWNrZ3JvdW5kQ29sb3ImJih4LnN0eWxlcy5iYWNrZ3JvdW5kQ29sb3I9YnQuVFJBTlNQQVJFTlQpLGgubG9nZ2VyLmRlYnVnKCJTdGFydGluZyByZW5kZXJlciBmb3IgZWxlbWVudCBhdCAiK18ueCsiLCIrXy55KyIgd2l0aCBzaXplICIrXy53aWR0aCsieCIrXy5oZWlnaHQpLFs0LG5ldyB1aShoLF8pLnJlbmRlcih4KV07Y2FzZSA0Omo9bi5zZW50KCksbi5sYWJlbD01O2Nhc2UgNTpyZXR1cm4obnVsbD09PShLPXQucmVtb3ZlQ29udGFpbmVyKXx8dm9pZCAwPT09S3x8SykmJihhcy5kZXN0cm95KG0pfHxoLmxvZ2dlci5lcnJvcigiQ2Fubm90IGRldGFjaCBjbG9uZWQgaWZyYW1lIGFzIGl0IGlzIG5vdCBpbiB0aGUgRE9NIGFueW1vcmUiKSksaC5sb2dnZXIuZGVidWcoIkZpbmlzaGVkIHJlbmRlcmluZyIpLFsyLGpdfX0pfSl9LGJpPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcj10Lm93bmVyRG9jdW1lbnQsbj1yLmRvY3VtZW50RWxlbWVudD92dChlLGdldENvbXB1dGVkU3R5bGUoci5kb2N1bWVudEVsZW1lbnQpLmJhY2tncm91bmRDb2xvcik6YnQuVFJBTlNQQVJFTlQscz1yLmJvZHk/dnQoZSxnZXRDb21wdXRlZFN0eWxlKHIuYm9keSkuYmFja2dyb3VuZENvbG9yKTpidC5UUkFOU1BBUkVOVCxpPSJzdHJpbmciPT10eXBlb2YgQT92dChlLEEpOm51bGw9PT1BP2J0LlRSQU5TUEFSRU5UOjQyOTQ5NjcyOTU7cmV0dXJuIHQ9PT1yLmRvY3VtZW50RWxlbWVudD9kdChuKT9kdChzKT9pOnM6bjppfTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLHZpKGUsdCl9fSgpfSwiLi9ub2RlX21vZHVsZXMvaW9idWZmZXIvbGliLWVzbS9JT0J1ZmZlci5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtBLnIodCksQS5kKHQse0lPQnVmZmVyOmZ1bmN0aW9uKCl7cmV0dXJuIGl9fSk7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvaW9idWZmZXIvbGliLWVzbS90ZXh0LmpzIik7Y29uc3Qgbj0oKCk9Pntjb25zdCBlPW5ldyBVaW50OEFycmF5KDQpO3JldHVybiEoKG5ldyBVaW50MzJBcnJheShlLmJ1ZmZlcilbMF09MSkmZVswXSl9KSgpLHM9e2ludDg6Z2xvYmFsVGhpcy5JbnQ4QXJyYXksdWludDg6Z2xvYmFsVGhpcy5VaW50OEFycmF5LGludDE2Omdsb2JhbFRoaXMuSW50MTZBcnJheSx1aW50MTY6Z2xvYmFsVGhpcy5VaW50MTZBcnJheSxpbnQzMjpnbG9iYWxUaGlzLkludDMyQXJyYXksdWludDMyOmdsb2JhbFRoaXMuVWludDMyQXJyYXksdWludDY0Omdsb2JhbFRoaXMuQmlnVWludDY0QXJyYXksaW50NjQ6Z2xvYmFsVGhpcy5CaWdJbnQ2NEFycmF5LGZsb2F0MzI6Z2xvYmFsVGhpcy5GbG9hdDMyQXJyYXksZmxvYXQ2NDpnbG9iYWxUaGlzLkZsb2F0NjRBcnJheX07Y2xhc3MgaXtidWZmZXI7Ynl0ZUxlbmd0aDtieXRlT2Zmc2V0O2xlbmd0aDtvZmZzZXQ7bGFzdFdyaXR0ZW5CeXRlO2xpdHRsZUVuZGlhbjtfZGF0YTtfbWFyaztfbWFya3M7Y29uc3RydWN0b3IoZT04MTkyLHQ9e30pe2xldCBBPSExOyJudW1iZXIiPT10eXBlb2YgZT9lPW5ldyBBcnJheUJ1ZmZlcihlKTooQT0hMCx0aGlzLmxhc3RXcml0dGVuQnl0ZT1lLmJ5dGVMZW5ndGgpO2NvbnN0IHI9dC5vZmZzZXQ/dC5vZmZzZXQ+Pj4wOjAsbj1lLmJ5dGVMZW5ndGgtcjtsZXQgcz1yOyhBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fGUgaW5zdGFuY2VvZiBpKSYmKGUuYnl0ZUxlbmd0aCE9PWUuYnVmZmVyLmJ5dGVMZW5ndGgmJihzPWUuYnl0ZU9mZnNldCtyKSxlPWUuYnVmZmVyKSx0aGlzLmxhc3RXcml0dGVuQnl0ZT1BP246MCx0aGlzLmJ1ZmZlcj1lLHRoaXMubGVuZ3RoPW4sdGhpcy5ieXRlTGVuZ3RoPW4sdGhpcy5ieXRlT2Zmc2V0PXMsdGhpcy5vZmZzZXQ9MCx0aGlzLmxpdHRsZUVuZGlhbj0hMCx0aGlzLl9kYXRhPW5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlcixzLG4pLHRoaXMuX21hcms9MCx0aGlzLl9tYXJrcz1bXX1hdmFpbGFibGUoZT0xKXtyZXR1cm4gdGhpcy5vZmZzZXQrZTw9dGhpcy5sZW5ndGh9aXNMaXR0bGVFbmRpYW4oKXtyZXR1cm4gdGhpcy5saXR0bGVFbmRpYW59c2V0TGl0dGxlRW5kaWFuKCl7cmV0dXJuIHRoaXMubGl0dGxlRW5kaWFuPSEwLHRoaXN9aXNCaWdFbmRpYW4oKXtyZXR1cm4hdGhpcy5saXR0bGVFbmRpYW59c2V0QmlnRW5kaWFuKCl7cmV0dXJuIHRoaXMubGl0dGxlRW5kaWFuPSExLHRoaXN9c2tpcChlPTEpe3JldHVybiB0aGlzLm9mZnNldCs9ZSx0aGlzfWJhY2soZT0xKXtyZXR1cm4gdGhpcy5vZmZzZXQtPWUsdGhpc31zZWVrKGUpe3JldHVybiB0aGlzLm9mZnNldD1lLHRoaXN9bWFyaygpe3JldHVybiB0aGlzLl9tYXJrPXRoaXMub2Zmc2V0LHRoaXN9cmVzZXQoKXtyZXR1cm4gdGhpcy5vZmZzZXQ9dGhpcy5fbWFyayx0aGlzfXB1c2hNYXJrKCl7cmV0dXJuIHRoaXMuX21hcmtzLnB1c2godGhpcy5vZmZzZXQpLHRoaXN9cG9wTWFyaygpe2NvbnN0IGU9dGhpcy5fbWFya3MucG9wKCk7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoIk1hcmsgc3RhY2sgZW1wdHkiKTtyZXR1cm4gdGhpcy5zZWVrKGUpLHRoaXN9cmV3aW5kKCl7cmV0dXJuIHRoaXMub2Zmc2V0PTAsdGhpc31lbnN1cmVBdmFpbGFibGUoZT0xKXtpZighdGhpcy5hdmFpbGFibGUoZSkpe2NvbnN0IHQ9MioodGhpcy5vZmZzZXQrZSksQT1uZXcgVWludDhBcnJheSh0KTtBLnNldChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcikpLHRoaXMuYnVmZmVyPUEuYnVmZmVyLHRoaXMubGVuZ3RoPXQsdGhpcy5ieXRlTGVuZ3RoPXQsdGhpcy5fZGF0YT1uZXcgRGF0YVZpZXcodGhpcy5idWZmZXIpfXJldHVybiB0aGlzfXJlYWRCb29sZWFuKCl7cmV0dXJuIDAhPT10aGlzLnJlYWRVaW50OCgpfXJlYWRJbnQ4KCl7cmV0dXJuIHRoaXMuX2RhdGEuZ2V0SW50OCh0aGlzLm9mZnNldCsrKX1yZWFkVWludDgoKXtyZXR1cm4gdGhpcy5fZGF0YS5nZXRVaW50OCh0aGlzLm9mZnNldCsrKX1yZWFkQnl0ZSgpe3JldHVybiB0aGlzLnJlYWRVaW50OCgpfXJlYWRCeXRlcyhlPTEpe3JldHVybiB0aGlzLnJlYWRBcnJheShlLCJ1aW50OCIpfXJlYWRBcnJheShlLHQpe2NvbnN0IEE9c1t0XS5CWVRFU19QRVJfRUxFTUVOVCplLHI9dGhpcy5ieXRlT2Zmc2V0K3RoaXMub2Zmc2V0LGk9dGhpcy5idWZmZXIuc2xpY2UocixyK0EpO2lmKHRoaXMubGl0dGxlRW5kaWFuPT09biYmInVpbnQ4IiE9PXQmJiJpbnQ4IiE9PXQpe2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIuc2xpY2UocixyK0EpKTtlLnJldmVyc2UoKTtjb25zdCBuPW5ldyBzW3RdKGUuYnVmZmVyKTtyZXR1cm4gdGhpcy5vZmZzZXQrPUEsbi5yZXZlcnNlKCksbn1jb25zdCBvPW5ldyBzW3RdKGkpO3JldHVybiB0aGlzLm9mZnNldCs9QSxvfXJlYWRJbnQxNigpe2NvbnN0IGU9dGhpcy5fZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCx0aGlzLmxpdHRsZUVuZGlhbik7cmV0dXJuIHRoaXMub2Zmc2V0Kz0yLGV9cmVhZFVpbnQxNigpe2NvbnN0IGU9dGhpcy5fZGF0YS5nZXRVaW50MTYodGhpcy5vZmZzZXQsdGhpcy5saXR0bGVFbmRpYW4pO3JldHVybiB0aGlzLm9mZnNldCs9MixlfXJlYWRJbnQzMigpe2NvbnN0IGU9dGhpcy5fZGF0YS5nZXRJbnQzMih0aGlzLm9mZnNldCx0aGlzLmxpdHRsZUVuZGlhbik7cmV0dXJuIHRoaXMub2Zmc2V0Kz00LGV9cmVhZFVpbnQzMigpe2NvbnN0IGU9dGhpcy5fZGF0YS5nZXRVaW50MzIodGhpcy5vZmZzZXQsdGhpcy5saXR0bGVFbmRpYW4pO3JldHVybiB0aGlzLm9mZnNldCs9NCxlfXJlYWRGbG9hdDMyKCl7Y29uc3QgZT10aGlzLl9kYXRhLmdldEZsb2F0MzIodGhpcy5vZmZzZXQsdGhpcy5saXR0bGVFbmRpYW4pO3JldHVybiB0aGlzLm9mZnNldCs9NCxlfXJlYWRGbG9hdDY0KCl7Y29uc3QgZT10aGlzLl9kYXRhLmdldEZsb2F0NjQodGhpcy5vZmZzZXQsdGhpcy5saXR0bGVFbmRpYW4pO3JldHVybiB0aGlzLm9mZnNldCs9OCxlfXJlYWRCaWdJbnQ2NCgpe2NvbnN0IGU9dGhpcy5fZGF0YS5nZXRCaWdJbnQ2NCh0aGlzLm9mZnNldCx0aGlzLmxpdHRsZUVuZGlhbik7cmV0dXJuIHRoaXMub2Zmc2V0Kz04LGV9cmVhZEJpZ1VpbnQ2NCgpe2NvbnN0IGU9dGhpcy5fZGF0YS5nZXRCaWdVaW50NjQodGhpcy5vZmZzZXQsdGhpcy5saXR0bGVFbmRpYW4pO3JldHVybiB0aGlzLm9mZnNldCs9OCxlfXJlYWRDaGFyKCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSW50OCgpKX1yZWFkQ2hhcnMoZT0xKXtsZXQgdD0iIjtmb3IobGV0IEE9MDtBPGU7QSsrKXQrPXRoaXMucmVhZENoYXIoKTtyZXR1cm4gdH1yZWFkVXRmOChlPTEpe3JldHVybigwLHIuZGVjb2RlKSh0aGlzLnJlYWRCeXRlcyhlKSl9ZGVjb2RlVGV4dChlPTEsdD0idXRmOCIpe3JldHVybigwLHIuZGVjb2RlKSh0aGlzLnJlYWRCeXRlcyhlKSx0KX13cml0ZUJvb2xlYW4oZSl7cmV0dXJuIHRoaXMud3JpdGVVaW50OChlPzI1NTowKSx0aGlzfXdyaXRlSW50OChlKXtyZXR1cm4gdGhpcy5lbnN1cmVBdmFpbGFibGUoMSksdGhpcy5fZGF0YS5zZXRJbnQ4KHRoaXMub2Zmc2V0KyssZSksdGhpcy5fdXBkYXRlTGFzdFdyaXR0ZW5CeXRlKCksdGhpc313cml0ZVVpbnQ4KGUpe3JldHVybiB0aGlzLmVuc3VyZUF2YWlsYWJsZSgxKSx0aGlzLl9kYXRhLnNldFVpbnQ4KHRoaXMub2Zmc2V0KyssZSksdGhpcy5fdXBkYXRlTGFzdFdyaXR0ZW5CeXRlKCksdGhpc313cml0ZUJ5dGUoZSl7cmV0dXJuIHRoaXMud3JpdGVVaW50OChlKX13cml0ZUJ5dGVzKGUpe3RoaXMuZW5zdXJlQXZhaWxhYmxlKGUubGVuZ3RoKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl0aGlzLl9kYXRhLnNldFVpbnQ4KHRoaXMub2Zmc2V0KyssZVt0XSk7cmV0dXJuIHRoaXMuX3VwZGF0ZUxhc3RXcml0dGVuQnl0ZSgpLHRoaXN9d3JpdGVJbnQxNihlKXtyZXR1cm4gdGhpcy5lbnN1cmVBdmFpbGFibGUoMiksdGhpcy5fZGF0YS5zZXRJbnQxNih0aGlzLm9mZnNldCxlLHRoaXMubGl0dGxlRW5kaWFuKSx0aGlzLm9mZnNldCs9Mix0aGlzLl91cGRhdGVMYXN0V3JpdHRlbkJ5dGUoKSx0aGlzfXdyaXRlVWludDE2KGUpe3JldHVybiB0aGlzLmVuc3VyZUF2YWlsYWJsZSgyKSx0aGlzLl9kYXRhLnNldFVpbnQxNih0aGlzLm9mZnNldCxlLHRoaXMubGl0dGxlRW5kaWFuKSx0aGlzLm9mZnNldCs9Mix0aGlzLl91cGRhdGVMYXN0V3JpdHRlbkJ5dGUoKSx0aGlzfXdyaXRlSW50MzIoZSl7cmV0dXJuIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDQpLHRoaXMuX2RhdGEuc2V0SW50MzIodGhpcy5vZmZzZXQsZSx0aGlzLmxpdHRsZUVuZGlhbiksdGhpcy5vZmZzZXQrPTQsdGhpcy5fdXBkYXRlTGFzdFdyaXR0ZW5CeXRlKCksdGhpc313cml0ZVVpbnQzMihlKXtyZXR1cm4gdGhpcy5lbnN1cmVBdmFpbGFibGUoNCksdGhpcy5fZGF0YS5zZXRVaW50MzIodGhpcy5vZmZzZXQsZSx0aGlzLmxpdHRsZUVuZGlhbiksdGhpcy5vZmZzZXQrPTQsdGhpcy5fdXBkYXRlTGFzdFdyaXR0ZW5CeXRlKCksdGhpc313cml0ZUZsb2F0MzIoZSl7cmV0dXJuIHRoaXMuZW5zdXJlQXZhaWxhYmxlKDQpLHRoaXMuX2RhdGEuc2V0RmxvYXQzMih0aGlzLm9mZnNldCxlLHRoaXMubGl0dGxlRW5kaWFuKSx0aGlzLm9mZnNldCs9NCx0aGlzLl91cGRhdGVMYXN0V3JpdHRlbkJ5dGUoKSx0aGlzfXdyaXRlRmxvYXQ2NChlKXtyZXR1cm4gdGhpcy5lbnN1cmVBdmFpbGFibGUoOCksdGhpcy5fZGF0YS5zZXRGbG9hdDY0KHRoaXMub2Zmc2V0LGUsdGhpcy5saXR0bGVFbmRpYW4pLHRoaXMub2Zmc2V0Kz04LHRoaXMuX3VwZGF0ZUxhc3RXcml0dGVuQnl0ZSgpLHRoaXN9d3JpdGVCaWdJbnQ2NChlKXtyZXR1cm4gdGhpcy5lbnN1cmVBdmFpbGFibGUoOCksdGhpcy5fZGF0YS5zZXRCaWdJbnQ2NCh0aGlzLm9mZnNldCxlLHRoaXMubGl0dGxlRW5kaWFuKSx0aGlzLm9mZnNldCs9OCx0aGlzLl91cGRhdGVMYXN0V3JpdHRlbkJ5dGUoKSx0aGlzfXdyaXRlQmlnVWludDY0KGUpe3JldHVybiB0aGlzLmVuc3VyZUF2YWlsYWJsZSg4KSx0aGlzLl9kYXRhLnNldEJpZ1VpbnQ2NCh0aGlzLm9mZnNldCxlLHRoaXMubGl0dGxlRW5kaWFuKSx0aGlzLm9mZnNldCs9OCx0aGlzLl91cGRhdGVMYXN0V3JpdHRlbkJ5dGUoKSx0aGlzfXdyaXRlQ2hhcihlKXtyZXR1cm4gdGhpcy53cml0ZVVpbnQ4KGUuY2hhckNvZGVBdCgwKSl9d3JpdGVDaGFycyhlKXtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl0aGlzLndyaXRlVWludDgoZS5jaGFyQ29kZUF0KHQpKTtyZXR1cm4gdGhpc313cml0ZVV0ZjgoZSl7cmV0dXJuIHRoaXMud3JpdGVCeXRlcygoMCxyLmVuY29kZSkoZSkpfXRvQXJyYXkoKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsdGhpcy5ieXRlT2Zmc2V0LHRoaXMubGFzdFdyaXR0ZW5CeXRlKX1nZXRXcml0dGVuQnl0ZUxlbmd0aCgpe3JldHVybiB0aGlzLmxhc3RXcml0dGVuQnl0ZS10aGlzLmJ5dGVPZmZzZXR9X3VwZGF0ZUxhc3RXcml0dGVuQnl0ZSgpe3RoaXMub2Zmc2V0PnRoaXMubGFzdFdyaXR0ZW5CeXRlJiYodGhpcy5sYXN0V3JpdHRlbkJ5dGU9dGhpcy5vZmZzZXQpfX19LCIuL25vZGVfbW9kdWxlcy9pb2J1ZmZlci9saWItZXNtL3RleHQuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlLHQ9InV0ZjgiKXtyZXR1cm4gbmV3IFRleHREZWNvZGVyKHQpLmRlY29kZShlKX1BLnIodCksQS5kKHQse2RlY29kZTpmdW5jdGlvbigpe3JldHVybiByfSxlbmNvZGU6ZnVuY3Rpb24oKXtyZXR1cm4gc319KTtjb25zdCBuPW5ldyBUZXh0RW5jb2RlcjtmdW5jdGlvbiBzKGUpe3JldHVybiBuLmVuY29kZShlKX19LCIuL25vZGVfbW9kdWxlcy9qc3BkZi9kaXN0L2pzcGRmLmVzLm1pbi5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtBLnIodCksQS5kKHQse0Fjcm9Gb3JtOmZ1bmN0aW9uKCl7cmV0dXJuIFVlfSxBY3JvRm9ybUFwcGVhcmFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gamV9LEFjcm9Gb3JtQnV0dG9uOmZ1bmN0aW9uKCl7cmV0dXJuIHdlfSxBY3JvRm9ybUNoZWNrQm94OmZ1bmN0aW9uKCl7cmV0dXJuIGJlfSxBY3JvRm9ybUNob2ljZUZpZWxkOmZ1bmN0aW9uKCl7cmV0dXJuIGZlfSxBY3JvRm9ybUNvbWJvQm94OmZ1bmN0aW9uKCl7cmV0dXJuIGdlfSxBY3JvRm9ybUVkaXRCb3g6ZnVuY3Rpb24oKXtyZXR1cm4gbWV9LEFjcm9Gb3JtTGlzdEJveDpmdW5jdGlvbigpe3JldHVybiBwZX0sQWNyb0Zvcm1QYXNzd29yZEZpZWxkOmZ1bmN0aW9uKCl7cmV0dXJuIF9lfSxBY3JvRm9ybVB1c2hCdXR0b246ZnVuY3Rpb24oKXtyZXR1cm4gQmV9LEFjcm9Gb3JtUmFkaW9CdXR0b246ZnVuY3Rpb24oKXtyZXR1cm4geWV9LEFjcm9Gb3JtVGV4dEZpZWxkOmZ1bmN0aW9uKCl7cmV0dXJuIENlfSxHU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gSH0sU2hhZGluZ1BhdHRlcm46ZnVuY3Rpb24oKXtyZXR1cm4gVH0sVGlsaW5nUGF0dGVybjpmdW5jdGlvbigpe3JldHVybiBPfSxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIE19LGpzUERGOmZ1bmN0aW9uKCl7cmV0dXJuIE19fSk7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiksbj1BKCIuL25vZGVfbW9kdWxlcy9mZmxhdGUvZXNtL2Jyb3dzZXIuanMiKSxzPUEoIi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanMiKSxpPUEoIi4vbm9kZV9tb2R1bGVzL2Zhc3QtcG5nL2xpYi1lc20vaW5kZXguanMiKSxvPWZ1bmN0aW9uKCl7cmV0dXJuInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OiJ1bmRlZmluZWQiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDoidW5kZWZpbmVkIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzfSgpO2Z1bmN0aW9uIGEoKXtvLmNvbnNvbGUmJiJmdW5jdGlvbiI9PXR5cGVvZiBvLmNvbnNvbGUubG9nJiZvLmNvbnNvbGUubG9nLmFwcGx5KG8uY29uc29sZSxhcmd1bWVudHMpfXZhciBsPXtsb2c6YSx3YXJuOmZ1bmN0aW9uKGUpe28uY29uc29sZSYmKCJmdW5jdGlvbiI9PXR5cGVvZiBvLmNvbnNvbGUud2Fybj9vLmNvbnNvbGUud2Fybi5hcHBseShvLmNvbnNvbGUsYXJndW1lbnRzKTphLmNhbGwobnVsbCxhcmd1bWVudHMpKX0sZXJyb3I6ZnVuY3Rpb24oZSl7by5jb25zb2xlJiYoImZ1bmN0aW9uIj09dHlwZW9mIG8uY29uc29sZS5lcnJvcj9vLmNvbnNvbGUuZXJyb3IuYXBwbHkoby5jb25zb2xlLGFyZ3VtZW50cyk6YShlKSl9fTtmdW5jdGlvbiBjKGUsdCxBKXt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKCJHRVQiLGUpLHIucmVzcG9uc2VUeXBlPSJibG9iIixyLm9ubG9hZD1mdW5jdGlvbigpe2Qoci5yZXNwb25zZSx0LEEpfSxyLm9uZXJyb3I9ZnVuY3Rpb24oKXtsLmVycm9yKCJjb3VsZCBub3QgZG93bmxvYWQgZmlsZSIpfSxyLnNlbmQoKX1mdW5jdGlvbiB1KGUpe3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDt0Lm9wZW4oIkhFQUQiLGUsITEpO3RyeXt0LnNlbmQoKX1jYXRjaChlKXt9cmV0dXJuIHQuc3RhdHVzPj0yMDAmJnQuc3RhdHVzPD0yOTl9ZnVuY3Rpb24gaChlKXt0cnl7ZS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCJjbGljayIpKX1jYXRjaChBKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFdmVudCgiTW91c2VFdmVudHMiKTt0LmluaXRNb3VzZUV2ZW50KCJjbGljayIsITAsITAsd2luZG93LDAsMCwwLDgwLDIwLCExLCExLCExLCExLDAsbnVsbCksZS5kaXNwYXRjaEV2ZW50KHQpfX12YXIgZD1vLnNhdmVBc3x8KCJvYmplY3QiIT09KCJ1bmRlZmluZWQiPT10eXBlb2Ygd2luZG93PyJ1bmRlZmluZWQiOigwLHIuZGVmYXVsdCkod2luZG93KSl8fHdpbmRvdyE9PW8/ZnVuY3Rpb24oKXt9OiJ1bmRlZmluZWQiIT10eXBlb2YgSFRNTEFuY2hvckVsZW1lbnQmJiJkb3dubG9hZCJpbiBIVE1MQW5jaG9yRWxlbWVudC5wcm90b3R5cGU/ZnVuY3Rpb24oZSx0LEEpe3ZhciByPW8uVVJMfHxvLndlYmtpdFVSTCxuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKTt0PXR8fGUubmFtZXx8ImRvd25sb2FkIixuLmRvd25sb2FkPXQsbi5yZWw9Im5vb3BlbmVyIiwic3RyaW5nIj09dHlwZW9mIGU/KG4uaHJlZj1lLG4ub3JpZ2luIT09bG9jYXRpb24ub3JpZ2luP3Uobi5ocmVmKT9jKGUsdCxBKTpoKG4sbi50YXJnZXQ9Il9ibGFuayIpOmgobikpOihuLmhyZWY9ci5jcmVhdGVPYmplY3RVUkwoZSksc2V0VGltZW91dChmdW5jdGlvbigpe3IucmV2b2tlT2JqZWN0VVJMKG4uaHJlZil9LDRlNCksc2V0VGltZW91dChmdW5jdGlvbigpe2gobil9LDApKX06Im1zU2F2ZU9yT3BlbkJsb2IiaW4gbmF2aWdhdG9yP2Z1bmN0aW9uKGUsdCxBKXtpZih0PXR8fGUubmFtZXx8ImRvd25sb2FkIiwic3RyaW5nIj09dHlwZW9mIGUpaWYodShlKSljKGUsdCxBKTtlbHNle3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKTtuLmhyZWY9ZSxuLnRhcmdldD0iX2JsYW5rIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aChuKX0pfWVsc2UgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dD90PXthdXRvQm9tOiExfToib2JqZWN0IiE9PSgwLHIuZGVmYXVsdCkodCkmJihsLndhcm4oIkRlcHJlY2F0ZWQ6IEV4cGVjdGVkIHRoaXJkIGFyZ3VtZW50IHRvIGJlIGEgb2JqZWN0IiksdD17YXV0b0JvbTohdH0pLHQuYXV0b0JvbSYmL15ccyooPzp0ZXh0XC9cUyp8YXBwbGljYXRpb25cL3htbHxcUypcL1xTKlwreG1sKVxzKjsuKmNoYXJzZXRccyo9XHMqdXRmLTgvaS50ZXN0KGUudHlwZSk/bmV3IEJsb2IoW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUyNzkpLGVdLHt0eXBlOmUudHlwZX0pOmV9KGUsQSksdCl9OmZ1bmN0aW9uKGUsdCxBLG4pe2lmKChuPW58fG9wZW4oIiIsIl9ibGFuayIpKSYmKG4uZG9jdW1lbnQudGl0bGU9bi5kb2N1bWVudC5ib2R5LmlubmVyVGV4dD0iZG93bmxvYWRpbmcuLi4iKSwic3RyaW5nIj09dHlwZW9mIGUpcmV0dXJuIGMoZSx0LEEpO3ZhciBzPSJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0iPT09ZS50eXBlLGk9L2NvbnN0cnVjdG9yL2kudGVzdChvLkhUTUxFbGVtZW50KXx8by5zYWZhcmksYT0vQ3JpT1NcL1tcZF0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO2lmKChhfHxzJiZpKSYmIm9iamVjdCI9PT0oInVuZGVmaW5lZCI9PXR5cGVvZiBGaWxlUmVhZGVyPyJ1bmRlZmluZWQiOigwLHIuZGVmYXVsdCkoRmlsZVJlYWRlcikpKXt2YXIgbD1uZXcgRmlsZVJlYWRlcjtsLm9ubG9hZGVuZD1mdW5jdGlvbigpe3ZhciBlPWwucmVzdWx0O2U9YT9lOmUucmVwbGFjZSgvXmRhdGE6W147XSo7LywiZGF0YTphdHRhY2htZW50L2ZpbGU7Iiksbj9uLmxvY2F0aW9uLmhyZWY9ZTpsb2NhdGlvbj1lLG49bnVsbH0sbC5yZWFkQXNEYXRhVVJMKGUpfWVsc2V7dmFyIHU9by5VUkx8fG8ud2Via2l0VVJMLGg9dS5jcmVhdGVPYmplY3RVUkwoZSk7bj9uLmxvY2F0aW9uPWg6bG9jYXRpb24uaHJlZj1oLG49bnVsbCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dS5yZXZva2VPYmplY3RVUkwoaCl9LDRlNCl9fSk7ZnVuY3Rpb24gZihlKXt2YXIgdDtlPWV8fCIiLHRoaXMub2s9ITEsIiMiPT1lLmNoYXJBdCgwKSYmKGU9ZS5zdWJzdHIoMSw2KSksZT17YWxpY2VibHVlOiJmMGY4ZmYiLGFudGlxdWV3aGl0ZToiZmFlYmQ3IixhcXVhOiIwMGZmZmYiLGFxdWFtYXJpbmU6IjdmZmZkNCIsYXp1cmU6ImYwZmZmZiIsYmVpZ2U6ImY1ZjVkYyIsYmlzcXVlOiJmZmU0YzQiLGJsYWNrOiIwMDAwMDAiLGJsYW5jaGVkYWxtb25kOiJmZmViY2QiLGJsdWU6IjAwMDBmZiIsYmx1ZXZpb2xldDoiOGEyYmUyIixicm93bjoiYTUyYTJhIixidXJseXdvb2Q6ImRlYjg4NyIsY2FkZXRibHVlOiI1ZjllYTAiLGNoYXJ0cmV1c2U6IjdmZmYwMCIsY2hvY29sYXRlOiJkMjY5MWUiLGNvcmFsOiJmZjdmNTAiLGNvcm5mbG93ZXJibHVlOiI2NDk1ZWQiLGNvcm5zaWxrOiJmZmY4ZGMiLGNyaW1zb246ImRjMTQzYyIsY3lhbjoiMDBmZmZmIixkYXJrYmx1ZToiMDAwMDhiIixkYXJrY3lhbjoiMDA4YjhiIixkYXJrZ29sZGVucm9kOiJiODg2MGIiLGRhcmtncmF5OiJhOWE5YTkiLGRhcmtncmVlbjoiMDA2NDAwIixkYXJra2hha2k6ImJkYjc2YiIsZGFya21hZ2VudGE6IjhiMDA4YiIsZGFya29saXZlZ3JlZW46IjU1NmIyZiIsZGFya29yYW5nZToiZmY4YzAwIixkYXJrb3JjaGlkOiI5OTMyY2MiLGRhcmtyZWQ6IjhiMDAwMCIsZGFya3NhbG1vbjoiZTk5NjdhIixkYXJrc2VhZ3JlZW46IjhmYmM4ZiIsZGFya3NsYXRlYmx1ZToiNDgzZDhiIixkYXJrc2xhdGVncmF5OiIyZjRmNGYiLGRhcmt0dXJxdW9pc2U6IjAwY2VkMSIsZGFya3Zpb2xldDoiOTQwMGQzIixkZWVwcGluazoiZmYxNDkzIixkZWVwc2t5Ymx1ZToiMDBiZmZmIixkaW1ncmF5OiI2OTY5NjkiLGRvZGdlcmJsdWU6IjFlOTBmZiIsZmVsZHNwYXI6ImQxOTI3NSIsZmlyZWJyaWNrOiJiMjIyMjIiLGZsb3JhbHdoaXRlOiJmZmZhZjAiLGZvcmVzdGdyZWVuOiIyMjhiMjIiLGZ1Y2hzaWE6ImZmMDBmZiIsZ2FpbnNib3JvOiJkY2RjZGMiLGdob3N0d2hpdGU6ImY4ZjhmZiIsZ29sZDoiZmZkNzAwIixnb2xkZW5yb2Q6ImRhYTUyMCIsZ3JheToiODA4MDgwIixncmVlbjoiMDA4MDAwIixncmVlbnllbGxvdzoiYWRmZjJmIixob25leWRldzoiZjBmZmYwIixob3RwaW5rOiJmZjY5YjQiLGluZGlhbnJlZDoiY2Q1YzVjIixpbmRpZ286IjRiMDA4MiIsaXZvcnk6ImZmZmZmMCIsa2hha2k6ImYwZTY4YyIsbGF2ZW5kZXI6ImU2ZTZmYSIsbGF2ZW5kZXJibHVzaDoiZmZmMGY1IixsYXduZ3JlZW46IjdjZmMwMCIsbGVtb25jaGlmZm9uOiJmZmZhY2QiLGxpZ2h0Ymx1ZToiYWRkOGU2IixsaWdodGNvcmFsOiJmMDgwODAiLGxpZ2h0Y3lhbjoiZTBmZmZmIixsaWdodGdvbGRlbnJvZHllbGxvdzoiZmFmYWQyIixsaWdodGdyZXk6ImQzZDNkMyIsbGlnaHRncmVlbjoiOTBlZTkwIixsaWdodHBpbms6ImZmYjZjMSIsbGlnaHRzYWxtb246ImZmYTA3YSIsbGlnaHRzZWFncmVlbjoiMjBiMmFhIixsaWdodHNreWJsdWU6Ijg3Y2VmYSIsbGlnaHRzbGF0ZWJsdWU6Ijg0NzBmZiIsbGlnaHRzbGF0ZWdyYXk6Ijc3ODg5OSIsbGlnaHRzdGVlbGJsdWU6ImIwYzRkZSIsbGlnaHR5ZWxsb3c6ImZmZmZlMCIsbGltZToiMDBmZjAwIixsaW1lZ3JlZW46IjMyY2QzMiIsbGluZW46ImZhZjBlNiIsbWFnZW50YToiZmYwMGZmIixtYXJvb246IjgwMDAwMCIsbWVkaXVtYXF1YW1hcmluZToiNjZjZGFhIixtZWRpdW1ibHVlOiIwMDAwY2QiLG1lZGl1bW9yY2hpZDoiYmE1NWQzIixtZWRpdW1wdXJwbGU6IjkzNzBkOCIsbWVkaXVtc2VhZ3JlZW46IjNjYjM3MSIsbWVkaXVtc2xhdGVibHVlOiI3YjY4ZWUiLG1lZGl1bXNwcmluZ2dyZWVuOiIwMGZhOWEiLG1lZGl1bXR1cnF1b2lzZToiNDhkMWNjIixtZWRpdW12aW9sZXRyZWQ6ImM3MTU4NSIsbWlkbmlnaHRibHVlOiIxOTE5NzAiLG1pbnRjcmVhbToiZjVmZmZhIixtaXN0eXJvc2U6ImZmZTRlMSIsbW9jY2FzaW46ImZmZTRiNSIsbmF2YWpvd2hpdGU6ImZmZGVhZCIsbmF2eToiMDAwMDgwIixvbGRsYWNlOiJmZGY1ZTYiLG9saXZlOiI4MDgwMDAiLG9saXZlZHJhYjoiNmI4ZTIzIixvcmFuZ2U6ImZmYTUwMCIsb3JhbmdlcmVkOiJmZjQ1MDAiLG9yY2hpZDoiZGE3MGQ2IixwYWxlZ29sZGVucm9kOiJlZWU4YWEiLHBhbGVncmVlbjoiOThmYjk4IixwYWxldHVycXVvaXNlOiJhZmVlZWUiLHBhbGV2aW9sZXRyZWQ6ImQ4NzA5MyIscGFwYXlhd2hpcDoiZmZlZmQ1IixwZWFjaHB1ZmY6ImZmZGFiOSIscGVydToiY2Q4NTNmIixwaW5rOiJmZmMwY2IiLHBsdW06ImRkYTBkZCIscG93ZGVyYmx1ZToiYjBlMGU2IixwdXJwbGU6IjgwMDA4MCIscmVkOiJmZjAwMDAiLHJvc3licm93bjoiYmM4ZjhmIixyb3lhbGJsdWU6IjQxNjllMSIsc2FkZGxlYnJvd246IjhiNDUxMyIsc2FsbW9uOiJmYTgwNzIiLHNhbmR5YnJvd246ImY0YTQ2MCIsc2VhZ3JlZW46IjJlOGI1NyIsc2Vhc2hlbGw6ImZmZjVlZSIsc2llbm5hOiJhMDUyMmQiLHNpbHZlcjoiYzBjMGMwIixza3libHVlOiI4N2NlZWIiLHNsYXRlYmx1ZToiNmE1YWNkIixzbGF0ZWdyYXk6IjcwODA5MCIsc25vdzoiZmZmYWZhIixzcHJpbmdncmVlbjoiMDBmZjdmIixzdGVlbGJsdWU6IjQ2ODJiNCIsdGFuOiJkMmI0OGMiLHRlYWw6IjAwODA4MCIsdGhpc3RsZToiZDhiZmQ4Iix0b21hdG86ImZmNjM0NyIsdHVycXVvaXNlOiI0MGUwZDAiLHZpb2xldDoiZWU4MmVlIix2aW9sZXRyZWQ6ImQwMjA5MCIsd2hlYXQ6ImY1ZGViMyIsd2hpdGU6ImZmZmZmZiIsd2hpdGVzbW9rZToiZjVmNWY1Iix5ZWxsb3c6ImZmZmYwMCIseWVsbG93Z3JlZW46IjlhY2QzMiJ9W2U9KGU9ZS5yZXBsYWNlKC8gL2csIiIpKS50b0xvd2VyQ2FzZSgpXXx8ZTtmb3IodmFyIEE9W3tyZTovXnJnYlwoKFxkezEsM30pLFxzKihcZHsxLDN9KSxccyooXGR7MSwzfSlcKSQvLGV4YW1wbGU6WyJyZ2IoMTIzLCAyMzQsIDQ1KSIsInJnYigyNTUsMjM0LDI0NSkiXSxwcm9jZXNzOmZ1bmN0aW9uKGUpe3JldHVybltwYXJzZUludChlWzFdKSxwYXJzZUludChlWzJdKSxwYXJzZUludChlWzNdKV19fSx7cmU6L14oXHd7Mn0pKFx3ezJ9KShcd3syfSkkLyxleGFtcGxlOlsiIzAwZmYwMCIsIjMzNjY5OSJdLHByb2Nlc3M6ZnVuY3Rpb24oZSl7cmV0dXJuW3BhcnNlSW50KGVbMV0sMTYpLHBhcnNlSW50KGVbMl0sMTYpLHBhcnNlSW50KGVbM10sMTYpXX19LHtyZTovXihcd3sxfSkoXHd7MX0pKFx3ezF9KSQvLGV4YW1wbGU6WyIjZmIwIiwiZjBmIl0scHJvY2VzczpmdW5jdGlvbihlKXtyZXR1cm5bcGFyc2VJbnQoZVsxXStlWzFdLDE2KSxwYXJzZUludChlWzJdK2VbMl0sMTYpLHBhcnNlSW50KGVbM10rZVszXSwxNildfX1dLHI9MDtyPEEubGVuZ3RoO3IrKyl7dmFyIG49QVtyXS5yZSxzPUFbcl0ucHJvY2VzcyxpPW4uZXhlYyhlKTtpJiYodD1zKGkpLHRoaXMucj10WzBdLHRoaXMuZz10WzFdLHRoaXMuYj10WzJdLHRoaXMub2s9ITApfXRoaXMucj10aGlzLnI8MHx8aXNOYU4odGhpcy5yKT8wOnRoaXMucj4yNTU/MjU1OnRoaXMucix0aGlzLmc9dGhpcy5nPDB8fGlzTmFOKHRoaXMuZyk/MDp0aGlzLmc+MjU1PzI1NTp0aGlzLmcsdGhpcy5iPXRoaXMuYjwwfHxpc05hTih0aGlzLmIpPzA6dGhpcy5iPjI1NT8yNTU6dGhpcy5iLHRoaXMudG9SR0I9ZnVuY3Rpb24oKXtyZXR1cm4icmdiKCIrdGhpcy5yKyIsICIrdGhpcy5nKyIsICIrdGhpcy5iKyIpIn0sdGhpcy50b0hleD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuci50b1N0cmluZygxNiksdD10aGlzLmcudG9TdHJpbmcoMTYpLEE9dGhpcy5iLnRvU3RyaW5nKDE2KTtyZXR1cm4gMT09ZS5sZW5ndGgmJihlPSIwIitlKSwxPT10Lmxlbmd0aCYmKHQ9IjAiK3QpLDE9PUEubGVuZ3RoJiYoQT0iMCIrQSksIiMiK2UrdCtBfX12YXIgcD1vLmF0b2IuYmluZChvKSxnPW8uYnRvYS5iaW5kKG8pO2Z1bmN0aW9uIG0oZSx0KXt2YXIgQT1lWzBdLHI9ZVsxXSxuPWVbMl0scz1lWzNdO0E9QihBLHIsbixzLHRbMF0sNywtNjgwODc2OTM2KSxzPUIocyxBLHIsbix0WzFdLDEyLC0zODk1NjQ1ODYpLG49QihuLHMsQSxyLHRbMl0sMTcsNjA2MTA1ODE5KSxyPUIocixuLHMsQSx0WzNdLDIyLC0xMDQ0NTI1MzMwKSxBPUIoQSxyLG4scyx0WzRdLDcsLTE3NjQxODg5Nykscz1CKHMsQSxyLG4sdFs1XSwxMiwxMjAwMDgwNDI2KSxuPUIobixzLEEscix0WzZdLDE3LC0xNDczMjMxMzQxKSxyPUIocixuLHMsQSx0WzddLDIyLC00NTcwNTk4MyksQT1CKEEscixuLHMsdFs4XSw3LDE3NzAwMzU0MTYpLHM9QihzLEEscixuLHRbOV0sMTIsLTE5NTg0MTQ0MTcpLG49QihuLHMsQSxyLHRbMTBdLDE3LC00MjA2Mykscj1CKHIsbixzLEEsdFsxMV0sMjIsLTE5OTA0MDQxNjIpLEE9QihBLHIsbixzLHRbMTJdLDcsMTgwNDYwMzY4Mikscz1CKHMsQSxyLG4sdFsxM10sMTIsLTQwMzQxMTAxKSxuPUIobixzLEEscix0WzE0XSwxNywtMTUwMjAwMjI5MCksQT15KEEscj1CKHIsbixzLEEsdFsxNV0sMjIsMTIzNjUzNTMyOSksbixzLHRbMV0sNSwtMTY1Nzk2NTEwKSxzPXkocyxBLHIsbix0WzZdLDksLTEwNjk1MDE2MzIpLG49eShuLHMsQSxyLHRbMTFdLDE0LDY0MzcxNzcxMykscj15KHIsbixzLEEsdFswXSwyMCwtMzczODk3MzAyKSxBPXkoQSxyLG4scyx0WzVdLDUsLTcwMTU1ODY5MSkscz15KHMsQSxyLG4sdFsxMF0sOSwzODAxNjA4Myksbj15KG4scyxBLHIsdFsxNV0sMTQsLTY2MDQ3ODMzNSkscj15KHIsbixzLEEsdFs0XSwyMCwtNDA1NTM3ODQ4KSxBPXkoQSxyLG4scyx0WzldLDUsNTY4NDQ2NDM4KSxzPXkocyxBLHIsbix0WzE0XSw5LC0xMDE5ODAzNjkwKSxuPXkobixzLEEscix0WzNdLDE0LC0xODczNjM5NjEpLHI9eShyLG4scyxBLHRbOF0sMjAsMTE2MzUzMTUwMSksQT15KEEscixuLHMsdFsxM10sNSwtMTQ0NDY4MTQ2Nykscz15KHMsQSxyLG4sdFsyXSw5LC01MTQwMzc4NCksbj15KG4scyxBLHIsdFs3XSwxNCwxNzM1MzI4NDczKSxBPXYoQSxyPXkocixuLHMsQSx0WzEyXSwyMCwtMTkyNjYwNzczNCksbixzLHRbNV0sNCwtMzc4NTU4KSxzPXYocyxBLHIsbix0WzhdLDExLC0yMDIyNTc0NDYzKSxuPXYobixzLEEscix0WzExXSwxNiwxODM5MDMwNTYyKSxyPXYocixuLHMsQSx0WzE0XSwyMywtMzUzMDk1NTYpLEE9dihBLHIsbixzLHRbMV0sNCwtMTUzMDk5MjA2MCkscz12KHMsQSxyLG4sdFs0XSwxMSwxMjcyODkzMzUzKSxuPXYobixzLEEscix0WzddLDE2LC0xNTU0OTc2MzIpLHI9dihyLG4scyxBLHRbMTBdLDIzLC0xMDk0NzMwNjQwKSxBPXYoQSxyLG4scyx0WzEzXSw0LDY4MTI3OTE3NCkscz12KHMsQSxyLG4sdFswXSwxMSwtMzU4NTM3MjIyKSxuPXYobixzLEEscix0WzNdLDE2LC03MjI1MjE5NzkpLHI9dihyLG4scyxBLHRbNl0sMjMsNzYwMjkxODkpLEE9dihBLHIsbixzLHRbOV0sNCwtNjQwMzY0NDg3KSxzPXYocyxBLHIsbix0WzEyXSwxMSwtNDIxODE1ODM1KSxuPXYobixzLEEscix0WzE1XSwxNiw1MzA3NDI1MjApLEE9YihBLHI9dihyLG4scyxBLHRbMl0sMjMsLTk5NTMzODY1MSksbixzLHRbMF0sNiwtMTk4NjMwODQ0KSxzPWIocyxBLHIsbix0WzddLDEwLDExMjY4OTE0MTUpLG49YihuLHMsQSxyLHRbMTRdLDE1LC0xNDE2MzU0OTA1KSxyPWIocixuLHMsQSx0WzVdLDIxLC01NzQzNDA1NSksQT1iKEEscixuLHMsdFsxMl0sNiwxNzAwNDg1NTcxKSxzPWIocyxBLHIsbix0WzNdLDEwLC0xODk0OTg2NjA2KSxuPWIobixzLEEscix0WzEwXSwxNSwtMTA1MTUyMykscj1iKHIsbixzLEEsdFsxXSwyMSwtMjA1NDkyMjc5OSksQT1iKEEscixuLHMsdFs4XSw2LDE4NzMzMTMzNTkpLHM9YihzLEEscixuLHRbMTVdLDEwLC0zMDYxMTc0NCksbj1iKG4scyxBLHIsdFs2XSwxNSwtMTU2MDE5ODM4MCkscj1iKHIsbixzLEEsdFsxM10sMjEsMTMwOTE1MTY0OSksQT1iKEEscixuLHMsdFs0XSw2LC0xNDU1MjMwNzApLHM9YihzLEEscixuLHRbMTFdLDEwLC0xMTIwMjEwMzc5KSxuPWIobixzLEEscix0WzJdLDE1LDcxODc4NzI1OSkscj1iKHIsbixzLEEsdFs5XSwyMSwtMzQzNDg1NTUxKSxlWzBdPUUoQSxlWzBdKSxlWzFdPUUocixlWzFdKSxlWzJdPUUobixlWzJdKSxlWzNdPUUocyxlWzNdKX1mdW5jdGlvbiB3KGUsdCxBLHIsbixzKXtyZXR1cm4gdD1FKEUodCxlKSxFKHIscykpLEUodDw8bnx0Pj4+MzItbixBKX1mdW5jdGlvbiBCKGUsdCxBLHIsbixzLGkpe3JldHVybiB3KHQmQXx+dCZyLGUsdCxuLHMsaSl9ZnVuY3Rpb24geShlLHQsQSxyLG4scyxpKXtyZXR1cm4gdyh0JnJ8QSZ+cixlLHQsbixzLGkpfWZ1bmN0aW9uIHYoZSx0LEEscixuLHMsaSl7cmV0dXJuIHcodF5BXnIsZSx0LG4scyxpKX1mdW5jdGlvbiBiKGUsdCxBLHIsbixzLGkpe3JldHVybiB3KEFeKHR8fnIpLGUsdCxuLHMsaSl9ZnVuY3Rpb24gQyhlKXt2YXIgdCxBPWUubGVuZ3RoLHI9WzE3MzI1ODQxOTMsLTI3MTczMzg3OSwtMTczMjU4NDE5NCwyNzE3MzM4NzhdO2Zvcih0PTY0O3Q8PWUubGVuZ3RoO3QrPTY0KW0ocixfKGUuc3Vic3RyaW5nKHQtNjQsdCkpKTtlPWUuc3Vic3RyaW5nKHQtNjQpO3ZhciBuPVswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXTtmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKW5bdD4+Ml18PWUuY2hhckNvZGVBdCh0KTw8KHQlNDw8Myk7aWYoblt0Pj4yXXw9MTI4PDwodCU0PDwzKSx0PjU1KWZvcihtKHIsbiksdD0wO3Q8MTY7dCsrKW5bdF09MDtyZXR1cm4gblsxNF09OCpBLG0ocixuKSxyfWZ1bmN0aW9uIF8oZSl7dmFyIHQsQT1bXTtmb3IodD0wO3Q8NjQ7dCs9NClBW3Q+PjJdPWUuY2hhckNvZGVBdCh0KSsoZS5jaGFyQ29kZUF0KHQrMSk8PDgpKyhlLmNoYXJDb2RlQXQodCsyKTw8MTYpKyhlLmNoYXJDb2RlQXQodCszKTw8MjQpO3JldHVybiBBfXZhciBqPSIwMTIzNDU2Nzg5YWJjZGVmIi5zcGxpdCgiIik7ZnVuY3Rpb24geChlKXtmb3IodmFyIHQ9IiIsQT0wO0E8NDtBKyspdCs9altlPj44KkErNCYxNV0raltlPj44KkEmMTVdO3JldHVybiB0fWZ1bmN0aW9uIEYoZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1JmUsKDY1MjgwJmUpPj44LCgxNjcxMTY4MCZlKT4+MTYsKDQyNzgxOTAwODAmZSk+PjI0KX1mdW5jdGlvbiBRKGUpe3JldHVybiBDKGUpLm1hcChGKS5qb2luKCIiKX12YXIgVT0iNWQ0MTQwMmFiYzRiMmE3NmI5NzE5ZDkxMTAxN2M1OTIiIT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdPXgoZVt0XSk7cmV0dXJuIGUuam9pbigiIil9KEMoImhlbGxvIikpO2Z1bmN0aW9uIEUoZSx0KXtpZihVKXt2YXIgQT0oNjU1MzUmZSkrKDY1NTM1JnQpO3JldHVybihlPj4xNikrKHQ+PjE2KSsoQT4+MTYpPDwxNnw2NTUzNSZBfXJldHVybiBlK3QmNDI5NDk2NzI5NX1mdW5jdGlvbiBTKGUsdCl7dmFyIEEscixuLHM7aWYoZSE9PUEpe2Zvcih2YXIgaT0obj1lLHM9MSsoMjU2L2UubGVuZ3RofDApLG5ldyBBcnJheShzKzEpLmpvaW4obikpLG89W10sYT0wO2E8MjU2O2ErKylvW2FdPWE7dmFyIGw9MDtmb3IoYT0wO2E8MjU2O2ErKyl7dmFyIGM9b1thXTtsPShsK2MraS5jaGFyQ29kZUF0KGEpKSUyNTYsb1thXT1vW2xdLG9bbF09Y31BPWUscj1vfWVsc2Ugbz1yO3ZhciB1PXQubGVuZ3RoLGg9MCxkPTAsZj0iIjtmb3IoYT0wO2E8dTthKyspZD0oZCsoYz1vW2g9KGgrMSklMjU2XSkpJTI1NixvW2hdPW9bZF0sb1tkXT1jLGk9b1sob1toXStvW2RdKSUyNTZdLGYrPVN0cmluZy5mcm9tQ2hhckNvZGUodC5jaGFyQ29kZUF0KGEpXmkpO3JldHVybiBmfXZhciBMPXtwcmludDo0LG1vZGlmeTo4LGNvcHk6MTYsImFubm90LWZvcm1zIjozMn07ZnVuY3Rpb24gSShlLHQsQSxyKXt0aGlzLnY9MSx0aGlzLnI9Mjt2YXIgbj0xOTI7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PUwucGVybSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcGVybWlzc2lvbjogIitlKTtuKz1MW2VdfSksdGhpcy5wYWRkaW5nPSIowr9OXk51wopBZFwwTlbDv8O6AVxiLi5cMMK2w5BoPsKAL1xmwqnDvmRTaXoiO3ZhciBzPSh0K3RoaXMucGFkZGluZykuc3Vic3RyKDAsMzIpLGk9KEErdGhpcy5wYWRkaW5nKS5zdWJzdHIoMCwzMik7dGhpcy5PPXRoaXMucHJvY2Vzc093bmVyUGFzc3dvcmQocyxpKSx0aGlzLlA9LSgxKygyNTVebikpLHRoaXMuZW5jcnlwdGlvbktleT1RKHMrdGhpcy5PK3RoaXMubHNiRmlyc3RXb3JkKHRoaXMuUCkrdGhpcy5oZXhUb0J5dGVzKHIpKS5zdWJzdHIoMCw1KSx0aGlzLlU9Uyh0aGlzLmVuY3J5cHRpb25LZXksdGhpcy5wYWRkaW5nKX1mdW5jdGlvbiBOKGUpe2lmKC9bXlx1MDAwMC1cdTAwZmZdLy50ZXN0KGUpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBQREYgTmFtZSBPYmplY3Q6ICIrZSsiLCBPbmx5IGFjY2VwdCBBU0NJSSBjaGFyYWN0ZXJzLiIpO2Zvcih2YXIgdD0iIixBPWUubGVuZ3RoLHI9MDtyPEE7cisrKXt2YXIgbj1lLmNoYXJDb2RlQXQocik7dCs9bjwzM3x8MzU9PT1ufHwzNz09PW58fDQwPT09bnx8NDE9PT1ufHw0Nz09PW58fDYwPT09bnx8NjI9PT1ufHw5MT09PW58fDkzPT09bnx8MTIzPT09bnx8MTI1PT09bnx8bj4xMjY/IiMiKygiMCIrbi50b1N0cmluZygxNikpLnNsaWNlKC0yKTplW3JdfXJldHVybiB0fWZ1bmN0aW9uIGsoZSl7aWYoIm9iamVjdCIhPT0oMCxyLmRlZmF1bHQpKGUpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBDb250ZXh0IHBhc3NlZCB0byBpbml0aWFsaXplIFB1YlN1YiAoanNQREYtbW9kdWxlKSIpO3ZhciB0PXt9O3RoaXMuc3Vic2NyaWJlPWZ1bmN0aW9uKGUsQSxyKXtpZihyPXJ8fCExLCJzdHJpbmciIT10eXBlb2YgZXx8ImZ1bmN0aW9uIiE9dHlwZW9mIEF8fCJib29sZWFuIiE9dHlwZW9mIHIpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8gUHViU3ViLnN1YnNjcmliZSAoanNQREYtbW9kdWxlKSIpO3QuaGFzT3duUHJvcGVydHkoZSl8fCh0W2VdPXt9KTt2YXIgbj1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM1KTtyZXR1cm4gdFtlXVtuXT1bQSwhIXJdLG59LHRoaXMudW5zdWJzY3JpYmU9ZnVuY3Rpb24oZSl7Zm9yKHZhciBBIGluIHQpaWYodFtBXVtlXSlyZXR1cm4gZGVsZXRlIHRbQV1bZV0sMD09PU9iamVjdC5rZXlzKHRbQV0pLmxlbmd0aCYmZGVsZXRlIHRbQV0sITA7cmV0dXJuITF9LHRoaXMucHVibGlzaD1mdW5jdGlvbihBKXtpZih0Lmhhc093blByb3BlcnR5KEEpKXt2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksbj1bXTtmb3IodmFyIHMgaW4gdFtBXSl7dmFyIGk9dFtBXVtzXTt0cnl7aVswXS5hcHBseShlLHIpfWNhdGNoKGUpe28uY29uc29sZSYmbC5lcnJvcigianNQREYgUHViU3ViIEVycm9yIixlLm1lc3NhZ2UsZSl9aVsxXSYmbi5wdXNoKHMpfW4ubGVuZ3RoJiZuLmZvckVhY2godGhpcy51bnN1YnNjcmliZSl9fSx0aGlzLmdldFRvcGljcz1mdW5jdGlvbigpe3JldHVybiB0fX1mdW5jdGlvbiBIKGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEgpKXJldHVybiBuZXcgSChlKTt2YXIgdD0ib3BhY2l0eSxzdHJva2Utb3BhY2l0eSIuc3BsaXQoIiwiKTtmb3IodmFyIEEgaW4gZSllLmhhc093blByb3BlcnR5KEEpJiZ0LmluZGV4T2YoQSk+PTAmJih0aGlzW0FdPWVbQV0pO3RoaXMuaWQ9IiIsdGhpcy5vYmplY3ROdW1iZXI9LTF9ZnVuY3Rpb24gUChlLHQpe3RoaXMuZ1N0YXRlPWUsdGhpcy5tYXRyaXg9dCx0aGlzLmlkPSIiLHRoaXMub2JqZWN0TnVtYmVyPS0xfWZ1bmN0aW9uIFQoZSx0LEEscixuKXtpZighKHRoaXMgaW5zdGFuY2VvZiBUKSlyZXR1cm4gbmV3IFQoZSx0LEEscixuKTt0aGlzLnR5cGU9ImF4aWFsIj09PWU/MjozLHRoaXMuY29vcmRzPXQsdGhpcy5jb2xvcnM9QSxQLmNhbGwodGhpcyxyLG4pfWZ1bmN0aW9uIE8oZSx0LEEscixuKXtpZighKHRoaXMgaW5zdGFuY2VvZiBPKSlyZXR1cm4gbmV3IE8oZSx0LEEscixuKTt0aGlzLmJvdW5kaW5nQm94PWUsdGhpcy54U3RlcD10LHRoaXMueVN0ZXA9QSx0aGlzLnN0cmVhbT0iIix0aGlzLmNsb25lSW5kZXg9MCxQLmNhbGwodGhpcyxyLG4pfWZ1bmN0aW9uIE0oZSl7dmFyIHQsQT0ic3RyaW5nIj09dHlwZW9mIGFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06InAiLG49YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdLGE9W10sYz0xLHU9MTYsaD0iUyIscD1udWxsOyJvYmplY3QiPT09KDAsci5kZWZhdWx0KShlPWV8fHt9KSYmKEE9ZS5vcmllbnRhdGlvbixuPWUudW5pdHx8bixzPWUuZm9ybWF0fHxzLGk9ZS5jb21wcmVzc3x8ZS5jb21wcmVzc1BkZnx8aSxudWxsIT09KHA9ZS5lbmNyeXB0aW9ufHxudWxsKSYmKHAudXNlclBhc3N3b3JkPXAudXNlclBhc3N3b3JkfHwiIixwLm93bmVyUGFzc3dvcmQ9cC5vd25lclBhc3N3b3JkfHwiIixwLnVzZXJQZXJtaXNzaW9ucz1wLnVzZXJQZXJtaXNzaW9uc3x8W10pLGM9Im51bWJlciI9PXR5cGVvZiBlLnVzZXJVbml0P01hdGguYWJzKGUudXNlclVuaXQpOjEsdm9pZCAwIT09ZS5wcmVjaXNpb24mJih0PWUucHJlY2lzaW9uKSx2b2lkIDAhPT1lLmZsb2F0UHJlY2lzaW9uJiYodT1lLmZsb2F0UHJlY2lzaW9uKSxoPWUuZGVmYXVsdFBhdGhPcGVyYXRpb258fCJTIiksYT1lLmZpbHRlcnN8fCghMD09PWk/WyJGbGF0ZUVuY29kZSJdOmEpLG49bnx8Im1tIixBPSgiIisoQXx8IlAiKSkudG9Mb3dlckNhc2UoKTt2YXIgbT1lLnB1dE9ubHlVc2VkRm9udHN8fCExLHc9e30sQj17aW50ZXJuYWw6e30sX19wcml2YXRlX186e319O0IuX19wcml2YXRlX18uUHViU3ViPWs7dmFyIHk9IjEuMyIsdj1CLl9fcHJpdmF0ZV9fLmdldFBkZlZlcnNpb249ZnVuY3Rpb24oKXtyZXR1cm4geX07Qi5fX3ByaXZhdGVfXy5zZXRQZGZWZXJzaW9uPWZ1bmN0aW9uKGUpe3k9ZX07dmFyIGI9e2EwOlsyMzgzLjk0LDMzNzAuMzldLGExOlsxNjgzLjc4LDIzODMuOTRdLGEyOlsxMTkwLjU1LDE2ODMuNzhdLGEzOls4NDEuODksMTE5MC41NV0sYTQ6WzU5NS4yOCw4NDEuODldLGE1Ols0MTkuNTMsNTk1LjI4XSxhNjpbMjk3LjY0LDQxOS41M10sYTc6WzIwOS43NiwyOTcuNjRdLGE4OlsxNDcuNCwyMDkuNzZdLGE5OlsxMDQuODgsMTQ3LjRdLGExMDpbNzMuNywxMDQuODhdLGIwOlsyODM0LjY1LDQwMDguMTldLGIxOlsyMDA0LjA5LDI4MzQuNjVdLGIyOlsxNDE3LjMyLDIwMDQuMDldLGIzOlsxMDAwLjYzLDE0MTcuMzJdLGI0Ols3MDguNjYsMTAwMC42M10sYjU6WzQ5OC45LDcwOC42Nl0sYjY6WzM1NC4zMyw0OTguOV0sYjc6WzI0OS40NSwzNTQuMzNdLGI4OlsxNzUuNzUsMjQ5LjQ1XSxiOTpbMTI0LjcyLDE3NS43NV0sYjEwOls4Ny44NywxMjQuNzJdLGMwOlsyNTk5LjM3LDM2NzYuNTRdLGMxOlsxODM2Ljg1LDI1OTkuMzddLGMyOlsxMjk4LjI3LDE4MzYuODVdLGMzOls5MTguNDMsMTI5OC4yN10sYzQ6WzY0OS4xMyw5MTguNDNdLGM1Ols0NTkuMjEsNjQ5LjEzXSxjNjpbMzIzLjE1LDQ1OS4yMV0sYzc6WzIyOS42MSwzMjMuMTVdLGM4OlsxNjEuNTcsMjI5LjYxXSxjOTpbMTEzLjM5LDE2MS41N10sYzEwOls3OS4zNywxMTMuMzldLGRsOlszMTEuODEsNjIzLjYyXSxsZXR0ZXI6WzYxMiw3OTJdLCJnb3Zlcm5tZW50LWxldHRlciI6WzU3Niw3NTZdLGxlZ2FsOls2MTIsMTAwOF0sImp1bmlvci1sZWdhbCI6WzU3NiwzNjBdLGxlZGdlcjpbMTIyNCw3OTJdLHRhYmxvaWQ6Wzc5MiwxMjI0XSwiY3JlZGl0LWNhcmQiOlsxNTMsMjQzXX07Qi5fX3ByaXZhdGVfXy5nZXRQYWdlRm9ybWF0cz1mdW5jdGlvbigpe3JldHVybiBifTt2YXIgQz1CLl9fcHJpdmF0ZV9fLmdldFBhZ2VGb3JtYXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGJbZV19O3M9c3x8ImE0Ijt2YXIgXz0iY29tcGF0IixqPSJhZHZhbmNlZCIseD1fO2Z1bmN0aW9uIEYoKXt0aGlzLnNhdmVHcmFwaGljc1N0YXRlKCksY2UobmV3IFZlKGplLDAsMCwtamUsMCx2QSgpKmplKS50b1N0cmluZygpKyIgY20iKSx0aGlzLnNldEZvbnRTaXplKHRoaXMuZ2V0Rm9udFNpemUoKS9qZSksaD0ibiIseD1qfWZ1bmN0aW9uIFEoKXt0aGlzLnJlc3RvcmVHcmFwaGljc1N0YXRlKCksaD0iUyIseD1ffXZhciBVPUIuX19wcml2YXRlX18uY29tYmluZUZvbnRTdHlsZUFuZEZvbnRXZWlnaHQ9ZnVuY3Rpb24oZSx0KXtpZigiYm9sZCI9PWUmJiJub3JtYWwiPT10fHwiYm9sZCI9PWUmJjQwMD09dHx8Im5vcm1hbCI9PWUmJiJpdGFsaWMiPT10fHwiYm9sZCI9PWUmJiJpdGFsaWMiPT10KXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBDb21iaW5hdGlvbiBvZiBmb250d2VpZ2h0IGFuZCBmb250c3R5bGUiKTtyZXR1cm4gdCYmKGU9NDAwPT10fHwibm9ybWFsIj09PXQ/Iml0YWxpYyI9PT1lPyJpdGFsaWMiOiJub3JtYWwiOjcwMCE9dCYmImJvbGQiIT09dHx8Im5vcm1hbCIhPT1lPyg3MDA9PXQ/ImJvbGQiOnQpKyIiK2U6ImJvbGQiKSxlfTtCLmFkdmFuY2VkQVBJPWZ1bmN0aW9uKGUpe3ZhciB0PXg9PT1fO3JldHVybiB0JiZGLmNhbGwodGhpcyksImZ1bmN0aW9uIiE9dHlwZW9mIGV8fChlKHRoaXMpLHQmJlEuY2FsbCh0aGlzKSksdGhpc30sQi5jb21wYXRBUEk9ZnVuY3Rpb24oZSl7dmFyIHQ9eD09PWo7cmV0dXJuIHQmJlEuY2FsbCh0aGlzKSwiZnVuY3Rpb24iIT10eXBlb2YgZXx8KGUodGhpcyksdCYmRi5jYWxsKHRoaXMpKSx0aGlzfSxCLmlzQWR2YW5jZWRBUEk9ZnVuY3Rpb24oKXtyZXR1cm4geD09PWp9O3ZhciBFLFM9ZnVuY3Rpb24oZSl7aWYoeCE9PWopdGhyb3cgbmV3IEVycm9yKGUrIiBpcyBvbmx5IGF2YWlsYWJsZSBpbiAnYWR2YW5jZWQnIEFQSSBtb2RlLiBZb3UgbmVlZCB0byBjYWxsIGFkdmFuY2VkQVBJKCkgZmlyc3QuIil9LEw9Qi5yb3VuZFRvUHJlY2lzaW9uPUIuX19wcml2YXRlX18ucm91bmRUb1ByZWNpc2lvbj1mdW5jdGlvbihlLEEpe3ZhciByPXR8fEE7aWYoaXNOYU4oZSl8fGlzTmFOKHIpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYucm91bmRUb1ByZWNpc2lvbiIpO3JldHVybiBlLnRvRml4ZWQocikucmVwbGFjZSgvMCskLywiIil9O0U9Qi5ocGY9Qi5fX3ByaXZhdGVfXy5ocGY9Im51bWJlciI9PXR5cGVvZiB1P2Z1bmN0aW9uKGUpe2lmKGlzTmFOKGUpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuaHBmIik7cmV0dXJuIEwoZSx1KX06InNtYXJ0Ij09PXU/ZnVuY3Rpb24oZSl7aWYoaXNOYU4oZSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5ocGYiKTtyZXR1cm4gTChlLGU+LTEmJmU8MT8xNjo1KX06ZnVuY3Rpb24oZSl7aWYoaXNOYU4oZSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5ocGYiKTtyZXR1cm4gTChlLDE2KX07dmFyIFA9Qi5mMj1CLl9fcHJpdmF0ZV9fLmYyPWZ1bmN0aW9uKGUpe2lmKGlzTmFOKGUpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuZjIiKTtyZXR1cm4gTChlLDIpfSxEPUIuX19wcml2YXRlX18uZjM9ZnVuY3Rpb24oZSl7aWYoaXNOYU4oZSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5mMyIpO3JldHVybiBMKGUsMyl9LFI9Qi5zY2FsZT1CLl9fcHJpdmF0ZV9fLnNjYWxlPWZ1bmN0aW9uKGUpe2lmKGlzTmFOKGUpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuc2NhbGUiKTtyZXR1cm4geD09PV8/ZSpqZTp4PT09aj9lOnZvaWQgMH0sSz1mdW5jdGlvbihlKXtyZXR1cm4gUihmdW5jdGlvbihlKXtyZXR1cm4geD09PV8/dkEoKS1lOng9PT1qP2U6dm9pZCAwfShlKSl9O0IuX19wcml2YXRlX18uc2V0UHJlY2lzaW9uPUIuc2V0UHJlY2lzaW9uPWZ1bmN0aW9uKGUpeyJudW1iZXIiPT10eXBlb2YgcGFyc2VJbnQoZSwxMCkmJih0PXBhcnNlSW50KGUsMTApKX07dmFyIFYsRz0iMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiLHo9Qi5fX3ByaXZhdGVfXy5nZXRGaWxlSWQ9ZnVuY3Rpb24oKXtyZXR1cm4gR30scT1CLl9fcHJpdmF0ZV9fLnNldEZpbGVJZD1mdW5jdGlvbihlKXtyZXR1cm4gRz12b2lkIDAhPT1lJiYvXlthLWZBLUYwLTldezMyfSQvLnRlc3QoZSk/ZS50b1VwcGVyQ2FzZSgpOkcuc3BsaXQoIiIpLm1hcChmdW5jdGlvbigpe3JldHVybiJBQkNERUYwMTIzNDU2Nzg5Ii5jaGFyQXQoTWF0aC5mbG9vcigxNipNYXRoLnJhbmRvbSgpKSl9KS5qb2luKCIiKSxudWxsIT09cCYmKFN0PW5ldyBJKHAudXNlclBlcm1pc3Npb25zLHAudXNlclBhc3N3b3JkLHAub3duZXJQYXNzd29yZCxHKSksR307Qi5zZXRGaWxlSWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHEoZSksdGhpc30sQi5nZXRGaWxlSWQ9ZnVuY3Rpb24oKXtyZXR1cm4geigpfTt2YXIgVz1CLl9fcHJpdmF0ZV9fLmNvbnZlcnREYXRlVG9QREZEYXRlPWZ1bmN0aW9uKGUpe3ZhciB0PWUuZ2V0VGltZXpvbmVPZmZzZXQoKSxBPXQ8MD8iKyI6Ii0iLHI9TWF0aC5mbG9vcihNYXRoLmFicyh0LzYwKSksbj1NYXRoLmFicyh0JTYwKSxzPVtBLCQociksIiciLCQobiksIiciXS5qb2luKCIiKTtyZXR1cm5bIkQ6IixlLmdldEZ1bGxZZWFyKCksJChlLmdldE1vbnRoKCkrMSksJChlLmdldERhdGUoKSksJChlLmdldEhvdXJzKCkpLCQoZS5nZXRNaW51dGVzKCkpLCQoZS5nZXRTZWNvbmRzKCkpLHNdLmpvaW4oIiIpfSxYPUIuX19wcml2YXRlX18uY29udmVydFBERkRhdGVUb0RhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9cGFyc2VJbnQoZS5zdWJzdHIoMiw0KSwxMCksQT1wYXJzZUludChlLnN1YnN0cig2LDIpLDEwKS0xLHI9cGFyc2VJbnQoZS5zdWJzdHIoOCwyKSwxMCksbj1wYXJzZUludChlLnN1YnN0cigxMCwyKSwxMCkscz1wYXJzZUludChlLnN1YnN0cigxMiwyKSwxMCksaT1wYXJzZUludChlLnN1YnN0cigxNCwyKSwxMCk7cmV0dXJuIG5ldyBEYXRlKHQsQSxyLG4scyxpLDApfSxZPUIuX19wcml2YXRlX18uc2V0Q3JlYXRpb25EYXRlPWZ1bmN0aW9uKGUpe3ZhciB0O2lmKHZvaWQgMD09PWUmJihlPW5ldyBEYXRlKSxlIGluc3RhbmNlb2YgRGF0ZSl0PVcoZSk7ZWxzZXtpZighL15EOigyMFswLTJdWzAtOV18MjAzWzAtN118MTlbNy05XVswLTldKSgwWzAtOV18MVswLTJdKShbMC0yXVswLTldfDNbMC0xXSkoMFswLTldfDFbMC05XXwyWzAtM10pKDBbMC05XXxbMS01XVswLTldKSgwWzAtOV18WzEtNV1bMC05XSkoXCswWzAtOV18XCsxWzAtNF18LTBbMC05XXwtMVswLTFdKScoMFswLTldfFsxLTVdWzAtOV0pJz8kLy50ZXN0KGUpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuc2V0Q3JlYXRpb25EYXRlIik7dD1lfXJldHVybiBWPXR9LEo9Qi5fX3ByaXZhdGVfXy5nZXRDcmVhdGlvbkRhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9VjtyZXR1cm4ianNEYXRlIj09PWUmJih0PVgoVikpLHR9O0Iuc2V0Q3JlYXRpb25EYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBZKGUpLHRoaXN9LEIuZ2V0Q3JlYXRpb25EYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBKKGUpfTt2YXIgWiwkPUIuX19wcml2YXRlX18ucGFkZDI9ZnVuY3Rpb24oZSl7cmV0dXJuKCIwIitwYXJzZUludChlKSkuc2xpY2UoLTIpfSxlZT1CLl9fcHJpdmF0ZV9fLnBhZGQySGV4PWZ1bmN0aW9uKGUpe3JldHVybigiMDAiKyhlPWUudG9TdHJpbmcoKSkpLnN1YnN0cihlLmxlbmd0aCl9LHRlPTAsQWU9W10scmU9W10sbmU9MCxzZT1bXSxpZT1bXSxvZT0hMSxhZT1yZTtCLl9fcHJpdmF0ZV9fLnNldEN1c3RvbU91dHB1dERlc3RpbmF0aW9uPWZ1bmN0aW9uKGUpe29lPSEwLGFlPWV9O3ZhciBsZT1mdW5jdGlvbihlKXtvZXx8KGFlPWUpfTtCLl9fcHJpdmF0ZV9fLnJlc2V0Q3VzdG9tT3V0cHV0RGVzdGluYXRpb249ZnVuY3Rpb24oKXtvZT0hMSxhZT1yZX07dmFyIGNlPUIuX19wcml2YXRlX18ub3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlPWUudG9TdHJpbmcoKSxuZSs9ZS5sZW5ndGgrMSxhZS5wdXNoKGUpLGFlfSx1ZT1CLl9fcHJpdmF0ZV9fLndyaXRlPWZ1bmN0aW9uKGUpe3JldHVybiBjZSgxPT09YXJndW1lbnRzLmxlbmd0aD9lLnRvU3RyaW5nKCk6QXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsIiAiKSl9LGhlPUIuX19wcml2YXRlX18uZ2V0QXJyYXlCdWZmZXI9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUubGVuZ3RoLEE9bmV3IEFycmF5QnVmZmVyKHQpLHI9bmV3IFVpbnQ4QXJyYXkoQSk7dC0tOylyW3RdPWUuY2hhckNvZGVBdCh0KTtyZXR1cm4gQX0sZGU9W1siSGVsdmV0aWNhIiwiaGVsdmV0aWNhIiwibm9ybWFsIiwiV2luQW5zaUVuY29kaW5nIl0sWyJIZWx2ZXRpY2EtQm9sZCIsImhlbHZldGljYSIsImJvbGQiLCJXaW5BbnNpRW5jb2RpbmciXSxbIkhlbHZldGljYS1PYmxpcXVlIiwiaGVsdmV0aWNhIiwiaXRhbGljIiwiV2luQW5zaUVuY29kaW5nIl0sWyJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiLCJoZWx2ZXRpY2EiLCJib2xkaXRhbGljIiwiV2luQW5zaUVuY29kaW5nIl0sWyJDb3VyaWVyIiwiY291cmllciIsIm5vcm1hbCIsIldpbkFuc2lFbmNvZGluZyJdLFsiQ291cmllci1Cb2xkIiwiY291cmllciIsImJvbGQiLCJXaW5BbnNpRW5jb2RpbmciXSxbIkNvdXJpZXItT2JsaXF1ZSIsImNvdXJpZXIiLCJpdGFsaWMiLCJXaW5BbnNpRW5jb2RpbmciXSxbIkNvdXJpZXItQm9sZE9ibGlxdWUiLCJjb3VyaWVyIiwiYm9sZGl0YWxpYyIsIldpbkFuc2lFbmNvZGluZyJdLFsiVGltZXMtUm9tYW4iLCJ0aW1lcyIsIm5vcm1hbCIsIldpbkFuc2lFbmNvZGluZyJdLFsiVGltZXMtQm9sZCIsInRpbWVzIiwiYm9sZCIsIldpbkFuc2lFbmNvZGluZyJdLFsiVGltZXMtSXRhbGljIiwidGltZXMiLCJpdGFsaWMiLCJXaW5BbnNpRW5jb2RpbmciXSxbIlRpbWVzLUJvbGRJdGFsaWMiLCJ0aW1lcyIsImJvbGRpdGFsaWMiLCJXaW5BbnNpRW5jb2RpbmciXSxbIlphcGZEaW5nYmF0cyIsInphcGZkaW5nYmF0cyIsIm5vcm1hbCIsbnVsbF0sWyJTeW1ib2wiLCJzeW1ib2wiLCJub3JtYWwiLG51bGxdXTtCLl9fcHJpdmF0ZV9fLmdldFN0YW5kYXJkRm9udHM9ZnVuY3Rpb24oKXtyZXR1cm4gZGV9O3ZhciBmZT1lLmZvbnRTaXplfHwxNjtCLl9fcHJpdmF0ZV9fLnNldEZvbnRTaXplPUIuc2V0Rm9udFNpemU9ZnVuY3Rpb24oZSl7cmV0dXJuIGZlPXg9PT1qP2UvamU6ZSx0aGlzfTt2YXIgcGUsZ2U9Qi5fX3ByaXZhdGVfXy5nZXRGb250U2l6ZT1CLmdldEZvbnRTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHg9PT1fP2ZlOmZlKmplfSxtZT1lLlIyTHx8ITE7Qi5fX3ByaXZhdGVfXy5zZXRSMkw9Qi5zZXRSMkw9ZnVuY3Rpb24oZSl7cmV0dXJuIG1lPWUsdGhpc30sQi5fX3ByaXZhdGVfXy5nZXRSMkw9Qi5nZXRSMkw9ZnVuY3Rpb24oKXtyZXR1cm4gbWV9O3ZhciB3ZSxCZT1CLl9fcHJpdmF0ZV9fLnNldFpvb21Nb2RlPWZ1bmN0aW9uKGUpe2lmKC9eKD86XGQrXC5cZCp8XGQqXC5cZCt8XGQrKSUkLy50ZXN0KGUpKXBlPWU7ZWxzZSBpZihpc05hTihlKSl7aWYoLTE9PT1bdm9pZCAwLG51bGwsImZ1bGx3aWR0aCIsImZ1bGxoZWlnaHQiLCJmdWxscGFnZSIsIm9yaWdpbmFsIl0uaW5kZXhPZihlKSl0aHJvdyBuZXcgRXJyb3IoJ3pvb20gbXVzdCBiZSBJbnRlZ2VyIChlLmcuIDIpLCBhIHBlcmNlbnRhZ2UgVmFsdWUgKGUuZy4gMzAwJSkgb3IgZnVsbHdpZHRoLCBmdWxsaGVpZ2h0LCBmdWxscGFnZSwgb3JpZ2luYWwuICInK2UrJyIgaXMgbm90IHJlY29nbml6ZWQuJyk7cGU9ZX1lbHNlIHBlPXBhcnNlSW50KGUsMTApfTtCLl9fcHJpdmF0ZV9fLmdldFpvb21Nb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHBlfTt2YXIgeWUsdmU9Qi5fX3ByaXZhdGVfXy5zZXRQYWdlTW9kZT1mdW5jdGlvbihlKXtpZigtMT09W3ZvaWQgMCxudWxsLCJVc2VOb25lIiwiVXNlT3V0bGluZXMiLCJVc2VUaHVtYnMiLCJGdWxsU2NyZWVuIl0uaW5kZXhPZihlKSl0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgbW9kZSBtdXN0IGJlIG9uZSBvZiBVc2VOb25lLCBVc2VPdXRsaW5lcywgVXNlVGh1bWJzLCBvciBGdWxsU2NyZWVuLiAiJytlKyciIGlzIG5vdCByZWNvZ25pemVkLicpO3dlPWV9O0IuX19wcml2YXRlX18uZ2V0UGFnZU1vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gd2V9O3ZhciBiZT1CLl9fcHJpdmF0ZV9fLnNldExheW91dE1vZGU9ZnVuY3Rpb24oZSl7aWYoLTE9PVt2b2lkIDAsbnVsbCwiY29udGludW91cyIsInNpbmdsZSIsInR3b2xlZnQiLCJ0d29yaWdodCIsInR3byJdLmluZGV4T2YoZSkpdGhyb3cgbmV3IEVycm9yKCdMYXlvdXQgbW9kZSBtdXN0IGJlIG9uZSBvZiBjb250aW51b3VzLCBzaW5nbGUsIHR3b2xlZnQsIHR3b3JpZ2h0LiAiJytlKyciIGlzIG5vdCByZWNvZ25pemVkLicpO3llPWV9O0IuX19wcml2YXRlX18uZ2V0TGF5b3V0TW9kZT1mdW5jdGlvbigpe3JldHVybiB5ZX0sQi5fX3ByaXZhdGVfXy5zZXREaXNwbGF5TW9kZT1CLnNldERpc3BsYXlNb2RlPWZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gQmUoZSksYmUodCksdmUoQSksdGhpc307dmFyIENlPXt0aXRsZToiIixzdWJqZWN0OiIiLGF1dGhvcjoiIixrZXl3b3JkczoiIixjcmVhdG9yOiIifTtCLl9fcHJpdmF0ZV9fLmdldERvY3VtZW50UHJvcGVydHk9ZnVuY3Rpb24oZSl7aWYoLTE9PT1PYmplY3Qua2V5cyhDZSkuaW5kZXhPZihlKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGpzUERGLmdldERvY3VtZW50UHJvcGVydHkiKTtyZXR1cm4gQ2VbZV19LEIuX19wcml2YXRlX18uZ2V0RG9jdW1lbnRQcm9wZXJ0aWVzPWZ1bmN0aW9uKCl7cmV0dXJuIENlfSxCLl9fcHJpdmF0ZV9fLnNldERvY3VtZW50UHJvcGVydGllcz1CLnNldFByb3BlcnRpZXM9Qi5zZXREb2N1bWVudFByb3BlcnRpZXM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0IGluIENlKUNlLmhhc093blByb3BlcnR5KHQpJiZlW3RdJiYoQ2VbdF09ZVt0XSk7cmV0dXJuIHRoaXN9LEIuX19wcml2YXRlX18uc2V0RG9jdW1lbnRQcm9wZXJ0eT1mdW5jdGlvbihlLHQpe2lmKC0xPT09T2JqZWN0LmtleXMoQ2UpLmluZGV4T2YoZSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuc2V0RG9jdW1lbnRQcm9wZXJ0eSIpO3JldHVybiBDZVtlXT10fTt2YXIgX2UsamUseGUsRmUsUWUsVWU9e30sRWU9e30sU2U9W10sTGU9e30sSWU9e30sTmU9e30sa2U9e30sSGU9bnVsbCxQZT0wLFRlPVtdLE9lPW5ldyBrKEIpLE1lPWUuaG90Zml4ZXN8fFtdLERlPXt9LFJlPXt9LEtlPVtdLFZlPWZ1bmN0aW9uIGUodCxBLHIsbixzLGkpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGUpKXJldHVybiBuZXcgZSh0LEEscixuLHMsaSk7aXNOYU4odCkmJih0PTEpLGlzTmFOKEEpJiYoQT0wKSxpc05hTihyKSYmKHI9MCksaXNOYU4obikmJihuPTEpLGlzTmFOKHMpJiYocz0wKSxpc05hTihpKSYmKGk9MCksdGhpcy5fbWF0cml4PVt0LEEscixuLHMsaV19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShWZS5wcm90b3R5cGUsInN4Iix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hdHJpeFswXX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX21hdHJpeFswXT1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZS5wcm90b3R5cGUsInNoeSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXRyaXhbMV19LHNldDpmdW5jdGlvbihlKXt0aGlzLl9tYXRyaXhbMV09ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVmUucHJvdG90eXBlLCJzaHgiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4WzJdfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fbWF0cml4WzJdPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlLnByb3RvdHlwZSwic3kiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4WzNdfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fbWF0cml4WzNdPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlLnByb3RvdHlwZSwidHgiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4WzRdfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fbWF0cml4WzRdPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlLnByb3RvdHlwZSwidHkiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4WzVdfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fbWF0cml4WzVdPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlLnByb3RvdHlwZSwiYSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXRyaXhbMF19LHNldDpmdW5jdGlvbihlKXt0aGlzLl9tYXRyaXhbMF09ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVmUucHJvdG90eXBlLCJiIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hdHJpeFsxXX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX21hdHJpeFsxXT1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZS5wcm90b3R5cGUsImMiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4WzJdfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fbWF0cml4WzJdPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlLnByb3RvdHlwZSwiZCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXRyaXhbM119LHNldDpmdW5jdGlvbihlKXt0aGlzLl9tYXRyaXhbM109ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVmUucHJvdG90eXBlLCJlIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hdHJpeFs0XX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX21hdHJpeFs0XT1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZS5wcm90b3R5cGUsImYiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4WzVdfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fbWF0cml4WzVdPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlLnByb3RvdHlwZSwicm90YXRpb24iLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5hdGFuMih0aGlzLnNoeCx0aGlzLnN4KX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVmUucHJvdG90eXBlLCJzY2FsZVgiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWNvbXBvc2UoKS5zY2FsZS5zeH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVmUucHJvdG90eXBlLCJzY2FsZVkiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWNvbXBvc2UoKS5zY2FsZS5zeX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVmUucHJvdG90eXBlLCJpc0lkZW50aXR5Iix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDE9PT10aGlzLnN4JiYwPT09dGhpcy5zaHkmJjA9PT10aGlzLnNoeCYmMT09PXRoaXMuc3kmJjA9PT10aGlzLnR4JiYwPT09dGhpcy50eX19KSxWZS5wcm90b3R5cGUuam9pbj1mdW5jdGlvbihlKXtyZXR1cm5bdGhpcy5zeCx0aGlzLnNoeSx0aGlzLnNoeCx0aGlzLnN5LHRoaXMudHgsdGhpcy50eV0ubWFwKEUpLmpvaW4oZSl9LFZlLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihlKXt2YXIgdD1lLnN4KnRoaXMuc3grZS5zaHkqdGhpcy5zaHgsQT1lLnN4KnRoaXMuc2h5K2Uuc2h5KnRoaXMuc3kscj1lLnNoeCp0aGlzLnN4K2Uuc3kqdGhpcy5zaHgsbj1lLnNoeCp0aGlzLnNoeStlLnN5KnRoaXMuc3kscz1lLnR4KnRoaXMuc3grZS50eSp0aGlzLnNoeCt0aGlzLnR4LGk9ZS50eCp0aGlzLnNoeStlLnR5KnRoaXMuc3krdGhpcy50eTtyZXR1cm4gbmV3IFZlKHQsQSxyLG4scyxpKX0sVmUucHJvdG90eXBlLmRlY29tcG9zZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuc3gsdD10aGlzLnNoeSxBPXRoaXMuc2h4LHI9dGhpcy5zeSxuPXRoaXMudHgscz10aGlzLnR5LGk9TWF0aC5zcXJ0KGUqZSt0KnQpLG89KGUvPWkpKkErKHQvPWkpKnI7QS09ZSpvLHItPXQqbzt2YXIgYT1NYXRoLnNxcnQoQSpBK3Iqcik7cmV0dXJuIG8vPWEsZSooci89YSk8dCooQS89YSkmJihlPS1lLHQ9LXQsbz0tbyxpPS1pKSx7c2NhbGU6bmV3IFZlKGksMCwwLGEsMCwwKSx0cmFuc2xhdGU6bmV3IFZlKDEsMCwwLDEsbixzKSxyb3RhdGU6bmV3IFZlKGUsdCwtdCxlLDAsMCksc2tldzpuZXcgVmUoMSwwLG8sMSwwLDApfX0sVmUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmpvaW4oIiAiKX0sVmUucHJvdG90eXBlLmludmVyc2VkPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zeCx0PXRoaXMuc2h5LEE9dGhpcy5zaHgscj10aGlzLnN5LG49dGhpcy50eCxzPXRoaXMudHksaT0xLyhlKnItdCpBKSxvPXIqaSxhPS10KmksbD0tQSppLGM9ZSppO3JldHVybiBuZXcgVmUobyxhLGwsYywtbypuLWwqcywtYSpuLWMqcyl9LFZlLnByb3RvdHlwZS5hcHBseVRvUG9pbnQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS54KnRoaXMuc3grZS55KnRoaXMuc2h4K3RoaXMudHgsQT1lLngqdGhpcy5zaHkrZS55KnRoaXMuc3krdGhpcy50eTtyZXR1cm4gbmV3IGZBKHQsQSl9LFZlLnByb3RvdHlwZS5hcHBseVRvUmVjdGFuZ2xlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuYXBwbHlUb1BvaW50KGUpLEE9dGhpcy5hcHBseVRvUG9pbnQobmV3IGZBKGUueCtlLncsZS55K2UuaCkpO3JldHVybiBuZXcgcEEodC54LHQueSxBLngtdC54LEEueS10LnkpfSxWZS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnN4LHQ9dGhpcy5zaHksQT10aGlzLnNoeCxyPXRoaXMuc3ksbj10aGlzLnR4LHM9dGhpcy50eTtyZXR1cm4gbmV3IFZlKGUsdCxBLHIsbixzKX0sQi5NYXRyaXg9VmU7dmFyIEdlPUIubWF0cml4TXVsdD1mdW5jdGlvbihlLHQpe3JldHVybiB0Lm11bHRpcGx5KGUpfSx6ZT1uZXcgVmUoMSwwLDAsMSwwLDApO0IudW5pdE1hdHJpeD1CLmlkZW50aXR5TWF0cml4PXplO3ZhciBxZT1mdW5jdGlvbihlLHQpe2lmKCFJZVtlXSl7dmFyIEE9KHQgaW5zdGFuY2VvZiBUPyJTaCI6IlAiKSsoT2JqZWN0LmtleXMoTGUpLmxlbmd0aCsxKS50b1N0cmluZygxMCk7dC5pZD1BLEllW2VdPUEsTGVbQV09dCxPZS5wdWJsaXNoKCJhZGRQYXR0ZXJuIix0KX19O0IuU2hhZGluZ1BhdHRlcm49VCxCLlRpbGluZ1BhdHRlcm49TyxCLmFkZFNoYWRpbmdQYXR0ZXJuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIFMoImFkZFNoYWRpbmdQYXR0ZXJuKCkiKSxxZShlLHQpLHRoaXN9LEIuYmVnaW5UaWxpbmdQYXR0ZXJuPWZ1bmN0aW9uKGUpe1MoImJlZ2luVGlsaW5nUGF0dGVybigpIiksbUEoZS5ib3VuZGluZ0JveFswXSxlLmJvdW5kaW5nQm94WzFdLGUuYm91bmRpbmdCb3hbMl0tZS5ib3VuZGluZ0JveFswXSxlLmJvdW5kaW5nQm94WzNdLWUuYm91bmRpbmdCb3hbMV0sZS5tYXRyaXgpfSxCLmVuZFRpbGluZ1BhdHRlcm49ZnVuY3Rpb24oZSx0KXtTKCJlbmRUaWxpbmdQYXR0ZXJuKCkiKSx0LnN0cmVhbT1pZVtaXS5qb2luKCJcbiIpLHFlKGUsdCksT2UucHVibGlzaCgiZW5kVGlsaW5nUGF0dGVybiIsdCksS2UucG9wKCkucmVzdG9yZSgpfTt2YXIgV2UsWGU9Qi5fX3ByaXZhdGVfXy5uZXdPYmplY3Q9ZnVuY3Rpb24oKXt2YXIgZT1ZZSgpO3JldHVybiBKZShlLCEwKSxlfSxZZT1CLl9fcHJpdmF0ZV9fLm5ld09iamVjdERlZmVycmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRlKyssQWVbdGVdPWZ1bmN0aW9uKCl7cmV0dXJuIG5lfSx0ZX0sSmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD0iYm9vbGVhbiI9PXR5cGVvZiB0JiZ0LEFlW2VdPW5lLHQmJmNlKGUrIiAwIG9iaiIpLGV9LFplPUIuX19wcml2YXRlX18ubmV3QWRkaXRpb25hbE9iamVjdD1mdW5jdGlvbigpe3ZhciBlPXtvYmpJZDpZZSgpLGNvbnRlbnQ6IiJ9O3JldHVybiBzZS5wdXNoKGUpLGV9LCRlPVllKCksZXQ9WWUoKSx0dD1CLl9fcHJpdmF0ZV9fLmRlY29kZUNvbG9yU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoIiAiKTtpZigyIT09dC5sZW5ndGh8fCJnIiE9PXRbMV0mJiJHIiE9PXRbMV0pNSE9PXQubGVuZ3RofHwiayIhPT10WzRdJiYiSyIhPT10WzRdfHwodD1bKDEtdFswXSkqKDEtdFszXSksKDEtdFsxXSkqKDEtdFszXSksKDEtdFsyXSkqKDEtdFszXSksInIiXSk7ZWxzZXt2YXIgQT1wYXJzZUZsb2F0KHRbMF0pO3Q9W0EsQSxBLCJyIl19Zm9yKHZhciByPSIjIixuPTA7bjwzO24rKylyKz0oIjAiK01hdGguZmxvb3IoMjU1KnBhcnNlRmxvYXQodFtuXSkpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO3JldHVybiByfSxBdD1CLl9fcHJpdmF0ZV9fLmVuY29kZUNvbG9yU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0OyJzdHJpbmciPT10eXBlb2YgZSYmKGU9e2NoMTplfSk7dmFyIEE9ZS5jaDEsbj1lLmNoMixzPWUuY2gzLGk9ZS5jaDQsbz0iZHJhdyI9PT1lLnBkZkNvbG9yVHlwZT9bIkciLCJSRyIsIksiXTpbImciLCJyZyIsImsiXTtpZigic3RyaW5nIj09dHlwZW9mIEEmJiIjIiE9PUEuY2hhckF0KDApKXt2YXIgYT1uZXcgZihBKTtpZihhLm9rKUE9YS50b0hleCgpO2Vsc2UgaWYoIS9eXGQqXC4/XGQqJC8udGVzdChBKSl0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29sb3IgIicrQSsnIiBwYXNzZWQgdG8ganNQREYuZW5jb2RlQ29sb3JTdHJpbmcuJyl9aWYoInN0cmluZyI9PXR5cGVvZiBBJiYvXiNbMC05QS1GYS1mXXszfSQvLnRlc3QoQSkmJihBPSIjIitBWzFdK0FbMV0rQVsyXStBWzJdK0FbM10rQVszXSksInN0cmluZyI9PXR5cGVvZiBBJiYvXiNbMC05QS1GYS1mXXs2fSQvLnRlc3QoQSkpe3ZhciBsPXBhcnNlSW50KEEuc3Vic3RyKDEpLDE2KTtBPWw+PjE2JjI1NSxuPWw+PjgmMjU1LHM9MjU1Jmx9aWYodm9pZCAwPT09bnx8dm9pZCAwPT09aSYmQT09PW4mJm49PT1zKXQ9InN0cmluZyI9PXR5cGVvZiBBP0ErIiAiK29bMF06Mj09PWUucHJlY2lzaW9uP1AoQS8yNTUpKyIgIitvWzBdOkQoQS8yNTUpKyIgIitvWzBdO2Vsc2UgaWYodm9pZCAwPT09aXx8Im9iamVjdCI9PT0oMCxyLmRlZmF1bHQpKGkpKXtpZihpJiYhaXNOYU4oaS5hKSYmMD09PWkuYSlyZXR1cm5bIjEuIiwiMS4iLCIxLiIsb1sxXV0uam9pbigiICIpO3Q9InN0cmluZyI9PXR5cGVvZiBBP1tBLG4scyxvWzFdXS5qb2luKCIgIik6Mj09PWUucHJlY2lzaW9uP1tQKEEvMjU1KSxQKG4vMjU1KSxQKHMvMjU1KSxvWzFdXS5qb2luKCIgIik6W0QoQS8yNTUpLEQobi8yNTUpLEQocy8yNTUpLG9bMV1dLmpvaW4oIiAiKX1lbHNlIHQ9InN0cmluZyI9PXR5cGVvZiBBP1tBLG4scyxpLG9bMl1dLmpvaW4oIiAiKToyPT09ZS5wcmVjaXNpb24/W1AoQSksUChuKSxQKHMpLFAoaSksb1syXV0uam9pbigiICIpOltEKEEpLEQobiksRChzKSxEKGkpLG9bMl1dLmpvaW4oIiAiKTtyZXR1cm4gdH0scnQ9Qi5fX3ByaXZhdGVfXy5nZXRGaWx0ZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIGF9LG50PUIuX19wcml2YXRlX18ucHV0U3RyZWFtPWZ1bmN0aW9uKGUpe3ZhciB0PShlPWV8fHt9KS5kYXRhfHwiIixBPWUuZmlsdGVyc3x8cnQoKSxyPWUuYWxyZWFkeUFwcGxpZWRGaWx0ZXJzfHxbXSxuPWUuYWRkTGVuZ3RoMXx8ITEscz10Lmxlbmd0aCxpPWUub2JqZWN0SWQsbz1mdW5jdGlvbihlKXtyZXR1cm4gZX07aWYobnVsbCE9PXAmJnZvaWQgMD09PWkpdGhyb3cgbmV3IEVycm9yKCJPYmplY3RJZCBtdXN0IGJlIHBhc3NlZCB0byBwdXRTdHJlYW0gZm9yIGZpbGUgZW5jcnlwdGlvbiIpO251bGwhPT1wJiYobz1TdC5lbmNyeXB0b3IoaSwwKSk7dmFyIGE9e307ITA9PT1BJiYoQT1bIkZsYXRlRW5jb2RlIl0pO3ZhciBsPWUuYWRkaXRpb25hbEtleVZhbHVlc3x8W10sYz0oYT12b2lkIDAhPT1NLkFQSS5wcm9jZXNzRGF0YUJ5RmlsdGVycz9NLkFQSS5wcm9jZXNzRGF0YUJ5RmlsdGVycyh0LEEpOntkYXRhOnQscmV2ZXJzZUNoYWluOltdfSkucmV2ZXJzZUNoYWluKyhBcnJheS5pc0FycmF5KHIpP3Iuam9pbigiICIpOnIudG9TdHJpbmcoKSk7aWYoMCE9PWEuZGF0YS5sZW5ndGgmJihsLnB1c2goe2tleToiTGVuZ3RoIix2YWx1ZTphLmRhdGEubGVuZ3RofSksITA9PT1uJiZsLnB1c2goe2tleToiTGVuZ3RoMSIsdmFsdWU6c30pKSwwIT1jLmxlbmd0aClpZihjLnNwbGl0KCIvIikubGVuZ3RoLTE9PTEpbC5wdXNoKHtrZXk6IkZpbHRlciIsdmFsdWU6Y30pO2Vsc2V7bC5wdXNoKHtrZXk6IkZpbHRlciIsdmFsdWU6IlsiK2MrIl0ifSk7Zm9yKHZhciB1PTA7dTxsLmxlbmd0aDt1Kz0xKWlmKCJEZWNvZGVQYXJtcyI9PT1sW3VdLmtleSl7Zm9yKHZhciBoPVtdLGQ9MDtkPGEucmV2ZXJzZUNoYWluLnNwbGl0KCIvIikubGVuZ3RoLTE7ZCs9MSloLnB1c2goIm51bGwiKTtoLnB1c2gobFt1XS52YWx1ZSksbFt1XS52YWx1ZT0iWyIraC5qb2luKCIgIikrIl0ifX1jZSgiPDwiKTtmb3IodmFyIGY9MDtmPGwubGVuZ3RoO2YrKyljZSgiLyIrbFtmXS5rZXkrIiAiK2xbZl0udmFsdWUpO2NlKCI+PiIpLDAhPT1hLmRhdGEubGVuZ3RoJiYoY2UoInN0cmVhbSIpLGNlKG8oYS5kYXRhKSksY2UoImVuZHN0cmVhbSIpKX0sc3Q9Qi5fX3ByaXZhdGVfXy5wdXRQYWdlPWZ1bmN0aW9uKGUpe3ZhciB0PWUubnVtYmVyLEE9ZS5kYXRhLHI9ZS5vYmpJZCxuPWUuY29udGVudHNPYmpJZDtKZShyLCEwKSxjZSgiPDwvVHlwZSAvUGFnZSIpLGNlKCIvUGFyZW50ICIrZS5yb290RGljdGlvbmFyeU9iaklkKyIgMCBSIiksY2UoIi9SZXNvdXJjZXMgIitlLnJlc291cmNlRGljdGlvbmFyeU9iaklkKyIgMCBSIiksY2UoIi9NZWRpYUJveCBbIitwYXJzZUZsb2F0KEUoZS5tZWRpYUJveC5ib3R0b21MZWZ0WCkpKyIgIitwYXJzZUZsb2F0KEUoZS5tZWRpYUJveC5ib3R0b21MZWZ0WSkpKyIgIitFKGUubWVkaWFCb3gudG9wUmlnaHRYKSsiICIrRShlLm1lZGlhQm94LnRvcFJpZ2h0WSkrIl0iKSxudWxsIT09ZS5jcm9wQm94JiZjZSgiL0Nyb3BCb3ggWyIrRShlLmNyb3BCb3guYm90dG9tTGVmdFgpKyIgIitFKGUuY3JvcEJveC5ib3R0b21MZWZ0WSkrIiAiK0UoZS5jcm9wQm94LnRvcFJpZ2h0WCkrIiAiK0UoZS5jcm9wQm94LnRvcFJpZ2h0WSkrIl0iKSxudWxsIT09ZS5ibGVlZEJveCYmY2UoIi9CbGVlZEJveCBbIitFKGUuYmxlZWRCb3guYm90dG9tTGVmdFgpKyIgIitFKGUuYmxlZWRCb3guYm90dG9tTGVmdFkpKyIgIitFKGUuYmxlZWRCb3gudG9wUmlnaHRYKSsiICIrRShlLmJsZWVkQm94LnRvcFJpZ2h0WSkrIl0iKSxudWxsIT09ZS50cmltQm94JiZjZSgiL1RyaW1Cb3ggWyIrRShlLnRyaW1Cb3guYm90dG9tTGVmdFgpKyIgIitFKGUudHJpbUJveC5ib3R0b21MZWZ0WSkrIiAiK0UoZS50cmltQm94LnRvcFJpZ2h0WCkrIiAiK0UoZS50cmltQm94LnRvcFJpZ2h0WSkrIl0iKSxudWxsIT09ZS5hcnRCb3gmJmNlKCIvQXJ0Qm94IFsiK0UoZS5hcnRCb3guYm90dG9tTGVmdFgpKyIgIitFKGUuYXJ0Qm94LmJvdHRvbUxlZnRZKSsiICIrRShlLmFydEJveC50b3BSaWdodFgpKyIgIitFKGUuYXJ0Qm94LnRvcFJpZ2h0WSkrIl0iKSwibnVtYmVyIj09dHlwZW9mIGUudXNlclVuaXQmJjEhPT1lLnVzZXJVbml0JiZjZSgiL1VzZXJVbml0ICIrZS51c2VyVW5pdCksT2UucHVibGlzaCgicHV0UGFnZSIse29iaklkOnIscGFnZUNvbnRleHQ6VGVbdF0scGFnZU51bWJlcjp0LHBhZ2U6QX0pLGNlKCIvQ29udGVudHMgIituKyIgMCBSIiksY2UoIj4+IiksY2UoImVuZG9iaiIpO3ZhciBzPUEuam9pbigiXG4iKTtyZXR1cm4geD09PWomJihzKz0iXG5RIiksSmUobiwhMCksbnQoe2RhdGE6cyxmaWx0ZXJzOnJ0KCksb2JqZWN0SWQ6bn0pLGNlKCJlbmRvYmoiKSxyfSxpdD1CLl9fcHJpdmF0ZV9fLnB1dFBhZ2VzPWZ1bmN0aW9uKCl7dmFyIGUsdCxBPVtdO2ZvcihlPTE7ZTw9UGU7ZSsrKVRlW2VdLm9iaklkPVllKCksVGVbZV0uY29udGVudHNPYmpJZD1ZZSgpO2ZvcihlPTE7ZTw9UGU7ZSsrKUEucHVzaChzdCh7bnVtYmVyOmUsZGF0YTppZVtlXSxvYmpJZDpUZVtlXS5vYmpJZCxjb250ZW50c09iaklkOlRlW2VdLmNvbnRlbnRzT2JqSWQsbWVkaWFCb3g6VGVbZV0ubWVkaWFCb3gsY3JvcEJveDpUZVtlXS5jcm9wQm94LGJsZWVkQm94OlRlW2VdLmJsZWVkQm94LHRyaW1Cb3g6VGVbZV0udHJpbUJveCxhcnRCb3g6VGVbZV0uYXJ0Qm94LHVzZXJVbml0OlRlW2VdLnVzZXJVbml0LHJvb3REaWN0aW9uYXJ5T2JqSWQ6JGUscmVzb3VyY2VEaWN0aW9uYXJ5T2JqSWQ6ZXR9KSk7SmUoJGUsITApLGNlKCI8PC9UeXBlIC9QYWdlcyIpO3ZhciByPSIvS2lkcyBbIjtmb3IodD0wO3Q8UGU7dCsrKXIrPUFbdF0rIiAwIFIgIjtjZShyKyJdIiksY2UoIi9Db3VudCAiK1BlKSxjZSgiPj4iKSxjZSgiZW5kb2JqIiksT2UucHVibGlzaCgicG9zdFB1dFBhZ2VzIil9LG90PWZ1bmN0aW9uKGUpe09lLnB1Ymxpc2goInB1dEZvbnQiLHtmb250OmUsb3V0OmNlLG5ld09iamVjdDpYZSxwdXRTdHJlYW06bnR9KSwhMCE9PWUuaXNBbHJlYWR5UHV0dGVkJiYoZS5vYmplY3ROdW1iZXI9WGUoKSxjZSgiPDwiKSxjZSgiL1R5cGUgL0ZvbnQiKSxjZSgiL0Jhc2VGb250IC8iK04oZS5wb3N0U2NyaXB0TmFtZSkpLGNlKCIvU3VidHlwZSAvVHlwZTEiKSwic3RyaW5nIj09dHlwZW9mIGUuZW5jb2RpbmcmJmNlKCIvRW5jb2RpbmcgLyIrZS5lbmNvZGluZyksY2UoIi9GaXJzdENoYXIgMzIiKSxjZSgiL0xhc3RDaGFyIDI1NSIpLGNlKCI+PiIpLGNlKCJlbmRvYmoiKSl9LGF0PWZ1bmN0aW9uKGUpe2Uub2JqZWN0TnVtYmVyPVhlKCk7dmFyIHQ9W107dC5wdXNoKHtrZXk6IlR5cGUiLHZhbHVlOiIvWE9iamVjdCJ9KSx0LnB1c2goe2tleToiU3VidHlwZSIsdmFsdWU6Ii9Gb3JtIn0pLHQucHVzaCh7a2V5OiJCQm94Iix2YWx1ZToiWyIrW0UoZS54KSxFKGUueSksRShlLngrZS53aWR0aCksRShlLnkrZS5oZWlnaHQpXS5qb2luKCIgIikrIl0ifSksdC5wdXNoKHtrZXk6Ik1hdHJpeCIsdmFsdWU6IlsiK2UubWF0cml4LnRvU3RyaW5nKCkrIl0ifSk7dmFyIEE9ZS5wYWdlc1sxXS5qb2luKCJcbiIpO250KHtkYXRhOkEsYWRkaXRpb25hbEtleVZhbHVlczp0LG9iamVjdElkOmUub2JqZWN0TnVtYmVyfSksY2UoImVuZG9iaiIpfSxsdD1mdW5jdGlvbihlLHQpe3R8fCh0PTIxKTt2YXIgQT1YZSgpLHI9ZnVuY3Rpb24oZSx0KXt2YXIgQSxyPVtdLG49MS8odC0xKTtmb3IoQT0wO0E8MTtBKz1uKXIucHVzaChBKTtpZihyLnB1c2goMSksMCE9ZVswXS5vZmZzZXQpe3ZhciBzPXtvZmZzZXQ6MCxjb2xvcjplWzBdLmNvbG9yfTtlLnVuc2hpZnQocyl9aWYoMSE9ZVtlLmxlbmd0aC0xXS5vZmZzZXQpe3ZhciBpPXtvZmZzZXQ6MSxjb2xvcjplW2UubGVuZ3RoLTFdLmNvbG9yfTtlLnB1c2goaSl9Zm9yKHZhciBvPSIiLGE9MCxsPTA7bDxyLmxlbmd0aDtsKyspe2ZvcihBPXJbbF07QT5lW2ErMV0ub2Zmc2V0OylhKys7dmFyIGM9ZVthXS5vZmZzZXQsdT0oQS1jKS8oZVthKzFdLm9mZnNldC1jKSxoPWVbYV0uY29sb3IsZD1lW2ErMV0uY29sb3I7bys9ZWUoTWF0aC5yb3VuZCgoMS11KSpoWzBdK3UqZFswXSkudG9TdHJpbmcoMTYpKStlZShNYXRoLnJvdW5kKCgxLXUpKmhbMV0rdSpkWzFdKS50b1N0cmluZygxNikpK2VlKE1hdGgucm91bmQoKDEtdSkqaFsyXSt1KmRbMl0pLnRvU3RyaW5nKDE2KSl9cmV0dXJuIG8udHJpbSgpfShlLmNvbG9ycyx0KSxuPVtdO24ucHVzaCh7a2V5OiJGdW5jdGlvblR5cGUiLHZhbHVlOiIwIn0pLG4ucHVzaCh7a2V5OiJEb21haW4iLHZhbHVlOiJbMC4wIDEuMF0ifSksbi5wdXNoKHtrZXk6IlNpemUiLHZhbHVlOiJbIit0KyJdIn0pLG4ucHVzaCh7a2V5OiJCaXRzUGVyU2FtcGxlIix2YWx1ZToiOCJ9KSxuLnB1c2goe2tleToiUmFuZ2UiLHZhbHVlOiJbMC4wIDEuMCAwLjAgMS4wIDAuMCAxLjBdIn0pLG4ucHVzaCh7a2V5OiJEZWNvZGUiLHZhbHVlOiJbMC4wIDEuMCAwLjAgMS4wIDAuMCAxLjBdIn0pLG50KHtkYXRhOnIsYWRkaXRpb25hbEtleVZhbHVlczpuLGFscmVhZHlBcHBsaWVkRmlsdGVyczpbIi9BU0NJSUhleERlY29kZSJdLG9iamVjdElkOkF9KSxjZSgiZW5kb2JqIiksZS5vYmplY3ROdW1iZXI9WGUoKSxjZSgiPDwgL1NoYWRpbmdUeXBlICIrZS50eXBlKSxjZSgiL0NvbG9yU3BhY2UgL0RldmljZVJHQiIpO3ZhciBzPSIvQ29vcmRzIFsiK0UocGFyc2VGbG9hdChlLmNvb3Jkc1swXSkpKyIgIitFKHBhcnNlRmxvYXQoZS5jb29yZHNbMV0pKSsiICI7Mj09PWUudHlwZT9zKz1FKHBhcnNlRmxvYXQoZS5jb29yZHNbMl0pKSsiICIrRShwYXJzZUZsb2F0KGUuY29vcmRzWzNdKSk6cys9RShwYXJzZUZsb2F0KGUuY29vcmRzWzJdKSkrIiAiK0UocGFyc2VGbG9hdChlLmNvb3Jkc1szXSkpKyIgIitFKHBhcnNlRmxvYXQoZS5jb29yZHNbNF0pKSsiICIrRShwYXJzZUZsb2F0KGUuY29vcmRzWzVdKSksY2Uocys9Il0iKSxlLm1hdHJpeCYmY2UoIi9NYXRyaXggWyIrZS5tYXRyaXgudG9TdHJpbmcoKSsiXSIpLGNlKCIvRnVuY3Rpb24gIitBKyIgMCBSIiksY2UoIi9FeHRlbmQgW3RydWUgdHJ1ZV0iKSxjZSgiPj4iKSxjZSgiZW5kb2JqIil9LGN0PWZ1bmN0aW9uKGUsdCl7dmFyIEE9WWUoKSxyPVhlKCk7dC5wdXNoKHtyZXNvdXJjZXNPaWQ6QSxvYmplY3RPaWQ6cn0pLGUub2JqZWN0TnVtYmVyPXI7dmFyIG49W107bi5wdXNoKHtrZXk6IlR5cGUiLHZhbHVlOiIvUGF0dGVybiJ9KSxuLnB1c2goe2tleToiUGF0dGVyblR5cGUiLHZhbHVlOiIxIn0pLG4ucHVzaCh7a2V5OiJQYWludFR5cGUiLHZhbHVlOiIxIn0pLG4ucHVzaCh7a2V5OiJUaWxpbmdUeXBlIix2YWx1ZToiMSJ9KSxuLnB1c2goe2tleToiQkJveCIsdmFsdWU6IlsiK2UuYm91bmRpbmdCb3gubWFwKEUpLmpvaW4oIiAiKSsiXSJ9KSxuLnB1c2goe2tleToiWFN0ZXAiLHZhbHVlOkUoZS54U3RlcCl9KSxuLnB1c2goe2tleToiWVN0ZXAiLHZhbHVlOkUoZS55U3RlcCl9KSxuLnB1c2goe2tleToiUmVzb3VyY2VzIix2YWx1ZTpBKyIgMCBSIn0pLGUubWF0cml4JiZuLnB1c2goe2tleToiTWF0cml4Iix2YWx1ZToiWyIrZS5tYXRyaXgudG9TdHJpbmcoKSsiXSJ9KSxudCh7ZGF0YTplLnN0cmVhbSxhZGRpdGlvbmFsS2V5VmFsdWVzOm4sb2JqZWN0SWQ6ZS5vYmplY3ROdW1iZXJ9KSxjZSgiZW5kb2JqIil9LHV0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiBlLm9iamVjdE51bWJlcj1YZSgpLGNlKCI8PCIpLGUpc3dpdGNoKHQpe2Nhc2Uib3BhY2l0eSI6Y2UoIi9jYSAiK1AoZVt0XSkpO2JyZWFrO2Nhc2Uic3Ryb2tlLW9wYWNpdHkiOmNlKCIvQ0EgIitQKGVbdF0pKX1jZSgiPj4iKSxjZSgiZW5kb2JqIil9LGh0PWZ1bmN0aW9uKGUpe0plKGUucmVzb3VyY2VzT2lkLCEwKSxjZSgiPDwiKSxjZSgiL1Byb2NTZXQgWy9QREYgL1RleHQgL0ltYWdlQiAvSW1hZ2VDIC9JbWFnZUldIiksZnVuY3Rpb24oKXtmb3IodmFyIGUgaW4gY2UoIi9Gb250IDw8IiksVWUpVWUuaGFzT3duUHJvcGVydHkoZSkmJighMT09PW18fCEwPT09bSYmdy5oYXNPd25Qcm9wZXJ0eShlKSkmJmNlKCIvIitlKyIgIitVZVtlXS5vYmplY3ROdW1iZXIrIiAwIFIiKTtjZSgiPj4iKX0oKSxmdW5jdGlvbigpe2lmKE9iamVjdC5rZXlzKExlKS5sZW5ndGg+MCl7Zm9yKHZhciBlIGluIGNlKCIvU2hhZGluZyA8PCIpLExlKUxlLmhhc093blByb3BlcnR5KGUpJiZMZVtlXWluc3RhbmNlb2YgVCYmTGVbZV0ub2JqZWN0TnVtYmVyPj0wJiZjZSgiLyIrZSsiICIrTGVbZV0ub2JqZWN0TnVtYmVyKyIgMCBSIik7T2UucHVibGlzaCgicHV0U2hhZGluZ1BhdHRlcm5EaWN0IiksY2UoIj4+Iil9fSgpLGZ1bmN0aW9uKGUpe2lmKE9iamVjdC5rZXlzKExlKS5sZW5ndGg+MCl7Zm9yKHZhciB0IGluIGNlKCIvUGF0dGVybiA8PCIpLExlKUxlLmhhc093blByb3BlcnR5KHQpJiZMZVt0XWluc3RhbmNlb2YgQi5UaWxpbmdQYXR0ZXJuJiZMZVt0XS5vYmplY3ROdW1iZXI+PTAmJkxlW3RdLm9iamVjdE51bWJlcjxlJiZjZSgiLyIrdCsiICIrTGVbdF0ub2JqZWN0TnVtYmVyKyIgMCBSIik7T2UucHVibGlzaCgicHV0VGlsaW5nUGF0dGVybkRpY3QiKSxjZSgiPj4iKX19KGUub2JqZWN0T2lkKSxmdW5jdGlvbigpe2lmKE9iamVjdC5rZXlzKE5lKS5sZW5ndGg+MCl7dmFyIGU7Zm9yKGUgaW4gY2UoIi9FeHRHU3RhdGUgPDwiKSxOZSlOZS5oYXNPd25Qcm9wZXJ0eShlKSYmTmVbZV0ub2JqZWN0TnVtYmVyPj0wJiZjZSgiLyIrZSsiICIrTmVbZV0ub2JqZWN0TnVtYmVyKyIgMCBSIik7T2UucHVibGlzaCgicHV0R1N0YXRlRGljdCIpLGNlKCI+PiIpfX0oKSxmdW5jdGlvbigpe2Zvcih2YXIgZSBpbiBjZSgiL1hPYmplY3QgPDwiKSxEZSlEZS5oYXNPd25Qcm9wZXJ0eShlKSYmRGVbZV0ub2JqZWN0TnVtYmVyPj0wJiZjZSgiLyIrZSsiICIrRGVbZV0ub2JqZWN0TnVtYmVyKyIgMCBSIik7T2UucHVibGlzaCgicHV0WG9iamVjdERpY3QiKSxjZSgiPj4iKX0oKSxjZSgiPj4iKSxjZSgiZW5kb2JqIil9LGR0PWZ1bmN0aW9uKGUpe0VlW2UuZm9udE5hbWVdPUVlW2UuZm9udE5hbWVdfHx7fSxFZVtlLmZvbnROYW1lXVtlLmZvbnRTdHlsZV09ZS5pZH0sZnQ9ZnVuY3Rpb24oZSx0LEEscixuKXt2YXIgcz17aWQ6IkYiKyhPYmplY3Qua2V5cyhVZSkubGVuZ3RoKzEpLnRvU3RyaW5nKDEwKSxwb3N0U2NyaXB0TmFtZTplLGZvbnROYW1lOnQsZm9udFN0eWxlOkEsZW5jb2Rpbmc6cixpc1N0YW5kYXJkRm9udDpufHwhMSxtZXRhZGF0YTp7fX07cmV0dXJuIE9lLnB1Ymxpc2goImFkZEZvbnQiLHtmb250OnMsaW5zdGFuY2U6dGhpc30pLFVlW3MuaWRdPXMsZHQocykscy5pZH0scHQ9Qi5fX3ByaXZhdGVfXy5wZGZFc2NhcGU9Qi5wZGZFc2NhcGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt2YXIgQSxyLG4scyxpLG8sYSxsLGM7aWYobj0odD10fHx7fSkuc291cmNlRW5jb2Rpbmd8fCJVbmljb2RlIixpPXQub3V0cHV0RW5jb2RpbmcsKHQuYXV0b2VuY29kZXx8aSkmJlVlW19lXS5tZXRhZGF0YSYmVWVbX2VdLm1ldGFkYXRhW25dJiZVZVtfZV0ubWV0YWRhdGFbbl0uZW5jb2RpbmcmJihzPVVlW19lXS5tZXRhZGF0YVtuXS5lbmNvZGluZywhaSYmVWVbX2VdLmVuY29kaW5nJiYoaT1VZVtfZV0uZW5jb2RpbmcpLCFpJiZzLmNvZGVQYWdlcyYmKGk9cy5jb2RlUGFnZXNbMF0pLCJzdHJpbmciPT10eXBlb2YgaSYmKGk9c1tpXSksaSkpe2ZvcihhPSExLG89W10sQT0wLHI9ZS5sZW5ndGg7QTxyO0ErKykobD1pW2UuY2hhckNvZGVBdChBKV0pP28ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGwpKTpvLnB1c2goZVtBXSksb1tBXS5jaGFyQ29kZUF0KDApPj44JiYoYT0hMCk7ZT1vLmpvaW4oIiIpfWZvcihBPWUubGVuZ3RoO3ZvaWQgMD09PWEmJjAhPT1BOyllLmNoYXJDb2RlQXQoQS0xKT4+OCYmKGE9ITApLEEtLTtpZighYSlyZXR1cm4gZTtmb3Iobz10Lm5vQk9NP1tdOlsyNTQsMjU1XSxBPTAscj1lLmxlbmd0aDtBPHI7QSsrKXtpZigoYz0obD1lLmNoYXJDb2RlQXQoQSkpPj44KT4+OCl0aHJvdyBuZXcgRXJyb3IoIkNoYXJhY3RlciBhdCBwb3NpdGlvbiAiK0ErIiBvZiBzdHJpbmcgJyIrZSsiJyBleGNlZWRzIDE2Yml0cy4gQ2Fubm90IGJlIGVuY29kZWQgaW50byBVQ1MtMiBCRSIpO28ucHVzaChjKSxvLnB1c2gobC0oYzw8OCkpfXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KHZvaWQgMCxvKX0oZSx0KS5yZXBsYWNlKC9cXC9nLCJcXFxcIikucmVwbGFjZSgvXCgvZywiXFwoIikucmVwbGFjZSgvXCkvZywiXFwpIil9LGd0PUIuX19wcml2YXRlX18uYmVnaW5QYWdlPWZ1bmN0aW9uKGUpe2llWysrUGVdPVtdLFRlW1BlXT17b2JqSWQ6MCxjb250ZW50c09iaklkOjAsdXNlclVuaXQ6TnVtYmVyKGMpLGFydEJveDpudWxsLGJsZWVkQm94Om51bGwsY3JvcEJveDpudWxsLHRyaW1Cb3g6bnVsbCxtZWRpYUJveDp7Ym90dG9tTGVmdFg6MCxib3R0b21MZWZ0WTowLHRvcFJpZ2h0WDpOdW1iZXIoZVswXSksdG9wUmlnaHRZOk51bWJlcihlWzFdKX19LEJ0KFBlKSxsZShpZVtaXSl9LG10PWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpO3N3aXRjaChBPXR8fEEsInN0cmluZyI9PXR5cGVvZiBlJiYocj1DKGUudG9Mb3dlckNhc2UoKSksQXJyYXkuaXNBcnJheShyKSYmKG49clswXSxpPXJbMV0pKSxBcnJheS5pc0FycmF5KGUpJiYobj1lWzBdKmplLGk9ZVsxXSpqZSksaXNOYU4obikmJihuPXNbMF0saT1zWzFdKSwobj4xNDQwMHx8aT4xNDQwMCkmJihsLndhcm4oIkEgcGFnZSBpbiBhIFBERiBjYW4gbm90IGJlIHdpZGVyIG9yIHRhbGxlciB0aGFuIDE0NDAwIHVzZXJVbml0LiBqc1BERiBsaW1pdHMgdGhlIHdpZHRoL2hlaWdodCB0byAxNDQwMCIpLG49TWF0aC5taW4oMTQ0MDAsbiksaT1NYXRoLm1pbigxNDQwMCxpKSkscz1bbixpXSxBLnN1YnN0cigwLDEpKXtjYXNlImwiOmk+biYmKHM9W2ksbl0pO2JyZWFrO2Nhc2UicCI6bj5pJiYocz1baSxuXSl9Z3QocyksSnQoWHQpLGNlKHNBKSwwIT09dUEmJmNlKHVBKyIgSiIpLDAhPT1oQSYmY2UoaEErIiBqIiksT2UucHVibGlzaCgiYWRkUGFnZSIse3BhZ2VOdW1iZXI6UGV9KX0sd3Q9ZnVuY3Rpb24oZSl7ZT4wJiZlPD1QZSYmKGllLnNwbGljZShlLDEpLFRlLnNwbGljZShlLDEpLFBlLS0sWj5QZSYmKFo9UGUpLHRoaXMuc2V0UGFnZShaKSl9LEJ0PWZ1bmN0aW9uKGUpe2U+MCYmZTw9UGUmJihaPWUpfSx5dD1CLl9fcHJpdmF0ZV9fLmdldE51bWJlck9mUGFnZXM9Qi5nZXROdW1iZXJPZlBhZ2VzPWZ1bmN0aW9uKCl7cmV0dXJuIGllLmxlbmd0aC0xfSx2dD1mdW5jdGlvbihlLHQsQSl7dmFyIHIsbj12b2lkIDA7cmV0dXJuIEE9QXx8e30sZT12b2lkIDAhPT1lP2U6VWVbX2VdLmZvbnROYW1lLHQ9dm9pZCAwIT09dD90OlVlW19lXS5mb250U3R5bGUscj1lLnRvTG93ZXJDYXNlKCksdm9pZCAwIT09RWVbcl0mJnZvaWQgMCE9PUVlW3JdW3RdP249RWVbcl1bdF06dm9pZCAwIT09RWVbZV0mJnZvaWQgMCE9PUVlW2VdW3RdP249RWVbZV1bdF06ITE9PT1BLmRpc2FibGVXYXJuaW5nJiZsLndhcm4oIlVuYWJsZSB0byBsb29rIHVwIGZvbnQgbGFiZWwgZm9yIGZvbnQgJyIrZSsiJywgJyIrdCsiJy4gUmVmZXIgdG8gZ2V0Rm9udExpc3QoKSBmb3IgYXZhaWxhYmxlIGZvbnRzLiIpLG58fEEubm9GYWxsYmFja3x8bnVsbD09KG49RWUudGltZXNbdF0pJiYobj1FZS50aW1lcy5ub3JtYWwpLG59LGJ0PUIuX19wcml2YXRlX18ucHV0SW5mbz1mdW5jdGlvbigpe3ZhciBlPVhlKCksdD1mdW5jdGlvbihlKXtyZXR1cm4gZX07Zm9yKHZhciBBIGluIG51bGwhPT1wJiYodD1TdC5lbmNyeXB0b3IoZSwwKSksY2UoIjw8IiksY2UoIi9Qcm9kdWNlciAoIitwdCh0KCJqc1BERiAiK00udmVyc2lvbikpKyIpIiksQ2UpQ2UuaGFzT3duUHJvcGVydHkoQSkmJkNlW0FdJiZjZSgiLyIrQS5zdWJzdHIoMCwxKS50b1VwcGVyQ2FzZSgpK0Euc3Vic3RyKDEpKyIgKCIrcHQodChDZVtBXSkpKyIpIik7Y2UoIi9DcmVhdGlvbkRhdGUgKCIrcHQodChWKSkrIikiKSxjZSgiPj4iKSxjZSgiZW5kb2JqIil9LEN0PUIuX19wcml2YXRlX18ucHV0Q2F0YWxvZz1mdW5jdGlvbihlKXt2YXIgdD0oZT1lfHx7fSkucm9vdERpY3Rpb25hcnlPYmpJZHx8JGU7c3dpdGNoKFhlKCksY2UoIjw8IiksY2UoIi9UeXBlIC9DYXRhbG9nIiksY2UoIi9QYWdlcyAiK3QrIiAwIFIiKSxwZXx8KHBlPSJmdWxsd2lkdGgiKSxwZSl7Y2FzZSJmdWxsd2lkdGgiOmNlKCIvT3BlbkFjdGlvbiBbMyAwIFIgL0ZpdEggbnVsbF0iKTticmVhaztjYXNlImZ1bGxoZWlnaHQiOmNlKCIvT3BlbkFjdGlvbiBbMyAwIFIgL0ZpdFYgbnVsbF0iKTticmVhaztjYXNlImZ1bGxwYWdlIjpjZSgiL09wZW5BY3Rpb24gWzMgMCBSIC9GaXRdIik7YnJlYWs7Y2FzZSJvcmlnaW5hbCI6Y2UoIi9PcGVuQWN0aW9uIFszIDAgUiAvWFlaIG51bGwgbnVsbCAxXSIpO2JyZWFrO2RlZmF1bHQ6dmFyIEE9IiIrcGU7IiUiPT09QS5zdWJzdHIoQS5sZW5ndGgtMSkmJihwZT1wYXJzZUludChwZSkvMTAwKSwibnVtYmVyIj09dHlwZW9mIHBlJiZjZSgiL09wZW5BY3Rpb24gWzMgMCBSIC9YWVogbnVsbCBudWxsICIrUChwZSkrIl0iKX1zd2l0Y2goeWV8fCh5ZT0iY29udGludW91cyIpLHllKXtjYXNlImNvbnRpbnVvdXMiOmNlKCIvUGFnZUxheW91dCAvT25lQ29sdW1uIik7YnJlYWs7Y2FzZSJzaW5nbGUiOmNlKCIvUGFnZUxheW91dCAvU2luZ2xlUGFnZSIpO2JyZWFrO2Nhc2UidHdvIjpjYXNlInR3b2xlZnQiOmNlKCIvUGFnZUxheW91dCAvVHdvQ29sdW1uTGVmdCIpO2JyZWFrO2Nhc2UidHdvcmlnaHQiOmNlKCIvUGFnZUxheW91dCAvVHdvQ29sdW1uUmlnaHQiKX13ZSYmY2UoIi9QYWdlTW9kZSAvIit3ZSksT2UucHVibGlzaCgicHV0Q2F0YWxvZyIpLGNlKCI+PiIpLGNlKCJlbmRvYmoiKX0sX3Q9Qi5fX3ByaXZhdGVfXy5wdXRUcmFpbGVyPWZ1bmN0aW9uKCl7Y2UoInRyYWlsZXIiKSxjZSgiPDwiKSxjZSgiL1NpemUgIisodGUrMSkpLGNlKCIvUm9vdCAiK3RlKyIgMCBSIiksY2UoIi9JbmZvICIrKHRlLTEpKyIgMCBSIiksbnVsbCE9PXAmJmNlKCIvRW5jcnlwdCAiK1N0Lm9pZCsiIDAgUiIpLGNlKCIvSUQgWyA8IitHKyI+IDwiK0crIj4gXSIpLGNlKCI+PiIpfSxqdD1CLl9fcHJpdmF0ZV9fLnB1dEhlYWRlcj1mdW5jdGlvbigpe2NlKCIlUERGLSIreSksY2UoIiXCusOfwqzDoCIpfSx4dD1CLl9fcHJpdmF0ZV9fLnB1dFhSZWY9ZnVuY3Rpb24oKXt2YXIgZT0iMDAwMDAwMDAwMCI7Y2UoInhyZWYiKSxjZSgiMCAiKyh0ZSsxKSksY2UoIjAwMDAwMDAwMDAgNjU1MzUgZiAiKTtmb3IodmFyIHQ9MTt0PD10ZTt0KyspImZ1bmN0aW9uIj09dHlwZW9mIEFlW3RdP2NlKChlK0FlW3RdKCkpLnNsaWNlKC0xMCkrIiAwMDAwMCBuICIpOnZvaWQgMCE9PUFlW3RdP2NlKChlK0FlW3RdKS5zbGljZSgtMTApKyIgMDAwMDAgbiAiKTpjZSgiMDAwMDAwMDAwMCAwMDAwMCBuICIpfSxGdD1CLl9fcHJpdmF0ZV9fLmJ1aWxkRG9jdW1lbnQ9ZnVuY3Rpb24oKXt2YXIgZTt0ZT0wLG5lPTAscmU9W10sQWU9W10sc2U9W10sJGU9WWUoKSxldD1ZZSgpLGxlKHJlKSxPZS5wdWJsaXNoKCJidWlsZERvY3VtZW50IiksanQoKSxpdCgpLGZ1bmN0aW9uKCl7T2UucHVibGlzaCgicHV0QWRkaXRpb25hbE9iamVjdHMiKTtmb3IodmFyIGU9MDtlPHNlLmxlbmd0aDtlKyspe3ZhciB0PXNlW2VdO0plKHQub2JqSWQsITApLGNlKHQuY29udGVudCksY2UoImVuZG9iaiIpfU9lLnB1Ymxpc2goInBvc3RQdXRBZGRpdGlvbmFsT2JqZWN0cyIpfSgpLGU9W10sZnVuY3Rpb24oKXtmb3IodmFyIGUgaW4gVWUpVWUuaGFzT3duUHJvcGVydHkoZSkmJighMT09PW18fCEwPT09bSYmdy5oYXNPd25Qcm9wZXJ0eShlKSkmJm90KFVlW2VdKX0oKSxmdW5jdGlvbigpe3ZhciBlO2ZvcihlIGluIE5lKU5lLmhhc093blByb3BlcnR5KGUpJiZ1dChOZVtlXSl9KCksZnVuY3Rpb24oKXtmb3IodmFyIGUgaW4gRGUpRGUuaGFzT3duUHJvcGVydHkoZSkmJmF0KERlW2VdKX0oKSxmdW5jdGlvbihlKXt2YXIgdDtmb3IodCBpbiBMZSlMZS5oYXNPd25Qcm9wZXJ0eSh0KSYmKExlW3RdaW5zdGFuY2VvZiBUP2x0KExlW3RdKTpMZVt0XWluc3RhbmNlb2YgTyYmY3QoTGVbdF0sZSkpfShlKSxPZS5wdWJsaXNoKCJwdXRSZXNvdXJjZXMiKSxlLmZvckVhY2goaHQpLGh0KHtyZXNvdXJjZXNPaWQ6ZXQsb2JqZWN0T2lkOk51bWJlci5NQVhfU0FGRV9JTlRFR0VSfSksT2UucHVibGlzaCgicG9zdFB1dFJlc291cmNlcyIpLG51bGwhPT1wJiYoU3Qub2lkPVhlKCksY2UoIjw8IiksY2UoIi9GaWx0ZXIgL1N0YW5kYXJkIiksY2UoIi9WICIrU3QudiksY2UoIi9SICIrU3QuciksY2UoIi9VIDwiK1N0LnRvSGV4U3RyaW5nKFN0LlUpKyI+IiksY2UoIi9PIDwiK1N0LnRvSGV4U3RyaW5nKFN0Lk8pKyI+IiksY2UoIi9QICIrU3QuUCksY2UoIj4+IiksY2UoImVuZG9iaiIpKSxidCgpLEN0KCk7dmFyIHQ9bmU7cmV0dXJuIHh0KCksX3QoKSxjZSgic3RhcnR4cmVmIiksY2UoIiIrdCksY2UoIiUlRU9GIiksbGUoaWVbWl0pLHJlLmpvaW4oIlxuIil9LFF0PUIuX19wcml2YXRlX18uZ2V0QmxvYj1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IEJsb2IoW2hlKGUpXSx7dHlwZToiYXBwbGljYXRpb24vcGRmIn0pfSxVdD1CLm91dHB1dD1CLl9fcHJpdmF0ZV9fLm91dHB1dD0oV2U9ZnVuY3Rpb24oZSx0KXtzd2l0Y2goInN0cmluZyI9PXR5cGVvZih0PXR8fHt9KT90PXtmaWxlbmFtZTp0fTp0LmZpbGVuYW1lPXQuZmlsZW5hbWV8fCJnZW5lcmF0ZWQucGRmIixlKXtjYXNlIHZvaWQgMDpyZXR1cm4gRnQoKTtjYXNlInNhdmUiOkIuc2F2ZSh0LmZpbGVuYW1lKTticmVhaztjYXNlImFycmF5YnVmZmVyIjpyZXR1cm4gaGUoRnQoKSk7Y2FzZSJibG9iIjpyZXR1cm4gUXQoRnQoKSk7Y2FzZSJibG9idXJpIjpjYXNlImJsb2J1cmwiOmlmKHZvaWQgMCE9PW8uVVJMJiYiZnVuY3Rpb24iPT10eXBlb2Ygby5VUkwuY3JlYXRlT2JqZWN0VVJMKXJldHVybiBvLlVSTCYmby5VUkwuY3JlYXRlT2JqZWN0VVJMKFF0KEZ0KCkpKXx8dm9pZCAwO2wud2FybigiYmxvYnVybCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgc3lzdGVtLCBiZWNhdXNlIFVSTC5jcmVhdGVPYmplY3RVUkwgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXIuIik7YnJlYWs7Y2FzZSJkYXRhdXJpc3RyaW5nIjpjYXNlImRhdGF1cmxzdHJpbmciOnZhciBBPSIiLHI9RnQoKTt0cnl7QT1nKHIpfWNhdGNoKGUpe0E9Zyh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQocikpKX1yZXR1cm4iZGF0YTphcHBsaWNhdGlvbi9wZGY7ZmlsZW5hbWU9Iit0LmZpbGVuYW1lKyI7YmFzZTY0LCIrQTtjYXNlInBkZm9iamVjdG5ld3dpbmRvdyI6aWYoIltvYmplY3QgV2luZG93XSI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpe3ZhciBuPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9wZGZvYmplY3QvMi4xLjEvcGRmb2JqZWN0Lm1pbi5qcyIscz0nIGludGVncml0eT0ic2hhNTEyLTR6ZS9hOS80anF1K3RYOWRmT3FKWVN2eVlkNU02cXVtLzNIcENMcisvSnFmMHdoYzM3VlVia3BOR0hSNy84cFNuQ0Z3NDdUMWZtSXB3QlY3VXlTaDNnPT0iIGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiJzt0LnBkZk9iamVjdFVybCYmKG49dC5wZGZPYmplY3RVcmwscz0iIik7dmFyIGk9JzxodG1sPjxzdHlsZT5odG1sLCBib2R5IHsgcGFkZGluZzogMDsgbWFyZ2luOiAwOyB9IGlmcmFtZSB7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IGJvcmRlcjogMDt9ICA8L3N0eWxlPjxib2R5PjxzY3JpcHQgc3JjPSInK24rJyInK3MrJz48XC9zY3JpcHQ+PHNjcmlwdCA+UERGT2JqZWN0LmVtYmVkKCInK3RoaXMub3V0cHV0KCJkYXRhdXJsc3RyaW5nIikrJyIsICcrSlNPTi5zdHJpbmdpZnkodCkrIik7PFwvc2NyaXB0PjwvYm9keT48L2h0bWw+IixhPW8ub3BlbigpO3JldHVybiBudWxsIT09YSYmYS5kb2N1bWVudC53cml0ZShpKSxhfXRocm93IG5ldyBFcnJvcigiVGhlIG9wdGlvbiBwZGZvYmplY3RuZXd3aW5kb3cganVzdCB3b3JrcyBpbiBhIGJyb3dzZXItZW52aXJvbm1lbnQuIik7Y2FzZSJwZGZqc25ld3dpbmRvdyI6aWYoIltvYmplY3QgV2luZG93XSI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpe3ZhciBjPSc8aHRtbD48c3R5bGU+aHRtbCwgYm9keSB7IHBhZGRpbmc6IDA7IG1hcmdpbjogMDsgfSBpZnJhbWUgeyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyBib3JkZXI6IDA7fSAgPC9zdHlsZT48Ym9keT48aWZyYW1lIGlkPSJwZGZWaWV3ZXIiIHNyYz0iJysodC5wZGZKc1VybHx8ImV4YW1wbGVzL1BERi5qcy93ZWIvdmlld2VyLmh0bWwiKSsiP2ZpbGU9JmRvd25sb2FkTmFtZT0iK3QuZmlsZW5hbWUrJyIgd2lkdGg9IjUwMHB4IiBoZWlnaHQ9IjQwMHB4IiAvPjwvYm9keT48L2h0bWw+Jyx1PW8ub3BlbigpO2lmKG51bGwhPT11KXt1LmRvY3VtZW50LndyaXRlKGMpO3ZhciBoPXRoaXM7dS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvcigiI3BkZlZpZXdlciIpLm9ubG9hZD1mdW5jdGlvbigpe3UuZG9jdW1lbnQudGl0bGU9dC5maWxlbmFtZSx1LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCIjcGRmVmlld2VyIikuY29udGVudFdpbmRvdy5QREZWaWV3ZXJBcHBsaWNhdGlvbi5vcGVuKGgub3V0cHV0KCJibG9idXJsIikpfX1yZXR1cm4gdX10aHJvdyBuZXcgRXJyb3IoIlRoZSBvcHRpb24gcGRmanNuZXd3aW5kb3cganVzdCB3b3JrcyBpbiBhIGJyb3dzZXItZW52aXJvbm1lbnQuIik7Y2FzZSJkYXRhdXJsbmV3d2luZG93IjppZigiW29iamVjdCBXaW5kb3ddIiE9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSl0aHJvdyBuZXcgRXJyb3IoIlRoZSBvcHRpb24gZGF0YXVybG5ld3dpbmRvdyBqdXN0IHdvcmtzIGluIGEgYnJvd3Nlci1lbnZpcm9ubWVudC4iKTt2YXIgZD0nPGh0bWw+PHN0eWxlPmh0bWwsIGJvZHkgeyBwYWRkaW5nOiAwOyBtYXJnaW46IDA7IH0gaWZyYW1lIHsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgYm9yZGVyOiAwO30gIDwvc3R5bGU+PGJvZHk+PGlmcmFtZSBzcmM9IicrdGhpcy5vdXRwdXQoImRhdGF1cmlzdHJpbmciLHQpKyciPjwvaWZyYW1lPjwvYm9keT48L2h0bWw+JyxmPW8ub3BlbigpO2lmKG51bGwhPT1mJiYoZi5kb2N1bWVudC53cml0ZShkKSxmLmRvY3VtZW50LnRpdGxlPXQuZmlsZW5hbWUpLGZ8fCJ1bmRlZmluZWQiPT10eXBlb2Ygc2FmYXJpKXJldHVybiBmO2JyZWFrO2Nhc2UiZGF0YXVyaSI6Y2FzZSJkYXRhdXJsIjpyZXR1cm4gby5kb2N1bWVudC5sb2NhdGlvbi5ocmVmPXRoaXMub3V0cHV0KCJkYXRhdXJpc3RyaW5nIix0KTtkZWZhdWx0OnJldHVybiBudWxsfX0sV2UuZm9vPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBXZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2F0Y2goQSl7dmFyIGU9QS5zdGFja3x8IiI7fmUuaW5kZXhPZigiIGF0ICIpJiYoZT1lLnNwbGl0KCIgYXQgIilbMV0pO3ZhciB0PSJFcnJvciBpbiBmdW5jdGlvbiAiK2Uuc3BsaXQoIlxuIilbMF0uc3BsaXQoIjwiKVswXSsiOiAiK0EubWVzc2FnZTtpZighby5jb25zb2xlKXRocm93IG5ldyBFcnJvcih0KTtvLmNvbnNvbGUuZXJyb3IodCxBKSxvLmFsZXJ0JiZhbGVydCh0KX19LFdlLmZvby5iYXI9V2UsV2UuZm9vKSxFdD1mdW5jdGlvbihlKXtyZXR1cm4hMD09PUFycmF5LmlzQXJyYXkoTWUpJiZNZS5pbmRleE9mKGUpPi0xfTtzd2l0Y2gobil7Y2FzZSJwdCI6amU9MTticmVhaztjYXNlIm1tIjpqZT03Mi8yNS40O2JyZWFrO2Nhc2UiY20iOmplPTcyLzIuNTQ7YnJlYWs7Y2FzZSJpbiI6amU9NzI7YnJlYWs7Y2FzZSJweCI6amU9MT09RXQoInB4X3NjYWxpbmciKT8uNzU6OTYvNzI7YnJlYWs7Y2FzZSJwYyI6Y2FzZSJlbSI6amU9MTI7YnJlYWs7Y2FzZSJleCI6amU9NjticmVhaztkZWZhdWx0OmlmKCJudW1iZXIiIT10eXBlb2Ygbil0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgdW5pdDogIituKTtqZT1ufXZhciBTdD1udWxsO1koKSxxKCk7dmFyIEx0PUIuX19wcml2YXRlX18uZ2V0UGFnZUluZm89Qi5nZXRQYWdlSW5mbz1mdW5jdGlvbihlKXtpZihpc05hTihlKXx8ZSUxIT0wKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuZ2V0UGFnZUluZm8iKTtyZXR1cm57b2JqSWQ6VGVbZV0ub2JqSWQscGFnZU51bWJlcjplLHBhZ2VDb250ZXh0OlRlW2VdfX0sSXQ9Qi5fX3ByaXZhdGVfXy5nZXRQYWdlSW5mb0J5T2JqSWQ9ZnVuY3Rpb24oZSl7aWYoaXNOYU4oZSl8fGUlMSE9MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGpzUERGLmdldFBhZ2VJbmZvQnlPYmpJZCIpO2Zvcih2YXIgdCBpbiBUZSlpZihUZVt0XS5vYmpJZD09PWUpYnJlYWs7cmV0dXJuIEx0KHQpfSxOdD1CLl9fcHJpdmF0ZV9fLmdldEN1cnJlbnRQYWdlSW5mbz1CLmdldEN1cnJlbnRQYWdlSW5mbz1mdW5jdGlvbigpe3JldHVybntvYmpJZDpUZVtaXS5vYmpJZCxwYWdlTnVtYmVyOloscGFnZUNvbnRleHQ6VGVbWl19fTtCLmFkZFBhZ2U9ZnVuY3Rpb24oKXtyZXR1cm4gbXQuYXBwbHkodGhpcyxhcmd1bWVudHMpLHRoaXN9LEIuc2V0UGFnZT1mdW5jdGlvbigpe3JldHVybiBCdC5hcHBseSh0aGlzLGFyZ3VtZW50cyksbGUuY2FsbCh0aGlzLGllW1pdKSx0aGlzfSxCLmluc2VydFBhZ2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWRkUGFnZSgpLHRoaXMubW92ZVBhZ2UoWixlKSx0aGlzfSxCLm1vdmVQYWdlPWZ1bmN0aW9uKGUsdCl7dmFyIEEscjtpZihlPnQpe0E9aWVbZV0scj1UZVtlXTtmb3IodmFyIG49ZTtuPnQ7bi0tKWllW25dPWllW24tMV0sVGVbbl09VGVbbi0xXTtpZVt0XT1BLFRlW3RdPXIsdGhpcy5zZXRQYWdlKHQpfWVsc2UgaWYoZTx0KXtBPWllW2VdLHI9VGVbZV07Zm9yKHZhciBzPWU7czx0O3MrKylpZVtzXT1pZVtzKzFdLFRlW3NdPVRlW3MrMV07aWVbdF09QSxUZVt0XT1yLHRoaXMuc2V0UGFnZSh0KX1yZXR1cm4gdGhpc30sQi5kZWxldGVQYWdlPWZ1bmN0aW9uKCl7cmV0dXJuIHd0LmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0aGlzfSxCLl9fcHJpdmF0ZV9fLnRleHQ9Qi50ZXh0PWZ1bmN0aW9uKGUsdCxBLG4scyl7dmFyIGksbyxhLGwsYyx1LGgsZCxmLHA9KG49bnx8e30pLnNjb3BlfHx0aGlzO2lmKCJudW1iZXIiPT10eXBlb2YgZSYmIm51bWJlciI9PXR5cGVvZiB0JiYoInN0cmluZyI9PXR5cGVvZiBBfHxBcnJheS5pc0FycmF5KEEpKSl7dmFyIGc9QTtBPXQsdD1lLGU9Z31pZihhcmd1bWVudHNbM11pbnN0YW5jZW9mIFZlPT0wPyhhPWFyZ3VtZW50c1s0XSxsPWFyZ3VtZW50c1s1XSwib2JqZWN0Ij09PSgwLHIuZGVmYXVsdCkoaD1hcmd1bWVudHNbM10pJiZudWxsIT09aHx8KCJzdHJpbmciPT10eXBlb2YgYSYmKGw9YSxhPW51bGwpLCJzdHJpbmciPT10eXBlb2YgaCYmKGw9aCxoPW51bGwpLCJudW1iZXIiPT10eXBlb2YgaCYmKGE9aCxoPW51bGwpLG49e2ZsYWdzOmgsYW5nbGU6YSxhbGlnbjpsfSkpOihTKCJUaGUgdHJhbnNmb3JtIHBhcmFtZXRlciBvZiB0ZXh0KCkgd2l0aCBhIE1hdHJpeCB2YWx1ZSIpLGY9cyksaXNOYU4odCl8fGlzTmFOKEEpfHxudWxsPT1lKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLnRleHQiKTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIHA7dmFyIG0sQj0iIix5PSJudW1iZXIiPT10eXBlb2Ygbi5saW5lSGVpZ2h0RmFjdG9yP24ubGluZUhlaWdodEZhY3RvcjpXdCx2PXAuaW50ZXJuYWwuc2NhbGVGYWN0b3I7ZnVuY3Rpb24gYihlKXtyZXR1cm4gZT1lLnNwbGl0KCJcdCIpLmpvaW4oQXJyYXkobi5UYWJMZW58fDkpLmpvaW4oIiAiKSkscHQoZSxoKX1mdW5jdGlvbiBDKGUpe2Zvcih2YXIgdCxBPWUuY29uY2F0KCkscj1bXSxuPUEubGVuZ3RoO24tLTspInN0cmluZyI9PXR5cGVvZih0PUEuc2hpZnQoKSk/ci5wdXNoKHQpOkFycmF5LmlzQXJyYXkoZSkmJigxPT09dC5sZW5ndGh8fHZvaWQgMD09PXRbMV0mJnZvaWQgMD09PXRbMl0pP3IucHVzaCh0WzBdKTpyLnB1c2goW3RbMF0sdFsxXSx0WzJdXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gXyhlLHQpe3ZhciBBO2lmKCJzdHJpbmciPT10eXBlb2YgZSlBPXQoZSlbMF07ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHIsbixzPWUuY29uY2F0KCksaT1bXSxvPXMubGVuZ3RoO28tLTspInN0cmluZyI9PXR5cGVvZihyPXMuc2hpZnQoKSk/aS5wdXNoKHQocilbMF0pOkFycmF5LmlzQXJyYXkocikmJiJzdHJpbmciPT10eXBlb2YgclswXSYmKG49dChyWzBdLHJbMV0sclsyXSksaS5wdXNoKFtuWzBdLG5bMV0sblsyXV0pKTtBPWl9cmV0dXJuIEF9dmFyIEY9ITEsUT0hMDtpZigic3RyaW5nIj09dHlwZW9mIGUpRj0hMDtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpe3ZhciBVPWUuY29uY2F0KCk7bz1bXTtmb3IodmFyIEwsST1VLmxlbmd0aDtJLS07KSgic3RyaW5nIiE9dHlwZW9mKEw9VS5zaGlmdCgpKXx8QXJyYXkuaXNBcnJheShMKSYmInN0cmluZyIhPXR5cGVvZiBMWzBdKSYmKFE9ITEpO0Y9UX1pZighMT09PUYpdGhyb3cgbmV3IEVycm9yKCdUeXBlIG9mIHRleHQgbXVzdCBiZSBzdHJpbmcgb3IgQXJyYXkuICInK2UrJyIgaXMgbm90IHJlY29nbml6ZWQuJyk7InN0cmluZyI9PXR5cGVvZiBlJiYoZT1lLm1hdGNoKC9bXHI/XG5dLyk/ZS5zcGxpdCgvXHJcbnxccnxcbi9nKTpbZV0pO3ZhciBOPWZlL3AuaW50ZXJuYWwuc2NhbGVGYWN0b3Isaz1OKih5LTEpO3N3aXRjaChuLmJhc2VsaW5lKXtjYXNlImJvdHRvbSI6QS09azticmVhaztjYXNlInRvcCI6QSs9Ti1rO2JyZWFrO2Nhc2UiaGFuZ2luZyI6QSs9Ti0yKms7YnJlYWs7Y2FzZSJtaWRkbGUiOkErPU4vMi1rfWlmKCh1PW4ubWF4V2lkdGh8fDApPjAmJigic3RyaW5nIj09dHlwZW9mIGU/ZT1wLnNwbGl0VGV4dFRvU2l6ZShlLHUpOiJbb2JqZWN0IEFycmF5XSI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkmJihlPWUucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuY29uY2F0KHAuc3BsaXRUZXh0VG9TaXplKHQsdSkpfSxbXSkpKSxpPXt0ZXh0OmUseDp0LHk6QSxvcHRpb25zOm4sbXV0ZXg6e3BkZkVzY2FwZTpwdCxhY3RpdmVGb250S2V5Ol9lLGZvbnRzOlVlLGFjdGl2ZUZvbnRTaXplOmZlfX0sT2UucHVibGlzaCgicHJlUHJvY2Vzc1RleHQiLGkpLGU9aS50ZXh0LGE9KG49aS5vcHRpb25zKS5hbmdsZSxmIGluc3RhbmNlb2YgVmU9PTAmJmEmJiJudW1iZXIiPT10eXBlb2YgYSl7YSo9TWF0aC5QSS8xODAsMD09PW4ucm90YXRpb25EaXJlY3Rpb24mJihhPS1hKSx4PT09aiYmKGE9LWEpO3ZhciBIPU1hdGguY29zKGEpLFA9TWF0aC5zaW4oYSk7Zj1uZXcgVmUoSCxQLC1QLEgsMCwwKX1lbHNlIGEmJmEgaW5zdGFuY2VvZiBWZSYmKGY9YSk7eCE9PWp8fGZ8fChmPXplKSx2b2lkIDAhPT0oYz1uLmNoYXJTcGFjZXx8bEEpJiYoQis9RShSKGMpKSsiIFRjXG4iLHRoaXMuc2V0Q2hhclNwYWNlKHRoaXMuZ2V0Q2hhclNwYWNlKCl8fDApKSx2b2lkIDAhPT0oZD1uLmhvcml6b250YWxTY2FsZSkmJihCKz1FKDEwMCpkKSsiIFR6XG4iKSxuLmxhbmc7dmFyIFQ9LTEsTz12b2lkIDAhPT1uLnJlbmRlcmluZ01vZGU/bi5yZW5kZXJpbmdNb2RlOm4uc3Ryb2tlLE09cC5pbnRlcm5hbC5nZXRDdXJyZW50UGFnZUluZm8oKS5wYWdlQ29udGV4dDtzd2l0Y2goTyl7Y2FzZSAwOmNhc2UhMTpjYXNlImZpbGwiOlQ9MDticmVhaztjYXNlIDE6Y2FzZSEwOmNhc2Uic3Ryb2tlIjpUPTE7YnJlYWs7Y2FzZSAyOmNhc2UiZmlsbFRoZW5TdHJva2UiOlQ9MjticmVhaztjYXNlIDM6Y2FzZSJpbnZpc2libGUiOlQ9MzticmVhaztjYXNlIDQ6Y2FzZSJmaWxsQW5kQWRkRm9yQ2xpcHBpbmciOlQ9NDticmVhaztjYXNlIDU6Y2FzZSJzdHJva2VBbmRBZGRQYXRoRm9yQ2xpcHBpbmciOlQ9NTticmVhaztjYXNlIDY6Y2FzZSJmaWxsVGhlblN0cm9rZUFuZEFkZFRvUGF0aEZvckNsaXBwaW5nIjpUPTY7YnJlYWs7Y2FzZSA3OmNhc2UiYWRkVG9QYXRoRm9yQ2xpcHBpbmciOlQ9N312YXIgRD12b2lkIDAhPT1NLnVzZWRSZW5kZXJpbmdNb2RlP00udXNlZFJlbmRlcmluZ01vZGU6LTE7LTEhPT1UP0IrPVQrIiBUclxuIjotMSE9PUQmJihCKz0iMCBUclxuIiksLTEhPT1UJiYoTS51c2VkUmVuZGVyaW5nTW9kZT1UKSxsPW4uYWxpZ258fCJsZWZ0Ijt2YXIgSyxWPWZlKnksRz1wLmludGVybmFsLnBhZ2VTaXplLmdldFdpZHRoKCksej1VZVtfZV07Yz1uLmNoYXJTcGFjZXx8bEEsdT1uLm1heFdpZHRofHwwLGg9T2JqZWN0LmFzc2lnbih7YXV0b2VuY29kZTohMCxub0JPTTohMH0sbi5mbGFncyk7dmFyIHE9W10sVz1mdW5jdGlvbihlKXtyZXR1cm4gcC5nZXRTdHJpbmdVbml0V2lkdGgoZSx7Zm9udDp6LGNoYXJTcGFjZTpjLGZvbnRTaXplOmZlLGRvS2VybmluZzohMX0pKmZlL3Z9O2lmKCJbb2JqZWN0IEFycmF5XSI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpe3ZhciBYO289QyhlKSwibGVmdCIhPT1sJiYoSz1vLm1hcChXKSk7dmFyIFksSj0wO2lmKCJyaWdodCI9PT1sKXt0LT1LWzBdLGU9W10sST1vLmxlbmd0aDtmb3IodmFyIFo9MDtaPEk7WisrKTA9PT1aPyhZPXRBKHQpLFg9QUEoQSkpOihZPVIoSi1LW1pdKSxYPS1WKSxlLnB1c2goW29bWl0sWSxYXSksSj1LW1pdfWVsc2UgaWYoImNlbnRlciI9PT1sKXt0LT1LWzBdLzIsZT1bXSxJPW8ubGVuZ3RoO2Zvcih2YXIgJD0wOyQ8STskKyspMD09PSQ/KFk9dEEodCksWD1BQShBKSk6KFk9UigoSi1LWyRdKS8yKSxYPS1WKSxlLnB1c2goW29bJF0sWSxYXSksSj1LWyRdfWVsc2UgaWYoImxlZnQiPT09bCl7ZT1bXSxJPW8ubGVuZ3RoO2Zvcih2YXIgZWU9MDtlZTxJO2VlKyspZS5wdXNoKG9bZWVdKX1lbHNlIGlmKCJqdXN0aWZ5Ij09PWwmJiJJZGVudGl0eS1IIj09PXouZW5jb2Rpbmcpe2U9W10sST1vLmxlbmd0aCx1PTAhPT11P3U6Rztmb3IodmFyIHRlPTAsQWU9MDtBZTxJO0FlKyspaWYoWD0wPT09QWU/QUEoQSk6LVYsWT0wPT09QWU/dEEodCk6dGUsQWU8SS0xKXt2YXIgcmU9UigodS1LW0FlXSkvKG9bQWVdLnNwbGl0KCIgIikubGVuZ3RoLTEpKSxuZT1vW0FlXS5zcGxpdCgiICIpO2UucHVzaChbbmVbMF0rIiAiLFksWF0pLHRlPTA7Zm9yKHZhciBzZT0xO3NlPG5lLmxlbmd0aDtzZSsrKXt2YXIgaWU9KFcobmVbc2UtMV0rIiAiK25lW3NlXSktVyhuZVtzZV0pKSp2K3JlO3NlPT1uZS5sZW5ndGgtMT9lLnB1c2goW25lW3NlXSxpZSwwXSk6ZS5wdXNoKFtuZVtzZV0rIiAiLGllLDBdKSx0ZS09aWV9fWVsc2UgZS5wdXNoKFtvW0FlXSxZLFhdKTtlLnB1c2goWyIiLHRlLDBdKX1lbHNle2lmKCJqdXN0aWZ5IiE9PWwpdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgYWxpZ25tZW50IG9wdGlvbiwgdXNlICJsZWZ0IiwgImNlbnRlciIsICJyaWdodCIgb3IgImp1c3RpZnkiLicpO2ZvcihlPVtdLEk9by5sZW5ndGgsdT0wIT09dT91OkcsQWU9MDtBZTxJO0FlKyspWD0wPT09QWU/QUEoQSk6LVYsWT0wPT09QWU/dEEodCk6MCxBZTxJLTE/cS5wdXNoKEUoUigodS1LW0FlXSkvKG9bQWVdLnNwbGl0KCIgIikubGVuZ3RoLTEpKSkpOnEucHVzaCgwKSxlLnB1c2goW29bQWVdLFksWF0pfX0hMD09PSgiYm9vbGVhbiI9PXR5cGVvZiBuLlIyTD9uLlIyTDptZSkmJihlPV8oZSxmdW5jdGlvbihlLHQsQSl7cmV0dXJuW2Uuc3BsaXQoIiIpLnJldmVyc2UoKS5qb2luKCIiKSx0LEFdfSkpLGk9e3RleHQ6ZSx4OnQseTpBLG9wdGlvbnM6bixtdXRleDp7cGRmRXNjYXBlOnB0LGFjdGl2ZUZvbnRLZXk6X2UsZm9udHM6VWUsYWN0aXZlRm9udFNpemU6ZmV9fSxPZS5wdWJsaXNoKCJwb3N0UHJvY2Vzc1RleHQiLGkpLGU9aS50ZXh0LG09aS5tdXRleC5pc0hleHx8ITE7dmFyIG9lPVVlW19lXS5lbmNvZGluZzsiV2luQW5zaUVuY29kaW5nIiE9PW9lJiYiU3RhbmRhcmRFbmNvZGluZyIhPT1vZXx8KGU9XyhlLGZ1bmN0aW9uKGUsdCxBKXtyZXR1cm5bYihlKSx0LEFdfSkpLG89QyhlKSxlPVtdO2Zvcih2YXIgYWUsbGUsdWUsaGU9QXJyYXkuaXNBcnJheShvWzBdKT8xOjAsZGU9IiIscGU9ZnVuY3Rpb24oZSx0LEEpe3ZhciByPSIiO3JldHVybiBBIGluc3RhbmNlb2YgVmU/KEE9Im51bWJlciI9PXR5cGVvZiBuLmFuZ2xlP0dlKEEsbmV3IFZlKDEsMCwwLDEsZSx0KSk6R2UobmV3IFZlKDEsMCwwLDEsZSx0KSxBKSx4PT09aiYmKEE9R2UobmV3IFZlKDEsMCwwLC0xLDAsMCksQSkpLHI9QS5qb2luKCIgIikrIiBUbVxuIik6cj1FKGUpKyIgIitFKHQpKyIgVGRcbiIscn0sZ2U9MDtnZTxvLmxlbmd0aDtnZSsrKXtzd2l0Y2goZGU9IiIsaGUpe2Nhc2UgMTp1ZT0obT8iPCI6IigiKStvW2dlXVswXSsobT8iPiI6IikiKSxhZT1wYXJzZUZsb2F0KG9bZ2VdWzFdKSxsZT1wYXJzZUZsb2F0KG9bZ2VdWzJdKTticmVhaztjYXNlIDA6dWU9KG0/IjwiOiIoIikrb1tnZV0rKG0/Ij4iOiIpIiksYWU9dEEodCksbGU9QUEoQSl9dm9pZCAwIT09cSYmdm9pZCAwIT09cVtnZV0mJihkZT1xW2dlXSsiIFR3XG4iKSwwPT09Z2U/ZS5wdXNoKGRlK3BlKGFlLGxlLGYpK3VlKTowPT09aGU/ZS5wdXNoKGRlK3VlKToxPT09aGUmJmUucHVzaChkZStwZShhZSxsZSxmKSt1ZSl9ZT0wPT09aGU/ZS5qb2luKCIgVGpcblQqICIpOmUuam9pbigiIFRqXG4iKSxlKz0iIFRqXG4iO3ZhciB3ZT0iQlRcbi8iO3JldHVybiB3ZSs9X2UrIiAiK2ZlKyIgVGZcbiIsd2UrPUUoZmUqeSkrIiBUTFxuIix3ZSs9b0ErIlxuIix3ZSs9Qix3ZSs9ZSxjZSh3ZSs9IkVUIiksd1tfZV09ITAscH07dmFyIGt0PUIuX19wcml2YXRlX18uY2xpcD1CLmNsaXA9ZnVuY3Rpb24oZSl7cmV0dXJuIGNlKCJldmVub2RkIj09PWU/IlcqIjoiVyIpLHRoaXN9O0IuY2xpcEV2ZW5PZGQ9ZnVuY3Rpb24oKXtyZXR1cm4ga3QoImV2ZW5vZGQiKX0sQi5fX3ByaXZhdGVfXy5kaXNjYXJkUGF0aD1CLmRpc2NhcmRQYXRoPWZ1bmN0aW9uKCl7cmV0dXJuIGNlKCJuIiksdGhpc307dmFyIEh0PUIuX19wcml2YXRlX18uaXNWYWxpZFN0eWxlPWZ1bmN0aW9uKGUpe3ZhciB0PSExO3JldHVybi0xIT09W3ZvaWQgMCxudWxsLCJTIiwiRCIsIkYiLCJERiIsIkZEIiwiZiIsImYqIiwiQiIsIkIqIiwibiJdLmluZGV4T2YoZSkmJih0PSEwKSx0fTtCLl9fcHJpdmF0ZV9fLnNldERlZmF1bHRQYXRoT3BlcmF0aW9uPUIuc2V0RGVmYXVsdFBhdGhPcGVyYXRpb249ZnVuY3Rpb24oZSl7cmV0dXJuIEh0KGUpJiYoaD1lKSx0aGlzfTt2YXIgUHQ9Qi5fX3ByaXZhdGVfXy5nZXRTdHlsZT1CLmdldFN0eWxlPWZ1bmN0aW9uKGUpe3ZhciB0PWg7c3dpdGNoKGUpe2Nhc2UiRCI6Y2FzZSJTIjp0PSJTIjticmVhaztjYXNlIkYiOnQ9ImYiO2JyZWFrO2Nhc2UiRkQiOmNhc2UiREYiOnQ9IkIiO2JyZWFrO2Nhc2UiZiI6Y2FzZSJmKiI6Y2FzZSJCIjpjYXNlIkIqIjp0PWV9cmV0dXJuIHR9LFR0PUIuY2xvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gY2UoImgiKSx0aGlzfTtCLnN0cm9rZT1mdW5jdGlvbigpe3JldHVybiBjZSgiUyIpLHRoaXN9LEIuZmlsbD1mdW5jdGlvbihlKXtyZXR1cm4gT3QoImYiLGUpLHRoaXN9LEIuZmlsbEV2ZW5PZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIE90KCJmKiIsZSksdGhpc30sQi5maWxsU3Ryb2tlPWZ1bmN0aW9uKGUpe3JldHVybiBPdCgiQiIsZSksdGhpc30sQi5maWxsU3Ryb2tlRXZlbk9kZD1mdW5jdGlvbihlKXtyZXR1cm4gT3QoIkIqIixlKSx0aGlzfTt2YXIgT3Q9ZnVuY3Rpb24oZSx0KXsib2JqZWN0Ij09PSgwLHIuZGVmYXVsdCkodCk/UnQodCxlKTpjZShlKX0sTXQ9ZnVuY3Rpb24oZSl7bnVsbD09PWV8fHg9PT1qJiZ2b2lkIDA9PT1lfHwoZT1QdChlKSxjZShlKSl9O2Z1bmN0aW9uIER0KGUsdCxBLHIsbil7dmFyIHM9bmV3IE8odHx8dGhpcy5ib3VuZGluZ0JveCxBfHx0aGlzLnhTdGVwLHJ8fHRoaXMueVN0ZXAsdGhpcy5nU3RhdGUsbnx8dGhpcy5tYXRyaXgpO3Muc3RyZWFtPXRoaXMuc3RyZWFtO3ZhciBpPWUrIiQkIit0aGlzLmNsb25lSW5kZXgrKysiJCQiO3JldHVybiBxZShpLHMpLHN9dmFyIFJ0PWZ1bmN0aW9uKGUsdCl7dmFyIEE9SWVbZS5rZXldLHI9TGVbQV07aWYociBpbnN0YW5jZW9mIFQpY2UoInEiKSxjZShLdCh0KSksci5nU3RhdGUmJkIuc2V0R1N0YXRlKHIuZ1N0YXRlKSxjZShlLm1hdHJpeC50b1N0cmluZygpKyIgY20iKSxjZSgiLyIrQSsiIHNoIiksY2UoIlEiKTtlbHNlIGlmKHIgaW5zdGFuY2VvZiBPKXt2YXIgbj1uZXcgVmUoMSwwLDAsLTEsMCx2QSgpKTtlLm1hdHJpeCYmKG49bi5tdWx0aXBseShlLm1hdHJpeHx8emUpLEE9RHQuY2FsbChyLGUua2V5LGUuYm91bmRpbmdCb3gsZS54U3RlcCxlLnlTdGVwLG4pLmlkKSxjZSgicSIpLGNlKCIvUGF0dGVybiBjcyIpLGNlKCIvIitBKyIgc2NuIiksci5nU3RhdGUmJkIuc2V0R1N0YXRlKHIuZ1N0YXRlKSxjZSh0KSxjZSgiUSIpfX0sS3Q9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2UiZiI6Y2FzZSJGIjpjYXNlIm4iOnJldHVybiJXIG4iO2Nhc2UiZioiOnJldHVybiJXKiBuIjtjYXNlIkIiOmNhc2UiUyI6cmV0dXJuIlcgUyI7Y2FzZSJCKiI6cmV0dXJuIlcqIFMifX0sVnQ9Qi5tb3ZlVG89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gY2UoRShSKGUpKSsiICIrRShLKHQpKSsiIG0iKSx0aGlzfSxHdD1CLmxpbmVUbz1mdW5jdGlvbihlLHQpe3JldHVybiBjZShFKFIoZSkpKyIgIitFKEsodCkpKyIgbCIpLHRoaXN9LHp0PUIuY3VydmVUbz1mdW5jdGlvbihlLHQsQSxyLG4scyl7cmV0dXJuIGNlKFtFKFIoZSkpLEUoSyh0KSksRShSKEEpKSxFKEsocikpLEUoUihuKSksRShLKHMpKSwiYyJdLmpvaW4oIiAiKSksdGhpc307Qi5fX3ByaXZhdGVfXy5saW5lPUIubGluZT1mdW5jdGlvbihlLHQsQSxyLG4pe2lmKGlzTmFOKGUpfHxpc05hTih0KXx8aXNOYU4oQSl8fGlzTmFOKHIpfHwhSHQobikpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYubGluZSIpO3JldHVybiB4PT09Xz90aGlzLmxpbmVzKFtbQS1lLHItdF1dLGUsdCxbMSwxXSxufHwiUyIpOnRoaXMubGluZXMoW1tBLWUsci10XV0sZSx0LFsxLDFdKS5zdHJva2UoKX0sQi5fX3ByaXZhdGVfXy5saW5lcz1CLmxpbmVzPWZ1bmN0aW9uKGUsdCxBLHIsbixzKXt2YXIgaSxvLGEsbCxjLHUsaCxkLGYscCxnLG07aWYoIm51bWJlciI9PXR5cGVvZiBlJiYobT1BLEE9dCx0PWUsZT1tKSxyPXJ8fFsxLDFdLHM9c3x8ITEsaXNOYU4odCl8fGlzTmFOKEEpfHwhQXJyYXkuaXNBcnJheShlKXx8IUFycmF5LmlzQXJyYXkocil8fCFIdChuKXx8ImJvb2xlYW4iIT10eXBlb2Ygcyl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5saW5lcyIpO2ZvcihWdCh0LEEpLGk9clswXSxvPXJbMV0sbD1lLmxlbmd0aCxwPXQsZz1BLGE9MDthPGw7YSsrKTI9PT0oYz1lW2FdKS5sZW5ndGg/KHA9Y1swXSppK3AsZz1jWzFdKm8rZyxHdChwLGcpKToodT1jWzBdKmkrcCxoPWNbMV0qbytnLGQ9Y1syXSppK3AsZj1jWzNdKm8rZyxwPWNbNF0qaStwLGc9Y1s1XSpvK2csenQodSxoLGQsZixwLGcpKTtyZXR1cm4gcyYmVHQoKSxNdChuKSx0aGlzfSxCLnBhdGg9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciBBPWVbdF0scj1BLmM7c3dpdGNoKEEub3Ape2Nhc2UibSI6VnQoclswXSxyWzFdKTticmVhaztjYXNlImwiOkd0KHJbMF0sclsxXSk7YnJlYWs7Y2FzZSJjIjp6dC5hcHBseSh0aGlzLHIpO2JyZWFrO2Nhc2UiaCI6VHQoKX19cmV0dXJuIHRoaXN9LEIuX19wcml2YXRlX18ucmVjdD1CLnJlY3Q9ZnVuY3Rpb24oZSx0LEEscixuKXtpZihpc05hTihlKXx8aXNOYU4odCl8fGlzTmFOKEEpfHxpc05hTihyKXx8IUh0KG4pKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLnJlY3QiKTtyZXR1cm4geD09PV8mJihyPS1yKSxjZShbRShSKGUpKSxFKEsodCkpLEUoUihBKSksRShSKHIpKSwicmUiXS5qb2luKCIgIikpLE10KG4pLHRoaXN9LEIuX19wcml2YXRlX18udHJpYW5nbGU9Qi50cmlhbmdsZT1mdW5jdGlvbihlLHQsQSxyLG4scyxpKXtpZihpc05hTihlKXx8aXNOYU4odCl8fGlzTmFOKEEpfHxpc05hTihyKXx8aXNOYU4obil8fGlzTmFOKHMpfHwhSHQoaSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYudHJpYW5nbGUiKTtyZXR1cm4gdGhpcy5saW5lcyhbW0EtZSxyLXRdLFtuLUEscy1yXSxbZS1uLHQtc11dLGUsdCxbMSwxXSxpLCEwKSx0aGlzfSxCLl9fcHJpdmF0ZV9fLnJvdW5kZWRSZWN0PUIucm91bmRlZFJlY3Q9ZnVuY3Rpb24oZSx0LEEscixuLHMsaSl7aWYoaXNOYU4oZSl8fGlzTmFOKHQpfHxpc05hTihBKXx8aXNOYU4ocil8fGlzTmFOKG4pfHxpc05hTihzKXx8IUh0KGkpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLnJvdW5kZWRSZWN0Iik7dmFyIG89NC8zKihNYXRoLlNRUlQyLTEpO3JldHVybiBuPU1hdGgubWluKG4sLjUqQSkscz1NYXRoLm1pbihzLC41KnIpLHRoaXMubGluZXMoW1tBLTIqbiwwXSxbbipvLDAsbixzLXMqbyxuLHNdLFswLHItMipzXSxbMCxzKm8sLW4qbyxzLC1uLHNdLFsyKm4tQSwwXSxbLW4qbywwLC1uLC1zKm8sLW4sLXNdLFswLDIqcy1yXSxbMCwtcypvLG4qbywtcyxuLC1zXV0sZStuLHQsWzEsMV0saSwhMCksdGhpc30sQi5fX3ByaXZhdGVfXy5lbGxpcHNlPUIuZWxsaXBzZT1mdW5jdGlvbihlLHQsQSxyLG4pe2lmKGlzTmFOKGUpfHxpc05hTih0KXx8aXNOYU4oQSl8fGlzTmFOKHIpfHwhSHQobikpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuZWxsaXBzZSIpO3ZhciBzPTQvMyooTWF0aC5TUVJUMi0xKSpBLGk9NC8zKihNYXRoLlNRUlQyLTEpKnI7cmV0dXJuIFZ0KGUrQSx0KSx6dChlK0EsdC1pLGUrcyx0LXIsZSx0LXIpLHp0KGUtcyx0LXIsZS1BLHQtaSxlLUEsdCksenQoZS1BLHQraSxlLXMsdCtyLGUsdCtyKSx6dChlK3MsdCtyLGUrQSx0K2ksZStBLHQpLE10KG4pLHRoaXN9LEIuX19wcml2YXRlX18uY2lyY2xlPUIuY2lyY2xlPWZ1bmN0aW9uKGUsdCxBLHIpe2lmKGlzTmFOKGUpfHxpc05hTih0KXx8aXNOYU4oQSl8fCFIdChyKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jaXJjbGUiKTtyZXR1cm4gdGhpcy5lbGxpcHNlKGUsdCxBLEEscil9LEIuc2V0Rm9udD1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIEEmJih0PVUodCxBKSksX2U9dnQoZSx0LHtkaXNhYmxlV2FybmluZzohMX0pLHRoaXN9O3ZhciBxdD1CLl9fcHJpdmF0ZV9fLmdldEZvbnQ9Qi5nZXRGb250PWZ1bmN0aW9uKCl7cmV0dXJuIFVlW3Z0LmFwcGx5KEIsYXJndW1lbnRzKV19O0IuX19wcml2YXRlX18uZ2V0Rm9udExpc3Q9Qi5nZXRGb250TGlzdD1mdW5jdGlvbigpe3ZhciBlLHQsQT17fTtmb3IoZSBpbiBFZSlpZihFZS5oYXNPd25Qcm9wZXJ0eShlKSlmb3IodCBpbiBBW2VdPVtdLEVlW2VdKUVlW2VdLmhhc093blByb3BlcnR5KHQpJiZBW2VdLnB1c2godCk7cmV0dXJuIEF9LEIuYWRkRm9udD1mdW5jdGlvbihlLHQsQSxyLG4pe3ZhciBzPVsiU3RhbmRhcmRFbmNvZGluZyIsIk1hY1JvbWFuRW5jb2RpbmciLCJJZGVudGl0eS1IIiwiV2luQW5zaUVuY29kaW5nIl07cmV0dXJuIGFyZ3VtZW50c1szXSYmLTEhPT1zLmluZGV4T2YoYXJndW1lbnRzWzNdKT9uPWFyZ3VtZW50c1szXTphcmd1bWVudHNbM10mJi0xPT1zLmluZGV4T2YoYXJndW1lbnRzWzNdKSYmKEE9VShBLHIpKSxmdC5jYWxsKHRoaXMsZSx0LEEsbj1ufHwiSWRlbnRpdHktSCIpfTt2YXIgV3QsWHQ9ZS5saW5lV2lkdGh8fC4yMDAwMjUsWXQ9Qi5fX3ByaXZhdGVfXy5nZXRMaW5lV2lkdGg9Qi5nZXRMaW5lV2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gWHR9LEp0PUIuX19wcml2YXRlX18uc2V0TGluZVdpZHRoPUIuc2V0TGluZVdpZHRoPWZ1bmN0aW9uKGUpe3JldHVybiBYdD1lLGNlKEUoUihlKSkrIiB3IiksdGhpc307Qi5fX3ByaXZhdGVfXy5zZXRMaW5lRGFzaD1NLkFQSS5zZXRMaW5lRGFzaD1NLkFQSS5zZXRMaW5lRGFzaFBhdHRlcm49ZnVuY3Rpb24oZSx0KXtpZihlPWV8fFtdLHQ9dHx8MCxpc05hTih0KXx8IUFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuc2V0TGluZURhc2giKTtyZXR1cm4gZT1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gRShSKGUpKX0pLmpvaW4oIiAiKSx0PUUoUih0KSksY2UoIlsiK2UrIl0gIit0KyIgZCIpLHRoaXN9O3ZhciBadD1CLl9fcHJpdmF0ZV9fLmdldExpbmVIZWlnaHQ9Qi5nZXRMaW5lSGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIGZlKld0fTtCLl9fcHJpdmF0ZV9fLmdldExpbmVIZWlnaHQ9Qi5nZXRMaW5lSGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIGZlKld0fTt2YXIgJHQ9Qi5fX3ByaXZhdGVfXy5zZXRMaW5lSGVpZ2h0RmFjdG9yPUIuc2V0TGluZUhlaWdodEZhY3Rvcj1mdW5jdGlvbihlKXtyZXR1cm4ibnVtYmVyIj09dHlwZW9mKGU9ZXx8MS4xNSkmJihXdD1lKSx0aGlzfSxlQT1CLl9fcHJpdmF0ZV9fLmdldExpbmVIZWlnaHRGYWN0b3I9Qi5nZXRMaW5lSGVpZ2h0RmFjdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIFd0fTskdChlLmxpbmVIZWlnaHQpO3ZhciB0QT1CLl9fcHJpdmF0ZV9fLmdldEhvcml6b250YWxDb29yZGluYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBSKGUpfSxBQT1CLl9fcHJpdmF0ZV9fLmdldFZlcnRpY2FsQ29vcmRpbmF0ZT1mdW5jdGlvbihlKXtyZXR1cm4geD09PWo/ZTpUZVtaXS5tZWRpYUJveC50b3BSaWdodFktVGVbWl0ubWVkaWFCb3guYm90dG9tTGVmdFktUihlKX0sckE9Qi5fX3ByaXZhdGVfXy5nZXRIb3Jpem9udGFsQ29vcmRpbmF0ZVN0cmluZz1CLmdldEhvcml6b250YWxDb29yZGluYXRlU3RyaW5nPWZ1bmN0aW9uKGUpe3JldHVybiBFKHRBKGUpKX0sbkE9Qi5fX3ByaXZhdGVfXy5nZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmc9Qi5nZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmc9ZnVuY3Rpb24oZSl7cmV0dXJuIEUoQUEoZSkpfSxzQT1lLnN0cm9rZUNvbG9yfHwiMCBHIjtCLl9fcHJpdmF0ZV9fLmdldFN0cm9rZUNvbG9yPUIuZ2V0RHJhd0NvbG9yPWZ1bmN0aW9uKCl7cmV0dXJuIHR0KHNBKX0sQi5fX3ByaXZhdGVfXy5zZXRTdHJva2VDb2xvcj1CLnNldERyYXdDb2xvcj1mdW5jdGlvbihlLHQsQSxyKXtyZXR1cm4gc0E9QXQoe2NoMTplLGNoMjp0LGNoMzpBLGNoNDpyLHBkZkNvbG9yVHlwZToiZHJhdyIscHJlY2lzaW9uOjJ9KSxjZShzQSksdGhpc307dmFyIGlBPWUuZmlsbENvbG9yfHwiMCBnIjtCLl9fcHJpdmF0ZV9fLmdldEZpbGxDb2xvcj1CLmdldEZpbGxDb2xvcj1mdW5jdGlvbigpe3JldHVybiB0dChpQSl9LEIuX19wcml2YXRlX18uc2V0RmlsbENvbG9yPUIuc2V0RmlsbENvbG9yPWZ1bmN0aW9uKGUsdCxBLHIpe3JldHVybiBpQT1BdCh7Y2gxOmUsY2gyOnQsY2gzOkEsY2g0OnIscGRmQ29sb3JUeXBlOiJmaWxsIixwcmVjaXNpb246Mn0pLGNlKGlBKSx0aGlzfTt2YXIgb0E9ZS50ZXh0Q29sb3J8fCIwIGciLGFBPUIuX19wcml2YXRlX18uZ2V0VGV4dENvbG9yPUIuZ2V0VGV4dENvbG9yPWZ1bmN0aW9uKCl7cmV0dXJuIHR0KG9BKX07Qi5fX3ByaXZhdGVfXy5zZXRUZXh0Q29sb3I9Qi5zZXRUZXh0Q29sb3I9ZnVuY3Rpb24oZSx0LEEscil7cmV0dXJuIG9BPUF0KHtjaDE6ZSxjaDI6dCxjaDM6QSxjaDQ6cixwZGZDb2xvclR5cGU6InRleHQiLHByZWNpc2lvbjozfSksdGhpc307dmFyIGxBPWUuY2hhclNwYWNlLGNBPUIuX19wcml2YXRlX18uZ2V0Q2hhclNwYWNlPUIuZ2V0Q2hhclNwYWNlPWZ1bmN0aW9uKCl7cmV0dXJuIHBhcnNlRmxvYXQobEF8fDApfTtCLl9fcHJpdmF0ZV9fLnNldENoYXJTcGFjZT1CLnNldENoYXJTcGFjZT1mdW5jdGlvbihlKXtpZihpc05hTihlKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGpzUERGLnNldENoYXJTcGFjZSIpO3JldHVybiBsQT1lLHRoaXN9O3ZhciB1QT0wO0IuQ2FwSm9pblN0eWxlcz17MDowLGJ1dHQ6MCxidXQ6MCxtaXRlcjowLDE6MSxyb3VuZDoxLHJvdW5kZWQ6MSxjaXJjbGU6MSwyOjIscHJvamVjdGluZzoyLHByb2plY3Q6MixzcXVhcmU6MixiZXZlbDoyfSxCLl9fcHJpdmF0ZV9fLnNldExpbmVDYXA9Qi5zZXRMaW5lQ2FwPWZ1bmN0aW9uKGUpe3ZhciB0PUIuQ2FwSm9pblN0eWxlc1tlXTtpZih2b2lkIDA9PT10KXRocm93IG5ldyBFcnJvcigiTGluZSBjYXAgc3R5bGUgb2YgJyIrZSsiJyBpcyBub3QgcmVjb2duaXplZC4gU2VlIG9yIGV4dGVuZCAuQ2FwSm9pblN0eWxlcyBwcm9wZXJ0eSBmb3IgdmFsaWQgc3R5bGVzIik7cmV0dXJuIHVBPXQsY2UodCsiIEoiKSx0aGlzfTt2YXIgaEE9MDtCLl9fcHJpdmF0ZV9fLnNldExpbmVKb2luPUIuc2V0TGluZUpvaW49ZnVuY3Rpb24oZSl7dmFyIHQ9Qi5DYXBKb2luU3R5bGVzW2VdO2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IEVycm9yKCJMaW5lIGpvaW4gc3R5bGUgb2YgJyIrZSsiJyBpcyBub3QgcmVjb2duaXplZC4gU2VlIG9yIGV4dGVuZCAuQ2FwSm9pblN0eWxlcyBwcm9wZXJ0eSBmb3IgdmFsaWQgc3R5bGVzIik7cmV0dXJuIGhBPXQsY2UodCsiIGoiKSx0aGlzfSxCLl9fcHJpdmF0ZV9fLnNldExpbmVNaXRlckxpbWl0PUIuX19wcml2YXRlX18uc2V0TWl0ZXJMaW1pdD1CLnNldExpbmVNaXRlckxpbWl0PUIuc2V0TWl0ZXJMaW1pdD1mdW5jdGlvbihlKXtpZihlPWV8fDAsaXNOYU4oZSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5zZXRMaW5lTWl0ZXJMaW1pdCIpO3JldHVybiBjZShFKFIoZSkpKyIgTSIpLHRoaXN9LEIuR1N0YXRlPUgsQi5zZXRHU3RhdGU9ZnVuY3Rpb24oZSl7KGU9InN0cmluZyI9PXR5cGVvZiBlP05lW2tlW2VdXTpkQShudWxsLGUpKS5lcXVhbHMoSGUpfHwoY2UoIi8iK2UuaWQrIiBncyIpLEhlPWUpfTt2YXIgZEE9ZnVuY3Rpb24oZSx0KXtpZighZXx8IWtlW2VdKXt2YXIgQT0hMTtmb3IodmFyIHIgaW4gTmUpaWYoTmUuaGFzT3duUHJvcGVydHkocikmJk5lW3JdLmVxdWFscyh0KSl7QT0hMDticmVha31pZihBKXQ9TmVbcl07ZWxzZXt2YXIgbj0iR1MiKyhPYmplY3Qua2V5cyhOZSkubGVuZ3RoKzEpLnRvU3RyaW5nKDEwKTtOZVtuXT10LHQuaWQ9bn1yZXR1cm4gZSYmKGtlW2VdPXQuaWQpLE9lLnB1Ymxpc2goImFkZEdTdGF0ZSIsdCksdH19O0IuYWRkR1N0YXRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGRBKGUsdCksdGhpc30sQi5zYXZlR3JhcGhpY3NTdGF0ZT1mdW5jdGlvbigpe3JldHVybiBjZSgicSIpLFNlLnB1c2goe2tleTpfZSxzaXplOmZlLGNvbG9yOm9BfSksdGhpc30sQi5yZXN0b3JlR3JhcGhpY3NTdGF0ZT1mdW5jdGlvbigpe2NlKCJRIik7dmFyIGU9U2UucG9wKCk7cmV0dXJuIF9lPWUua2V5LGZlPWUuc2l6ZSxvQT1lLmNvbG9yLEhlPW51bGwsdGhpc30sQi5zZXRDdXJyZW50VHJhbnNmb3JtYXRpb25NYXRyaXg9ZnVuY3Rpb24oZSl7cmV0dXJuIGNlKGUudG9TdHJpbmcoKSsiIGNtIiksdGhpc30sQi5jb21tZW50PWZ1bmN0aW9uKGUpe3JldHVybiBjZSgiIyIrZSksdGhpc307dmFyIGZBPWZ1bmN0aW9uKGUsdCl7dmFyIEE9ZXx8MDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEF9LHNldDpmdW5jdGlvbihlKXtpc05hTihlKXx8KEE9cGFyc2VGbG9hdChlKSl9fSk7dmFyIHI9dHx8MDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHNldDpmdW5jdGlvbihlKXtpc05hTihlKXx8KHI9cGFyc2VGbG9hdChlKSl9fSk7dmFyIG49InB0IjtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInR5cGUiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBufSxzZXQ6ZnVuY3Rpb24oZSl7bj1lLnRvU3RyaW5nKCl9fSksdGhpc30scEE9ZnVuY3Rpb24oZSx0LEEscil7ZkEuY2FsbCh0aGlzLGUsdCksdGhpcy50eXBlPSJyZWN0Ijt2YXIgbj1BfHwwO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbn0sc2V0OmZ1bmN0aW9uKGUpe2lzTmFOKGUpfHwobj1wYXJzZUZsb2F0KGUpKX19KTt2YXIgcz1yfHwwO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHN9LHNldDpmdW5jdGlvbihlKXtpc05hTihlKXx8KHM9cGFyc2VGbG9hdChlKSl9fSksdGhpc30sZ0E9ZnVuY3Rpb24oKXt0aGlzLnBhZ2U9UGUsdGhpcy5jdXJyZW50UGFnZT1aLHRoaXMucGFnZXM9aWUuc2xpY2UoMCksdGhpcy5wYWdlc0NvbnRleHQ9VGUuc2xpY2UoMCksdGhpcy54PXhlLHRoaXMueT1GZSx0aGlzLm1hdHJpeD1RZSx0aGlzLndpZHRoPUJBKFopLHRoaXMuaGVpZ2h0PXZBKFopLHRoaXMub3V0cHV0RGVzdGluYXRpb249YWUsdGhpcy5pZD0iIix0aGlzLm9iamVjdE51bWJlcj0tMX07Z0EucHJvdG90eXBlLnJlc3RvcmU9ZnVuY3Rpb24oKXtQZT10aGlzLnBhZ2UsWj10aGlzLmN1cnJlbnRQYWdlLFRlPXRoaXMucGFnZXNDb250ZXh0LGllPXRoaXMucGFnZXMseGU9dGhpcy54LEZlPXRoaXMueSxRZT10aGlzLm1hdHJpeCx5QShaLHRoaXMud2lkdGgpLGJBKFosdGhpcy5oZWlnaHQpLGFlPXRoaXMub3V0cHV0RGVzdGluYXRpb259O3ZhciBtQT1mdW5jdGlvbihlLHQsQSxyLG4pe0tlLnB1c2gobmV3IGdBKSxQZT1aPTAsaWU9W10seGU9ZSxGZT10LFFlPW4sZ3QoW0Escl0pfTtmb3IodmFyIHdBIGluIEIuYmVnaW5Gb3JtT2JqZWN0PWZ1bmN0aW9uKGUsdCxBLHIsbil7cmV0dXJuIG1BKGUsdCxBLHIsbiksdGhpc30sQi5lbmRGb3JtT2JqZWN0PWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihSZVtlXSlLZS5wb3AoKS5yZXN0b3JlKCk7ZWxzZXt2YXIgdD1uZXcgZ0EsQT0iWG8iKyhPYmplY3Qua2V5cyhEZSkubGVuZ3RoKzEpLnRvU3RyaW5nKDEwKTt0LmlkPUEsUmVbZV09QSxEZVtBXT10LE9lLnB1Ymxpc2goImFkZEZvcm1PYmplY3QiLHQpLEtlLnBvcCgpLnJlc3RvcmUoKX19KGUpLHRoaXN9LEIuZG9Gb3JtT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dmFyIEE9RGVbUmVbZV1dO3JldHVybiBjZSgicSIpLGNlKHQudG9TdHJpbmcoKSsiIGNtIiksY2UoIi8iK0EuaWQrIiBEbyIpLGNlKCJRIiksdGhpc30sQi5nZXRGb3JtT2JqZWN0PWZ1bmN0aW9uKGUpe3ZhciB0PURlW1JlW2VdXTtyZXR1cm57eDp0LngseTp0Lnksd2lkdGg6dC53aWR0aCxoZWlnaHQ6dC5oZWlnaHQsbWF0cml4OnQubWF0cml4fX0sQi5zYXZlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9ZXx8ImdlbmVyYXRlZC5wZGYiLCh0PXR8fHt9KS5yZXR1cm5Qcm9taXNlPXQucmV0dXJuUHJvbWlzZXx8ITEsITE9PT10LnJldHVyblByb21pc2U/KGQoUXQoRnQoKSksZSksImZ1bmN0aW9uIj09dHlwZW9mIGQudW5sb2FkJiZvLnNldFRpbWVvdXQmJnNldFRpbWVvdXQoZC51bmxvYWQsOTExKSx0aGlzKTpuZXcgUHJvbWlzZShmdW5jdGlvbih0LEEpe3RyeXt2YXIgcj1kKFF0KEZ0KCkpLGUpOyJmdW5jdGlvbiI9PXR5cGVvZiBkLnVubG9hZCYmby5zZXRUaW1lb3V0JiZzZXRUaW1lb3V0KGQudW5sb2FkLDkxMSksdChyKX1jYXRjaChlKXtBKGUubWVzc2FnZSl9fSl9LE0uQVBJKU0uQVBJLmhhc093blByb3BlcnR5KHdBKSYmKCJldmVudHMiPT09d0EmJk0uQVBJLmV2ZW50cy5sZW5ndGg/ZnVuY3Rpb24oZSx0KXt2YXIgQSxyLG47Zm9yKG49dC5sZW5ndGgtMTstMSE9PW47bi0tKUE9dFtuXVswXSxyPXRbbl1bMV0sZS5zdWJzY3JpYmUuYXBwbHkoZSxbQV0uY29uY2F0KCJmdW5jdGlvbiI9PXR5cGVvZiByP1tyXTpyKSl9KE9lLE0uQVBJLmV2ZW50cyk6Qlt3QV09TS5BUElbd0FdKTt2YXIgQkE9Qi5nZXRQYWdlV2lkdGg9ZnVuY3Rpb24oZSl7cmV0dXJuKFRlW2U9ZXx8Wl0ubWVkaWFCb3gudG9wUmlnaHRYLVRlW2VdLm1lZGlhQm94LmJvdHRvbUxlZnRYKS9qZX0seUE9Qi5zZXRQYWdlV2lkdGg9ZnVuY3Rpb24oZSx0KXtUZVtlXS5tZWRpYUJveC50b3BSaWdodFg9dCpqZStUZVtlXS5tZWRpYUJveC5ib3R0b21MZWZ0WH0sdkE9Qi5nZXRQYWdlSGVpZ2h0PWZ1bmN0aW9uKGUpe3JldHVybihUZVtlPWV8fFpdLm1lZGlhQm94LnRvcFJpZ2h0WS1UZVtlXS5tZWRpYUJveC5ib3R0b21MZWZ0WSkvamV9LGJBPUIuc2V0UGFnZUhlaWdodD1mdW5jdGlvbihlLHQpe1RlW2VdLm1lZGlhQm94LnRvcFJpZ2h0WT10KmplK1RlW2VdLm1lZGlhQm94LmJvdHRvbUxlZnRZfTtyZXR1cm4gQi5pbnRlcm5hbD17cGRmRXNjYXBlOnB0LGdldFN0eWxlOlB0LGdldEZvbnQ6cXQsZ2V0Rm9udFNpemU6Z2UsZ2V0Q2hhclNwYWNlOmNBLGdldFRleHRDb2xvcjphQSxnZXRMaW5lSGVpZ2h0Olp0LGdldExpbmVIZWlnaHRGYWN0b3I6ZUEsZ2V0TGluZVdpZHRoOll0LHdyaXRlOnVlLGdldEhvcml6b250YWxDb29yZGluYXRlOnRBLGdldFZlcnRpY2FsQ29vcmRpbmF0ZTpBQSxnZXRDb29yZGluYXRlU3RyaW5nOnJBLGdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZzpuQSxjb2xsZWN0aW9uczp7fSxuZXdPYmplY3Q6WGUsbmV3QWRkaXRpb25hbE9iamVjdDpaZSxuZXdPYmplY3REZWZlcnJlZDpZZSxuZXdPYmplY3REZWZlcnJlZEJlZ2luOkplLGdldEZpbHRlcnM6cnQscHV0U3RyZWFtOm50LGV2ZW50czpPZSxzY2FsZUZhY3RvcjpqZSxwYWdlU2l6ZTp7Z2V0V2lkdGg6ZnVuY3Rpb24oKXtyZXR1cm4gQkEoWil9LHNldFdpZHRoOmZ1bmN0aW9uKGUpe3lBKFosZSl9LGdldEhlaWdodDpmdW5jdGlvbigpe3JldHVybiB2QShaKX0sc2V0SGVpZ2h0OmZ1bmN0aW9uKGUpe2JBKFosZSl9fSxlbmNyeXB0aW9uT3B0aW9uczpwLGVuY3J5cHRpb246U3QsZ2V0RW5jcnlwdG9yOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT09cD9TdC5lbmNyeXB0b3IoZSwwKTpmdW5jdGlvbihlKXtyZXR1cm4gZX19LG91dHB1dDpVdCxnZXROdW1iZXJPZlBhZ2VzOnl0LHBhZ2VzOmllLG91dDpjZSxmMjpQLGYzOkQsZ2V0UGFnZUluZm86THQsZ2V0UGFnZUluZm9CeU9iaklkOkl0LGdldEN1cnJlbnRQYWdlSW5mbzpOdCxnZXRQREZWZXJzaW9uOnYsUG9pbnQ6ZkEsUmVjdGFuZ2xlOnBBLE1hdHJpeDpWZSxoYXNIb3RmaXg6RXR9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCLmludGVybmFsLnBhZ2VTaXplLCJ3aWR0aCIse2dldDpmdW5jdGlvbigpe3JldHVybiBCQShaKX0sc2V0OmZ1bmN0aW9uKGUpe3lBKFosZSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEIuaW50ZXJuYWwucGFnZVNpemUsImhlaWdodCIse2dldDpmdW5jdGlvbigpe3JldHVybiB2QShaKX0sc2V0OmZ1bmN0aW9uKGUpe2JBKFosZSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsQT1kZS5sZW5ndGg7dDxBO3QrKyl7dmFyIHI9ZnQuY2FsbCh0aGlzLGVbdF1bMF0sZVt0XVsxXSxlW3RdWzJdLGRlW3RdWzNdLCEwKTshMT09PW0mJih3W3JdPSEwKTt2YXIgbj1lW3RdWzBdLnNwbGl0KCItIik7ZHQoe2lkOnIsZm9udE5hbWU6blswXSxmb250U3R5bGU6blsxXXx8IiJ9KX1PZS5wdWJsaXNoKCJhZGRGb250cyIse2ZvbnRzOlVlLGRpY3Rpb25hcnk6RWV9KX0uY2FsbChCLGRlKSxfZT0iRjEiLG10KHMsQSksT2UucHVibGlzaCgiaW5pdGlhbGl6ZWQiKSxCfUkucHJvdG90eXBlLmxzYkZpcnN0V29yZD1mdW5jdGlvbihlKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmZSxlPj44JjI1NSxlPj4xNiYyNTUsZT4+MjQmMjU1KX0sSS5wcm90b3R5cGUudG9IZXhTdHJpbmc9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoIiIpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4oIjAiKygyNTUmZS5jaGFyQ29kZUF0KDApKS50b1N0cmluZygxNikpLnNsaWNlKC0yKX0pLmpvaW4oIiIpfSxJLnByb3RvdHlwZS5oZXhUb0J5dGVzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxBPTA7QTxlLmxlbmd0aDtBKz0yKXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGUuc3Vic3RyKEEsMiksMTYpKSk7cmV0dXJuIHQuam9pbigiIil9LEkucHJvdG90eXBlLnByb2Nlc3NPd25lclBhc3N3b3JkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIFMoUSh0KS5zdWJzdHIoMCw1KSxlKX0sSS5wcm90b3R5cGUuZW5jcnlwdG9yPWZ1bmN0aW9uKGUsdCl7dmFyIEE9USh0aGlzLmVuY3J5cHRpb25LZXkrU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmZSxlPj44JjI1NSxlPj4xNiYyNTUsMjU1JnQsdD4+OCYyNTUpKS5zdWJzdHIoMCwxMCk7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBTKEEsZSl9fSxILnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oZSl7dmFyIHQsQT0iaWQsb2JqZWN0TnVtYmVyLGVxdWFscyI7aWYoIWV8fCgwLHIuZGVmYXVsdCkoZSkhPT0oMCxyLmRlZmF1bHQpKHRoaXMpKXJldHVybiExO3ZhciBuPTA7Zm9yKHQgaW4gdGhpcylpZighKEEuaW5kZXhPZih0KT49MCkpe2lmKHRoaXMuaGFzT3duUHJvcGVydHkodCkmJiFlLmhhc093blByb3BlcnR5KHQpKXJldHVybiExO2lmKHRoaXNbdF0hPT1lW3RdKXJldHVybiExO24rK31mb3IodCBpbiBlKWUuaGFzT3duUHJvcGVydHkodCkmJkEuaW5kZXhPZih0KTwwJiZuLS07cmV0dXJuIDA9PT1ufSxNLkFQST17ZXZlbnRzOltdfSxNLnZlcnNpb249IjMuMC4yIjt2YXIgRD1NLkFQSSxSPTEsSz1mdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC9cXC9nLCJcXFxcIikucmVwbGFjZSgvXCgvZywiXFwoIikucmVwbGFjZSgvXCkvZywiXFwpIil9LFY9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZSgvXFxcXC9nLCJcXCIpLnJlcGxhY2UoL1xcXCgvZywiKCIpLnJlcGxhY2UoL1xcXCkvZywiKSIpfSxHPWZ1bmN0aW9uKGUpe3JldHVybiBlLnRvRml4ZWQoMil9LHo9ZnVuY3Rpb24oZSl7cmV0dXJuIGUudG9GaXhlZCg1KX07RC5fX2Fjcm9mb3JtX189e307dmFyIHE9ZnVuY3Rpb24oZSx0KXtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lfSxXPWZ1bmN0aW9uKGUpe3JldHVybiBlKlJ9LFg9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IHVlLEE9amUuaW50ZXJuYWwuZ2V0SGVpZ2h0KGUpfHwwLHI9amUuaW50ZXJuYWwuZ2V0V2lkdGgoZSl8fDA7cmV0dXJuIHQuQkJveD1bMCwwLE51bWJlcihHKHIpKSxOdW1iZXIoRyhBKSldLHR9LFk9RC5fX2Fjcm9mb3JtX18uc2V0Qml0PWZ1bmN0aW9uKGUsdCl7aWYoZT1lfHwwLHQ9dHx8MCxpc05hTihlKXx8aXNOYU4odCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuQVBJLl9fYWNyb2Zvcm1fXy5zZXRCaXQiKTtyZXR1cm4gZXwxPDx0fSxKPUQuX19hY3JvZm9ybV9fLmNsZWFyQml0PWZ1bmN0aW9uKGUsdCl7aWYoZT1lfHwwLHQ9dHx8MCxpc05hTihlKXx8aXNOYU4odCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuQVBJLl9fYWNyb2Zvcm1fXy5jbGVhckJpdCIpO3JldHVybiBlJn4oMTw8dCl9LFo9RC5fX2Fjcm9mb3JtX18uZ2V0Qml0PWZ1bmN0aW9uKGUsdCl7aWYoaXNOYU4oZSl8fGlzTmFOKHQpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLkFQSS5fX2Fjcm9mb3JtX18uZ2V0Qml0Iik7cmV0dXJuIGUmMTw8dD8xOjB9LCQ9RC5fX2Fjcm9mb3JtX18uZ2V0Qml0Rm9yUGRmPWZ1bmN0aW9uKGUsdCl7aWYoaXNOYU4oZSl8fGlzTmFOKHQpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLkFQSS5fX2Fjcm9mb3JtX18uZ2V0Qml0Rm9yUGRmIik7cmV0dXJuIFooZSx0LTEpfSxlZT1ELl9fYWNyb2Zvcm1fXy5zZXRCaXRGb3JQZGY9ZnVuY3Rpb24oZSx0KXtpZihpc05hTihlKXx8aXNOYU4odCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuQVBJLl9fYWNyb2Zvcm1fXy5zZXRCaXRGb3JQZGYiKTtyZXR1cm4gWShlLHQtMSl9LHRlPUQuX19hY3JvZm9ybV9fLmNsZWFyQml0Rm9yUGRmPWZ1bmN0aW9uKGUsdCl7aWYoaXNOYU4oZSl8fGlzTmFOKHQpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLkFQSS5fX2Fjcm9mb3JtX18uY2xlYXJCaXRGb3JQZGYiKTtyZXR1cm4gSihlLHQtMSl9LEFlPUQuX19hY3JvZm9ybV9fLmNhbGN1bGF0ZUNvb3JkaW5hdGVzPWZ1bmN0aW9uKGUsdCl7dmFyIEE9dC5pbnRlcm5hbC5nZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSxyPXQuaW50ZXJuYWwuZ2V0VmVydGljYWxDb29yZGluYXRlLG49ZVswXSxzPWVbMV0saT1lWzJdLG89ZVszXSxhPXt9O3JldHVybiBhLmxvd2VyTGVmdF9YPUEobil8fDAsYS5sb3dlckxlZnRfWT1yKHMrbyl8fDAsYS51cHBlclJpZ2h0X1g9QShuK2kpfHwwLGEudXBwZXJSaWdodF9ZPXIocyl8fDAsW051bWJlcihHKGEubG93ZXJMZWZ0X1gpKSxOdW1iZXIoRyhhLmxvd2VyTGVmdF9ZKSksTnVtYmVyKEcoYS51cHBlclJpZ2h0X1gpKSxOdW1iZXIoRyhhLnVwcGVyUmlnaHRfWSkpXX0scmU9ZnVuY3Rpb24oZSl7aWYoZS5hcHBlYXJhbmNlU3RyZWFtQ29udGVudClyZXR1cm4gZS5hcHBlYXJhbmNlU3RyZWFtQ29udGVudDtpZihlLlZ8fGUuRFYpe3ZhciB0PVtdLEE9ZS5fVnx8ZS5EVixyPW5lKGUsQSksbj1lLnNjb3BlLmludGVybmFsLmdldEZvbnQoZS5mb250TmFtZSxlLmZvbnRTdHlsZSkuaWQ7dC5wdXNoKCIvVHggQk1DIiksdC5wdXNoKCJxIiksdC5wdXNoKCJCVCIpLHQucHVzaChlLnNjb3BlLl9fcHJpdmF0ZV9fLmVuY29kZUNvbG9yU3RyaW5nKGUuY29sb3IpKSx0LnB1c2goIi8iK24rIiAiK0coci5mb250U2l6ZSkrIiBUZiIpLHQucHVzaCgiMSAwIDAgMSAwIDAgVG0iKSx0LnB1c2goci50ZXh0KSx0LnB1c2goIkVUIiksdC5wdXNoKCJRIiksdC5wdXNoKCJFTUMiKTt2YXIgcz1YKGUpO3JldHVybiBzLnNjb3BlPWUuc2NvcGUscy5zdHJlYW09dC5qb2luKCJcbiIpLHN9fSxuZT1mdW5jdGlvbihlLHQpe3ZhciBBPTA9PT1lLmZvbnRTaXplP2UubWF4Rm9udFNpemU6ZS5mb250U2l6ZSxyPXt0ZXh0OiIiLGZvbnRTaXplOiIifSxuPSh0PSIpIj09KHQ9IigiPT10LnN1YnN0cigwLDEpP3Quc3Vic3RyKDEpOnQpLnN1YnN0cih0Lmxlbmd0aC0xKT90LnN1YnN0cigwLHQubGVuZ3RoLTEpOnQpLnNwbGl0KCIgIik7bj1lLm11bHRpbGluZT9uLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdCgiXG4iKX0pOm4ubWFwKGZ1bmN0aW9uKGUpe3JldHVybltlXX0pO3ZhciBzPUEsaT1qZS5pbnRlcm5hbC5nZXRIZWlnaHQoZSl8fDA7aT1pPDA/LWk6aTt2YXIgbz1qZS5pbnRlcm5hbC5nZXRXaWR0aChlKXx8MDtvPW88MD8tbzpvO3ZhciBhPWZ1bmN0aW9uKHQsQSxyKXtpZih0KzE8bi5sZW5ndGgpe3ZhciBzPUErIiAiK25bdCsxXVswXTtyZXR1cm4gc2UocyxlLHIpLndpZHRoPD1vLTR9cmV0dXJuITF9O3MrKztlOmZvcig7cz4wOyl7dD0iIixzLS07dmFyIGwsYyx1PXNlKCIzIixlLHMpLmhlaWdodCxoPWUubXVsdGlsaW5lP2ktczooaS11KS8yLGQ9aCs9MixmPTAscD0wLGc9MDtpZihzPD0wKXt0PSIoLi4uKSBUalxuIix0Kz0iJSBXaWR0aCBvZiBUZXh0OiAiK3NlKHQsZSxzPTEyKS53aWR0aCsiLCBGaWVsZFdpZHRoOiIrbysiXG4iO2JyZWFrfWZvcih2YXIgbT0iIix3PTAsQj0wO0I8bi5sZW5ndGg7QisrKWlmKG4uaGFzT3duUHJvcGVydHkoQikpe3ZhciB5PSExO2lmKDEhPT1uW0JdLmxlbmd0aCYmZyE9PW5bQl0ubGVuZ3RoLTEpe2lmKCh1KzIpKih3KzIpKzI+aSljb250aW51ZSBlO20rPW5bQl1bZ10seT0hMCxwPUIsQi0tfWVsc2V7bT0iICI9PShtKz1uW0JdW2ddKyIgIikuc3Vic3RyKG0ubGVuZ3RoLTEpP20uc3Vic3RyKDAsbS5sZW5ndGgtMSk6bTt2YXIgdj1wYXJzZUludChCKSxiPWEodixtLHMpLEM9Qj49bi5sZW5ndGgtMTtpZihiJiYhQyl7bSs9IiAiLGc9MDtjb250aW51ZX1pZihifHxDKXtpZihDKXA9djtlbHNlIGlmKGUubXVsdGlsaW5lJiYodSsyKSoodysyKSsyPmkpY29udGludWUgZX1lbHNle2lmKCFlLm11bHRpbGluZSljb250aW51ZSBlO2lmKCh1KzIpKih3KzIpKzI+aSljb250aW51ZSBlO3A9dn19Zm9yKHZhciBfPSIiLGo9ZjtqPD1wO2orKyl7dmFyIHg9bltqXTtpZihlLm11bHRpbGluZSl7aWYoaj09PXApe18rPXhbZ10rIiAiLGc9KGcrMSkleC5sZW5ndGg7Y29udGludWV9aWYoaj09PWYpe18rPXhbeC5sZW5ndGgtMV0rIiAiO2NvbnRpbnVlfX1fKz14WzBdKyIgIn1zd2l0Y2goXz0iICI9PV8uc3Vic3RyKF8ubGVuZ3RoLTEpP18uc3Vic3RyKDAsXy5sZW5ndGgtMSk6XyxjPXNlKF8sZSxzKS53aWR0aCxlLnRleHRBbGlnbil7Y2FzZSJyaWdodCI6bD1vLWMtMjticmVhaztjYXNlImNlbnRlciI6bD0oby1jKS8yO2JyZWFrO2RlZmF1bHQ6bD0yfXQrPUcobCkrIiAiK0coZCkrIiBUZFxuIix0Kz0iKCIrSyhfKSsiKSBUalxuIix0Kz0tRyhsKSsiIDAgVGRcbiIsZD0tKHMrMiksYz0wLGY9eT9wOnArMSx3KyssbT0iIn1icmVha31yZXR1cm4gci50ZXh0PXQsci5mb250U2l6ZT1zLHJ9LHNlPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcj10LnNjb3BlLmludGVybmFsLmdldEZvbnQodC5mb250TmFtZSx0LmZvbnRTdHlsZSksbj10LnNjb3BlLmdldFN0cmluZ1VuaXRXaWR0aChlLHtmb250OnIsZm9udFNpemU6cGFyc2VGbG9hdChBKSxjaGFyU3BhY2U6MH0pKnBhcnNlRmxvYXQoQSk7cmV0dXJue2hlaWdodDp0LnNjb3BlLmdldFN0cmluZ1VuaXRXaWR0aCgiMyIse2ZvbnQ6cixmb250U2l6ZTpwYXJzZUZsb2F0KEEpLGNoYXJTcGFjZTowfSkqcGFyc2VGbG9hdChBKSoxLjUsd2lkdGg6bn19LGllPXtmaWVsZHM6W10seEZvcm1zOltdLGFjcm9Gb3JtRGljdGlvbmFyeVJvb3Q6bnVsbCxwcmludGVkT3V0OiExLGludGVybmFsOm51bGwsaXNJbml0aWFsaXplZDohMX0sb2U9ZnVuY3Rpb24oZSx0KXt2YXIgQT17dHlwZToicmVmZXJlbmNlIixvYmplY3Q6ZX07dm9pZCAwPT09dC5pbnRlcm5hbC5nZXRQYWdlSW5mbyhlLnBhZ2UpLnBhZ2VDb250ZXh0LmFubm90YXRpb25zLmZpbmQoZnVuY3Rpb24oZSl7cmV0dXJuIGUudHlwZT09PUEudHlwZSYmZS5vYmplY3Q9PT1BLm9iamVjdH0pJiZ0LmludGVybmFsLmdldFBhZ2VJbmZvKGUucGFnZSkucGFnZUNvbnRleHQuYW5ub3RhdGlvbnMucHVzaChBKX0sYWU9RC5fX2Fjcm9mb3JtX18uYXJyYXlUb1BkZkFycmF5PWZ1bmN0aW9uKGUsdCxBKXt2YXIgbj1mdW5jdGlvbihlKXtyZXR1cm4gZX07aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciBzPSJbIixpPTA7aTxlLmxlbmd0aDtpKyspc3dpdGNoKDAhPT1pJiYocys9IiAiKSwoMCxyLmRlZmF1bHQpKGVbaV0pKXtjYXNlImJvb2xlYW4iOmNhc2UibnVtYmVyIjpjYXNlIm9iamVjdCI6cys9ZVtpXS50b1N0cmluZygpO2JyZWFrO2Nhc2Uic3RyaW5nIjoiLyIhPT1lW2ldLnN1YnN0cigwLDEpPyh2b2lkIDAhPT10JiZBJiYobj1BLmludGVybmFsLmdldEVuY3J5cHRvcih0KSkscys9IigiK0sobihlW2ldLnRvU3RyaW5nKCkpKSsiKSIpOnMrPWVbaV0udG9TdHJpbmcoKX1yZXR1cm4gcysiXSJ9dGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5fX2Fjcm9mb3JtX18uYXJyYXlUb1BkZkFycmF5Iil9LGxlPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcj1mdW5jdGlvbihlKXtyZXR1cm4gZX07cmV0dXJuIHZvaWQgMCE9PXQmJkEmJihyPUEuaW50ZXJuYWwuZ2V0RW5jcnlwdG9yKHQpKSwoZT1lfHwiIikudG9TdHJpbmcoKSwiKCIrSyhyKGUpKSsiKSJ9LGNlPWZ1bmN0aW9uKCl7dGhpcy5fb2JqSWQ9dm9pZCAwLHRoaXMuX3Njb3BlPXZvaWQgMCxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywib2JqSWQiLHtnZXQ6ZnVuY3Rpb24oKXtpZih2b2lkIDA9PT10aGlzLl9vYmpJZCl7aWYodm9pZCAwPT09dGhpcy5zY29wZSlyZXR1cm47dGhpcy5fb2JqSWQ9dGhpcy5zY29wZS5pbnRlcm5hbC5uZXdPYmplY3REZWZlcnJlZCgpfXJldHVybiB0aGlzLl9vYmpJZH0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX29iaklkPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNjb3BlIix7dmFsdWU6dGhpcy5fc2NvcGUsd3JpdGFibGU6ITB9KX07Y2UucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2JqSWQrIiAwIFIifSxjZS5wcm90b3R5cGUucHV0U3RyZWFtPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5nZXRLZXlWYWx1ZUxpc3RGb3JTdHJlYW0oKTt0aGlzLnNjb3BlLmludGVybmFsLnB1dFN0cmVhbSh7ZGF0YTp0aGlzLnN0cmVhbSxhZGRpdGlvbmFsS2V5VmFsdWVzOmUsb2JqZWN0SWQ6dGhpcy5vYmpJZH0pLHRoaXMuc2NvcGUuaW50ZXJuYWwub3V0KCJlbmRvYmoiKX0sY2UucHJvdG90eXBlLmdldEtleVZhbHVlTGlzdEZvclN0cmVhbT1mdW5jdGlvbigpe3ZhciBlPVtdLHQ9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiJjb250ZW50IiE9ZSYmImFwcGVhcmFuY2VTdHJlYW1Db250ZW50IiE9ZSYmInNjb3BlIiE9ZSYmIm9iaklkIiE9ZSYmIl8iIT1lLnN1YnN0cmluZygwLDEpfSk7Zm9yKHZhciBBIGluIHQpaWYoITE9PT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsdFtBXSkuY29uZmlndXJhYmxlKXt2YXIgcj10W0FdLG49dGhpc1tyXTtuJiYoQXJyYXkuaXNBcnJheShuKT9lLnB1c2goe2tleTpyLHZhbHVlOmFlKG4sdGhpcy5vYmpJZCx0aGlzLnNjb3BlKX0pOm4gaW5zdGFuY2VvZiBjZT8obi5zY29wZT10aGlzLnNjb3BlLGUucHVzaCh7a2V5OnIsdmFsdWU6bi5vYmpJZCsiIDAgUiJ9KSk6ImZ1bmN0aW9uIiE9dHlwZW9mIG4mJmUucHVzaCh7a2V5OnIsdmFsdWU6bn0pKX1yZXR1cm4gZX07dmFyIHVlPWZ1bmN0aW9uKCl7Y2UuY2FsbCh0aGlzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiVHlwZSIse3ZhbHVlOiIvWE9iamVjdCIsY29uZmlndXJhYmxlOiExLHdyaXRhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlN1YnR5cGUiLHt2YWx1ZToiL0Zvcm0iLGNvbmZpZ3VyYWJsZTohMSx3cml0YWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJGb3JtVHlwZSIse3ZhbHVlOjEsY29uZmlndXJhYmxlOiExLHdyaXRhYmxlOiEwfSk7dmFyIGUsdD1bXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiQkJveCIse2NvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH0sc2V0OmZ1bmN0aW9uKGUpe3Q9ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiUmVzb3VyY2VzIix7dmFsdWU6IjIgMCBSIixjb25maWd1cmFibGU6ITEsd3JpdGFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3RyZWFtIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITAsc2V0OmZ1bmN0aW9uKHQpe2U9dC50cmltKCl9LGdldDpmdW5jdGlvbigpe3JldHVybiBlfHxudWxsfX0pfTtxKHVlLGNlKTt2YXIgaGU9ZnVuY3Rpb24oKXtjZS5jYWxsKHRoaXMpO3ZhciBlLHQ9W107T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIktpZHMiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5sZW5ndGg+MD90OnZvaWQgMH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiRmllbGRzIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIkRBIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7aWYoZSl7dmFyIHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9O3JldHVybiB0aGlzLnNjb3BlJiYodD10aGlzLnNjb3BlLmludGVybmFsLmdldEVuY3J5cHRvcih0aGlzLm9iaklkKSksIigiK0sodChlKSkrIikifX0sc2V0OmZ1bmN0aW9uKHQpe2U9dH19KX07cShoZSxjZSk7dmFyIGRlPWZ1bmN0aW9uIGUoKXtjZS5jYWxsKHRoaXMpO3ZhciB0PTQ7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIkYiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH0sc2V0OmZ1bmN0aW9uKGUpe2lmKGlzTmFOKGUpKXRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSAiJytlKyciIGZvciBhdHRyaWJ1dGUgRiBzdXBwbGllZC4nKTt0PWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNob3dXaGVuUHJpbnRlZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKCQodCwzKSl9LHNldDpmdW5jdGlvbihlKXshMD09PUJvb2xlYW4oZSk/dGhpcy5GPWVlKHQsMyk6dGhpcy5GPXRlKHQsMyl9fSk7dmFyIEE9MDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiRmYiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQX0sc2V0OmZ1bmN0aW9uKGUpe2lmKGlzTmFOKGUpKXRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSAiJytlKyciIGZvciBhdHRyaWJ1dGUgRmYgc3VwcGxpZWQuJyk7QT1lfX0pO3ZhciByPVtdO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJSZWN0Iix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7aWYoMCE9PXIubGVuZ3RoKXJldHVybiByfSxzZXQ6ZnVuY3Rpb24oZSl7cj12b2lkIDAhPT1lP2U6W119fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4hcnx8aXNOYU4oclswXSk/MDpyWzBdfSxzZXQ6ZnVuY3Rpb24oZSl7clswXT1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIXJ8fGlzTmFOKHJbMV0pPzA6clsxXX0sc2V0OmZ1bmN0aW9uKGUpe3JbMV09ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid2lkdGgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4hcnx8aXNOYU4oclsyXSk/MDpyWzJdfSxzZXQ6ZnVuY3Rpb24oZSl7clsyXT1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJoZWlnaHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4hcnx8aXNOYU4oclszXSk/MDpyWzNdfSxzZXQ6ZnVuY3Rpb24oZSl7clszXT1lfX0pO3ZhciBuPSIiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJGVCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiBufSxzZXQ6ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2UiL0J0biI6Y2FzZSIvVHgiOmNhc2UiL0NoIjpjYXNlIi9TaWciOm49ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSAiJytlKyciIGZvciBhdHRyaWJ1dGUgRlQgc3VwcGxpZWQuJyl9fX0pO3ZhciBzPW51bGw7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtpZighc3x8cy5sZW5ndGg8MSl7aWYodGhpcyBpbnN0YW5jZW9mIHZlKXJldHVybjtzPSJGaWVsZE9iamVjdCIrZS5GaWVsZE51bSsrfXZhciB0PWZ1bmN0aW9uKGUpe3JldHVybiBlfTtyZXR1cm4gdGhpcy5zY29wZSYmKHQ9dGhpcy5zY29wZS5pbnRlcm5hbC5nZXRFbmNyeXB0b3IodGhpcy5vYmpJZCkpLCIoIitLKHQocykpKyIpIn0sc2V0OmZ1bmN0aW9uKGUpe3M9ZS50b1N0cmluZygpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmaWVsZE5hbWUiLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gc30sc2V0OmZ1bmN0aW9uKGUpe3M9ZX19KTt2YXIgaT0iaGVsdmV0aWNhIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZm9udE5hbWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sc2V0OmZ1bmN0aW9uKGUpe2k9ZX19KTt2YXIgbz0ibm9ybWFsIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZm9udFN0eWxlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG99LHNldDpmdW5jdGlvbihlKXtvPWV9fSk7dmFyIGE9MDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZm9udFNpemUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYX0sc2V0OmZ1bmN0aW9uKGUpe2E9ZX19KTt2YXIgbD12b2lkIDA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm1heEZvbnRTaXplIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PWw/NTAvUjpsfSxzZXQ6ZnVuY3Rpb24oZSl7bD1lfX0pO3ZhciBjPSJibGFjayI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbG9yIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGN9LHNldDpmdW5jdGlvbihlKXtjPWV9fSk7dmFyIHU9Ii9GMSAwIFRmIDAgZyI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIkRBIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7aWYoISghdXx8dGhpcyBpbnN0YW5jZW9mIHZlfHx0aGlzIGluc3RhbmNlb2YgQ2UpKXJldHVybiBsZSh1LHRoaXMub2JqSWQsdGhpcy5zY29wZSl9LHNldDpmdW5jdGlvbihlKXtlPWUudG9TdHJpbmcoKSx1PWV9fSk7dmFyIGg9bnVsbDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiRFYiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtpZihoKXJldHVybiB0aGlzIGluc3RhbmNlb2Ygd2U9PTA/bGUoaCx0aGlzLm9iaklkLHRoaXMuc2NvcGUpOmh9LHNldDpmdW5jdGlvbihlKXtlPWUudG9TdHJpbmcoKSxoPXRoaXMgaW5zdGFuY2VvZiB3ZT09MD8iKCI9PT1lLnN1YnN0cigwLDEpP1YoZS5zdWJzdHIoMSxlLmxlbmd0aC0yKSk6VihlKTplfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkZWZhdWx0VmFsdWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIHdlPT0xP1YoaC5zdWJzdHIoMSxoLmxlbmd0aC0xKSk6aH0sc2V0OmZ1bmN0aW9uKGUpe2U9ZS50b1N0cmluZygpLGg9dGhpcyBpbnN0YW5jZW9mIHdlPT0xPyIvIitlOmV9fSk7dmFyIGQ9bnVsbDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiX1YiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtpZihkKXJldHVybiBkfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5WPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlYiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtpZihkKXJldHVybiB0aGlzIGluc3RhbmNlb2Ygd2U9PTA/bGUoZCx0aGlzLm9iaklkLHRoaXMuc2NvcGUpOmR9LHNldDpmdW5jdGlvbihlKXtlPWUudG9TdHJpbmcoKSxkPXRoaXMgaW5zdGFuY2VvZiB3ZT09MD8iKCI9PT1lLnN1YnN0cigwLDEpP1YoZS5zdWJzdHIoMSxlLmxlbmd0aC0yKSk6VihlKTplfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ2YWx1ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzIGluc3RhbmNlb2Ygd2U9PTE/VihkLnN1YnN0cigxLGQubGVuZ3RoLTEpKTpkfSxzZXQ6ZnVuY3Rpb24oZSl7ZT1lLnRvU3RyaW5nKCksZD10aGlzIGluc3RhbmNlb2Ygd2U9PTE/Ii8iK2U6ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaGFzQW5ub3RhdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLlJlY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNBbm5vdGF0aW9uPyIvQW5ub3QiOm51bGx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlN1YnR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNBbm5vdGF0aW9uPyIvV2lkZ2V0IjpudWxsfX0pO3ZhciBmLHA9ITE7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImhhc0FwcGVhcmFuY2VTdHJlYW0iLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcH0sc2V0OmZ1bmN0aW9uKGUpe2U9Qm9vbGVhbihlKSxwPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhZ2UiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtpZihmKXJldHVybiBmfSxzZXQ6ZnVuY3Rpb24oZSl7Zj1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJyZWFkT25seSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKCQodGhpcy5GZiwxKSl9LHNldDpmdW5jdGlvbihlKXshMD09PUJvb2xlYW4oZSk/dGhpcy5GZj1lZSh0aGlzLkZmLDEpOnRoaXMuRmY9dGUodGhpcy5GZiwxKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicmVxdWlyZWQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbigkKHRoaXMuRmYsMikpfSxzZXQ6ZnVuY3Rpb24oZSl7ITA9PT1Cb29sZWFuKGUpP3RoaXMuRmY9ZWUodGhpcy5GZiwyKTp0aGlzLkZmPXRlKHRoaXMuRmYsMil9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm5vRXhwb3J0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oJCh0aGlzLkZmLDMpKX0sc2V0OmZ1bmN0aW9uKGUpeyEwPT09Qm9vbGVhbihlKT90aGlzLkZmPWVlKHRoaXMuRmYsMyk6dGhpcy5GZj10ZSh0aGlzLkZmLDMpfX0pO3ZhciBnPW51bGw7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlEiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtpZihudWxsIT09ZylyZXR1cm4gZ30sc2V0OmZ1bmN0aW9uKGUpe2lmKC0xPT09WzAsMSwyXS5pbmRleE9mKGUpKXRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSAiJytlKyciIGZvciBhdHRyaWJ1dGUgUSBzdXBwbGllZC4nKTtnPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRleHRBbGlnbiIse2dldDpmdW5jdGlvbigpe3ZhciBlO3N3aXRjaChnKXtjYXNlIDA6ZGVmYXVsdDplPSJsZWZ0IjticmVhaztjYXNlIDE6ZT0iY2VudGVyIjticmVhaztjYXNlIDI6ZT0icmlnaHQifXJldHVybiBlfSxjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCxzZXQ6ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2UicmlnaHQiOmNhc2UgMjpnPTI7YnJlYWs7Y2FzZSJjZW50ZXIiOmNhc2UgMTpnPTE7YnJlYWs7ZGVmYXVsdDpnPTB9fX0pfTtxKGRlLGNlKTt2YXIgZmU9ZnVuY3Rpb24oKXtkZS5jYWxsKHRoaXMpLHRoaXMuRlQ9Ii9DaCIsdGhpcy5WPSIoKSIsdGhpcy5mb250TmFtZT0iemFwZmRpbmdiYXRzIjt2YXIgZT0wO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJUSSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiBlfSxzZXQ6ZnVuY3Rpb24odCl7ZT10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b3BJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlfSxzZXQ6ZnVuY3Rpb24odCl7ZT10fX0pO3ZhciB0PVtdO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJPcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYWUodCx0aGlzLm9iaklkLHRoaXMuc2NvcGUpfSxzZXQ6ZnVuY3Rpb24oZSl7dmFyIEEscjtyPVtdLCJzdHJpbmciPT10eXBlb2YoQT1lKSYmKHI9ZnVuY3Rpb24oZSx0LEEpe0F8fChBPTEpO2Zvcih2YXIgcixuPVtdO3I9dC5leGVjKGUpOyluLnB1c2gocltBXSk7cmV0dXJuIG59KEEsL1woKC4qPylcKS9nKSksdD1yfX0pLHRoaXMuZ2V0T3B0aW9ucz1mdW5jdGlvbigpe3JldHVybiB0fSx0aGlzLnNldE9wdGlvbnM9ZnVuY3Rpb24oZSl7dD1lLHRoaXMuc29ydCYmdC5zb3J0KCl9LHRoaXMuYWRkT3B0aW9uPWZ1bmN0aW9uKGUpe2U9KGU9ZXx8IiIpLnRvU3RyaW5nKCksdC5wdXNoKGUpLHRoaXMuc29ydCYmdC5zb3J0KCl9LHRoaXMucmVtb3ZlT3B0aW9uPWZ1bmN0aW9uKGUsQSl7Zm9yKEE9QXx8ITEsZT0oZT1lfHwiIikudG9TdHJpbmcoKTstMSE9PXQuaW5kZXhPZihlKSYmKHQuc3BsaWNlKHQuaW5kZXhPZihlKSwxKSwhMSE9PUEpOyk7fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYm8iLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbigkKHRoaXMuRmYsMTgpKX0sc2V0OmZ1bmN0aW9uKGUpeyEwPT09Qm9vbGVhbihlKT90aGlzLkZmPWVlKHRoaXMuRmYsMTgpOnRoaXMuRmY9dGUodGhpcy5GZiwxOCl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImVkaXQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbigkKHRoaXMuRmYsMTkpKX0sc2V0OmZ1bmN0aW9uKGUpeyEwPT09dGhpcy5jb21ibyYmKCEwPT09Qm9vbGVhbihlKT90aGlzLkZmPWVlKHRoaXMuRmYsMTkpOnRoaXMuRmY9dGUodGhpcy5GZiwxOSkpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzb3J0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oJCh0aGlzLkZmLDIwKSl9LHNldDpmdW5jdGlvbihlKXshMD09PUJvb2xlYW4oZSk/KHRoaXMuRmY9ZWUodGhpcy5GZiwyMCksdC5zb3J0KCkpOnRoaXMuRmY9dGUodGhpcy5GZiwyMCl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm11bHRpU2VsZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oJCh0aGlzLkZmLDIyKSl9LHNldDpmdW5jdGlvbihlKXshMD09PUJvb2xlYW4oZSk/dGhpcy5GZj1lZSh0aGlzLkZmLDIyKTp0aGlzLkZmPXRlKHRoaXMuRmYsMjIpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkb05vdFNwZWxsQ2hlY2siLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbigkKHRoaXMuRmYsMjMpKX0sc2V0OmZ1bmN0aW9uKGUpeyEwPT09Qm9vbGVhbihlKT90aGlzLkZmPWVlKHRoaXMuRmYsMjMpOnRoaXMuRmY9dGUodGhpcy5GZiwyMyl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNvbW1pdE9uU2VsQ2hhbmdlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oJCh0aGlzLkZmLDI3KSl9LHNldDpmdW5jdGlvbihlKXshMD09PUJvb2xlYW4oZSk/dGhpcy5GZj1lZSh0aGlzLkZmLDI3KTp0aGlzLkZmPXRlKHRoaXMuRmYsMjcpfX0pLHRoaXMuaGFzQXBwZWFyYW5jZVN0cmVhbT0hMX07cShmZSxkZSk7dmFyIHBlPWZ1bmN0aW9uKCl7ZmUuY2FsbCh0aGlzKSx0aGlzLmZvbnROYW1lPSJoZWx2ZXRpY2EiLHRoaXMuY29tYm89ITF9O3EocGUsZmUpO3ZhciBnZT1mdW5jdGlvbigpe3BlLmNhbGwodGhpcyksdGhpcy5jb21ibz0hMH07cShnZSxwZSk7dmFyIG1lPWZ1bmN0aW9uKCl7Z2UuY2FsbCh0aGlzKSx0aGlzLmVkaXQ9ITB9O3EobWUsZ2UpO3ZhciB3ZT1mdW5jdGlvbigpe2RlLmNhbGwodGhpcyksdGhpcy5GVD0iL0J0biIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm5vVG9nZ2xlVG9PZmYiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbigkKHRoaXMuRmYsMTUpKX0sc2V0OmZ1bmN0aW9uKGUpeyEwPT09Qm9vbGVhbihlKT90aGlzLkZmPWVlKHRoaXMuRmYsMTUpOnRoaXMuRmY9dGUodGhpcy5GZiwxNSl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInJhZGlvIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oJCh0aGlzLkZmLDE2KSl9LHNldDpmdW5jdGlvbihlKXshMD09PUJvb2xlYW4oZSk/dGhpcy5GZj1lZSh0aGlzLkZmLDE2KTp0aGlzLkZmPXRlKHRoaXMuRmYsMTYpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwdXNoQnV0dG9uIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oJCh0aGlzLkZmLDE3KSl9LHNldDpmdW5jdGlvbihlKXshMD09PUJvb2xlYW4oZSk/dGhpcy5GZj1lZSh0aGlzLkZmLDE3KTp0aGlzLkZmPXRlKHRoaXMuRmYsMTcpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJyYWRpb0lzVW5pc29uIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oJCh0aGlzLkZmLDI2KSl9LHNldDpmdW5jdGlvbihlKXshMD09PUJvb2xlYW4oZSk/dGhpcy5GZj1lZSh0aGlzLkZmLDI2KTp0aGlzLkZmPXRlKHRoaXMuRmYsMjYpfX0pO3ZhciBlLHQ9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIk1LIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7dmFyIGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9O2lmKHRoaXMuc2NvcGUmJihlPXRoaXMuc2NvcGUuaW50ZXJuYWwuZ2V0RW5jcnlwdG9yKHRoaXMub2JqSWQpKSwwIT09T2JqZWN0LmtleXModCkubGVuZ3RoKXt2YXIgQSxyPVtdO2ZvcihBIGluIHIucHVzaCgiPDwiKSx0KXIucHVzaCgiLyIrQSsiICgiK0soZSh0W0FdKSkrIikiKTtyZXR1cm4gci5wdXNoKCI+PiIpLHIuam9pbigiXG4iKX19LHNldDpmdW5jdGlvbihlKXsib2JqZWN0Ij09PSgwLHIuZGVmYXVsdCkoZSkmJih0PWUpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYXB0aW9uIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuQ0F8fCIifSxzZXQ6ZnVuY3Rpb24oZSl7InN0cmluZyI9PXR5cGVvZiBlJiYodC5DQT1lKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiQVMiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZX0sc2V0OmZ1bmN0aW9uKHQpe2U9dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYXBwZWFyYW5jZVN0YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuc3Vic3RyKDEsZS5sZW5ndGgtMSl9LHNldDpmdW5jdGlvbih0KXtlPSIvIit0fX0pfTtxKHdlLGRlKTt2YXIgQmU9ZnVuY3Rpb24oKXt3ZS5jYWxsKHRoaXMpLHRoaXMucHVzaEJ1dHRvbj0hMH07cShCZSx3ZSk7dmFyIHllPWZ1bmN0aW9uKCl7d2UuY2FsbCh0aGlzKSx0aGlzLnJhZGlvPSEwLHRoaXMucHVzaEJ1dHRvbj0hMTt2YXIgZT1bXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiS2lkcyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiBlfSxzZXQ6ZnVuY3Rpb24odCl7ZT12b2lkIDAhPT10P3Q6W119fSl9O3EoeWUsd2UpO3ZhciB2ZT1mdW5jdGlvbigpe3ZhciBlLHQ7ZGUuY2FsbCh0aGlzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiUGFyZW50Iix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGV9LHNldDpmdW5jdGlvbih0KXtlPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9wdGlvbk5hbWUiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH0sc2V0OmZ1bmN0aW9uKGUpe3Q9ZX19KTt2YXIgQSxuPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJNSyIse2VudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3ZhciBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfTt0aGlzLnNjb3BlJiYoZT10aGlzLnNjb3BlLmludGVybmFsLmdldEVuY3J5cHRvcih0aGlzLm9iaklkKSk7dmFyIHQsQT1bXTtmb3IodCBpbiBBLnB1c2goIjw8IiksbilBLnB1c2goIi8iK3QrIiAoIitLKGUoblt0XSkpKyIpIik7cmV0dXJuIEEucHVzaCgiPj4iKSxBLmpvaW4oIlxuIil9LHNldDpmdW5jdGlvbihlKXsib2JqZWN0Ij09PSgwLHIuZGVmYXVsdCkoZSkmJihuPWUpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjYXB0aW9uIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uQ0F8fCIifSxzZXQ6ZnVuY3Rpb24oZSl7InN0cmluZyI9PXR5cGVvZiBlJiYobi5DQT1lKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiQVMiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQX0sc2V0OmZ1bmN0aW9uKGUpe0E9ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiYXBwZWFyYW5jZVN0YXRlIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEEuc3Vic3RyKDEsQS5sZW5ndGgtMSl9LHNldDpmdW5jdGlvbihlKXtBPSIvIitlfX0pLHRoaXMuY2FwdGlvbj0ibCIsdGhpcy5hcHBlYXJhbmNlU3RhdGU9Ik9mZiIsdGhpcy5fQXBwZWFyYW5jZVR5cGU9amUuUmFkaW9CdXR0b24uQ2lyY2xlLHRoaXMuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQ9dGhpcy5fQXBwZWFyYW5jZVR5cGUuY3JlYXRlQXBwZWFyYW5jZVN0cmVhbSh0aGlzLm9wdGlvbk5hbWUpfTtxKHZlLGRlKSx5ZS5wcm90b3R5cGUuc2V0QXBwZWFyYW5jZT1mdW5jdGlvbihlKXtpZighKCJjcmVhdGVBcHBlYXJhbmNlU3RyZWFtImluIGUpfHwhKCJnZXRDQSJpbiBlKSl0aHJvdyBuZXcgRXJyb3IoIkNvdWxkbid0IGFzc2lnbiBBcHBlYXJhbmNlIHRvIFJhZGlvQnV0dG9uLiBBcHBlYXJhbmNlIHdhcyBJbnZhbGlkISIpO2Zvcih2YXIgdCBpbiB0aGlzLktpZHMpaWYodGhpcy5LaWRzLmhhc093blByb3BlcnR5KHQpKXt2YXIgQT10aGlzLktpZHNbdF07QS5hcHBlYXJhbmNlU3RyZWFtQ29udGVudD1lLmNyZWF0ZUFwcGVhcmFuY2VTdHJlYW0oQS5vcHRpb25OYW1lKSxBLmNhcHRpb249ZS5nZXRDQSgpfX0seWUucHJvdG90eXBlLmNyZWF0ZU9wdGlvbj1mdW5jdGlvbihlKXt2YXIgdD1uZXcgdmU7cmV0dXJuIHQuUGFyZW50PXRoaXMsdC5vcHRpb25OYW1lPWUsdGhpcy5LaWRzLnB1c2godCkseGUuY2FsbCh0aGlzLnNjb3BlLHQpLHR9O3ZhciBiZT1mdW5jdGlvbigpe3dlLmNhbGwodGhpcyksdGhpcy5mb250TmFtZT0iemFwZmRpbmdiYXRzIix0aGlzLmNhcHRpb249IjMiLHRoaXMuYXBwZWFyYW5jZVN0YXRlPSJPbiIsdGhpcy52YWx1ZT0iT24iLHRoaXMudGV4dEFsaWduPSJjZW50ZXIiLHRoaXMuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQ9amUuQ2hlY2tCb3guY3JlYXRlQXBwZWFyYW5jZVN0cmVhbSgpfTtxKGJlLHdlKTt2YXIgQ2U9ZnVuY3Rpb24oKXtkZS5jYWxsKHRoaXMpLHRoaXMuRlQ9Ii9UeCIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm11bHRpbGluZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKCQodGhpcy5GZiwxMykpfSxzZXQ6ZnVuY3Rpb24oZSl7ITA9PT1Cb29sZWFuKGUpP3RoaXMuRmY9ZWUodGhpcy5GZiwxMyk6dGhpcy5GZj10ZSh0aGlzLkZmLDEzKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZmlsZVNlbGVjdCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKCQodGhpcy5GZiwyMSkpfSxzZXQ6ZnVuY3Rpb24oZSl7ITA9PT1Cb29sZWFuKGUpP3RoaXMuRmY9ZWUodGhpcy5GZiwyMSk6dGhpcy5GZj10ZSh0aGlzLkZmLDIxKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZG9Ob3RTcGVsbENoZWNrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oJCh0aGlzLkZmLDIzKSl9LHNldDpmdW5jdGlvbihlKXshMD09PUJvb2xlYW4oZSk/dGhpcy5GZj1lZSh0aGlzLkZmLDIzKTp0aGlzLkZmPXRlKHRoaXMuRmYsMjMpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkb05vdFNjcm9sbCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKCQodGhpcy5GZiwyNCkpfSxzZXQ6ZnVuY3Rpb24oZSl7ITA9PT1Cb29sZWFuKGUpP3RoaXMuRmY9ZWUodGhpcy5GZiwyNCk6dGhpcy5GZj10ZSh0aGlzLkZmLDI0KX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKCQodGhpcy5GZiwyNSkpfSxzZXQ6ZnVuY3Rpb24oZSl7ITA9PT1Cb29sZWFuKGUpP3RoaXMuRmY9ZWUodGhpcy5GZiwyNSk6dGhpcy5GZj10ZSh0aGlzLkZmLDI1KX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicmljaFRleHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbigkKHRoaXMuRmYsMjYpKX0sc2V0OmZ1bmN0aW9uKGUpeyEwPT09Qm9vbGVhbihlKT90aGlzLkZmPWVlKHRoaXMuRmYsMjYpOnRoaXMuRmY9dGUodGhpcy5GZiwyNil9fSk7dmFyIGU9bnVsbDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiTWF4TGVuIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGV9LHNldDpmdW5jdGlvbih0KXtlPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm1heExlbmd0aCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlfSxzZXQ6ZnVuY3Rpb24odCl7TnVtYmVyLmlzSW50ZWdlcih0KSYmKGU9dCl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImhhc0FwcGVhcmFuY2VTdHJlYW0iLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5WfHx0aGlzLkRWfX0pfTtxKENlLGRlKTt2YXIgX2U9ZnVuY3Rpb24oKXtDZS5jYWxsKHRoaXMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwYXNzd29yZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKCQodGhpcy5GZiwxNCkpfSxzZXQ6ZnVuY3Rpb24oZSl7ITA9PT1Cb29sZWFuKGUpP3RoaXMuRmY9ZWUodGhpcy5GZiwxNCk6dGhpcy5GZj10ZSh0aGlzLkZmLDE0KX19KSx0aGlzLnBhc3N3b3JkPSEwfTtxKF9lLENlKTt2YXIgamU9e0NoZWNrQm94OntjcmVhdGVBcHBlYXJhbmNlU3RyZWFtOmZ1bmN0aW9uKCl7cmV0dXJue046e09uOmplLkNoZWNrQm94Llllc05vcm1hbH0sRDp7T246amUuQ2hlY2tCb3guWWVzUHVzaERvd24sT2ZmOmplLkNoZWNrQm94Lk9mZlB1c2hEb3dufX19LFllc1B1c2hEb3duOmZ1bmN0aW9uKGUpe3ZhciB0PVgoZSk7dC5zY29wZT1lLnNjb3BlO3ZhciBBPVtdLHI9ZS5zY29wZS5pbnRlcm5hbC5nZXRGb250KGUuZm9udE5hbWUsZS5mb250U3R5bGUpLmlkLG49ZS5zY29wZS5fX3ByaXZhdGVfXy5lbmNvZGVDb2xvclN0cmluZyhlLmNvbG9yKSxzPW5lKGUsZS5jYXB0aW9uKTtyZXR1cm4gQS5wdXNoKCIwLjc0OTAyMyBnIiksQS5wdXNoKCIwIDAgIitHKGplLmludGVybmFsLmdldFdpZHRoKGUpKSsiICIrRyhqZS5pbnRlcm5hbC5nZXRIZWlnaHQoZSkpKyIgcmUiKSxBLnB1c2goImYiKSxBLnB1c2goIkJNQyIpLEEucHVzaCgicSIpLEEucHVzaCgiMCAwIDEgcmciKSxBLnB1c2goIi8iK3IrIiAiK0cocy5mb250U2l6ZSkrIiBUZiAiK24pLEEucHVzaCgiQlQiKSxBLnB1c2gocy50ZXh0KSxBLnB1c2goIkVUIiksQS5wdXNoKCJRIiksQS5wdXNoKCJFTUMiKSx0LnN0cmVhbT1BLmpvaW4oIlxuIiksdH0sWWVzTm9ybWFsOmZ1bmN0aW9uKGUpe3ZhciB0PVgoZSk7dC5zY29wZT1lLnNjb3BlO3ZhciBBPWUuc2NvcGUuaW50ZXJuYWwuZ2V0Rm9udChlLmZvbnROYW1lLGUuZm9udFN0eWxlKS5pZCxyPWUuc2NvcGUuX19wcml2YXRlX18uZW5jb2RlQ29sb3JTdHJpbmcoZS5jb2xvciksbj1bXSxzPWplLmludGVybmFsLmdldEhlaWdodChlKSxpPWplLmludGVybmFsLmdldFdpZHRoKGUpLG89bmUoZSxlLmNhcHRpb24pO3JldHVybiBuLnB1c2goIjEgZyIpLG4ucHVzaCgiMCAwICIrRyhpKSsiICIrRyhzKSsiIHJlIiksbi5wdXNoKCJmIiksbi5wdXNoKCJxIiksbi5wdXNoKCIwIDAgMSByZyIpLG4ucHVzaCgiMCAwICIrRyhpLTEpKyIgIitHKHMtMSkrIiByZSIpLG4ucHVzaCgiVyIpLG4ucHVzaCgibiIpLG4ucHVzaCgiMCBnIiksbi5wdXNoKCJCVCIpLG4ucHVzaCgiLyIrQSsiICIrRyhvLmZvbnRTaXplKSsiIFRmICIrciksbi5wdXNoKG8udGV4dCksbi5wdXNoKCJFVCIpLG4ucHVzaCgiUSIpLHQuc3RyZWFtPW4uam9pbigiXG4iKSx0fSxPZmZQdXNoRG93bjpmdW5jdGlvbihlKXt2YXIgdD1YKGUpO3Quc2NvcGU9ZS5zY29wZTt2YXIgQT1bXTtyZXR1cm4gQS5wdXNoKCIwLjc0OTAyMyBnIiksQS5wdXNoKCIwIDAgIitHKGplLmludGVybmFsLmdldFdpZHRoKGUpKSsiICIrRyhqZS5pbnRlcm5hbC5nZXRIZWlnaHQoZSkpKyIgcmUiKSxBLnB1c2goImYiKSx0LnN0cmVhbT1BLmpvaW4oIlxuIiksdH19LFJhZGlvQnV0dG9uOntDaXJjbGU6e2NyZWF0ZUFwcGVhcmFuY2VTdHJlYW06ZnVuY3Rpb24oZSl7dmFyIHQ9e0Q6e09mZjpqZS5SYWRpb0J1dHRvbi5DaXJjbGUuT2ZmUHVzaERvd259LE46e319O3JldHVybiB0Lk5bZV09amUuUmFkaW9CdXR0b24uQ2lyY2xlLlllc05vcm1hbCx0LkRbZV09amUuUmFkaW9CdXR0b24uQ2lyY2xlLlllc1B1c2hEb3duLHR9LGdldENBOmZ1bmN0aW9uKCl7cmV0dXJuImwifSxZZXNOb3JtYWw6ZnVuY3Rpb24oZSl7dmFyIHQ9WChlKTt0LnNjb3BlPWUuc2NvcGU7dmFyIEE9W10scj1qZS5pbnRlcm5hbC5nZXRXaWR0aChlKTw9amUuaW50ZXJuYWwuZ2V0SGVpZ2h0KGUpP2plLmludGVybmFsLmdldFdpZHRoKGUpLzQ6amUuaW50ZXJuYWwuZ2V0SGVpZ2h0KGUpLzQ7cj1OdW1iZXIoKC45KnIpLnRvRml4ZWQoNSkpO3ZhciBuPWplLmludGVybmFsLkJlemllcl9DLHM9TnVtYmVyKChyKm4pLnRvRml4ZWQoNSkpO3JldHVybiBBLnB1c2goInEiKSxBLnB1c2goIjEgMCAwIDEgIit6KGplLmludGVybmFsLmdldFdpZHRoKGUpLzIpKyIgIit6KGplLmludGVybmFsLmdldEhlaWdodChlKS8yKSsiIGNtIiksQS5wdXNoKHIrIiAwIG0iKSxBLnB1c2gocisiICIrcysiICIrcysiICIrcisiIDAgIityKyIgYyIpLEEucHVzaCgiLSIrcysiICIrcisiIC0iK3IrIiAiK3MrIiAtIityKyIgMCBjIiksQS5wdXNoKCItIityKyIgLSIrcysiIC0iK3MrIiAtIityKyIgMCAtIityKyIgYyIpLEEucHVzaChzKyIgLSIrcisiICIrcisiIC0iK3MrIiAiK3IrIiAwIGMiKSxBLnB1c2goImYiKSxBLnB1c2goIlEiKSx0LnN0cmVhbT1BLmpvaW4oIlxuIiksdH0sWWVzUHVzaERvd246ZnVuY3Rpb24oZSl7dmFyIHQ9WChlKTt0LnNjb3BlPWUuc2NvcGU7dmFyIEE9W10scj1qZS5pbnRlcm5hbC5nZXRXaWR0aChlKTw9amUuaW50ZXJuYWwuZ2V0SGVpZ2h0KGUpP2plLmludGVybmFsLmdldFdpZHRoKGUpLzQ6amUuaW50ZXJuYWwuZ2V0SGVpZ2h0KGUpLzQ7cj1OdW1iZXIoKC45KnIpLnRvRml4ZWQoNSkpO3ZhciBuPU51bWJlcigoMipyKS50b0ZpeGVkKDUpKSxzPU51bWJlcigobipqZS5pbnRlcm5hbC5CZXppZXJfQykudG9GaXhlZCg1KSksaT1OdW1iZXIoKHIqamUuaW50ZXJuYWwuQmV6aWVyX0MpLnRvRml4ZWQoNSkpO3JldHVybiBBLnB1c2goIjAuNzQ5MDIzIGciKSxBLnB1c2goInEiKSxBLnB1c2goIjEgMCAwIDEgIit6KGplLmludGVybmFsLmdldFdpZHRoKGUpLzIpKyIgIit6KGplLmludGVybmFsLmdldEhlaWdodChlKS8yKSsiIGNtIiksQS5wdXNoKG4rIiAwIG0iKSxBLnB1c2gobisiICIrcysiICIrcysiICIrbisiIDAgIituKyIgYyIpLEEucHVzaCgiLSIrcysiICIrbisiIC0iK24rIiAiK3MrIiAtIituKyIgMCBjIiksQS5wdXNoKCItIituKyIgLSIrcysiIC0iK3MrIiAtIituKyIgMCAtIituKyIgYyIpLEEucHVzaChzKyIgLSIrbisiICIrbisiIC0iK3MrIiAiK24rIiAwIGMiKSxBLnB1c2goImYiKSxBLnB1c2goIlEiKSxBLnB1c2goIjAgZyIpLEEucHVzaCgicSIpLEEucHVzaCgiMSAwIDAgMSAiK3ooamUuaW50ZXJuYWwuZ2V0V2lkdGgoZSkvMikrIiAiK3ooamUuaW50ZXJuYWwuZ2V0SGVpZ2h0KGUpLzIpKyIgY20iKSxBLnB1c2gocisiIDAgbSIpLEEucHVzaChyKyIgIitpKyIgIitpKyIgIityKyIgMCAiK3IrIiBjIiksQS5wdXNoKCItIitpKyIgIityKyIgLSIrcisiICIraSsiIC0iK3IrIiAwIGMiKSxBLnB1c2goIi0iK3IrIiAtIitpKyIgLSIraSsiIC0iK3IrIiAwIC0iK3IrIiBjIiksQS5wdXNoKGkrIiAtIityKyIgIityKyIgLSIraSsiICIrcisiIDAgYyIpLEEucHVzaCgiZiIpLEEucHVzaCgiUSIpLHQuc3RyZWFtPUEuam9pbigiXG4iKSx0fSxPZmZQdXNoRG93bjpmdW5jdGlvbihlKXt2YXIgdD1YKGUpO3Quc2NvcGU9ZS5zY29wZTt2YXIgQT1bXSxyPWplLmludGVybmFsLmdldFdpZHRoKGUpPD1qZS5pbnRlcm5hbC5nZXRIZWlnaHQoZSk/amUuaW50ZXJuYWwuZ2V0V2lkdGgoZSkvNDpqZS5pbnRlcm5hbC5nZXRIZWlnaHQoZSkvNDtyPU51bWJlcigoLjkqcikudG9GaXhlZCg1KSk7dmFyIG49TnVtYmVyKCgyKnIpLnRvRml4ZWQoNSkpLHM9TnVtYmVyKChuKmplLmludGVybmFsLkJlemllcl9DKS50b0ZpeGVkKDUpKTtyZXR1cm4gQS5wdXNoKCIwLjc0OTAyMyBnIiksQS5wdXNoKCJxIiksQS5wdXNoKCIxIDAgMCAxICIreihqZS5pbnRlcm5hbC5nZXRXaWR0aChlKS8yKSsiICIreihqZS5pbnRlcm5hbC5nZXRIZWlnaHQoZSkvMikrIiBjbSIpLEEucHVzaChuKyIgMCBtIiksQS5wdXNoKG4rIiAiK3MrIiAiK3MrIiAiK24rIiAwICIrbisiIGMiKSxBLnB1c2goIi0iK3MrIiAiK24rIiAtIituKyIgIitzKyIgLSIrbisiIDAgYyIpLEEucHVzaCgiLSIrbisiIC0iK3MrIiAtIitzKyIgLSIrbisiIDAgLSIrbisiIGMiKSxBLnB1c2gocysiIC0iK24rIiAiK24rIiAtIitzKyIgIituKyIgMCBjIiksQS5wdXNoKCJmIiksQS5wdXNoKCJRIiksdC5zdHJlYW09QS5qb2luKCJcbiIpLHR9fSxDcm9zczp7Y3JlYXRlQXBwZWFyYW5jZVN0cmVhbTpmdW5jdGlvbihlKXt2YXIgdD17RDp7T2ZmOmplLlJhZGlvQnV0dG9uLkNyb3NzLk9mZlB1c2hEb3dufSxOOnt9fTtyZXR1cm4gdC5OW2VdPWplLlJhZGlvQnV0dG9uLkNyb3NzLlllc05vcm1hbCx0LkRbZV09amUuUmFkaW9CdXR0b24uQ3Jvc3MuWWVzUHVzaERvd24sdH0sZ2V0Q0E6ZnVuY3Rpb24oKXtyZXR1cm4iOCJ9LFllc05vcm1hbDpmdW5jdGlvbihlKXt2YXIgdD1YKGUpO3Quc2NvcGU9ZS5zY29wZTt2YXIgQT1bXSxyPWplLmludGVybmFsLmNhbGN1bGF0ZUNyb3NzKGUpO3JldHVybiBBLnB1c2goInEiKSxBLnB1c2goIjEgMSAiK0coamUuaW50ZXJuYWwuZ2V0V2lkdGgoZSktMikrIiAiK0coamUuaW50ZXJuYWwuZ2V0SGVpZ2h0KGUpLTIpKyIgcmUiKSxBLnB1c2goIlciKSxBLnB1c2goIm4iKSxBLnB1c2goRyhyLngxLngpKyIgIitHKHIueDEueSkrIiBtIiksQS5wdXNoKEcoci54Mi54KSsiICIrRyhyLngyLnkpKyIgbCIpLEEucHVzaChHKHIueDQueCkrIiAiK0coci54NC55KSsiIG0iKSxBLnB1c2goRyhyLngzLngpKyIgIitHKHIueDMueSkrIiBsIiksQS5wdXNoKCJzIiksQS5wdXNoKCJRIiksdC5zdHJlYW09QS5qb2luKCJcbiIpLHR9LFllc1B1c2hEb3duOmZ1bmN0aW9uKGUpe3ZhciB0PVgoZSk7dC5zY29wZT1lLnNjb3BlO3ZhciBBPWplLmludGVybmFsLmNhbGN1bGF0ZUNyb3NzKGUpLHI9W107cmV0dXJuIHIucHVzaCgiMC43NDkwMjMgZyIpLHIucHVzaCgiMCAwICIrRyhqZS5pbnRlcm5hbC5nZXRXaWR0aChlKSkrIiAiK0coamUuaW50ZXJuYWwuZ2V0SGVpZ2h0KGUpKSsiIHJlIiksci5wdXNoKCJmIiksci5wdXNoKCJxIiksci5wdXNoKCIxIDEgIitHKGplLmludGVybmFsLmdldFdpZHRoKGUpLTIpKyIgIitHKGplLmludGVybmFsLmdldEhlaWdodChlKS0yKSsiIHJlIiksci5wdXNoKCJXIiksci5wdXNoKCJuIiksci5wdXNoKEcoQS54MS54KSsiICIrRyhBLngxLnkpKyIgbSIpLHIucHVzaChHKEEueDIueCkrIiAiK0coQS54Mi55KSsiIGwiKSxyLnB1c2goRyhBLng0LngpKyIgIitHKEEueDQueSkrIiBtIiksci5wdXNoKEcoQS54My54KSsiICIrRyhBLngzLnkpKyIgbCIpLHIucHVzaCgicyIpLHIucHVzaCgiUSIpLHQuc3RyZWFtPXIuam9pbigiXG4iKSx0fSxPZmZQdXNoRG93bjpmdW5jdGlvbihlKXt2YXIgdD1YKGUpO3Quc2NvcGU9ZS5zY29wZTt2YXIgQT1bXTtyZXR1cm4gQS5wdXNoKCIwLjc0OTAyMyBnIiksQS5wdXNoKCIwIDAgIitHKGplLmludGVybmFsLmdldFdpZHRoKGUpKSsiICIrRyhqZS5pbnRlcm5hbC5nZXRIZWlnaHQoZSkpKyIgcmUiKSxBLnB1c2goImYiKSx0LnN0cmVhbT1BLmpvaW4oIlxuIiksdH19fSxjcmVhdGVEZWZhdWx0QXBwZWFyYW5jZVN0cmVhbTpmdW5jdGlvbihlKXt2YXIgdD1lLnNjb3BlLmludGVybmFsLmdldEZvbnQoZS5mb250TmFtZSxlLmZvbnRTdHlsZSkuaWQsQT1lLnNjb3BlLl9fcHJpdmF0ZV9fLmVuY29kZUNvbG9yU3RyaW5nKGUuY29sb3IpO3JldHVybiIvIit0KyIgIitlLmZvbnRTaXplKyIgVGYgIitBfX07amUuaW50ZXJuYWw9e0Jlemllcl9DOi41NTE5MTUwMjQ0OTQsY2FsY3VsYXRlQ3Jvc3M6ZnVuY3Rpb24oZSl7dmFyIHQ9amUuaW50ZXJuYWwuZ2V0V2lkdGgoZSksQT1qZS5pbnRlcm5hbC5nZXRIZWlnaHQoZSkscj1NYXRoLm1pbih0LEEpO3JldHVybnt4MTp7eDoodC1yKS8yLHk6KEEtcikvMityfSx4Mjp7eDoodC1yKS8yK3IseTooQS1yKS8yfSx4Mzp7eDoodC1yKS8yLHk6KEEtcikvMn0seDQ6e3g6KHQtcikvMityLHk6KEEtcikvMityfX19fSxqZS5pbnRlcm5hbC5nZXRXaWR0aD1mdW5jdGlvbihlKXt2YXIgdD0wO3JldHVybiJvYmplY3QiPT09KDAsci5kZWZhdWx0KShlKSYmKHQ9VyhlLlJlY3RbMl0pKSx0fSxqZS5pbnRlcm5hbC5nZXRIZWlnaHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9MDtyZXR1cm4ib2JqZWN0Ij09PSgwLHIuZGVmYXVsdCkoZSkmJih0PVcoZS5SZWN0WzNdKSksdH07dmFyIHhlPUQuYWRkRmllbGQ9ZnVuY3Rpb24oZSl7aWYoZnVuY3Rpb24oZSx0KXtpZih0LnNjb3BlPWUsdm9pZCAwIT09ZS5pbnRlcm5hbCYmKHZvaWQgMD09PWUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW58fCExPT09ZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5pc0luaXRpYWxpemVkKSl7aWYoZGUuRmllbGROdW09MCxlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaWUpKSxlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3QpdGhyb3cgbmV3IEVycm9yKCJFeGNlcHRpb24gd2hpbGUgY3JlYXRpbmcgQWNyb2Zvcm1EaWN0aW9uYXJ5Iik7Uj1lLmludGVybmFsLnNjYWxlRmFjdG9yLGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdD1uZXcgaGUsZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290LnNjb3BlPWUsZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290Ll9ldmVudElEPWUuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgicG9zdFB1dFJlc291cmNlcyIsZnVuY3Rpb24oKXt2YXIgdDsodD1lKS5pbnRlcm5hbC5ldmVudHMudW5zdWJzY3JpYmUodC5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290Ll9ldmVudElEKSxkZWxldGUgdC5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290Ll9ldmVudElELHQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ucHJpbnRlZE91dD0hMH0pLGUuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgiYnVpbGREb2N1bWVudCIsZnVuY3Rpb24oKXshZnVuY3Rpb24oZSl7ZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290Lm9iaklkPXZvaWQgMDt2YXIgdD1lLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3QuRmllbGRzO2Zvcih2YXIgQSBpbiB0KWlmKHQuaGFzT3duUHJvcGVydHkoQSkpe3ZhciByPXRbQV07ci5vYmpJZD12b2lkIDAsci5oYXNBbm5vdGF0aW9uJiZvZShyLGUpfX0oZSl9KSxlLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInB1dENhdGFsb2ciLGZ1bmN0aW9uKCl7IWZ1bmN0aW9uKGUpe2lmKHZvaWQgMD09PWUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdCl0aHJvdyBuZXcgRXJyb3IoInB1dENhdGFsb2dDYWxsYmFjazogUm9vdCBtaXNzaW5nLiIpO2UuaW50ZXJuYWwud3JpdGUoIi9BY3JvRm9ybSAiK2UuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5vYmpJZCsiIDAgUiIpfShlKX0pLGUuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgicG9zdFB1dFBhZ2VzIixmdW5jdGlvbih0KXshZnVuY3Rpb24oZSx0KXt2YXIgQT0hZTtmb3IodmFyIG4gaW4gZXx8KHQuaW50ZXJuYWwubmV3T2JqZWN0RGVmZXJyZWRCZWdpbih0LmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3Qub2JqSWQsITApLHQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5wdXRTdHJlYW0oKSksZT1lfHx0LmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3QuS2lkcylpZihlLmhhc093blByb3BlcnR5KG4pKXt2YXIgcz1lW25dLGk9W10sbz1zLlJlY3Q7aWYocy5SZWN0JiYocy5SZWN0PUFlKHMuUmVjdCx0KSksdC5pbnRlcm5hbC5uZXdPYmplY3REZWZlcnJlZEJlZ2luKHMub2JqSWQsITApLHMuREE9amUuY3JlYXRlRGVmYXVsdEFwcGVhcmFuY2VTdHJlYW0ocyksIm9iamVjdCI9PT0oMCxyLmRlZmF1bHQpKHMpJiYiZnVuY3Rpb24iPT10eXBlb2Ygcy5nZXRLZXlWYWx1ZUxpc3RGb3JTdHJlYW0mJihpPXMuZ2V0S2V5VmFsdWVMaXN0Rm9yU3RyZWFtKCkpLHMuUmVjdD1vLHMuaGFzQXBwZWFyYW5jZVN0cmVhbSYmIXMuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQpe3ZhciBhPXJlKHMpO2kucHVzaCh7a2V5OiJBUCIsdmFsdWU6Ijw8L04gIithKyI+PiJ9KSx0LmludGVybmFsLmFjcm9mb3JtUGx1Z2luLnhGb3Jtcy5wdXNoKGEpfWlmKHMuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQpe3ZhciBsPSIiO2Zvcih2YXIgYyBpbiBzLmFwcGVhcmFuY2VTdHJlYW1Db250ZW50KWlmKHMuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQuaGFzT3duUHJvcGVydHkoYykpe3ZhciB1PXMuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnRbY107aWYobCs9Ii8iK2MrIiAiLGwrPSI8PCIsT2JqZWN0LmtleXModSkubGVuZ3RoPj0xfHxBcnJheS5pc0FycmF5KHUpKXtmb3IodmFyIG4gaW4gdSlpZih1Lmhhc093blByb3BlcnR5KG4pKXt2YXIgaD11W25dOyJmdW5jdGlvbiI9PXR5cGVvZiBoJiYoaD1oLmNhbGwodCxzKSksbCs9Ii8iK24rIiAiK2grIiAiLHQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ueEZvcm1zLmluZGV4T2YoaCk+PTB8fHQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ueEZvcm1zLnB1c2goaCl9fWVsc2UiZnVuY3Rpb24iPT10eXBlb2YoaD11KSYmKGg9aC5jYWxsKHQscykpLGwrPSIvIituKyIgIitoLHQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ueEZvcm1zLmluZGV4T2YoaCk+PTB8fHQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ueEZvcm1zLnB1c2goaCk7bCs9Ij4+In1pLnB1c2goe2tleToiQVAiLHZhbHVlOiI8PFxuIitsKyI+PiJ9KX10LmludGVybmFsLnB1dFN0cmVhbSh7YWRkaXRpb25hbEtleVZhbHVlczppLG9iamVjdElkOnMub2JqSWR9KSx0LmludGVybmFsLm91dCgiZW5kb2JqIil9QSYmZnVuY3Rpb24oZSx0KXtmb3IodmFyIEEgaW4gZSlpZihlLmhhc093blByb3BlcnR5KEEpKXt2YXIgbj1BLHM9ZVtBXTt0LmludGVybmFsLm5ld09iamVjdERlZmVycmVkQmVnaW4ocy5vYmpJZCwhMCksIm9iamVjdCI9PT0oMCxyLmRlZmF1bHQpKHMpJiYiZnVuY3Rpb24iPT10eXBlb2Ygcy5wdXRTdHJlYW0mJnMucHV0U3RyZWFtKCksZGVsZXRlIGVbbl19fSh0LmludGVybmFsLmFjcm9mb3JtUGx1Z2luLnhGb3Jtcyx0KX0odCxlKX0pLGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uaXNJbml0aWFsaXplZD0hMH19KHRoaXMsZSksIShlIGluc3RhbmNlb2YgZGUpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuYWRkRmllbGQuIik7dmFyIHQ7cmV0dXJuKHQ9ZSkuc2NvcGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ucHJpbnRlZE91dCYmKHQuc2NvcGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ucHJpbnRlZE91dD0hMSx0LnNjb3BlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3Q9bnVsbCksdC5zY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290LkZpZWxkcy5wdXNoKHQpLGUucGFnZT1lLnNjb3BlLmludGVybmFsLmdldEN1cnJlbnRQYWdlSW5mbygpLnBhZ2VOdW1iZXIsdGhpc307RC5BY3JvRm9ybUNob2ljZUZpZWxkPWZlLEQuQWNyb0Zvcm1MaXN0Qm94PXBlLEQuQWNyb0Zvcm1Db21ib0JveD1nZSxELkFjcm9Gb3JtRWRpdEJveD1tZSxELkFjcm9Gb3JtQnV0dG9uPXdlLEQuQWNyb0Zvcm1QdXNoQnV0dG9uPUJlLEQuQWNyb0Zvcm1SYWRpb0J1dHRvbj15ZSxELkFjcm9Gb3JtQ2hlY2tCb3g9YmUsRC5BY3JvRm9ybVRleHRGaWVsZD1DZSxELkFjcm9Gb3JtUGFzc3dvcmRGaWVsZD1fZSxELkFjcm9Gb3JtQXBwZWFyYW5jZT1qZSxELkFjcm9Gb3JtPXtDaG9pY2VGaWVsZDpmZSxMaXN0Qm94OnBlLENvbWJvQm94OmdlLEVkaXRCb3g6bWUsQnV0dG9uOndlLFB1c2hCdXR0b246QmUsUmFkaW9CdXR0b246eWUsQ2hlY2tCb3g6YmUsVGV4dEZpZWxkOkNlLFBhc3N3b3JkRmllbGQ6X2UsQXBwZWFyYW5jZTpqZX0sTS5BY3JvRm9ybT17Q2hvaWNlRmllbGQ6ZmUsTGlzdEJveDpwZSxDb21ib0JveDpnZSxFZGl0Qm94Om1lLEJ1dHRvbjp3ZSxQdXNoQnV0dG9uOkJlLFJhZGlvQnV0dG9uOnllLENoZWNrQm94OmJlLFRleHRGaWVsZDpDZSxQYXNzd29yZEZpZWxkOl9lLEFwcGVhcmFuY2U6amV9O3ZhciBGZSxRZSxVZT1NLkFjcm9Gb3JtO2Z1bmN0aW9uIEVlKGUpe3JldHVybiBlLnJlZHVjZShmdW5jdGlvbihlLHQsQSl7cmV0dXJuIGVbdF09QSxlfSx7fSl9IWZ1bmN0aW9uKGUpe3ZhciB0PSJhZGRJbWFnZV8iO2UuX19hZGRpbWFnZV9fPXt9O3ZhciBBPSJVTktOT1dOIixuPXtQTkc6W1sxMzcsODAsNzgsNzFdXSxUSUZGOltbNzcsNzcsMCw0Ml0sWzczLDczLDQyLDBdXSxKUEVHOltbMjU1LDIxNiwyNTUsMjI0LHZvaWQgMCx2b2lkIDAsNzQsNzAsNzMsNzAsMF0sWzI1NSwyMTYsMjU1LDIyNSx2b2lkIDAsdm9pZCAwLDY5LDEyMCwxMDUsMTAyLDAsMF0sWzI1NSwyMTYsMjU1LDIxOV0sWzI1NSwyMTYsMjU1LDIzOF1dLEpQRUcyMDAwOltbMCwwLDAsMTIsMTA2LDgwLDMyLDMyXV0sR0lGODdhOltbNzEsNzMsNzAsNTYsNTUsOTddXSxHSUY4OWE6W1s3MSw3Myw3MCw1Niw1Nyw5N11dLFdFQlA6W1s4Miw3Myw3MCw3MCx2b2lkIDAsdm9pZCAwLHZvaWQgMCx2b2lkIDAsODcsNjksNjYsODBdXSxCTVA6W1s2Niw3N10sWzY2LDY1XSxbNjcsNzNdLFs2Nyw4MF0sWzczLDY3XSxbODAsODRdXX0scz1lLl9fYWRkaW1hZ2VfXy5nZXRJbWFnZUZpbGVUeXBlQnlJbWFnZURhdGE9ZnVuY3Rpb24oZSx0KXt2YXIgcixzLGksbyxhLGw9QTtpZigiUkdCQSI9PT0odD10fHxBKXx8dm9pZCAwIT09ZS5kYXRhJiZlLmRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSYmImhlaWdodCJpbiBlJiYid2lkdGgiaW4gZSlyZXR1cm4iUkdCQSI7aWYoXyhlKSlmb3IoYSBpbiBuKWZvcihpPW5bYV0scj0wO3I8aS5sZW5ndGg7cis9MSl7Zm9yKG89ITAscz0wO3M8aVtyXS5sZW5ndGg7cys9MSlpZih2b2lkIDAhPT1pW3JdW3NdJiZpW3JdW3NdIT09ZVtzXSl7bz0hMTticmVha31pZighMD09PW8pe2w9YTticmVha319ZWxzZSBmb3IoYSBpbiBuKWZvcihpPW5bYV0scj0wO3I8aS5sZW5ndGg7cis9MSl7Zm9yKG89ITAscz0wO3M8aVtyXS5sZW5ndGg7cys9MSlpZih2b2lkIDAhPT1pW3JdW3NdJiZpW3JdW3NdIT09ZS5jaGFyQ29kZUF0KHMpKXtvPSExO2JyZWFrfWlmKCEwPT09byl7bD1hO2JyZWFrfX1yZXR1cm4gbD09PUEmJnQhPT1BJiYobD10KSxsfSxpPWZ1bmN0aW9uIGUodCl7Zm9yKHZhciBBPXRoaXMuaW50ZXJuYWwud3JpdGUscj10aGlzLmludGVybmFsLnB1dFN0cmVhbSxuPSgwLHRoaXMuaW50ZXJuYWwuZ2V0RmlsdGVycykoKTstMSE9PW4uaW5kZXhPZigiRmxhdGVFbmNvZGUiKTspbi5zcGxpY2Uobi5pbmRleE9mKCJGbGF0ZUVuY29kZSIpLDEpO3Qub2JqZWN0SWQ9dGhpcy5pbnRlcm5hbC5uZXdPYmplY3QoKTt2YXIgcz1bXTtpZihzLnB1c2goe2tleToiVHlwZSIsdmFsdWU6Ii9YT2JqZWN0In0pLHMucHVzaCh7a2V5OiJTdWJ0eXBlIix2YWx1ZToiL0ltYWdlIn0pLHMucHVzaCh7a2V5OiJXaWR0aCIsdmFsdWU6dC53aWR0aH0pLHMucHVzaCh7a2V5OiJIZWlnaHQiLHZhbHVlOnQuaGVpZ2h0fSksdC5jb2xvclNwYWNlPT09Qi5JTkRFWEVEP3MucHVzaCh7a2V5OiJDb2xvclNwYWNlIix2YWx1ZToiWy9JbmRleGVkIC9EZXZpY2VSR0IgIisodC5wYWxldHRlLmxlbmd0aC8zLTEpKyIgIisoInNNYXNrImluIHQmJnZvaWQgMCE9PXQuc01hc2s/dC5vYmplY3RJZCsyOnQub2JqZWN0SWQrMSkrIiAwIFJdIn0pOihzLnB1c2goe2tleToiQ29sb3JTcGFjZSIsdmFsdWU6Ii8iK3QuY29sb3JTcGFjZX0pLHQuY29sb3JTcGFjZT09PUIuREVWSUNFX0NNWUsmJnMucHVzaCh7a2V5OiJEZWNvZGUiLHZhbHVlOiJbMSAwIDEgMCAxIDAgMSAwXSJ9KSkscy5wdXNoKHtrZXk6IkJpdHNQZXJDb21wb25lbnQiLHZhbHVlOnQuYml0c1BlckNvbXBvbmVudH0pLCJkZWNvZGVQYXJhbWV0ZXJzImluIHQmJnZvaWQgMCE9PXQuZGVjb2RlUGFyYW1ldGVycyYmcy5wdXNoKHtrZXk6IkRlY29kZVBhcm1zIix2YWx1ZToiPDwiK3QuZGVjb2RlUGFyYW1ldGVycysiPj4ifSksInRyYW5zcGFyZW5jeSJpbiB0JiZBcnJheS5pc0FycmF5KHQudHJhbnNwYXJlbmN5KSl7Zm9yKHZhciBpPSIiLG89MCxhPXQudHJhbnNwYXJlbmN5Lmxlbmd0aDtvPGE7bysrKWkrPXQudHJhbnNwYXJlbmN5W29dKyIgIit0LnRyYW5zcGFyZW5jeVtvXSsiICI7cy5wdXNoKHtrZXk6Ik1hc2siLHZhbHVlOiJbIitpKyJdIn0pfXZvaWQgMCE9PXQuc01hc2smJnMucHVzaCh7a2V5OiJTTWFzayIsdmFsdWU6dC5vYmplY3RJZCsxKyIgMCBSIn0pO3ZhciBsPXZvaWQgMCE9PXQuZmlsdGVyP1siLyIrdC5maWx0ZXJdOnZvaWQgMDtpZihyKHtkYXRhOnQuZGF0YSxhZGRpdGlvbmFsS2V5VmFsdWVzOnMsYWxyZWFkeUFwcGxpZWRGaWx0ZXJzOmwsb2JqZWN0SWQ6dC5vYmplY3RJZH0pLEEoImVuZG9iaiIpLCJzTWFzayJpbiB0JiZ2b2lkIDAhPT10LnNNYXNrKXt2YXIgYz0obnVsbCE9dC5wcmVkaWN0b3I/Ii9QcmVkaWN0b3IgIit0LnByZWRpY3RvcjoiIikrIiAvQ29sb3JzIDEgL0JpdHNQZXJDb21wb25lbnQgOCAvQ29sdW1ucyAiK3Qud2lkdGgsdT17d2lkdGg6dC53aWR0aCxoZWlnaHQ6dC5oZWlnaHQsY29sb3JTcGFjZToiRGV2aWNlR3JheSIsYml0c1BlckNvbXBvbmVudDp0LmJpdHNQZXJDb21wb25lbnQsZGVjb2RlUGFyYW1ldGVyczpjLGRhdGE6dC5zTWFza307ImZpbHRlciJpbiB0JiYodS5maWx0ZXI9dC5maWx0ZXIpLGUuY2FsbCh0aGlzLHUpfWlmKHQuY29sb3JTcGFjZT09PUIuSU5ERVhFRCl7dmFyIGg9dGhpcy5pbnRlcm5hbC5uZXdPYmplY3QoKTtyKHtkYXRhOngobmV3IFVpbnQ4QXJyYXkodC5wYWxldHRlKSksb2JqZWN0SWQ6aH0pLEEoImVuZG9iaiIpfX0sbz1mdW5jdGlvbigpe3ZhciBlPXRoaXMuaW50ZXJuYWwuY29sbGVjdGlvbnNbdCsiaW1hZ2VzIl07Zm9yKHZhciBBIGluIGUpaS5jYWxsKHRoaXMsZVtBXSl9LGE9ZnVuY3Rpb24oKXt2YXIgZSxBPXRoaXMuaW50ZXJuYWwuY29sbGVjdGlvbnNbdCsiaW1hZ2VzIl0scj10aGlzLmludGVybmFsLndyaXRlO2Zvcih2YXIgbiBpbiBBKXIoIi9JIisoZT1BW25dKS5pbmRleCxlLm9iamVjdElkLCIwIiwiUiIpfSxsPWZ1bmN0aW9uKCl7dGhpcy5pbnRlcm5hbC5jb2xsZWN0aW9uc1t0KyJpbWFnZXMiXXx8KHRoaXMuaW50ZXJuYWwuY29sbGVjdGlvbnNbdCsiaW1hZ2VzIl09e30sdGhpcy5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKCJwdXRSZXNvdXJjZXMiLG8pLHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgicHV0WG9iamVjdERpY3QiLGEpKX0sYz1mdW5jdGlvbigpe3ZhciBlPXRoaXMuaW50ZXJuYWwuY29sbGVjdGlvbnNbdCsiaW1hZ2VzIl07cmV0dXJuIGwuY2FsbCh0aGlzKSxlfSx1PWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaW50ZXJuYWwuY29sbGVjdGlvbnNbdCsiaW1hZ2VzIl0pLmxlbmd0aH0saD1mdW5jdGlvbih0KXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgZVsicHJvY2VzcyIrdC50b1VwcGVyQ2FzZSgpXX0sZD1mdW5jdGlvbihlKXtyZXR1cm4ib2JqZWN0Ij09PSgwLHIuZGVmYXVsdCkoZSkmJjE9PT1lLm5vZGVUeXBlfSxmPWZ1bmN0aW9uKHQsQSl7aWYoIklNRyI9PT10Lm5vZGVOYW1lJiZ0Lmhhc0F0dHJpYnV0ZSgic3JjIikpe3ZhciByPSIiK3QuZ2V0QXR0cmlidXRlKCJzcmMiKTtpZigwPT09ci5pbmRleE9mKCJkYXRhOmltYWdlLyIpKXJldHVybiBwKHVuZXNjYXBlKHIpLnNwbGl0KCJiYXNlNjQsIikucG9wKCkpO3ZhciBuPWUubG9hZEZpbGUociwhMCk7aWYodm9pZCAwIT09bilyZXR1cm4gbn1pZigiQ0FOVkFTIj09PXQubm9kZU5hbWUpe2lmKDA9PT10LndpZHRofHwwPT09dC5oZWlnaHQpdGhyb3cgbmV3IEVycm9yKCJHaXZlbiBjYW52YXMgbXVzdCBoYXZlIGRhdGEuIENhbnZhcyB3aWR0aDogIit0LndpZHRoKyIsIGhlaWdodDogIit0LmhlaWdodCk7dmFyIHM7c3dpdGNoKEEpe2Nhc2UiUE5HIjpzPSJpbWFnZS9wbmciO2JyZWFrO2Nhc2UiV0VCUCI6cz0iaW1hZ2Uvd2VicCI7YnJlYWs7ZGVmYXVsdDpzPSJpbWFnZS9qcGVnIn1yZXR1cm4gcCh0LnRvRGF0YVVSTChzLDEpLnNwbGl0KCJiYXNlNjQsIikucG9wKCkpfX0sZz1mdW5jdGlvbihlKXt2YXIgQT10aGlzLmludGVybmFsLmNvbGxlY3Rpb25zW3QrImltYWdlcyJdO2lmKEEpZm9yKHZhciByIGluIEEpaWYoZT09PUFbcl0uYWxpYXMpcmV0dXJuIEFbcl19LG09ZnVuY3Rpb24oZSx0LEEpe3JldHVybiBlfHx0fHwoZT0tOTYsdD0tOTYpLGU8MCYmKGU9LTEqQS53aWR0aCo3Mi9lL3RoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3IpLHQ8MCYmKHQ9LTEqQS5oZWlnaHQqNzIvdC90aGlzLmludGVybmFsLnNjYWxlRmFjdG9yKSwwPT09ZSYmKGU9dCpBLndpZHRoL0EuaGVpZ2h0KSwwPT09dCYmKHQ9ZSpBLmhlaWdodC9BLndpZHRoKSxbZSx0XX0sdz1mdW5jdGlvbihlLHQsQSxyLG4scyl7dmFyIGk9bS5jYWxsKHRoaXMsQSxyLG4pLG89dGhpcy5pbnRlcm5hbC5nZXRDb29yZGluYXRlU3RyaW5nLGE9dGhpcy5pbnRlcm5hbC5nZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmcsbD1jLmNhbGwodGhpcyk7aWYoQT1pWzBdLHI9aVsxXSxsW24uaW5kZXhdPW4scyl7cyo9TWF0aC5QSS8xODA7dmFyIHU9TWF0aC5jb3MocyksaD1NYXRoLnNpbihzKSxkPWZ1bmN0aW9uKGUpe3JldHVybiBlLnRvRml4ZWQoNCl9LGY9W2QodSksZChoKSxkKC0xKmgpLGQodSksMCwwLCJjbSJdfXRoaXMuaW50ZXJuYWwud3JpdGUoInEiKSxzPyh0aGlzLmludGVybmFsLndyaXRlKFsxLCIwIiwiMCIsMSxvKGUpLGEodCtyKSwiY20iXS5qb2luKCIgIikpLHRoaXMuaW50ZXJuYWwud3JpdGUoZi5qb2luKCIgIikpLHRoaXMuaW50ZXJuYWwud3JpdGUoW28oQSksIjAiLCIwIixvKHIpLCIwIiwiMCIsImNtIl0uam9pbigiICIpKSk6dGhpcy5pbnRlcm5hbC53cml0ZShbbyhBKSwiMCIsIjAiLG8ociksbyhlKSxhKHQrciksImNtIl0uam9pbigiICIpKSx0aGlzLmlzQWR2YW5jZWRBUEkoKSYmdGhpcy5pbnRlcm5hbC53cml0ZShbMSwwLDAsLTEsMCwwLCJjbSJdLmpvaW4oIiAiKSksdGhpcy5pbnRlcm5hbC53cml0ZSgiL0kiK24uaW5kZXgrIiBEbyIpLHRoaXMuaW50ZXJuYWwud3JpdGUoIlEiKX0sQj1lLmNvbG9yX3NwYWNlcz17REVWSUNFX1JHQjoiRGV2aWNlUkdCIixERVZJQ0VfR1JBWToiRGV2aWNlR3JheSIsREVWSUNFX0NNWUs6IkRldmljZUNNWUsiLENBTF9HUkVZOiJDYWxHcmF5IixDQUxfUkdCOiJDYWxSR0IiLExBQjoiTGFiIixJQ0NfQkFTRUQ6IklDQ0Jhc2VkIixJTkRFWEVEOiJJbmRleGVkIixQQVRURVJOOiJQYXR0ZXJuIixTRVBBUkFUSU9OOiJTZXBhcmF0aW9uIixERVZJQ0VfTjoiRGV2aWNlTiJ9O2UuZGVjb2RlPXtEQ1RfREVDT0RFOiJEQ1REZWNvZGUiLEZMQVRFX0RFQ09ERToiRmxhdGVEZWNvZGUiLExaV19ERUNPREU6IkxaV0RlY29kZSIsSlBYX0RFQ09ERToiSlBYRGVjb2RlIixKQklHMl9ERUNPREU6IkpCSUcyRGVjb2RlIixBU0NJSTg1X0RFQ09ERToiQVNDSUk4NURlY29kZSIsQVNDSUlfSEVYX0RFQ09ERToiQVNDSUlIZXhEZWNvZGUiLFJVTl9MRU5HVEhfREVDT0RFOiJSdW5MZW5ndGhEZWNvZGUiLENDSVRUX0ZBWF9ERUNPREU6IkNDSVRURmF4RGVjb2RlIn07dmFyIHk9ZS5pbWFnZV9jb21wcmVzc2lvbj17Tk9ORToiTk9ORSIsRkFTVDoiRkFTVCIsTUVESVVNOiJNRURJVU0iLFNMT1c6IlNMT1cifSx2PWUuX19hZGRpbWFnZV9fLnNIYXNoQ29kZT1mdW5jdGlvbihlKXt2YXIgdCxBLHI9MDtpZigic3RyaW5nIj09dHlwZW9mIGUpZm9yKEE9ZS5sZW5ndGgsdD0wO3Q8QTt0Kyspcj0ocjw8NSktcitlLmNoYXJDb2RlQXQodCkscnw9MDtlbHNlIGlmKF8oZSkpZm9yKEE9ZS5ieXRlTGVuZ3RoLzIsdD0wO3Q8QTt0Kyspcj0ocjw8NSktcitlW3RdLHJ8PTA7cmV0dXJuIHJ9LGI9ZS5fX2FkZGltYWdlX18udmFsaWRhdGVTdHJpbmdBc0Jhc2U2ND1mdW5jdGlvbihlKXsoZT1lfHwiIikudG9TdHJpbmcoKS50cmltKCk7dmFyIHQ9ITA7cmV0dXJuIDA9PT1lLmxlbmd0aCYmKHQ9ITEpLGUubGVuZ3RoJTQhPTAmJih0PSExKSwhMT09PS9eW0EtWmEtejAtOSsvXSskLy50ZXN0KGUuc3Vic3RyKDAsZS5sZW5ndGgtMikpJiYodD0hMSksITE9PT0vXltBLVphLXowLTkvXVtBLVphLXowLTkrL118W0EtWmEtejAtOSsvXT18PT0kLy50ZXN0KGUuc3Vic3RyKC0yKSkmJih0PSExKSx0fSxDPWUuX19hZGRpbWFnZV9fLmV4dHJhY3RJbWFnZUZyb21EYXRhVXJsPWZ1bmN0aW9uKGUpe2lmKG51bGw9PWUpcmV0dXJuIG51bGw7aWYoIShlPWUudHJpbSgpKS5zdGFydHNXaXRoKCJkYXRhOiIpKXJldHVybiBudWxsO3ZhciB0PWUuaW5kZXhPZigiLCIpO3JldHVybiB0PDA/bnVsbDplLnN1YnN0cmluZygwLHQpLnRyaW0oKS5lbmRzV2l0aCgiYmFzZTY0Iik/ZS5zdWJzdHJpbmcodCsxKTpudWxsfTtlLl9fYWRkaW1hZ2VfXy5pc0FycmF5QnVmZmVyPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ9O3ZhciBfPWUuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXJWaWV3PWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgSW50OEFycmF5fHxlIGluc3RhbmNlb2YgVWludDhBcnJheXx8ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHxlIGluc3RhbmNlb2YgSW50MTZBcnJheXx8ZSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5fHxlIGluc3RhbmNlb2YgSW50MzJBcnJheXx8ZSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5fHxlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHxlIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5fSxqPWUuX19hZGRpbWFnZV9fLmJpbmFyeVN0cmluZ1RvVWludDhBcnJheT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5sZW5ndGgsQT1uZXcgVWludDhBcnJheSh0KSxyPTA7cjx0O3IrKylBW3JdPWUuY2hhckNvZGVBdChyKTtyZXR1cm4gQX0seD1lLl9fYWRkaW1hZ2VfXy5hcnJheUJ1ZmZlclRvQmluYXJ5U3RyaW5nPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0iIixBPV8oZSk/ZTpuZXcgVWludDhBcnJheShlKSxyPTA7cjxBLmxlbmd0aDtyKz04MTkyKXQrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxBLnN1YmFycmF5KHIscis4MTkyKSk7cmV0dXJuIHR9O2UuYWRkSW1hZ2U9ZnVuY3Rpb24oKXt2YXIgZSx0LG4scyxpLG8sYSxjLHU7aWYoIm51bWJlciI9PXR5cGVvZiBhcmd1bWVudHNbMV0/KHQ9QSxuPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXSxvPWFyZ3VtZW50c1s0XSxhPWFyZ3VtZW50c1s1XSxjPWFyZ3VtZW50c1s2XSx1PWFyZ3VtZW50c1s3XSk6KHQ9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLG89YXJndW1lbnRzWzVdLGE9YXJndW1lbnRzWzZdLGM9YXJndW1lbnRzWzddLHU9YXJndW1lbnRzWzhdKSwib2JqZWN0Ij09PSgwLHIuZGVmYXVsdCkoZT1hcmd1bWVudHNbMF0pJiYhZChlKSYmImltYWdlRGF0YSJpbiBlKXt2YXIgaD1lO2U9aC5pbWFnZURhdGEsdD1oLmZvcm1hdHx8dHx8QSxuPWgueHx8bnx8MCxzPWgueXx8c3x8MCxpPWgud3x8aC53aWR0aHx8aSxvPWguaHx8aC5oZWlnaHR8fG8sYT1oLmFsaWFzfHxhLGM9aC5jb21wcmVzc2lvbnx8Yyx1PWgucm90YXRpb258fGguYW5nbGV8fHV9dmFyIGY9dGhpcy5pbnRlcm5hbC5nZXRGaWx0ZXJzKCk7aWYodm9pZCAwPT09YyYmLTEhPT1mLmluZGV4T2YoIkZsYXRlRW5jb2RlIikmJihjPSJTTE9XIiksaXNOYU4obil8fGlzTmFOKHMpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb29yZGluYXRlcyBwYXNzZWQgdG8ganNQREYuYWRkSW1hZ2UiKTtsLmNhbGwodGhpcyk7dmFyIHA9Ri5jYWxsKHRoaXMsZSx0LGEsYyk7cmV0dXJuIHcuY2FsbCh0aGlzLG4scyxpLG8scCx1KSx0aGlzfTt2YXIgRj1mdW5jdGlvbih0LHIsbixpKXt2YXIgbyxhLGw7aWYoInN0cmluZyI9PXR5cGVvZiB0JiZzKHQpPT09QSl7dD11bmVzY2FwZSh0KTt2YXIgYz1RKHQsITEpOygiIiE9PWN8fHZvaWQgMCE9PShjPWUubG9hZEZpbGUodCwhMCkpKSYmKHQ9Yyl9aWYoZCh0KSYmKHQ9Zih0LHIpKSxyPXModCxyKSwhaChyKSl0aHJvdyBuZXcgRXJyb3IoImFkZEltYWdlIGRvZXMgbm90IHN1cHBvcnQgZmlsZXMgb2YgdHlwZSAnIityKyInLCBwbGVhc2UgZW5zdXJlIHRoYXQgYSBwbHVnaW4gZm9yICciK3IrIicgc3VwcG9ydCBpcyBhZGRlZC4iKTtpZigobnVsbD09KGw9bil8fDA9PT1sLmxlbmd0aCkmJihuPWZ1bmN0aW9uKGUpe3JldHVybiJzdHJpbmciPT10eXBlb2YgZXx8XyhlKT92KGUpOl8oZS5kYXRhKT92KGUuZGF0YSk6bnVsbH0odCkpLChvPWcuY2FsbCh0aGlzLG4pKXx8KHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fHwiUkdCQSI9PT1yfHwoYT10LHQ9aih0KSksbz10aGlzWyJwcm9jZXNzIityLnRvVXBwZXJDYXNlKCldKHQsdS5jYWxsKHRoaXMpLG4sZnVuY3Rpb24odCl7cmV0dXJuIHQmJiJzdHJpbmciPT10eXBlb2YgdCYmKHQ9dC50b1VwcGVyQ2FzZSgpKSx0IGluIGUuaW1hZ2VfY29tcHJlc3Npb24/dDp5Lk5PTkV9KGkpLGEpKSwhbyl0aHJvdyBuZXcgRXJyb3IoIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbHN0IHByb2Nlc3NpbmcgdGhlIGltYWdlLiIpO3JldHVybiBvfSxRPWUuX19hZGRpbWFnZV9fLmNvbnZlcnRCYXNlNjRUb0JpbmFyeVN0cmluZz1mdW5jdGlvbihlLHQpe3Q9ImJvb2xlYW4iIT10eXBlb2YgdHx8dDt2YXIgQSxyPSIiO2lmKCJzdHJpbmciPT10eXBlb2YgZSl7dmFyIG47QT1udWxsIT09KG49QyhlKSkmJnZvaWQgMCE9PW4/bjplO3RyeXtyPXAoQSl9Y2F0Y2goZSl7aWYodCl0aHJvdyBiKEEpP25ldyBFcnJvcigiYXRvYi1FcnJvciBpbiBqc1BERi5jb252ZXJ0QmFzZTY0VG9CaW5hcnlTdHJpbmcgIitlLm1lc3NhZ2UpOm5ldyBFcnJvcigiU3VwcGxpZWQgRGF0YSBpcyBub3QgYSB2YWxpZCBiYXNlNjQtU3RyaW5nIGpzUERGLmNvbnZlcnRCYXNlNjRUb0JpbmFyeVN0cmluZyAiKX19cmV0dXJuIHJ9O2UuZ2V0SW1hZ2VQcm9wZXJ0aWVzPWZ1bmN0aW9uKHQpe3ZhciByLG4saT0iIjtpZihkKHQpJiYodD1mKHQpKSwic3RyaW5nIj09dHlwZW9mIHQmJnModCk9PT1BJiYoIiI9PT0oaT1RKHQsITEpKSYmKGk9ZS5sb2FkRmlsZSh0KXx8IiIpLHQ9aSksbj1zKHQpLCFoKG4pKXRocm93IG5ldyBFcnJvcigiYWRkSW1hZ2UgZG9lcyBub3Qgc3VwcG9ydCBmaWxlcyBvZiB0eXBlICciK24rIicsIHBsZWFzZSBlbnN1cmUgdGhhdCBhIHBsdWdpbiBmb3IgJyIrbisiJyBzdXBwb3J0IGlzIGFkZGVkLiIpO2lmKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fHwodD1qKHQpKSwhKHI9dGhpc1sicHJvY2VzcyIrbi50b1VwcGVyQ2FzZSgpXSh0KSkpdGhyb3cgbmV3IEVycm9yKCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxzdCBwcm9jZXNzaW5nIHRoZSBpbWFnZSIpO3JldHVybiByLmZpbGVUeXBlPW4scn19KE0uQVBJKSxGZT1NLkFQSSxRZT1mdW5jdGlvbihlKXtpZih2b2lkIDAhPT1lJiYiIiE9ZSlyZXR1cm4hMH0sTS5BUEkuZXZlbnRzLnB1c2goWyJhZGRQYWdlIixmdW5jdGlvbihlKXt0aGlzLmludGVybmFsLmdldFBhZ2VJbmZvKGUucGFnZU51bWJlcikucGFnZUNvbnRleHQuYW5ub3RhdGlvbnM9W119XSksRmUuZXZlbnRzLnB1c2goWyJwdXRQYWdlIixmdW5jdGlvbihlKXtmb3IodmFyIHQsQSxyLG49dGhpcy5pbnRlcm5hbC5nZXRDb29yZGluYXRlU3RyaW5nLHM9dGhpcy5pbnRlcm5hbC5nZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmcsaT10aGlzLmludGVybmFsLmdldFBhZ2VJbmZvQnlPYmpJZChlLm9iaklkKSxvPWUucGFnZUNvbnRleHQuYW5ub3RhdGlvbnMsYT0hMSxsPTA7bDxvLmxlbmd0aCYmIWE7bCsrKXN3aXRjaCgodD1vW2xdKS50eXBlKXtjYXNlImxpbmsiOihRZSh0Lm9wdGlvbnMudXJsKXx8UWUodC5vcHRpb25zLnBhZ2VOdW1iZXIpKSYmKGE9ITApO2JyZWFrO2Nhc2UicmVmZXJlbmNlIjpjYXNlInRleHQiOmNhc2UiZnJlZXRleHQiOmE9ITB9aWYoMCE9YSl7dGhpcy5pbnRlcm5hbC53cml0ZSgiL0Fubm90cyBbIik7Zm9yKHZhciBjPTA7YzxvLmxlbmd0aDtjKyspe3Q9b1tjXTt2YXIgdT10aGlzLmludGVybmFsLnBkZkVzY2FwZSxoPXRoaXMuaW50ZXJuYWwuZ2V0RW5jcnlwdG9yKGUub2JqSWQpO3N3aXRjaCh0LnR5cGUpe2Nhc2UicmVmZXJlbmNlIjp0aGlzLmludGVybmFsLndyaXRlKCIgIit0Lm9iamVjdC5vYmpJZCsiIDAgUiAiKTticmVhaztjYXNlInRleHQiOnZhciBkPXRoaXMuaW50ZXJuYWwubmV3QWRkaXRpb25hbE9iamVjdCgpLGY9dGhpcy5pbnRlcm5hbC5uZXdBZGRpdGlvbmFsT2JqZWN0KCkscD10aGlzLmludGVybmFsLmdldEVuY3J5cHRvcihkLm9iaklkKSxnPXQudGl0bGV8fCJOb3RlIjtyPSI8PC9UeXBlIC9Bbm5vdCAvU3VidHlwZSAvVGV4dCAiKyhBPSIvUmVjdCBbIituKHQuYm91bmRzLngpKyIgIitzKHQuYm91bmRzLnkrdC5ib3VuZHMuaCkrIiAiK24odC5ib3VuZHMueCt0LmJvdW5kcy53KSsiICIrcyh0LmJvdW5kcy55KSsiXSAiKSsiL0NvbnRlbnRzICgiK3UocCh0LmNvbnRlbnRzKSkrIikiLHIrPSIgL1BvcHVwICIrZi5vYmpJZCsiIDAgUiIscis9IiAvUCAiK2kub2JqSWQrIiAwIFIiLHIrPSIgL1QgKCIrdShwKGcpKSsiKSA+PiIsZC5jb250ZW50PXI7dmFyIG09ZC5vYmpJZCsiIDAgUiI7cj0iPDwvVHlwZSAvQW5ub3QgL1N1YnR5cGUgL1BvcHVwICIrKEE9Ii9SZWN0IFsiK24odC5ib3VuZHMueCszMCkrIiAiK3ModC5ib3VuZHMueSt0LmJvdW5kcy5oKSsiICIrbih0LmJvdW5kcy54K3QuYm91bmRzLncrMzApKyIgIitzKHQuYm91bmRzLnkpKyJdICIpKyIgL1BhcmVudCAiK20sdC5vcGVuJiYocis9IiAvT3BlbiB0cnVlIikscis9IiA+PiIsZi5jb250ZW50PXIsdGhpcy5pbnRlcm5hbC53cml0ZShkLm9iaklkLCIwIFIiLGYub2JqSWQsIjAgUiIpO2JyZWFrO2Nhc2UiZnJlZXRleHQiOkE9Ii9SZWN0IFsiK24odC5ib3VuZHMueCkrIiAiK3ModC5ib3VuZHMueSkrIiAiK24odC5ib3VuZHMueCt0LmJvdW5kcy53KSsiICIrcyh0LmJvdW5kcy55K3QuYm91bmRzLmgpKyJdICI7dmFyIHc9dC5jb2xvcnx8IiMwMDAwMDAiO3I9Ijw8L1R5cGUgL0Fubm90IC9TdWJ0eXBlIC9GcmVlVGV4dCAiK0ErIi9Db250ZW50cyAoIit1KGgodC5jb250ZW50cykpKyIpIixyKz0iIC9EUyhmb250OiBIZWx2ZXRpY2Esc2Fucy1zZXJpZiAxMi4wcHQ7IHRleHQtYWxpZ246bGVmdDsgY29sb3I6IyIrdysiKSIscis9IiAvQm9yZGVyIFswIDAgMF0iLHIrPSIgPj4iLHRoaXMuaW50ZXJuYWwud3JpdGUocik7YnJlYWs7Y2FzZSJsaW5rIjppZih0Lm9wdGlvbnMubmFtZSl7dmFyIEI9dGhpcy5hbm5vdGF0aW9ucy5fbmFtZU1hcFt0Lm9wdGlvbnMubmFtZV07dC5vcHRpb25zLnBhZ2VOdW1iZXI9Qi5wYWdlLHQub3B0aW9ucy50b3A9Qi55fWVsc2UgdC5vcHRpb25zLnRvcHx8KHQub3B0aW9ucy50b3A9MCk7aWYoQT0iL1JlY3QgWyIrdC5maW5hbEJvdW5kcy54KyIgIit0LmZpbmFsQm91bmRzLnkrIiAiK3QuZmluYWxCb3VuZHMudysiICIrdC5maW5hbEJvdW5kcy5oKyJdICIscj0iIix0Lm9wdGlvbnMudXJsKXI9Ijw8L1R5cGUgL0Fubm90IC9TdWJ0eXBlIC9MaW5rICIrQSsiL0JvcmRlciBbMCAwIDBdIC9BIDw8L1MgL1VSSSAvVVJJICgiK3UoaCh0Lm9wdGlvbnMudXJsKSkrIikgPj4iO2Vsc2UgaWYodC5vcHRpb25zLnBhZ2VOdW1iZXIpc3dpdGNoKHI9Ijw8L1R5cGUgL0Fubm90IC9TdWJ0eXBlIC9MaW5rICIrQSsiL0JvcmRlciBbMCAwIDBdIC9EZXN0IFsiK3RoaXMuaW50ZXJuYWwuZ2V0UGFnZUluZm8odC5vcHRpb25zLnBhZ2VOdW1iZXIpLm9iaklkKyIgMCBSIix0Lm9wdGlvbnMubWFnRmFjdG9yPXQub3B0aW9ucy5tYWdGYWN0b3J8fCJYWVoiLHQub3B0aW9ucy5tYWdGYWN0b3Ipe2Nhc2UiRml0IjpyKz0iIC9GaXRdIjticmVhaztjYXNlIkZpdEgiOnIrPSIgL0ZpdEggIit0Lm9wdGlvbnMudG9wKyJdIjticmVhaztjYXNlIkZpdFYiOnQub3B0aW9ucy5sZWZ0PXQub3B0aW9ucy5sZWZ0fHwwLHIrPSIgL0ZpdFYgIit0Lm9wdGlvbnMubGVmdCsiXSI7YnJlYWs7ZGVmYXVsdDp2YXIgeT1zKHQub3B0aW9ucy50b3ApO3Qub3B0aW9ucy5sZWZ0PXQub3B0aW9ucy5sZWZ0fHwwLHZvaWQgMD09PXQub3B0aW9ucy56b29tJiYodC5vcHRpb25zLnpvb209MCkscis9IiAvWFlaICIrdC5vcHRpb25zLmxlZnQrIiAiK3krIiAiK3Qub3B0aW9ucy56b29tKyJdIn0iIiE9ciYmKHIrPSIgPj4iLHRoaXMuaW50ZXJuYWwud3JpdGUocikpfX10aGlzLmludGVybmFsLndyaXRlKCJdIil9fV0pLEZlLmNyZWF0ZUFubm90YXRpb249ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5pbnRlcm5hbC5nZXRDdXJyZW50UGFnZUluZm8oKTtzd2l0Y2goZS50eXBlKXtjYXNlImxpbmsiOnRoaXMubGluayhlLmJvdW5kcy54LGUuYm91bmRzLnksZS5ib3VuZHMudyxlLmJvdW5kcy5oLGUpO2JyZWFrO2Nhc2UidGV4dCI6Y2FzZSJmcmVldGV4dCI6dC5wYWdlQ29udGV4dC5hbm5vdGF0aW9ucy5wdXNoKGUpfX0sRmUubGluaz1mdW5jdGlvbihlLHQsQSxyLG4pe3ZhciBzPXRoaXMuaW50ZXJuYWwuZ2V0Q3VycmVudFBhZ2VJbmZvKCksaT10aGlzLmludGVybmFsLmdldENvb3JkaW5hdGVTdHJpbmcsbz10aGlzLmludGVybmFsLmdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZztzLnBhZ2VDb250ZXh0LmFubm90YXRpb25zLnB1c2goe2ZpbmFsQm91bmRzOnt4OmkoZSkseTpvKHQpLHc6aShlK0EpLGg6byh0K3IpfSxvcHRpb25zOm4sdHlwZToibGluayJ9KX0sRmUudGV4dFdpdGhMaW5rPWZ1bmN0aW9uKGUsdCxBLHIpe3ZhciBuLHMsaT10aGlzLmdldFRleHRXaWR0aChlKSxvPXRoaXMuaW50ZXJuYWwuZ2V0TGluZUhlaWdodCgpL3RoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3I7aWYodm9pZCAwIT09ci5tYXhXaWR0aCl7cz1yLm1heFdpZHRoO3ZhciBhPXRoaXMuc3BsaXRUZXh0VG9TaXplKGUscykubGVuZ3RoO249TWF0aC5jZWlsKG8qYSl9ZWxzZSBzPWksbj1vO3JldHVybiB0aGlzLnRleHQoZSx0LEEsciksQSs9LjIqbywiY2VudGVyIj09PXIuYWxpZ24mJih0LT1pLzIpLCJyaWdodCI9PT1yLmFsaWduJiYodC09aSksdGhpcy5saW5rKHQsQS1vLHMsbixyKSxpfSxGZS5nZXRUZXh0V2lkdGg9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpO3JldHVybiB0aGlzLmdldFN0cmluZ1VuaXRXaWR0aChlKSp0L3RoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3J9LGZ1bmN0aW9uKGUpe3ZhciB0PXsxNTY5Ols2NTE1Ml0sMTU3MDpbNjUxNTMsNjUxNTRdLDE1NzE6WzY1MTU1LDY1MTU2XSwxNTcyOls2NTE1Nyw2NTE1OF0sMTU3MzpbNjUxNTksNjUxNjBdLDE1NzQ6WzY1MTYxLDY1MTYyLDY1MTYzLDY1MTY0XSwxNTc1Ols2NTE2NSw2NTE2Nl0sMTU3NjpbNjUxNjcsNjUxNjgsNjUxNjksNjUxNzBdLDE1Nzc6WzY1MTcxLDY1MTcyXSwxNTc4Ols2NTE3Myw2NTE3NCw2NTE3NSw2NTE3Nl0sMTU3OTpbNjUxNzcsNjUxNzgsNjUxNzksNjUxODBdLDE1ODA6WzY1MTgxLDY1MTgyLDY1MTgzLDY1MTg0XSwxNTgxOls2NTE4NSw2NTE4Niw2NTE4Nyw2NTE4OF0sMTU4MjpbNjUxODksNjUxOTAsNjUxOTEsNjUxOTJdLDE1ODM6WzY1MTkzLDY1MTk0XSwxNTg0Ols2NTE5NSw2NTE5Nl0sMTU4NTpbNjUxOTcsNjUxOThdLDE1ODY6WzY1MTk5LDY1MjAwXSwxNTg3Ols2NTIwMSw2NTIwMiw2NTIwMyw2NTIwNF0sMTU4ODpbNjUyMDUsNjUyMDYsNjUyMDcsNjUyMDhdLDE1ODk6WzY1MjA5LDY1MjEwLDY1MjExLDY1MjEyXSwxNTkwOls2NTIxMyw2NTIxNCw2NTIxNSw2NTIxNl0sMTU5MTpbNjUyMTcsNjUyMTgsNjUyMTksNjUyMjBdLDE1OTI6WzY1MjIxLDY1MjIyLDY1MjIzLDY1MjI0XSwxNTkzOls2NTIyNSw2NTIyNiw2NTIyNyw2NTIyOF0sMTU5NDpbNjUyMjksNjUyMzAsNjUyMzEsNjUyMzJdLDE2MDE6WzY1MjMzLDY1MjM0LDY1MjM1LDY1MjM2XSwxNjAyOls2NTIzNyw2NTIzOCw2NTIzOSw2NTI0MF0sMTYwMzpbNjUyNDEsNjUyNDIsNjUyNDMsNjUyNDRdLDE2MDQ6WzY1MjQ1LDY1MjQ2LDY1MjQ3LDY1MjQ4XSwxNjA1Ols2NTI0OSw2NTI1MCw2NTI1MSw2NTI1Ml0sMTYwNjpbNjUyNTMsNjUyNTQsNjUyNTUsNjUyNTZdLDE2MDc6WzY1MjU3LDY1MjU4LDY1MjU5LDY1MjYwXSwxNjA4Ols2NTI2MSw2NTI2Ml0sMTYwOTpbNjUyNjMsNjUyNjQsNjQ0ODgsNjQ0ODldLDE2MTA6WzY1MjY1LDY1MjY2LDY1MjY3LDY1MjY4XSwxNjQ5Ols2NDMzNiw2NDMzN10sMTY1NTpbNjQ0NzddLDE2NTc6WzY0MzU4LDY0MzU5LDY0MzYwLDY0MzYxXSwxNjU4Ols2NDM1MCw2NDM1MSw2NDM1Miw2NDM1M10sMTY1OTpbNjQzMzgsNjQzMzksNjQzNDAsNjQzNDFdLDE2NjI6WzY0MzQyLDY0MzQzLDY0MzQ0LDY0MzQ1XSwxNjYzOls2NDM1NCw2NDM1NSw2NDM1Niw2NDM1N10sMTY2NDpbNjQzNDYsNjQzNDcsNjQzNDgsNjQzNDldLDE2Njc6WzY0Mzc0LDY0Mzc1LDY0Mzc2LDY0Mzc3XSwxNjY4Ols2NDM3MCw2NDM3MSw2NDM3Miw2NDM3M10sMTY3MDpbNjQzNzgsNjQzNzksNjQzODAsNjQzODFdLDE2NzE6WzY0MzgyLDY0MzgzLDY0Mzg0LDY0Mzg1XSwxNjcyOls2NDM5Miw2NDM5M10sMTY3NjpbNjQzODgsNjQzODldLDE2Nzc6WzY0Mzg2LDY0Mzg3XSwxNjc4Ols2NDM5MCw2NDM5MV0sMTY4MTpbNjQzOTYsNjQzOTddLDE2ODg6WzY0Mzk0LDY0Mzk1XSwxNzAwOls2NDM2Miw2NDM2Myw2NDM2NCw2NDM2NV0sMTcwMjpbNjQzNjYsNjQzNjcsNjQzNjgsNjQzNjldLDE3MDU6WzY0Mzk4LDY0Mzk5LDY0NDAwLDY0NDAxXSwxNzA5Ols2NDQ2Nyw2NDQ2OCw2NDQ2OSw2NDQ3MF0sMTcxMTpbNjQ0MDIsNjQ0MDMsNjQ0MDQsNjQ0MDVdLDE3MTM6WzY0NDEwLDY0NDExLDY0NDEyLDY0NDEzXSwxNzE1Ols2NDQwNiw2NDQwNyw2NDQwOCw2NDQwOV0sMTcyMjpbNjQ0MTQsNjQ0MTVdLDE3MjM6WzY0NDE2LDY0NDE3LDY0NDE4LDY0NDE5XSwxNzI2Ols2NDQyNiw2NDQyNyw2NDQyOCw2NDQyOV0sMTcyODpbNjQ0MjAsNjQ0MjFdLDE3Mjk6WzY0NDIyLDY0NDIzLDY0NDI0LDY0NDI1XSwxNzMzOls2NDQ4MCw2NDQ4MV0sMTczNDpbNjQ0NzMsNjQ0NzRdLDE3MzU6WzY0NDcxLDY0NDcyXSwxNzM2Ols2NDQ3NSw2NDQ3Nl0sMTczNzpbNjQ0ODIsNjQ0ODNdLDE3Mzk6WzY0NDc4LDY0NDc5XSwxNzQwOls2NDUwOCw2NDUwOSw2NDUxMCw2NDUxMV0sMTc0NDpbNjQ0ODQsNjQ0ODUsNjQ0ODYsNjQ0ODddLDE3NDY6WzY0NDMwLDY0NDMxXSwxNzQ3Ols2NDQzMiw2NDQzM119LEE9ezY1MjQ3Ons2NTE1NDo2NTI2OSw2NTE1Njo2NTI3MSw2NTE2MDo2NTI3Myw2NTE2Njo2NTI3NX0sNjUyNDg6ezY1MTU0OjY1MjcwLDY1MTU2OjY1MjcyLDY1MTYwOjY1Mjc0LDY1MTY2OjY1Mjc2fSw2NTE2NTp7NjUyNDc6ezY1MjQ4Ons2NTI1ODo2NTAxMH19fSwxNjE3OnsxNjEyOjY0NjA2LDE2MTM6NjQ2MDcsMTYxNDo2NDYwOCwxNjE1OjY0NjA5LDE2MTY6NjQ2MTB9fSxyPXsxNjEyOjY0NjA2LDE2MTM6NjQ2MDcsMTYxNDo2NDYwOCwxNjE1OjY0NjA5LDE2MTY6NjQ2MTB9LG49WzE1NzAsMTU3MSwxNTczLDE1NzVdO2UuX19hcmFiaWNQYXJzZXJfXz17fTt2YXIgcz1lLl9fYXJhYmljUGFyc2VyX18uaXNJbkFyYWJpY1N1YnN0aXR1dGlvbkE9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMCE9PXRbZS5jaGFyQ29kZUF0KDApXX0saT1lLl9fYXJhYmljUGFyc2VyX18uaXNBcmFiaWNMZXR0ZXI9ZnVuY3Rpb24oZSl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiBlJiYvXltcdTA2MDAtXHUwNkZGXHUwNzUwLVx1MDc3Rlx1MDhBMC1cdTA4RkZcdUZCNTAtXHVGREZGXHVGRTcwLVx1RkVGRl0rJC8udGVzdChlKX0sbz1lLl9fYXJhYmljUGFyc2VyX18uaXNBcmFiaWNFbmRMZXR0ZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIGkoZSkmJnMoZSkmJnRbZS5jaGFyQ29kZUF0KDApXS5sZW5ndGg8PTJ9LGE9ZS5fX2FyYWJpY1BhcnNlcl9fLmlzQXJhYmljQWxmTGV0dGVyPWZ1bmN0aW9uKGUpe3JldHVybiBpKGUpJiZuLmluZGV4T2YoZS5jaGFyQ29kZUF0KDApKT49MH07ZS5fX2FyYWJpY1BhcnNlcl9fLmFyYWJpY0xldHRlckhhc0lzb2xhdGVkRm9ybT1mdW5jdGlvbihlKXtyZXR1cm4gaShlKSYmcyhlKSYmdFtlLmNoYXJDb2RlQXQoMCldLmxlbmd0aD49MX07dmFyIGw9ZS5fX2FyYWJpY1BhcnNlcl9fLmFyYWJpY0xldHRlckhhc0ZpbmFsRm9ybT1mdW5jdGlvbihlKXtyZXR1cm4gaShlKSYmcyhlKSYmdFtlLmNoYXJDb2RlQXQoMCldLmxlbmd0aD49Mn07ZS5fX2FyYWJpY1BhcnNlcl9fLmFyYWJpY0xldHRlckhhc0luaXRpYWxGb3JtPWZ1bmN0aW9uKGUpe3JldHVybiBpKGUpJiZzKGUpJiZ0W2UuY2hhckNvZGVBdCgwKV0ubGVuZ3RoPj0zfTt2YXIgYz1lLl9fYXJhYmljUGFyc2VyX18uYXJhYmljTGV0dGVySGFzTWVkaWFsRm9ybT1mdW5jdGlvbihlKXtyZXR1cm4gaShlKSYmcyhlKSYmND09dFtlLmNoYXJDb2RlQXQoMCldLmxlbmd0aH0sdT1lLl9fYXJhYmljUGFyc2VyX18ucmVzb2x2ZUxpZ2F0dXJlcz1mdW5jdGlvbihlKXt2YXIgdD0wLHI9QSxuPSIiLHM9MDtmb3IodD0wO3Q8ZS5sZW5ndGg7dCs9MSl2b2lkIDAhPT1yW2UuY2hhckNvZGVBdCh0KV0/KHMrKywibnVtYmVyIj09dHlwZW9mKHI9cltlLmNoYXJDb2RlQXQodCldKSYmKG4rPVN0cmluZy5mcm9tQ2hhckNvZGUocikscj1BLHM9MCksdD09PWUubGVuZ3RoLTEmJihyPUEsbis9ZS5jaGFyQXQodC0ocy0xKSksdC09cy0xLHM9MCkpOihyPUEsbis9ZS5jaGFyQXQodC1zKSx0LT1zLHM9MCk7cmV0dXJuIG59O2UuX19hcmFiaWNQYXJzZXJfXy5pc0FyYWJpY0RpYWNyaXRpYz1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09ZSYmdm9pZCAwIT09cltlLmNoYXJDb2RlQXQoMCldfTt2YXIgaD1lLl9fYXJhYmljUGFyc2VyX18uZ2V0Q29ycmVjdEZvcm09ZnVuY3Rpb24oZSx0LEEpe3JldHVybiBpKGUpPyExPT09cyhlKT8tMTohbChlKXx8IWkodCkmJiFpKEEpfHwhaShBKSYmbyh0KXx8byhlKSYmIWkodCl8fG8oZSkmJmEodCl8fG8oZSkmJm8odCk/MDpjKGUpJiZpKHQpJiYhbyh0KSYmaShBKSYmbChBKT8zOm8oZSl8fCFpKEEpPzE6MjotMX0sZD1mdW5jdGlvbihlKXt2YXIgQT0wLHI9MCxuPTAscz0iIixvPSIiLGE9IiIsbD0oZT1lfHwiIikuc3BsaXQoIlxccysiKSxjPVtdO2ZvcihBPTA7QTxsLmxlbmd0aDtBKz0xKXtmb3IoYy5wdXNoKCIiKSxyPTA7cjxsW0FdLmxlbmd0aDtyKz0xKXM9bFtBXVtyXSxvPWxbQV1bci0xXSxhPWxbQV1bcisxXSxpKHMpPyhuPWgocyxvLGEpLGNbQV0rPS0xIT09bj9TdHJpbmcuZnJvbUNoYXJDb2RlKHRbcy5jaGFyQ29kZUF0KDApXVtuXSk6cyk6Y1tBXSs9cztjW0FdPXUoY1tBXSl9cmV0dXJuIGMuam9pbigiICIpfSxmPWUuX19hcmFiaWNQYXJzZXJfXy5wcm9jZXNzQXJhYmljPWUucHJvY2Vzc0FyYWJpYz1mdW5jdGlvbigpe3ZhciBlLHQ9InN0cmluZyI9PXR5cGVvZiBhcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOmFyZ3VtZW50c1swXS50ZXh0LEE9W107aWYoQXJyYXkuaXNBcnJheSh0KSl7dmFyIHI9MDtmb3IoQT1bXSxyPTA7cjx0Lmxlbmd0aDtyKz0xKUFycmF5LmlzQXJyYXkodFtyXSk/QS5wdXNoKFtkKHRbcl1bMF0pLHRbcl1bMV0sdFtyXVsyXV0pOkEucHVzaChbZCh0W3JdKV0pO2U9QX1lbHNlIGU9ZCh0KTtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIGFyZ3VtZW50c1swXT9lOihhcmd1bWVudHNbMF0udGV4dD1lLGFyZ3VtZW50c1swXSl9O2UuZXZlbnRzLnB1c2goWyJwcmVQcm9jZXNzVGV4dCIsZl0pfShNLkFQSSksTS5BUEkuYXV0b1ByaW50PWZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybihlPWV8fHt9KS52YXJpYW50PWUudmFyaWFudHx8Im5vbi1jb25mb3JtIiwiamF2YXNjcmlwdCI9PT1lLnZhcmlhbnQ/dGhpcy5hZGRKUygicHJpbnQoe30pOyIpOih0aGlzLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInBvc3RQdXRSZXNvdXJjZXMiLGZ1bmN0aW9uKCl7dD10aGlzLmludGVybmFsLm5ld09iamVjdCgpLHRoaXMuaW50ZXJuYWwub3V0KCI8PCIpLHRoaXMuaW50ZXJuYWwub3V0KCIvUyAvTmFtZWQiKSx0aGlzLmludGVybmFsLm91dCgiL1R5cGUgL0FjdGlvbiIpLHRoaXMuaW50ZXJuYWwub3V0KCIvTiAvUHJpbnQiKSx0aGlzLmludGVybmFsLm91dCgiPj4iKSx0aGlzLmludGVybmFsLm91dCgiZW5kb2JqIil9KSx0aGlzLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInB1dENhdGFsb2ciLGZ1bmN0aW9uKCl7dGhpcy5pbnRlcm5hbC5vdXQoIi9PcGVuQWN0aW9uICIrdCsiIDAgUiIpfSkpLHRoaXN9LGZ1bmN0aW9uKGUpe3ZhciB0PWZ1bmN0aW9uKCl7dmFyIGU9dm9pZCAwO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwZGYiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZX0sc2V0OmZ1bmN0aW9uKHQpe2U9dH19KTt2YXIgdD0xNTA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndpZHRoIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHR9LHNldDpmdW5jdGlvbihlKXt0PWlzTmFOKGUpfHwhMT09PU51bWJlci5pc0ludGVnZXIoZSl8fGU8MD8xNTA6ZSx0aGlzLmdldENvbnRleHQoIjJkIikucGFnZVdyYXBYRW5hYmxlZCYmKHRoaXMuZ2V0Q29udGV4dCgiMmQiKS5wYWdlV3JhcFg9dCsxKX19KTt2YXIgQT0zMDA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImhlaWdodCIse2dldDpmdW5jdGlvbigpe3JldHVybiBBfSxzZXQ6ZnVuY3Rpb24oZSl7QT1pc05hTihlKXx8ITE9PT1OdW1iZXIuaXNJbnRlZ2VyKGUpfHxlPDA/MzAwOmUsdGhpcy5nZXRDb250ZXh0KCIyZCIpLnBhZ2VXcmFwWUVuYWJsZWQmJih0aGlzLmdldENvbnRleHQoIjJkIikucGFnZVdyYXBZPUErMSl9fSk7dmFyIHI9W107T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNoaWxkTm9kZXMiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn0sc2V0OmZ1bmN0aW9uKGUpe3I9ZX19KTt2YXIgbj17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3R5bGUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbn0sc2V0OmZ1bmN0aW9uKGUpe249ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFyZW50Tm9kZSIse30pfTt0LnByb3RvdHlwZS5nZXRDb250ZXh0PWZ1bmN0aW9uKGUsdCl7dmFyIEE7aWYoIjJkIiE9PShlPWV8fCIyZCIpKXJldHVybiBudWxsO2ZvcihBIGluIHQpdGhpcy5wZGYuY29udGV4dDJkLmhhc093blByb3BlcnR5KEEpJiYodGhpcy5wZGYuY29udGV4dDJkW0FdPXRbQV0pO3JldHVybiB0aGlzLnBkZi5jb250ZXh0MmQuX2NhbnZhcz10aGlzLHRoaXMucGRmLmNvbnRleHQyZH0sdC5wcm90b3R5cGUudG9EYXRhVVJMPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKCJ0b0RhdGFVUkwgaXMgbm90IGltcGxlbWVudGVkLiIpfSxlLmV2ZW50cy5wdXNoKFsiaW5pdGlhbGl6ZWQiLGZ1bmN0aW9uKCl7dGhpcy5jYW52YXM9bmV3IHQsdGhpcy5jYW52YXMucGRmPXRoaXN9XSl9KE0uQVBJKSxmdW5jdGlvbihlKXt2YXIgdD17bGVmdDowLHRvcDowLGJvdHRvbTowLHJpZ2h0OjB9LEE9ITEsbj1mdW5jdGlvbigpe3ZvaWQgMD09PXRoaXMuaW50ZXJuYWwuX19jZWxsX18mJih0aGlzLmludGVybmFsLl9fY2VsbF9fPXt9LHRoaXMuaW50ZXJuYWwuX19jZWxsX18ucGFkZGluZz0zLHRoaXMuaW50ZXJuYWwuX19jZWxsX18uaGVhZGVyRnVuY3Rpb249dm9pZCAwLHRoaXMuaW50ZXJuYWwuX19jZWxsX18ubWFyZ2lucz1PYmplY3QuYXNzaWduKHt9LHQpLHRoaXMuaW50ZXJuYWwuX19jZWxsX18ubWFyZ2lucy53aWR0aD10aGlzLmdldFBhZ2VXaWR0aCgpLHMuY2FsbCh0aGlzKSl9LHM9ZnVuY3Rpb24oKXt0aGlzLmludGVybmFsLl9fY2VsbF9fLmxhc3RDZWxsPW5ldyBpLHRoaXMuaW50ZXJuYWwuX19jZWxsX18ucGFnZXM9MX0saT1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50c1swXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGV9LHNldDpmdW5jdGlvbih0KXtlPXR9fSk7dmFyIHQ9YXJndW1lbnRzWzFdO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ5Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH0sc2V0OmZ1bmN0aW9uKGUpe3Q9ZX19KTt2YXIgQT1hcmd1bWVudHNbMl07T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndpZHRoIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQX0sc2V0OmZ1bmN0aW9uKGUpe0E9ZX19KTt2YXIgcj1hcmd1bWVudHNbM107T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImhlaWdodCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHNldDpmdW5jdGlvbihlKXtyPWV9fSk7dmFyIG49YXJndW1lbnRzWzRdO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0ZXh0Iix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbn0sc2V0OmZ1bmN0aW9uKGUpe249ZX19KTt2YXIgcz1hcmd1bWVudHNbNV07T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxpbmVOdW1iZXIiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzfSxzZXQ6ZnVuY3Rpb24oZSl7cz1lfX0pO3ZhciBpPWFyZ3VtZW50c1s2XTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFsaWduIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sc2V0OmZ1bmN0aW9uKGUpe2k9ZX19KSx0aGlzfTtpLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgaSh0aGlzLngsdGhpcy55LHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsdGhpcy50ZXh0LHRoaXMubGluZU51bWJlcix0aGlzLmFsaWduKX0saS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe3JldHVyblt0aGlzLngsdGhpcy55LHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsdGhpcy50ZXh0LHRoaXMubGluZU51bWJlcix0aGlzLmFsaWduXX0sZS5zZXRIZWFkZXJGdW5jdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gbi5jYWxsKHRoaXMpLHRoaXMuaW50ZXJuYWwuX19jZWxsX18uaGVhZGVyRnVuY3Rpb249ImZ1bmN0aW9uIj09dHlwZW9mIGU/ZTp2b2lkIDAsdGhpc30sZS5nZXRUZXh0RGltZW5zaW9ucz1mdW5jdGlvbihlLHQpe24uY2FsbCh0aGlzKTt2YXIgQT0odD10fHx7fSkuZm9udFNpemV8fHRoaXMuZ2V0Rm9udFNpemUoKSxyPXQuZm9udHx8dGhpcy5nZXRGb250KCkscz10LnNjYWxlRmFjdG9yfHx0aGlzLmludGVybmFsLnNjYWxlRmFjdG9yLGk9MCxvPTAsYT0wLGw9dGhpcztpZighQXJyYXkuaXNBcnJheShlKSYmInN0cmluZyIhPXR5cGVvZiBlKXtpZigibnVtYmVyIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKCJnZXRUZXh0RGltZW5zaW9ucyBleHBlY3RzIHRleHQtcGFyYW1ldGVyIHRvIGJlIG9mIHR5cGUgU3RyaW5nIG9yIHR5cGUgTnVtYmVyIG9yIGFuIEFycmF5IG9mIFN0cmluZ3MuIik7ZT1TdHJpbmcoZSl9dmFyIGM9dC5tYXhXaWR0aDtjPjA/InN0cmluZyI9PXR5cGVvZiBlP2U9dGhpcy5zcGxpdFRleHRUb1NpemUoZSxjKToiW29iamVjdCBBcnJheV0iPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpJiYoZT1lLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlLmNvbmNhdChsLnNwbGl0VGV4dFRvU2l6ZSh0LGMpKX0sW10pKTplPUFycmF5LmlzQXJyYXkoZSk/ZTpbZV07Zm9yKHZhciB1PTA7dTxlLmxlbmd0aDt1KyspaTwoYT10aGlzLmdldFN0cmluZ1VuaXRXaWR0aChlW3VdLHtmb250OnJ9KSpBKSYmKGk9YSk7cmV0dXJuIDAhPT1pJiYobz1lLmxlbmd0aCkse3c6aS89cyxoOk1hdGgubWF4KChvKkEqdGhpcy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCktQSoodGhpcy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCktMSkpL3MsMCl9fSxlLmNlbGxBZGRQYWdlPWZ1bmN0aW9uKCl7bi5jYWxsKHRoaXMpLHRoaXMuYWRkUGFnZSgpO3ZhciBlPXRoaXMuaW50ZXJuYWwuX19jZWxsX18ubWFyZ2luc3x8dDtyZXR1cm4gdGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5sYXN0Q2VsbD1uZXcgaShlLmxlZnQsZS50b3Asdm9pZCAwLHZvaWQgMCksdGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5wYWdlcys9MSx0aGlzfTt2YXIgbz1lLmNlbGw9ZnVuY3Rpb24oKXt2YXIgZTtlPWFyZ3VtZW50c1swXWluc3RhbmNlb2YgaT9hcmd1bWVudHNbMF06bmV3IGkoYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0pLG4uY2FsbCh0aGlzKTt2YXIgcj10aGlzLmludGVybmFsLl9fY2VsbF9fLmxhc3RDZWxsLHM9dGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5wYWRkaW5nLG89dGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5tYXJnaW5zfHx0LGE9dGhpcy5pbnRlcm5hbC5fX2NlbGxfXy50YWJsZUhlYWRlclJvdyxsPXRoaXMuaW50ZXJuYWwuX19jZWxsX18ucHJpbnRIZWFkZXJzO3JldHVybiB2b2lkIDAhPT1yLmxpbmVOdW1iZXImJihyLmxpbmVOdW1iZXI9PT1lLmxpbmVOdW1iZXI/KGUueD0oci54fHwwKSsoci53aWR0aHx8MCksZS55PXIueXx8MCk6ci55K3IuaGVpZ2h0K2UuaGVpZ2h0K28uYm90dG9tPnRoaXMuZ2V0UGFnZUhlaWdodCgpPyh0aGlzLmNlbGxBZGRQYWdlKCksZS55PW8udG9wLGwmJmEmJih0aGlzLnByaW50SGVhZGVyUm93KGUubGluZU51bWJlciwhMCksZS55Kz1hWzBdLmhlaWdodCkpOmUueT1yLnkrci5oZWlnaHR8fGUueSksdm9pZCAwIT09ZS50ZXh0WzBdJiYodGhpcy5yZWN0KGUueCxlLnksZS53aWR0aCxlLmhlaWdodCwhMD09PUE/IkZEIjp2b2lkIDApLCJyaWdodCI9PT1lLmFsaWduP3RoaXMudGV4dChlLnRleHQsZS54K2Uud2lkdGgtcyxlLnkrcyx7YWxpZ246InJpZ2h0IixiYXNlbGluZToidG9wIn0pOiJjZW50ZXIiPT09ZS5hbGlnbj90aGlzLnRleHQoZS50ZXh0LGUueCtlLndpZHRoLzIsZS55K3Mse2FsaWduOiJjZW50ZXIiLGJhc2VsaW5lOiJ0b3AiLG1heFdpZHRoOmUud2lkdGgtcy1zfSk6dGhpcy50ZXh0KGUudGV4dCxlLngrcyxlLnkrcyx7YWxpZ246ImxlZnQiLGJhc2VsaW5lOiJ0b3AiLG1heFdpZHRoOmUud2lkdGgtcy1zfSkpLHRoaXMuaW50ZXJuYWwuX19jZWxsX18ubGFzdENlbGw9ZSx0aGlzfTtlLnRhYmxlPWZ1bmN0aW9uKGUsQSxsLGMsdSl7aWYobi5jYWxsKHRoaXMpLCFsKXRocm93IG5ldyBFcnJvcigiTm8gZGF0YSBmb3IgUERGIHRhYmxlLiIpO3ZhciBoLGQsZixwLGc9W10sbT1bXSx3PVtdLEI9e30seT17fSx2PVtdLGI9W10sQz0odT11fHx7fSkuYXV0b1NpemV8fCExLF89ITEhPT11LnByaW50SGVhZGVycyxqPXUuY3NzJiZ2b2lkIDAhPT11LmNzc1siZm9udC1zaXplIl0/MTYqdS5jc3NbImZvbnQtc2l6ZSJdOnUuZm9udFNpemV8fDEyLHg9dS5tYXJnaW5zfHxPYmplY3QuYXNzaWduKHt3aWR0aDp0aGlzLmdldFBhZ2VXaWR0aCgpfSx0KSxGPSJudW1iZXIiPT10eXBlb2YgdS5wYWRkaW5nP3UucGFkZGluZzozLFE9dS5oZWFkZXJCYWNrZ3JvdW5kQ29sb3J8fCIjYzhjOGM4IixVPXUuaGVhZGVyVGV4dENvbG9yfHwiIzAwMCI7aWYocy5jYWxsKHRoaXMpLHRoaXMuaW50ZXJuYWwuX19jZWxsX18ucHJpbnRIZWFkZXJzPV8sdGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5tYXJnaW5zPXgsdGhpcy5pbnRlcm5hbC5fX2NlbGxfXy50YWJsZV9mb250X3NpemU9aix0aGlzLmludGVybmFsLl9fY2VsbF9fLnBhZGRpbmc9Rix0aGlzLmludGVybmFsLl9fY2VsbF9fLmhlYWRlckJhY2tncm91bmRDb2xvcj1RLHRoaXMuaW50ZXJuYWwuX19jZWxsX18uaGVhZGVyVGV4dENvbG9yPVUsdGhpcy5zZXRGb250U2l6ZShqKSxudWxsPT1jKW09Zz1PYmplY3Qua2V5cyhsWzBdKSx3PWcubWFwKGZ1bmN0aW9uKCl7cmV0dXJuImxlZnQifSk7ZWxzZSBpZihBcnJheS5pc0FycmF5KGMpJiYib2JqZWN0Ij09PSgwLHIuZGVmYXVsdCkoY1swXSkpZm9yKGc9Yy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pLG09Yy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUucHJvbXB0fHxlLm5hbWV8fCIifSksdz1jLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5hbGlnbnx8ImxlZnQifSksaD0wO2g8Yy5sZW5ndGg7aCs9MSl5W2NbaF0ubmFtZV09Ljc0OTk5OTA1NTExODExMDMqY1toXS53aWR0aDtlbHNlIEFycmF5LmlzQXJyYXkoYykmJiJzdHJpbmciPT10eXBlb2YgY1swXSYmKG09Zz1jLHc9Zy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4ibGVmdCJ9KSk7aWYoQ3x8QXJyYXkuaXNBcnJheShjKSYmInN0cmluZyI9PXR5cGVvZiBjWzBdKWZvcihoPTA7aDxnLmxlbmd0aDtoKz0xKXtmb3IoQltwPWdbaF1dPWwubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlW3BdfSksdGhpcy5zZXRGb250KHZvaWQgMCwiYm9sZCIpLHYucHVzaCh0aGlzLmdldFRleHREaW1lbnNpb25zKG1baF0se2ZvbnRTaXplOnRoaXMuaW50ZXJuYWwuX19jZWxsX18udGFibGVfZm9udF9zaXplLHNjYWxlRmFjdG9yOnRoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3J9KS53KSxkPUJbcF0sdGhpcy5zZXRGb250KHZvaWQgMCwibm9ybWFsIiksZj0wO2Y8ZC5sZW5ndGg7Zis9MSl2LnB1c2godGhpcy5nZXRUZXh0RGltZW5zaW9ucyhkW2ZdLHtmb250U2l6ZTp0aGlzLmludGVybmFsLl9fY2VsbF9fLnRhYmxlX2ZvbnRfc2l6ZSxzY2FsZUZhY3Rvcjp0aGlzLmludGVybmFsLnNjYWxlRmFjdG9yfSkudyk7eVtwXT1NYXRoLm1heC5hcHBseShudWxsLHYpK0YrRix2PVtdfWlmKF8pe3ZhciBFPXt9O2ZvcihoPTA7aDxnLmxlbmd0aDtoKz0xKUVbZ1toXV09e30sRVtnW2hdXS50ZXh0PW1baF0sRVtnW2hdXS5hbGlnbj13W2hdO3ZhciBTPWEuY2FsbCh0aGlzLEUseSk7Yj1nLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkoZSxBLHlbdF0sUyxFW3RdLnRleHQsdm9pZCAwLEVbdF0uYWxpZ24pfSksdGhpcy5zZXRUYWJsZUhlYWRlclJvdyhiKSx0aGlzLnByaW50SGVhZGVyUm93KDEsITEpfXZhciBMPWMucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbdC5uYW1lXT10LmFsaWduLGV9LHt9KTtmb3IoaD0wO2g8bC5sZW5ndGg7aCs9MSl7InJvd1N0YXJ0ImluIHUmJnUucm93U3RhcnQgaW5zdGFuY2VvZiBGdW5jdGlvbiYmdS5yb3dTdGFydCh7cm93OmgsZGF0YTpsW2hdfSx0aGlzKTt2YXIgST1hLmNhbGwodGhpcyxsW2hdLHkpO2ZvcihmPTA7ZjxnLmxlbmd0aDtmKz0xKXt2YXIgTj1sW2hdW2dbZl1dOyJjZWxsU3RhcnQiaW4gdSYmdS5jZWxsU3RhcnQgaW5zdGFuY2VvZiBGdW5jdGlvbiYmdS5jZWxsU3RhcnQoe3JvdzpoLGNvbDpmLGRhdGE6Tn0sdGhpcyksby5jYWxsKHRoaXMsbmV3IGkoZSxBLHlbZ1tmXV0sSSxOLGgrMixMW2dbZl1dKSl9fXJldHVybiB0aGlzLmludGVybmFsLl9fY2VsbF9fLnRhYmxlX3g9ZSx0aGlzLmludGVybmFsLl9fY2VsbF9fLnRhYmxlX3k9QSx0aGlzfTt2YXIgYT1mdW5jdGlvbihlLHQpe3ZhciBBPXRoaXMuaW50ZXJuYWwuX19jZWxsX18ucGFkZGluZyxyPXRoaXMuaW50ZXJuYWwuX19jZWxsX18udGFibGVfZm9udF9zaXplLG49dGhpcy5pbnRlcm5hbC5zY2FsZUZhY3RvcjtyZXR1cm4gT2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHIpe3ZhciBuPWVbcl07cmV0dXJuIHRoaXMuc3BsaXRUZXh0VG9TaXplKG4uaGFzT3duUHJvcGVydHkoInRleHQiKT9uLnRleHQ6bix0W3JdLUEtQSl9LHRoaXMpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCkqZS5sZW5ndGgqci9uK0ErQX0sdGhpcykucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIE1hdGgubWF4KGUsdCl9LDApfTtlLnNldFRhYmxlSGVhZGVyUm93PWZ1bmN0aW9uKGUpe24uY2FsbCh0aGlzKSx0aGlzLmludGVybmFsLl9fY2VsbF9fLnRhYmxlSGVhZGVyUm93PWV9LGUucHJpbnRIZWFkZXJSb3c9ZnVuY3Rpb24oZSx0KXtpZihuLmNhbGwodGhpcyksIXRoaXMuaW50ZXJuYWwuX19jZWxsX18udGFibGVIZWFkZXJSb3cpdGhyb3cgbmV3IEVycm9yKCJQcm9wZXJ0eSB0YWJsZUhlYWRlclJvdyBkb2VzIG5vdCBleGlzdC4iKTt2YXIgcjtpZihBPSEwLCJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzLmludGVybmFsLl9fY2VsbF9fLmhlYWRlckZ1bmN0aW9uKXt2YXIgcz10aGlzLmludGVybmFsLl9fY2VsbF9fLmhlYWRlckZ1bmN0aW9uKHRoaXMsdGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5wYWdlcyk7dGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5sYXN0Q2VsbD1uZXcgaShzWzBdLHNbMV0sc1syXSxzWzNdLHZvaWQgMCwtMSl9dGhpcy5zZXRGb250KHZvaWQgMCwiYm9sZCIpO2Zvcih2YXIgYT1bXSxsPTA7bDx0aGlzLmludGVybmFsLl9fY2VsbF9fLnRhYmxlSGVhZGVyUm93Lmxlbmd0aDtsKz0xKXtyPXRoaXMuaW50ZXJuYWwuX19jZWxsX18udGFibGVIZWFkZXJSb3dbbF0uY2xvbmUoKSx0JiYoci55PXRoaXMuaW50ZXJuYWwuX19jZWxsX18ubWFyZ2lucy50b3B8fDAsYS5wdXNoKHIpKSxyLmxpbmVOdW1iZXI9ZTt2YXIgYz10aGlzLmdldFRleHRDb2xvcigpO3RoaXMuc2V0VGV4dENvbG9yKHRoaXMuaW50ZXJuYWwuX19jZWxsX18uaGVhZGVyVGV4dENvbG9yKSx0aGlzLnNldEZpbGxDb2xvcih0aGlzLmludGVybmFsLl9fY2VsbF9fLmhlYWRlckJhY2tncm91bmRDb2xvciksby5jYWxsKHRoaXMsciksdGhpcy5zZXRUZXh0Q29sb3IoYyl9YS5sZW5ndGg+MCYmdGhpcy5zZXRUYWJsZUhlYWRlclJvdyhhKSx0aGlzLnNldEZvbnQodm9pZCAwLCJub3JtYWwiKSxBPSExfX0oTS5BUEkpO3ZhciBTZT17aXRhbGljOlsiaXRhbGljIiwib2JsaXF1ZSIsIm5vcm1hbCJdLG9ibGlxdWU6WyJvYmxpcXVlIiwiaXRhbGljIiwibm9ybWFsIl0sbm9ybWFsOlsibm9ybWFsIiwib2JsaXF1ZSIsIml0YWxpYyJdfSxMZT1bInVsdHJhLWNvbmRlbnNlZCIsImV4dHJhLWNvbmRlbnNlZCIsImNvbmRlbnNlZCIsInNlbWktY29uZGVuc2VkIiwibm9ybWFsIiwic2VtaS1leHBhbmRlZCIsImV4cGFuZGVkIiwiZXh0cmEtZXhwYW5kZWQiLCJ1bHRyYS1leHBhbmRlZCJdLEllPUVlKExlKSxOZT1bMTAwLDIwMCwzMDAsNDAwLDUwMCw2MDAsNzAwLDgwMCw5MDBdLGtlPUVlKE5lKTtmdW5jdGlvbiBIZShlKXt2YXIgdD1lLmZhbWlseS5yZXBsYWNlKC8ifCcvZywiIikudG9Mb3dlckNhc2UoKSxBPWZ1bmN0aW9uKGUpe3JldHVybiBTZVtlPWV8fCJub3JtYWwiXT9lOiJub3JtYWwifShlLnN0eWxlKSxyPWZ1bmN0aW9uKGUpe3JldHVybiBlPyJudW1iZXIiPT10eXBlb2YgZT9lPj0xMDAmJmU8PTkwMCYmZSUxMDA9PTA/ZTo0MDA6L15cZDAwJC8udGVzdChlKT9wYXJzZUludChlKToiYm9sZCI9PT1lPzcwMDo0MDA6NDAwfShlLndlaWdodCksbj1mdW5jdGlvbihlKXtyZXR1cm4ibnVtYmVyIj09dHlwZW9mIEllW2U9ZXx8Im5vcm1hbCJdP2U6Im5vcm1hbCJ9KGUuc3RyZXRjaCk7cmV0dXJue2ZhbWlseTp0LHN0eWxlOkEsd2VpZ2h0OnIsc3RyZXRjaDpuLHNyYzplLnNyY3x8W10scmVmOmUucmVmfHx7bmFtZTp0LHN0eWxlOltuLEEscl0uam9pbigiICIpfX19ZnVuY3Rpb24gUGUoZSx0LEEscil7dmFyIG47Zm9yKG49QTtuPj0wJiZuPHQubGVuZ3RoO24rPXIpaWYoZVt0W25dXSlyZXR1cm4gZVt0W25dXTtmb3Iobj1BO24+PTAmJm48dC5sZW5ndGg7bi09cilpZihlW3Rbbl1dKXJldHVybiBlW3Rbbl1dfXZhciBUZT17InNhbnMtc2VyaWYiOiJoZWx2ZXRpY2EiLGZpeGVkOiJjb3VyaWVyIixtb25vc3BhY2U6ImNvdXJpZXIiLHRlcm1pbmFsOiJjb3VyaWVyIixjdXJzaXZlOiJ0aW1lcyIsZmFudGFzeToidGltZXMiLHNlcmlmOiJ0aW1lcyJ9LE9lPXtjYXB0aW9uOiJ0aW1lcyIsaWNvbjoidGltZXMiLG1lbnU6InRpbWVzIiwibWVzc2FnZS1ib3giOiJ0aW1lcyIsInNtYWxsLWNhcHRpb24iOiJ0aW1lcyIsInN0YXR1cy1iYXIiOiJ0aW1lcyJ9O2Z1bmN0aW9uIE1lKGUpe3JldHVybltlLnN0cmV0Y2gsZS5zdHlsZSxlLndlaWdodCxlLmZhbWlseV0uam9pbigiICIpfWZ1bmN0aW9uIERlKGUpe3JldHVybiBlLnRyaW1MZWZ0KCl9ZnVuY3Rpb24gUmUoZSx0KXtmb3IodmFyIEE9MDtBPGUubGVuZ3RoOyl7aWYoZS5jaGFyQXQoQSk9PT10KXJldHVybltlLnN1YnN0cmluZygwLEEpLGUuc3Vic3RyaW5nKEErMSldO0ErPTF9cmV0dXJuIG51bGx9ZnVuY3Rpb24gS2UoZSl7dmFyIHQ9ZS5tYXRjaCgvXigtW2Etel9dfFthLXpfXSlbYS16MC05Xy1dKi9pKTtyZXR1cm4gbnVsbD09PXQ/bnVsbDpbdFswXSxlLnN1YnN0cmluZyh0WzBdLmxlbmd0aCldfXZhciBWZSxHZSx6ZSxxZSxXZSxYZSxZZSxKZSxaZT1bInRpbWVzIl07ZnVuY3Rpb24gJGUoZSx0LEEscil7dmFyIHM9NCxpPUF0O3N3aXRjaChyKXtjYXNlIE0uQVBJLmltYWdlX2NvbXByZXNzaW9uLkZBU1Q6cz0xLGk9dHQ7YnJlYWs7Y2FzZSBNLkFQSS5pbWFnZV9jb21wcmVzc2lvbi5NRURJVU06cz02LGk9cnQ7YnJlYWs7Y2FzZSBNLkFQSS5pbWFnZV9jb21wcmVzc2lvbi5TTE9XOnM9OSxpPW50fWU9ZnVuY3Rpb24oZSx0LEEscil7Zm9yKHZhciBuLHM9ZS5sZW5ndGgvdCxpPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoK3MpLG89W2V0LHR0LEF0LHJ0LG50XSxhPTA7YTxzO2ErPTEpe3ZhciBsPWEqdCxjPWUuc3ViYXJyYXkobCxsK3QpO2lmKHIpaS5zZXQocihjLEEsbiksbCthKTtlbHNle2Zvcih2YXIgdT1vLmxlbmd0aCxoPVtdLGQ9MDtkPHU7ZCs9MSloW2RdPW9bZF0oYyxBLG4pO3ZhciBmPWl0KGguY29uY2F0KCkpO2kuc2V0KGhbZl0sbCthKX1uPWN9cmV0dXJuIGl9KGUsdCxBLGkpO3ZhciBvPSgwLG4uemxpYlN5bmMpKGUse2xldmVsOnN9KTtyZXR1cm4gTS5BUEkuX19hZGRpbWFnZV9fLmFycmF5QnVmZmVyVG9CaW5hcnlTdHJpbmcobyl9ZnVuY3Rpb24gZXQoZSl7dmFyIHQ9QXJyYXkuYXBwbHkoW10sZSk7cmV0dXJuIHQudW5zaGlmdCgwKSx0fWZ1bmN0aW9uIHR0KGUsdCl7dmFyIEE9ZS5sZW5ndGgscj1bXTtyWzBdPTE7Zm9yKHZhciBuPTA7bjxBO24rPTEpe3ZhciBzPWVbbi10XXx8MDtyW24rMV09ZVtuXS1zKzI1NiYyNTV9cmV0dXJuIHJ9ZnVuY3Rpb24gQXQoZSx0LEEpe3ZhciByPWUubGVuZ3RoLG49W107blswXT0yO2Zvcih2YXIgcz0wO3M8cjtzKz0xKXt2YXIgaT1BJiZBW3NdfHwwO25bcysxXT1lW3NdLWkrMjU2JjI1NX1yZXR1cm4gbn1mdW5jdGlvbiBydChlLHQsQSl7dmFyIHI9ZS5sZW5ndGgsbj1bXTtuWzBdPTM7Zm9yKHZhciBzPTA7czxyO3MrPTEpe3ZhciBpPWVbcy10XXx8MCxvPUEmJkFbc118fDA7bltzKzFdPWVbc10rMjU2LShpK28+Pj4xKSYyNTV9cmV0dXJuIG59ZnVuY3Rpb24gbnQoZSx0LEEpe3ZhciByPWUubGVuZ3RoLG49W107blswXT00O2Zvcih2YXIgcz0wO3M8cjtzKz0xKXt2YXIgaT1zdChlW3MtdF18fDAsQSYmQVtzXXx8MCxBJiZBW3MtdF18fDApO25bcysxXT1lW3NdLWkrMjU2JjI1NX1yZXR1cm4gbn1mdW5jdGlvbiBzdChlLHQsQSl7aWYoZT09PXQmJnQ9PT1BKXJldHVybiBlO3ZhciByPU1hdGguYWJzKHQtQSksbj1NYXRoLmFicyhlLUEpLHM9TWF0aC5hYnMoZSt0LUEtQSk7cmV0dXJuIHI8PW4mJnI8PXM/ZTpuPD1zP3Q6QX1mdW5jdGlvbiBpdChlKXt2YXIgdD1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZStNYXRoLmFicyh0KX0sMCl9KTtyZXR1cm4gdC5pbmRleE9mKE1hdGgubWluLmFwcGx5KG51bGwsdCkpfWZ1bmN0aW9uIG90KGUsdCxBKXt2YXIgcj10KkEsbj1NYXRoLmZsb29yKHIvOCkscz0xNi0oci04Km4rQSksaT0oMTw8QSktMTtyZXR1cm4gbHQoZSxuKT4+cyZpfWZ1bmN0aW9uIGF0KGUsdCxBLHIpe3ZhciBuPUEqcixzPU1hdGguZmxvb3Iobi84KSxpPTE2LShuLTgqcytyKSxvPSgxPDxyKS0xLGE9KHQmbyk8PGk7IWZ1bmN0aW9uKGUsdCxBKXtpZih0KzE8ZS5ieXRlTGVuZ3RoKWUuc2V0VWludDE2KHQsQSwhMSk7ZWxzZXt2YXIgcj1BPj44JjI1NTtlLnNldFVpbnQ4KHQscil9fShlLHMsbHQoZSxzKSZ+KG88PGkpJjY1NTM1fGEpfWZ1bmN0aW9uIGx0KGUsdCl7cmV0dXJuIHQrMTxlLmJ5dGVMZW5ndGg/ZS5nZXRVaW50MTYodCwhMSk6ZS5nZXRVaW50OCh0KTw8OH1mdW5jdGlvbiBjdChlKXt2YXIgdD0wO2lmKDcxIT09ZVt0KytdfHw3MyE9PWVbdCsrXXx8NzAhPT1lW3QrK118fDU2IT09ZVt0KytdfHw1NiE9KGVbdCsrXSsxJjI1Myl8fDk3IT09ZVt0KytdKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBHSUYgODdhLzg5YSBoZWFkZXIuIik7dmFyIEE9ZVt0KytdfGVbdCsrXTw8OCxyPWVbdCsrXXxlW3QrK108PDgsbj1lW3QrK10scz1uPj43LGk9MTw8MSsoNyZuKTtlW3QrK10sZVt0KytdO3ZhciBvPW51bGwsYT1udWxsO3MmJihvPXQsYT1pLHQrPTMqaSk7dmFyIGw9ITAsYz1bXSx1PTAsaD1udWxsLGQ9MCxmPW51bGw7Zm9yKHRoaXMud2lkdGg9QSx0aGlzLmhlaWdodD1yO2wmJnQ8ZS5sZW5ndGg7KXN3aXRjaChlW3QrK10pe2Nhc2UgMzM6c3dpdGNoKGVbdCsrXSl7Y2FzZSAyNTU6aWYoMTEhPT1lW3RdfHw3OD09ZVt0KzFdJiY2OT09ZVt0KzJdJiY4ND09ZVt0KzNdJiY4Mz09ZVt0KzRdJiY2Nz09ZVt0KzVdJiY2NT09ZVt0KzZdJiY4MD09ZVt0KzddJiY2OT09ZVt0KzhdJiY1MD09ZVt0KzldJiY0Nj09ZVt0KzEwXSYmNDg9PWVbdCsxMV0mJjM9PWVbdCsxMl0mJjE9PWVbdCsxM10mJjA9PWVbdCsxNl0pdCs9MTQsZj1lW3QrK118ZVt0KytdPDw4LHQrKztlbHNlIGZvcih0Kz0xMjs7KXtpZighKChGPWVbdCsrXSk+PTApKXRocm93IEVycm9yKCJJbnZhbGlkIGJsb2NrIHNpemUiKTtpZigwPT09RilicmVhazt0Kz1GfWJyZWFrO2Nhc2UgMjQ5OmlmKDQhPT1lW3QrK118fDAhPT1lW3QrNF0pdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGdyYXBoaWNzIGV4dGVuc2lvbiBibG9jay4iKTt2YXIgcD1lW3QrK107dT1lW3QrK118ZVt0KytdPDw4LGg9ZVt0KytdLDEmcHx8KGg9bnVsbCksZD1wPj4yJjcsdCsrO2JyZWFrO2Nhc2UgMjU0OmZvcig7Oyl7aWYoISgoRj1lW3QrK10pPj0wKSl0aHJvdyBFcnJvcigiSW52YWxpZCBibG9jayBzaXplIik7aWYoMD09PUYpYnJlYWs7dCs9Rn1icmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5rbm93biBncmFwaGljIGNvbnRyb2wgbGFiZWw6IDB4IitlW3QtMV0udG9TdHJpbmcoMTYpKX1icmVhaztjYXNlIDQ0OnZhciBnPWVbdCsrXXxlW3QrK108PDgsbT1lW3QrK118ZVt0KytdPDw4LHc9ZVt0KytdfGVbdCsrXTw8OCxCPWVbdCsrXXxlW3QrK108PDgseT1lW3QrK10sdj15Pj42JjEsYj0xPDwxKyg3JnkpLEM9byxfPWEsaj0hMTt5Pj43JiYoaj0hMCxDPXQsXz1iLHQrPTMqYik7dmFyIHg9dDtmb3IodCsrOzspe3ZhciBGO2lmKCEoKEY9ZVt0KytdKT49MCkpdGhyb3cgRXJyb3IoIkludmFsaWQgYmxvY2sgc2l6ZSIpO2lmKDA9PT1GKWJyZWFrO3QrPUZ9Yy5wdXNoKHt4OmcseTptLHdpZHRoOncsaGVpZ2h0OkIsaGFzX2xvY2FsX3BhbGV0dGU6aixwYWxldHRlX29mZnNldDpDLHBhbGV0dGVfc2l6ZTpfLGRhdGFfb2Zmc2V0OngsZGF0YV9sZW5ndGg6dC14LHRyYW5zcGFyZW50X2luZGV4OmgsaW50ZXJsYWNlZDohIXYsZGVsYXk6dSxkaXNwb3NhbDpkfSk7YnJlYWs7Y2FzZSA1OTpsPSExO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJVbmtub3duIGdpZiBibG9jazogMHgiK2VbdC0xXS50b1N0cmluZygxNikpfXRoaXMubnVtRnJhbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIGMubGVuZ3RofSx0aGlzLmxvb3BDb3VudD1mdW5jdGlvbigpe3JldHVybiBmfSx0aGlzLmZyYW1lSW5mbz1mdW5jdGlvbihlKXtpZihlPDB8fGU+PWMubGVuZ3RoKXRocm93IG5ldyBFcnJvcigiRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlLiIpO3JldHVybiBjW2VdfSx0aGlzLmRlY29kZUFuZEJsaXRGcmFtZUJHUkE9ZnVuY3Rpb24odCxyKXt2YXIgbj10aGlzLmZyYW1lSW5mbyh0KSxzPW4ud2lkdGgqbi5oZWlnaHQsaT1uZXcgVWludDhBcnJheShzKTt1dChlLG4uZGF0YV9vZmZzZXQsaSxzKTt2YXIgbz1uLnBhbGV0dGVfb2Zmc2V0LGE9bi50cmFuc3BhcmVudF9pbmRleDtudWxsPT09YSYmKGE9MjU2KTt2YXIgbD1uLndpZHRoLGM9QS1sLHU9bCxoPTQqKG4ueSpBK24ueCksZD00Kigobi55K24uaGVpZ2h0KSpBK24ueCksZj1oLHA9NCpjOyEwPT09bi5pbnRlcmxhY2VkJiYocCs9NCpBKjcpO2Zvcih2YXIgZz04LG09MCx3PWkubGVuZ3RoO208dzsrK20pe3ZhciBCPWlbbV07aWYoMD09PXUmJih1PWwsKGYrPXApPj1kJiYocD00KmMrNCpBKihnLTEpLGY9aCsobCtjKSooZzw8MSksZz4+PTEpKSxCPT09YSlmKz00O2Vsc2V7dmFyIHk9ZVtvKzMqQl0sdj1lW28rMypCKzFdLGI9ZVtvKzMqQisyXTtyW2YrK109YixyW2YrK109dixyW2YrK109eSxyW2YrK109MjU1fS0tdX19LHRoaXMuZGVjb2RlQW5kQmxpdEZyYW1lUkdCQT1mdW5jdGlvbih0LHIpe3ZhciBuPXRoaXMuZnJhbWVJbmZvKHQpLHM9bi53aWR0aCpuLmhlaWdodCxpPW5ldyBVaW50OEFycmF5KHMpO3V0KGUsbi5kYXRhX29mZnNldCxpLHMpO3ZhciBvPW4ucGFsZXR0ZV9vZmZzZXQsYT1uLnRyYW5zcGFyZW50X2luZGV4O251bGw9PT1hJiYoYT0yNTYpO3ZhciBsPW4ud2lkdGgsYz1BLWwsdT1sLGg9NCoobi55KkErbi54KSxkPTQqKChuLnkrbi5oZWlnaHQpKkErbi54KSxmPWgscD00KmM7ITA9PT1uLmludGVybGFjZWQmJihwKz00KkEqNyk7Zm9yKHZhciBnPTgsbT0wLHc9aS5sZW5ndGg7bTx3OysrbSl7dmFyIEI9aVttXTtpZigwPT09dSYmKHU9bCwoZis9cCk+PWQmJihwPTQqYys0KkEqKGctMSksZj1oKyhsK2MpKihnPDwxKSxnPj49MSkpLEI9PT1hKWYrPTQ7ZWxzZXt2YXIgeT1lW28rMypCXSx2PWVbbyszKkIrMV0sYj1lW28rMypCKzJdO3JbZisrXT15LHJbZisrXT12LHJbZisrXT1iLHJbZisrXT0yNTV9LS11fX19ZnVuY3Rpb24gdXQoZSx0LEEscil7Zm9yKHZhciBuPWVbdCsrXSxzPTE8PG4saT1zKzEsbz1pKzEsYT1uKzEsYz0oMTw8YSktMSx1PTAsaD0wLGQ9MCxmPWVbdCsrXSxwPW5ldyBJbnQzMkFycmF5KDQwOTYpLGc9bnVsbDs7KXtmb3IoO3U8MTYmJjAhPT1mOylofD1lW3QrK108PHUsdSs9OCwxPT09Zj9mPWVbdCsrXTotLWY7aWYodTxhKWJyZWFrO3ZhciBtPWgmYztpZihoPj49YSx1LT1hLG0hPT1zKXtpZihtPT09aSlicmVhaztmb3IodmFyIHc9bTxvP206ZyxCPTAseT13O3k+czspeT1wW3ldPj44LCsrQjt2YXIgdj15O2lmKGQrQisodyE9PW0/MTowKT5yKXJldHVybiB2b2lkIGwubG9nKCJXYXJuaW5nLCBnaWYgc3RyZWFtIGxvbmdlciB0aGFuIGV4cGVjdGVkLiIpO0FbZCsrXT12O3ZhciBiPWQrPUI7Zm9yKHchPT1tJiYoQVtkKytdPXYpLHk9dztCLS07KXk9cFt5XSxBWy0tYl09MjU1JnkseT4+PTg7bnVsbCE9PWcmJm88NDA5NiYmKHBbbysrXT1nPDw4fHYsbz49YysxJiZhPDEyJiYoKythLGM9Yzw8MXwxKSksZz1tfWVsc2Ugbz1pKzEsYz0oMTw8KGE9bisxKSktMSxnPW51bGx9cmV0dXJuIGQhPT1yJiZsLmxvZygiV2FybmluZywgZ2lmIHN0cmVhbSBzaG9ydGVyIHRoYW4gZXhwZWN0ZWQuIiksQX1mdW5jdGlvbiBodChlKXt2YXIgdCxBLHIsbixzLGk9TWF0aC5mbG9vcixvPW5ldyBBcnJheSg2NCksYT1uZXcgQXJyYXkoNjQpLGw9bmV3IEFycmF5KDY0KSxjPW5ldyBBcnJheSg2NCksdT1uZXcgQXJyYXkoNjU1MzUpLGg9bmV3IEFycmF5KDY1NTM1KSxkPW5ldyBBcnJheSg2NCksZj1uZXcgQXJyYXkoNjQpLHA9W10sZz0wLG09Nyx3PW5ldyBBcnJheSg2NCksQj1uZXcgQXJyYXkoNjQpLHk9bmV3IEFycmF5KDY0KSx2PW5ldyBBcnJheSgyNTYpLGI9bmV3IEFycmF5KDIwNDgpLEM9WzAsMSw1LDYsMTQsMTUsMjcsMjgsMiw0LDcsMTMsMTYsMjYsMjksNDIsMyw4LDEyLDE3LDI1LDMwLDQxLDQzLDksMTEsMTgsMjQsMzEsNDAsNDQsNTMsMTAsMTksMjMsMzIsMzksNDUsNTIsNTQsMjAsMjIsMzMsMzgsNDYsNTEsNTUsNjAsMjEsMzQsMzcsNDcsNTAsNTYsNTksNjEsMzUsMzYsNDgsNDksNTcsNTgsNjIsNjNdLF89WzAsMCwxLDUsMSwxLDEsMSwxLDEsMCwwLDAsMCwwLDAsMF0saj1bMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMV0seD1bMCwwLDIsMSwzLDMsMiw0LDMsNSw1LDQsNCwwLDAsMSwxMjVdLEY9WzEsMiwzLDAsNCwxNyw1LDE4LDMzLDQ5LDY1LDYsMTksODEsOTcsNywzNCwxMTMsMjAsNTAsMTI5LDE0NSwxNjEsOCwzNSw2NiwxNzcsMTkzLDIxLDgyLDIwOSwyNDAsMzYsNTEsOTgsMTE0LDEzMCw5LDEwLDIyLDIzLDI0LDI1LDI2LDM3LDM4LDM5LDQwLDQxLDQyLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDEzMSwxMzIsMTMzLDEzNCwxMzUsMTM2LDEzNywxMzgsMTQ2LDE0NywxNDgsMTQ5LDE1MCwxNTEsMTUyLDE1MywxNTQsMTYyLDE2MywxNjQsMTY1LDE2NiwxNjcsMTY4LDE2OSwxNzAsMTc4LDE3OSwxODAsMTgxLDE4MiwxODMsMTg0LDE4NSwxODYsMTk0LDE5NSwxOTYsMTk3LDE5OCwxOTksMjAwLDIwMSwyMDIsMjEwLDIxMSwyMTIsMjEzLDIxNCwyMTUsMjE2LDIxNywyMTgsMjI1LDIyNiwyMjcsMjI4LDIyOSwyMzAsMjMxLDIzMiwyMzMsMjM0LDI0MSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5LDI1MF0sUT1bMCwwLDMsMSwxLDEsMSwxLDEsMSwxLDEsMCwwLDAsMCwwXSxVPVswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExXSxFPVswLDAsMiwxLDIsNCw0LDMsNCw3LDUsNCw0LDAsMSwyLDExOV0sUz1bMCwxLDIsMywxNyw0LDUsMzMsNDksNiwxOCw2NSw4MSw3LDk3LDExMywxOSwzNCw1MCwxMjksOCwyMCw2NiwxNDUsMTYxLDE3NywxOTMsOSwzNSw1MSw4MiwyNDAsMjEsOTgsMTE0LDIwOSwxMCwyMiwzNiw1MiwyMjUsMzcsMjQxLDIzLDI0LDI1LDI2LDM4LDM5LDQwLDQxLDQyLDUzLDU0LDU1LDU2LDU3LDU4LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDEzMCwxMzEsMTMyLDEzMywxMzQsMTM1LDEzNiwxMzcsMTM4LDE0NiwxNDcsMTQ4LDE0OSwxNTAsMTUxLDE1MiwxNTMsMTU0LDE2MiwxNjMsMTY0LDE2NSwxNjYsMTY3LDE2OCwxNjksMTcwLDE3OCwxNzksMTgwLDE4MSwxODIsMTgzLDE4NCwxODUsMTg2LDE5NCwxOTUsMTk2LDE5NywxOTgsMTk5LDIwMCwyMDEsMjAyLDIxMCwyMTEsMjEyLDIxMywyMTQsMjE1LDIxNiwyMTcsMjE4LDIyNiwyMjcsMjI4LDIyOSwyMzAsMjMxLDIzMiwyMzMsMjM0LDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDksMjUwXTtmdW5jdGlvbiBMKGUsdCl7Zm9yKHZhciBBPTAscj0wLG49bmV3IEFycmF5LHM9MTtzPD0xNjtzKyspe2Zvcih2YXIgaT0xO2k8PWVbc107aSsrKW5bdFtyXV09W10sblt0W3JdXVswXT1BLG5bdFtyXV1bMV09cyxyKyssQSsrO0EqPTJ9cmV0dXJuIG59ZnVuY3Rpb24gSShlKXtmb3IodmFyIHQ9ZVswXSxBPWVbMV0tMTtBPj0wOyl0JjE8PEEmJihnfD0xPDxtKSxBLS0sLS1tPDAmJigyNTU9PWc/KE4oMjU1KSxOKDApKTpOKGcpLG09NyxnPTApfWZ1bmN0aW9uIE4oZSl7cC5wdXNoKGUpfWZ1bmN0aW9uIGsoZSl7TihlPj44JjI1NSksTigyNTUmZSl9ZnVuY3Rpb24gSChlLHQsQSxyLG4pe2Zvcih2YXIgcyxpPW5bMF0sbz1uWzI0MF0sYT1mdW5jdGlvbihlLHQpe3ZhciBBLHIsbixzLGksbyxhLGwsYyx1LGg9MDtmb3IoYz0wO2M8ODsrK2Mpe0E9ZVtoXSxyPWVbaCsxXSxuPWVbaCsyXSxzPWVbaCszXSxpPWVbaCs0XSxvPWVbaCs1XSxhPWVbaCs2XTt2YXIgZj1BKyhsPWVbaCs3XSkscD1BLWwsZz1yK2EsbT1yLWEsdz1uK28sQj1uLW8seT1zK2ksdj1zLWksYj1mK3ksQz1mLXksXz1nK3csaj1nLXc7ZVtoXT1iK18sZVtoKzRdPWItXzt2YXIgeD0uNzA3MTA2NzgxKihqK0MpO2VbaCsyXT1DK3gsZVtoKzZdPUMteDt2YXIgRj0uMzgyNjgzNDMzKigoYj12K0IpLShqPW0rcCkpLFE9LjU0MTE5NjEqYitGLFU9MS4zMDY1NjI5NjUqaitGLEU9LjcwNzEwNjc4MSooXz1CK20pLFM9cCtFLEw9cC1FO2VbaCs1XT1MK1EsZVtoKzNdPUwtUSxlW2grMV09UytVLGVbaCs3XT1TLVUsaCs9OH1mb3IoaD0wLGM9MDtjPDg7KytjKXtBPWVbaF0scj1lW2grOF0sbj1lW2grMTZdLHM9ZVtoKzI0XSxpPWVbaCszMl0sbz1lW2grNDBdLGE9ZVtoKzQ4XTt2YXIgST1BKyhsPWVbaCs1Nl0pLE49QS1sLGs9cithLEg9ci1hLFA9bitvLFQ9bi1vLE89cytpLE09cy1pLEQ9SStPLFI9SS1PLEs9aytQLFY9ay1QO2VbaF09RCtLLGVbaCszMl09RC1LO3ZhciBHPS43MDcxMDY3ODEqKFYrUik7ZVtoKzE2XT1SK0csZVtoKzQ4XT1SLUc7dmFyIHo9LjM4MjY4MzQzMyooKEQ9TStUKS0oVj1IK04pKSxxPS41NDExOTYxKkQreixXPTEuMzA2NTYyOTY1KlYreixYPS43MDcxMDY3ODEqKEs9VCtIKSxZPU4rWCxKPU4tWDtlW2grNDBdPUorcSxlW2grMjRdPUotcSxlW2grOF09WStXLGVbaCs1Nl09WS1XLGgrK31mb3IoYz0wO2M8NjQ7KytjKXU9ZVtjXSp0W2NdLGRbY109dT4wP3UrLjV8MDp1LS41fDA7cmV0dXJuIGR9KGUsdCksbD0wO2w8NjQ7KytsKWZbQ1tsXV09YVtsXTt2YXIgYz1mWzBdLUE7QT1mWzBdLDA9PWM/SShyWzBdKTooSShyW2hbcz0zMjc2NytjXV0pLEkodVtzXSkpO2Zvcih2YXIgcD02MztwPjAmJjA9PWZbcF07KXAtLTtpZigwPT1wKXJldHVybiBJKGkpLEE7Zm9yKHZhciBnLG09MTttPD1wOyl7Zm9yKHZhciB3PW07MD09ZlttXSYmbTw9cDspKyttO3ZhciBCPW0tdztpZihCPj0xNil7Zz1CPj40O2Zvcih2YXIgeT0xO3k8PWc7Kyt5KUkobyk7QiY9MTV9cz0zMjc2NytmW21dLEkoblsoQjw8NCkraFtzXV0pLEkodVtzXSksbSsrfXJldHVybiA2MyE9cCYmSShpKSxBfWZ1bmN0aW9uIFAoZSl7ZT1NYXRoLm1pbihNYXRoLm1heChlLDEpLDEwMCkscyE9ZSYmKGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bMTYsMTEsMTAsMTYsMjQsNDAsNTEsNjEsMTIsMTIsMTQsMTksMjYsNTgsNjAsNTUsMTQsMTMsMTYsMjQsNDAsNTcsNjksNTYsMTQsMTcsMjIsMjksNTEsODcsODAsNjIsMTgsMjIsMzcsNTYsNjgsMTA5LDEwMyw3NywyNCwzNSw1NSw2NCw4MSwxMDQsMTEzLDkyLDQ5LDY0LDc4LDg3LDEwMywxMjEsMTIwLDEwMSw3Miw5Miw5NSw5OCwxMTIsMTAwLDEwMyw5OV0sQT0wO0E8NjQ7QSsrKXt2YXIgcj1pKCh0W0FdKmUrNTApLzEwMCk7cj1NYXRoLm1pbihNYXRoLm1heChyLDEpLDI1NSksb1tDW0FdXT1yfWZvcih2YXIgbj1bMTcsMTgsMjQsNDcsOTksOTksOTksOTksMTgsMjEsMjYsNjYsOTksOTksOTksOTksMjQsMjYsNTYsOTksOTksOTksOTksOTksNDcsNjYsOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTksOTldLHM9MDtzPDY0O3MrKyl7dmFyIHU9aSgobltzXSplKzUwKS8xMDApO3U9TWF0aC5taW4oTWF0aC5tYXgodSwxKSwyNTUpLGFbQ1tzXV09dX1mb3IodmFyIGg9WzEsMS4zODcwMzk4NDUsMS4zMDY1NjI5NjUsMS4xNzU4NzU2MDIsMSwuNzg1Njk0OTU4LC41NDExOTYxLC4yNzU4OTkzNzldLGQ9MCxmPTA7Zjw4O2YrKylmb3IodmFyIHA9MDtwPDg7cCsrKWxbZF09MS8ob1tDW2RdXSpoW2ZdKmhbcF0qOCksY1tkXT0xLyhhW0NbZF1dKmhbZl0qaFtwXSo4KSxkKyt9KGU8NTA/TWF0aC5mbG9vcig1ZTMvZSk6TWF0aC5mbG9vcigyMDAtMiplKSkscz1lKX10aGlzLmVuY29kZT1mdW5jdGlvbihlLHMpe3MmJlAocykscD1uZXcgQXJyYXksZz0wLG09NyxrKDY1NDk2KSxrKDY1NTA0KSxrKDE2KSxOKDc0KSxOKDcwKSxOKDczKSxOKDcwKSxOKDApLE4oMSksTigxKSxOKDApLGsoMSksaygxKSxOKDApLE4oMCksZnVuY3Rpb24oKXtrKDY1NDk5KSxrKDEzMiksTigwKTtmb3IodmFyIGU9MDtlPDY0O2UrKylOKG9bZV0pO04oMSk7Zm9yKHZhciB0PTA7dDw2NDt0KyspTihhW3RdKX0oKSxmdW5jdGlvbihlLHQpe2soNjU0NzIpLGsoMTcpLE4oOCksayh0KSxrKGUpLE4oMyksTigxKSxOKDE3KSxOKDApLE4oMiksTigxNyksTigxKSxOKDMpLE4oMTcpLE4oMSl9KGUud2lkdGgsZS5oZWlnaHQpLGZ1bmN0aW9uKCl7ayg2NTQ3Niksayg0MTgpLE4oMCk7Zm9yKHZhciBlPTA7ZTwxNjtlKyspTihfW2UrMV0pO2Zvcih2YXIgdD0wO3Q8PTExO3QrKylOKGpbdF0pO04oMTYpO2Zvcih2YXIgQT0wO0E8MTY7QSsrKU4oeFtBKzFdKTtmb3IodmFyIHI9MDtyPD0xNjE7cisrKU4oRltyXSk7TigxKTtmb3IodmFyIG49MDtuPDE2O24rKylOKFFbbisxXSk7Zm9yKHZhciBzPTA7czw9MTE7cysrKU4oVVtzXSk7TigxNyk7Zm9yKHZhciBpPTA7aTwxNjtpKyspTihFW2krMV0pO2Zvcih2YXIgbz0wO288PTE2MTtvKyspTihTW29dKX0oKSxrKDY1NDk4KSxrKDEyKSxOKDMpLE4oMSksTigwKSxOKDIpLE4oMTcpLE4oMyksTigxNyksTigwKSxOKDYzKSxOKDApO3ZhciBpPTAsdT0wLGg9MDtnPTAsbT03LHRoaXMuZW5jb2RlLmRpc3BsYXlOYW1lPSJfZW5jb2RlXyI7Zm9yKHZhciBkLGYsdixDLEwsVCxPLE0sRCxSPWUuZGF0YSxLPWUud2lkdGgsVj1lLmhlaWdodCxHPTQqSyx6PTA7ejxWOyl7Zm9yKGQ9MDtkPEc7KXtmb3IoTD1HKnorZCxPPS0xLE09MCxEPTA7RDw2NDtEKyspVD1MKyhNPUQ+PjMpKkcrKE89NCooNyZEKSkseitNPj1WJiYoVC09RyooeisxK00tVikpLGQrTz49RyYmKFQtPWQrTy1HKzQpLGY9UltUKytdLHY9UltUKytdLEM9UltUKytdLHdbRF09KGJbZl0rYlt2KzI1NnwwXStiW0MrNTEyfDBdPj4xNiktMTI4LEJbRF09KGJbZis3Njh8MF0rYlt2KzEwMjR8MF0rYltDKzEyODB8MF0+PjE2KS0xMjgseVtEXT0oYltmKzEyODB8MF0rYlt2KzE1MzZ8MF0rYltDKzE3OTJ8MF0+PjE2KS0xMjg7aT1IKHcsbCxpLHQsciksdT1IKEIsYyx1LEEsbiksaD1IKHksYyxoLEEsbiksZCs9MzJ9eis9OH1pZihtPj0wKXt2YXIgcT1bXTtxWzFdPW0rMSxxWzBdPSgxPDxtKzEpLTEsSShxKX1yZXR1cm4gayg2NTQ5NyksbmV3IFVpbnQ4QXJyYXkocCl9LGU9ZXx8NTAsZnVuY3Rpb24oKXtmb3IodmFyIGU9U3RyaW5nLmZyb21DaGFyQ29kZSx0PTA7dDwyNTY7dCsrKXZbdF09ZSh0KX0oKSx0PUwoXyxqKSxBPUwoUSxVKSxyPUwoeCxGKSxuPUwoRSxTKSxmdW5jdGlvbigpe2Zvcih2YXIgZT0xLHQ9MixBPTE7QTw9MTU7QSsrKXtmb3IodmFyIHI9ZTtyPHQ7cisrKWhbMzI3Njcrcl09QSx1WzMyNzY3K3JdPVtdLHVbMzI3Njcrcl1bMV09QSx1WzMyNzY3K3JdWzBdPXI7Zm9yKHZhciBuPS0odC0xKTtuPD0tZTtuKyspaFszMjc2NytuXT1BLHVbMzI3Njcrbl09W10sdVszMjc2NytuXVsxXT1BLHVbMzI3Njcrbl1bMF09dC0xK247ZTw8PTEsdDw8PTF9fSgpLGZ1bmN0aW9uKCl7Zm9yKHZhciBlPTA7ZTwyNTY7ZSsrKWJbZV09MTk1OTUqZSxiW2UrMjU2fDBdPTM4NDcwKmUsYltlKzUxMnwwXT03NDcxKmUrMzI3NjgsYltlKzc2OHwwXT0tMTEwNTkqZSxiW2UrMTAyNHwwXT0tMjE3MDkqZSxiW2UrMTI4MHwwXT0zMjc2OCplKzg0MjEzNzUsYltlKzE1MzZ8MF09LTI3NDM5KmUsYltlKzE3OTJ8MF09LTUzMjkqZX0oKSxQKGUpfWZ1bmN0aW9uIGR0KGUsdCl7aWYodGhpcy5wb3M9MCx0aGlzLmJ1ZmZlcj1lLHRoaXMuZGF0YXY9bmV3IERhdGFWaWV3KGUuYnVmZmVyKSx0aGlzLmlzX3dpdGhfYWxwaGE9ISF0LHRoaXMuYm90dG9tX3VwPSEwLHRoaXMuZmxhZz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuYnVmZmVyWzBdKStTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuYnVmZmVyWzFdKSx0aGlzLnBvcys9MiwtMT09PVsiQk0iLCJCQSIsIkNJIiwiQ1AiLCJJQyIsIlBUIl0uaW5kZXhPZih0aGlzLmZsYWcpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBCTVAgRmlsZSIpO3RoaXMucGFyc2VIZWFkZXIoKSx0aGlzLnBhcnNlQkdSKCl9ZnVuY3Rpb24gZnQoZSl7ZnVuY3Rpb24gdChlKXtpZighZSl0aHJvdyBFcnJvcigiYXNzZXJ0IDpQIil9ZnVuY3Rpb24gQShlLHQsQSl7Zm9yKHZhciByPTA7ND5yO3IrKylpZihlW3Qrcl0hPUEuY2hhckNvZGVBdChyKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiByKGUsdCxBLHIsbil7Zm9yKHZhciBzPTA7czxuO3MrKyllW3Qrc109QVtyK3NdfWZ1bmN0aW9uIG4oZSx0LEEscil7Zm9yKHZhciBuPTA7bjxyO24rKyllW3Qrbl09QX1mdW5jdGlvbiBzKGUpe3JldHVybiBuZXcgSW50MzJBcnJheShlKX1mdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciBBPVtdLHI9MDtyPGU7cisrKUEucHVzaChuZXcgdCk7cmV0dXJuIEF9ZnVuY3Rpb24gbyhlLHQpe3ZhciBBPVtdO3JldHVybiBmdW5jdGlvbiBlKEEscixuKXtmb3IodmFyIHM9bltyXSxpPTA7aTxzJiYoQS5wdXNoKG4ubGVuZ3RoPnIrMT9bXTpuZXcgdCksIShuLmxlbmd0aDxyKzEpKTtpKyspZShBW2ldLHIrMSxuKX0oQSwwLGUpLEF9dmFyIGE9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2Z1bmN0aW9uIGEoZSx0KXtmb3IodmFyIEE9MTw8dC0xPj4+MDtlJkE7KUE+Pj49MTtyZXR1cm4gQT8oZSZBLTEpK0E6ZX1mdW5jdGlvbiBsKGUsQSxyLG4scyl7dCghKG4lcikpO2Rve2VbQSsobi09cildPXN9d2hpbGUoMDxuKX1mdW5jdGlvbiBjKGUsQSxyLG4saSl7aWYodCgyMzI4Pj1pKSw1MTI+PWkpdmFyIG89cyg1MTIpO2Vsc2UgaWYobnVsbD09KG89cyhpKSkpcmV0dXJuIDA7cmV0dXJuIGZ1bmN0aW9uKGUsQSxyLG4saSxvKXt2YXIgYyxoLGQ9QSxmPTE8PHIscD1zKDE2KSxnPXMoMTYpO2Zvcih0KDAhPWkpLHQobnVsbCE9biksdChudWxsIT1lKSx0KDA8ciksaD0wO2g8aTsrK2gpe2lmKDE1PG5baF0pcmV0dXJuIDA7KytwW25baF1dfWlmKHBbMF09PWkpcmV0dXJuIDA7Zm9yKGdbMV09MCxjPTE7MTU+YzsrK2Mpe2lmKHBbY10+MTw8YylyZXR1cm4gMDtnW2MrMV09Z1tjXStwW2NdfWZvcihoPTA7aDxpOysraCljPW5baF0sMDxuW2hdJiYob1tnW2NdKytdPWgpO2lmKDE9PWdbMTVdKXJldHVybihuPW5ldyB1KS5nPTAsbi52YWx1ZT1vWzBdLGwoZSxkLDEsZixuKSxmO3ZhciBtLHc9LTEsQj1mLTEseT0wLHY9MSxiPTEsQz0xPDxyO2ZvcihoPTAsYz0xLGk9MjtjPD1yOysrYyxpPDw9MSl7aWYodis9Yjw8PTEsMD4oYi09cFtjXSkpcmV0dXJuIDA7Zm9yKDswPHBbY107LS1wW2NdKShuPW5ldyB1KS5nPWMsbi52YWx1ZT1vW2grK10sbChlLGQreSxpLEMsbikseT1hKHksYyl9Zm9yKGM9cisxLGk9MjsxNT49YzsrK2MsaTw8PTEpe2lmKHYrPWI8PD0xLDA+KGItPXBbY10pKXJldHVybiAwO2Zvcig7MDxwW2NdOy0tcFtjXSl7aWYobj1uZXcgdSwoeSZCKSE9dyl7Zm9yKGQrPUMsbT0xPDwodz1jKS1yOzE1PncmJiEoMD49KG0tPXBbd10pKTspKyt3LG08PD0xO2YrPUM9MTw8KG09dy1yKSxlW0ErKHc9eSZCKV0uZz1tK3IsZVtBK3ddLnZhbHVlPWQtQS13fW4uZz1jLXIsbi52YWx1ZT1vW2grK10sbChlLGQrKHk+PnIpLGksQyxuKSx5PWEoeSxjKX19cmV0dXJuIHYhPTIqZ1sxNV0tMT8wOmZ9KGUsQSxyLG4saSxvKX1mdW5jdGlvbiB1KCl7dGhpcy52YWx1ZT10aGlzLmc9MH1mdW5jdGlvbiBoKCl7dGhpcy52YWx1ZT10aGlzLmc9MH1mdW5jdGlvbiBkKCl7dGhpcy5HPWkoNSx1KSx0aGlzLkg9cyg1KSx0aGlzLmpjPXRoaXMuUWI9dGhpcy5xYj10aGlzLm5kPTAsdGhpcy5wZD1pKFBBLGgpfWZ1bmN0aW9uIGYoZSxBLHIsbil7dChudWxsIT1lKSx0KG51bGwhPUEpLHQoMjE0NzQ4MzY0OD5uKSxlLkNhPTI1NCxlLkk9MCxlLmI9LTgsZS5LYT0wLGUub2E9QSxlLnBhPXIsZS5KZD1BLGUuWWM9cituLGUuWmM9NDw9bj9yK24tNCsxOnIseChlKX1mdW5jdGlvbiBwKGUsdCl7Zm9yKHZhciBBPTA7MDx0LS07KUF8PVEoZSwxMjgpPDx0O3JldHVybiBBfWZ1bmN0aW9uIGcoZSx0KXt2YXIgQT1wKGUsdCk7cmV0dXJuIEYoZSk/LUE6QX1mdW5jdGlvbiBtKGUsQSxyLG4pe3ZhciBzLGk9MDtmb3IodChudWxsIT1lKSx0KG51bGwhPUEpLHQoNDI5NDk2NzI4OD5uKSxlLlNiPW4sZS5SYT0wLGUudT0wLGUuaD0wLDQ8biYmKG49NCkscz0wO3M8bjsrK3MpaSs9QVtyK3NdPDw4KnM7ZS5SYT1pLGUuYmI9bixlLm9hPUEsZS5wYT1yfWZ1bmN0aW9uIHcoZSl7Zm9yKDs4PD1lLnUmJmUuYmI8ZS5TYjspZS5SYT4+Pj04LGUuUmErPWUub2FbZS5wYStlLmJiXTw8TUEtOD4+PjAsKytlLmJiLGUudS09ODtDKGUpJiYoZS5oPTEsZS51PTApfWZ1bmN0aW9uIEIoZSxBKXtpZih0KDA8PUEpLCFlLmgmJkE8PU9BKXt2YXIgcj1iKGUpJlRBW0FdO3JldHVybiBlLnUrPUEsdyhlKSxyfXJldHVybiBlLmg9MSxlLnU9MH1mdW5jdGlvbiB5KCl7dGhpcy5iPXRoaXMuQ2E9dGhpcy5JPTAsdGhpcy5vYT1bXSx0aGlzLnBhPTAsdGhpcy5KZD1bXSx0aGlzLlljPTAsdGhpcy5aYz1bXSx0aGlzLkthPTB9ZnVuY3Rpb24gdigpe3RoaXMuUmE9MCx0aGlzLm9hPVtdLHRoaXMuaD10aGlzLnU9dGhpcy5iYj10aGlzLlNiPXRoaXMucGE9MH1mdW5jdGlvbiBiKGUpe3JldHVybiBlLlJhPj4+KGUudSZNQS0xKT4+PjB9ZnVuY3Rpb24gQyhlKXtyZXR1cm4gdChlLmJiPD1lLlNiKSxlLmh8fGUuYmI9PWUuU2ImJmUudT5NQX1mdW5jdGlvbiBfKGUsdCl7ZS51PXQsZS5oPUMoZSl9ZnVuY3Rpb24gaihlKXtlLnU+PURBJiYodChlLnU+PURBKSx3KGUpKX1mdW5jdGlvbiB4KGUpe3QobnVsbCE9ZSYmbnVsbCE9ZS5vYSksZS5wYTxlLlpjPyhlLkk9KGUub2FbZS5wYSsrXXxlLkk8PDgpPj4+MCxlLmIrPTgpOih0KG51bGwhPWUmJm51bGwhPWUub2EpLGUucGE8ZS5ZYz8oZS5iKz04LGUuST1lLm9hW2UucGErK118ZS5JPDw4KTplLkthP2UuYj0wOihlLkk8PD04LGUuYis9OCxlLkthPTEpKX1mdW5jdGlvbiBGKGUpe3JldHVybiBwKGUsMSl9ZnVuY3Rpb24gUShlLHQpe3ZhciBBPWUuQ2E7MD5lLmImJngoZSk7dmFyIHI9ZS5iLG49QSp0Pj4+OCxzPShlLkk+Pj5yPm4pKzA7Zm9yKHM/KEEtPW4sZS5JLT1uKzE8PHI+Pj4wKTpBPW4rMSxyPUEsbj0wOzI1Njw9cjspbis9OCxyPj49ODtyZXR1cm4gcj03Xm4rUkFbcl0sZS5iLT1yLGUuQ2E9KEE8PHIpLTEsc31mdW5jdGlvbiBVKGUsdCxBKXtlW3QrMF09QT4+MjQmMjU1LGVbdCsxXT1BPj4xNiYyNTUsZVt0KzJdPUE+PjgmMjU1LGVbdCszXT0yNTUmQX1mdW5jdGlvbiBFKGUsdCl7cmV0dXJuIGVbdCswXXxlW3QrMV08PDh9ZnVuY3Rpb24gUyhlLHQpe3JldHVybiBFKGUsdCl8ZVt0KzJdPDwxNn1mdW5jdGlvbiBMKGUsdCl7cmV0dXJuIEUoZSx0KXxFKGUsdCsyKTw8MTZ9ZnVuY3Rpb24gSShlLEEpe3ZhciByPTE8PEE7cmV0dXJuIHQobnVsbCE9ZSksdCgwPEEpLGUuWD1zKHIpLG51bGw9PWUuWD8wOihlLk1iPTMyLUEsZS5YYT1BLDEpfWZ1bmN0aW9uIE4oZSxBKXt0KG51bGwhPWUpLHQobnVsbCE9QSksdChlLlhhPT1BLlhhKSxyKEEuWCwwLGUuWCwwLDE8PEEuWGEpfWZ1bmN0aW9uIGsoKXt0aGlzLlg9W10sdGhpcy5YYT10aGlzLk1iPTB9ZnVuY3Rpb24gSChlLEEscixuKXt0KG51bGwhPXIpLHQobnVsbCE9bik7dmFyIHM9clswXSxpPW5bMF07cmV0dXJuIDA9PXMmJihzPShlKmkrQS8yKS9BKSwwPT1pJiYoaT0oQSpzK2UvMikvZSksMD49c3x8MD49aT8wOihyWzBdPXMsblswXT1pLDEpfWZ1bmN0aW9uIFAoZSx0KXtyZXR1cm4gZSsoMTw8dCktMT4+PnR9ZnVuY3Rpb24gVChlLHQpe3JldHVybigoNDI3ODI1NTM2MCZlKSsoNDI3ODI1NTM2MCZ0KT4+PjAmNDI3ODI1NTM2MCkrKCgxNjcxMTkzNSZlKSsoMTY3MTE5MzUmdCk+Pj4wJjE2NzExOTM1KT4+PjB9ZnVuY3Rpb24gTyh0LEEpe2VbQV09ZnVuY3Rpb24oQSxyLG4scyxpLG8sYSl7dmFyIGw7Zm9yKGw9MDtsPGk7KytsKXt2YXIgYz1lW3RdKG9bYStsLTFdLG4scytsKTtvW2ErbF09VChBW3IrbF0sYyl9fX1mdW5jdGlvbiBNKCl7dGhpcy51ZD10aGlzLmhkPXRoaXMuamQ9MH1mdW5jdGlvbiBEKGUsdCl7cmV0dXJuKCg0Mjc4MTI0Mjg2JihlXnQpKT4+PjEpKyhlJnQpPj4+MH1mdW5jdGlvbiBSKGUpe3JldHVybiAwPD1lJiYyNTY+ZT9lOjA+ZT8wOjI1NTxlPzI1NTp2b2lkIDB9ZnVuY3Rpb24gSyhlLHQpe3JldHVybiBSKGUrKGUtdCsuNT4+MSkpfWZ1bmN0aW9uIFYoZSx0LEEpe3JldHVybiBNYXRoLmFicyh0LUEpLU1hdGguYWJzKGUtQSl9ZnVuY3Rpb24gRyhlLHQsQSxyLG4scyxpKXtmb3Iocj1zW2ktMV0sQT0wO0E8bjsrK0Epc1tpK0FdPXI9VChlW3QrQV0scil9ZnVuY3Rpb24geihlLHQsQSxyLG4pe3ZhciBzO2ZvcihzPTA7czxBOysrcyl7dmFyIGk9ZVt0K3NdLG89aT4+OCYyNTUsYT0xNjcxMTkzNSYoYT0oYT0xNjcxMTkzNSZpKSsoKG88PDE2KStvKSk7cltuK3NdPSg0Mjc4MjU1MzYwJmkpK2E+Pj4wfX1mdW5jdGlvbiBxKGUsdCl7dC5qZD0yNTUmZSx0LmhkPWU+PjgmMjU1LHQudWQ9ZT4+MTYmMjU1fWZ1bmN0aW9uIFcoZSx0LEEscixuLHMpe3ZhciBpO2ZvcihpPTA7aTxyOysraSl7dmFyIG89dFtBK2ldLGE9bz4+PjgsbD1vLGM9MjU1JihjPShjPW8+Pj4xNikrKChlLmpkPDwyND4+MjQpKihhPDwyND4+MjQpPj4+NSkpO2w9MjU1JihsPShsKz0oZS5oZDw8MjQ+PjI0KSooYTw8MjQ+PjI0KT4+PjUpKygoZS51ZDw8MjQ+PjI0KSooYzw8MjQ+PjI0KT4+PjUpKSxuW3MraV09KDQyNzgyNTUzNjAmbykrKGM8PDE2KStsfX1mdW5jdGlvbiBYKHQsQSxyLG4scyl7ZVtBXT1mdW5jdGlvbihlLHQsQSxyLGksbyxhLGwsYyl7Zm9yKHI9YTtyPGw7KytyKWZvcihhPTA7YTxjOysrYSlpW28rK109cyhBW24oZVt0KytdKV0pfSxlW3RdPWZ1bmN0aW9uKHQsQSxpLG8sYSxsLGMpe3ZhciB1PTg+PnQuYixoPXQuRWEsZD10LktbMF0sZj10Lnc7aWYoOD51KWZvcih0PSgxPDx0LmIpLTEsZj0oMTw8dSktMTtBPGk7KytBKXt2YXIgcCxnPTA7Zm9yKHA9MDtwPGg7KytwKXAmdHx8KGc9bihvW2ErK10pKSxsW2MrK109cyhkW2cmZl0pLGc+Pj11fWVsc2UgZVsiVlA4TE1hcENvbG9yIityXShvLGEsZCxmLGwsYyxBLGksaCl9fWZ1bmN0aW9uIFkoZSx0LEEscixuKXtmb3IoQT10K0E7dDxBOyl7dmFyIHM9ZVt0KytdO3JbbisrXT1zPj4xNiYyNTUscltuKytdPXM+PjgmMjU1LHJbbisrXT0yNTUmc319ZnVuY3Rpb24gSihlLHQsQSxyLG4pe2ZvcihBPXQrQTt0PEE7KXt2YXIgcz1lW3QrK107cltuKytdPXM+PjE2JjI1NSxyW24rK109cz4+OCYyNTUscltuKytdPTI1NSZzLHJbbisrXT1zPj4yNCYyNTV9fWZ1bmN0aW9uIFooZSx0LEEscixuKXtmb3IoQT10K0E7dDxBOyl7dmFyIHM9KGk9ZVt0KytdKT4+MTYmMjQwfGk+PjEyJjE1LGk9MjQwJml8aT4+MjgmMTU7cltuKytdPXMscltuKytdPWl9fWZ1bmN0aW9uICQoZSx0LEEscixuKXtmb3IoQT10K0E7dDxBOyl7dmFyIHM9KGk9ZVt0KytdKT4+MTYmMjQ4fGk+PjEzJjcsaT1pPj41JjIyNHxpPj4zJjMxO3JbbisrXT1zLHJbbisrXT1pfX1mdW5jdGlvbiBlZShlLHQsQSxyLG4pe2ZvcihBPXQrQTt0PEE7KXt2YXIgcz1lW3QrK107cltuKytdPTI1NSZzLHJbbisrXT1zPj44JjI1NSxyW24rK109cz4+MTYmMjU1fX1mdW5jdGlvbiB0ZShlLHQsQSxuLHMsaSl7aWYoMD09aSlmb3IoQT10K0E7dDxBOylVKG4sKChpPWVbdCsrXSlbMF0+PjI0fGlbMV0+PjgmNjUyODB8aVsyXTw8OCYxNjcxMTY4MHxpWzNdPDwyNCk+Pj4wKSxzKz0zMjtlbHNlIHIobixzLGUsdCxBKX1mdW5jdGlvbiBBZSh0LEEpe2VbQV1bMF09ZVt0KyIwIl0sZVtBXVsxXT1lW3QrIjEiXSxlW0FdWzJdPWVbdCsiMiJdLGVbQV1bM109ZVt0KyIzIl0sZVtBXVs0XT1lW3QrIjQiXSxlW0FdWzVdPWVbdCsiNSJdLGVbQV1bNl09ZVt0KyI2Il0sZVtBXVs3XT1lW3QrIjciXSxlW0FdWzhdPWVbdCsiOCJdLGVbQV1bOV09ZVt0KyI5Il0sZVtBXVsxMF09ZVt0KyIxMCJdLGVbQV1bMTFdPWVbdCsiMTEiXSxlW0FdWzEyXT1lW3QrIjEyIl0sZVtBXVsxM109ZVt0KyIxMyJdLGVbQV1bMTRdPWVbdCsiMCJdLGVbQV1bMTVdPWVbdCsiMCJdfWZ1bmN0aW9uIHJlKGUpe3JldHVybiBlPT1Ecnx8ZT09UnJ8fGU9PUtyfHxlPT1Wcn1mdW5jdGlvbiBuZSgpe3RoaXMuZWI9W10sdGhpcy5zaXplPXRoaXMuQT10aGlzLmZiPTB9ZnVuY3Rpb24gc2UoKXt0aGlzLnk9W10sdGhpcy5mPVtdLHRoaXMuZWE9W10sdGhpcy5GPVtdLHRoaXMuVGM9dGhpcy5FZD10aGlzLkNkPXRoaXMuRmQ9dGhpcy5sYj10aGlzLkRiPXRoaXMuQWI9dGhpcy5mYT10aGlzLko9dGhpcy5XPXRoaXMuTj10aGlzLk89MH1mdW5jdGlvbiBpZSgpe3RoaXMuUmQ9dGhpcy5oZWlnaHQ9dGhpcy53aWR0aD10aGlzLlM9MCx0aGlzLmY9e30sdGhpcy5mLlJHQkE9bmV3IG5lLHRoaXMuZi5rYj1uZXcgc2UsdGhpcy5zZD1udWxsfWZ1bmN0aW9uIG9lKCl7dGhpcy53aWR0aD1bMF0sdGhpcy5oZWlnaHQ9WzBdLHRoaXMuUGQ9WzBdLHRoaXMuUWQ9WzBdLHRoaXMuZm9ybWF0PVswXX1mdW5jdGlvbiBhZSgpe3RoaXMuSWQ9dGhpcy5mZD10aGlzLk1kPXRoaXMuaGI9dGhpcy5pYj10aGlzLmRhPXRoaXMuYmQ9dGhpcy5jZD10aGlzLmo9dGhpcy52PXRoaXMuRGE9dGhpcy5TZD10aGlzLm9iPTB9ZnVuY3Rpb24gbGUoZSl7cmV0dXJuIGFsZXJ0KCJ0b2RvOldlYlBTYW1wbGVyUHJvY2Vzc1BsYW5lIiksZS5UfWZ1bmN0aW9uIGNlKGUsdCl7dmFyIEE9ZS5ULG49dC5iYS5mLlJHQkEscz1uLmViLGk9bi5mYitlLmthKm4uQSxvPWduW3QuYmEuU10sYT1lLnksbD1lLk8sYz1lLmYsdT1lLk4saD1lLmVhLGQ9ZS5XLGY9dC5jYyxwPXQuZGMsZz10Lk1jLG09dC5OYyx3PWUua2EsQj1lLmthK2UuVCx5PWUuVSx2PXkrMT4+MTtmb3IoMD09dz9vKGEsbCxudWxsLG51bGwsYyx1LGgsZCxjLHUsaCxkLHMsaSxudWxsLG51bGwseSk6KG8odC5lYyx0LmZjLGEsbCxmLHAsZyxtLGMsdSxoLGQscyxpLW4uQSxzLGkseSksKytBKTt3KzI8Qjt3Kz0yKWY9YyxwPXUsZz1oLG09ZCx1Kz1lLlJjLGQrPWUuUmMsaSs9MipuLkEsbyhhLChsKz0yKmUuZmEpLWUuZmEsYSxsLGYscCxnLG0sYyx1LGgsZCxzLGktbi5BLHMsaSx5KTtyZXR1cm4gbCs9ZS5mYSxlLmorQjxlLm8/KHIodC5lYyx0LmZjLGEsbCx5KSxyKHQuY2MsdC5kYyxjLHUsdikscih0Lk1jLHQuTmMsaCxkLHYpLEEtLSk6MSZCfHxvKGEsbCxudWxsLG51bGwsYyx1LGgsZCxjLHUsaCxkLHMsaStuLkEsbnVsbCxudWxsLHkpLEF9ZnVuY3Rpb24gdWUoZSxBLHIpe3ZhciBuPWUuRixzPVtlLkpdO2lmKG51bGwhPW4pe3ZhciBpPWUuVSxvPUEuYmEuUyxhPW89PVRyfHxvPT1LcjtBPUEuYmEuZi5SR0JBO3ZhciBsPVswXSxjPWUua2E7bFswXT1lLlQsZS5LYiYmKDA9PWM/LS1sWzBdOigtLWMsc1swXS09ZS53aWR0aCksZS5qK2Uua2ErZS5UPT1lLm8mJihsWzBdPWUuby1lLmotYykpO3ZhciB1PUEuZWI7Yz1BLmZiK2MqQS5BLGU9Q3IobixzWzBdLGUud2lkdGgsaSxsLHUsYysoYT8wOjMpLEEuQSksdChyPT1sKSxlJiZyZShvKSYmdnIodSxjLGEsaSxsLEEuQSl9cmV0dXJuIDB9ZnVuY3Rpb24gaGUoZSl7dmFyIHQ9ZS5tYSxBPXQuYmEuUyxyPTExPkEsbj1BPT1rcnx8QT09UHJ8fEE9PVRyfHxBPT1Pcnx8MTI9PUF8fHJlKEEpO2lmKHQubWVtb3J5PW51bGwsdC5JYj1udWxsLHQuSmI9bnVsbCx0Lk5kPW51bGwsIU5BKHQuT2EsZSxuPzExOjEyKSlyZXR1cm4gMDtpZihuJiZyZShBKSYmbUEoKSxlLmRhKWFsZXJ0KCJ0b2RvOnVzZV9zY2FsaW5nIik7ZWxzZXtpZihyKXtpZih0LkliPWxlLGUuS2Ipe2lmKEE9ZS5VKzE+PjEsdC5tZW1vcnk9cyhlLlUrMipBKSxudWxsPT10Lm1lbW9yeSlyZXR1cm4gMDt0LmVjPXQubWVtb3J5LHQuZmM9MCx0LmNjPXQuZWMsdC5kYz10LmZjK2UuVSx0Lk1jPXQuY2MsdC5OYz10LmRjK0EsdC5JYj1jZSxtQSgpfX1lbHNlIGFsZXJ0KCJ0b2RvOkVtaXRZVVYiKTtuJiYodC5KYj11ZSxyJiZwQSgpKX1pZihyJiYhRW4pe2ZvcihlPTA7MjU2PmU7KytlKVNuW2VdPTg5ODU4KihlLTEyOCkram4+Pl9uLE5uW2VdPS0yMjAxNCooZS0xMjgpK2puLEluW2VdPS00NTc3MyooZS0xMjgpLExuW2VdPTExMzYxOCooZS0xMjgpK2puPj5fbjtmb3IoZT14bjtlPEZuOysrZSl0PTc2MjgzKihlLTE2KStqbj4+X24sa25bZS14bl09R2UodCwyNTUpLEhuW2UteG5dPUdlKHQrOD4+NCwxNSk7RW49MX1yZXR1cm4gMX1mdW5jdGlvbiBkZShlKXt2YXIgQT1lLm1hLHI9ZS5VLG49ZS5UO3JldHVybiB0KCEoMSZlLmthKSksMD49cnx8MD49bj8wOihyPUEuSWIoZSxBKSxudWxsIT1BLkpiJiZBLkpiKGUsQSxyKSxBLkRjKz1yLDEpfWZ1bmN0aW9uIGZlKGUpe2UubWEubWVtb3J5PW51bGx9ZnVuY3Rpb24gcGUoZSx0LEEscil7cmV0dXJuIDQ3IT1CKGUsOCk/MDoodFswXT1CKGUsMTQpKzEsQVswXT1CKGUsMTQpKzEsclswXT1CKGUsMSksMCE9QihlLDMpPzA6IWUuaCl9ZnVuY3Rpb24gZ2UoZSx0KXtpZig0PmUpcmV0dXJuIGUrMTt2YXIgQT1lLTI+PjE7cmV0dXJuKDIrKDEmZSk8PEEpK0IodCxBKSsxfWZ1bmN0aW9uIG1lKGUsdCl7cmV0dXJuIDEyMDx0P3QtMTIwOjE8PShBPSgoQT1Zclt0LTFdKT4+NCkqZSsoOC0oMTUmQSkpKT9BOjE7dmFyIEF9ZnVuY3Rpb24gd2UoZSx0LEEpe3ZhciByPWIoQSksbj1lW3QrPTI1NSZyXS5nLTg7cmV0dXJuIDA8biYmKF8oQSxBLnUrOCkscj1iKEEpLHQrPWVbdF0udmFsdWUsdCs9ciYoMTw8biktMSksXyhBLEEudStlW3RdLmcpLGVbdF0udmFsdWV9ZnVuY3Rpb24gQmUoZSxBLHIpe3JldHVybiByLmcrPWUuZyxyLnZhbHVlKz1lLnZhbHVlPDxBPj4+MCx0KDg+PXIuZyksZS5nfWZ1bmN0aW9uIHllKGUsQSxyKXt2YXIgbj1lLnhjO3JldHVybiB0KChBPTA9PW4/MDplLnZjW2UubWQqKHI+Pm4pKyhBPj5uKV0pPGUuV2IpLGUuWWFbQV19ZnVuY3Rpb24gdmUoZSxBLG4scyl7dmFyIGk9ZS5hYixvPWUuYypBLGE9ZS5DO0E9YStBO3ZhciBsPW4sYz1zO2ZvcihzPWUuVGEsbj1lLlVhOzA8aS0tOyl7dmFyIHU9ZS5nY1tpXSxoPWEsZD1BLGY9bCxwPWMsZz0oYz1zLGw9bix1LkVhKTtzd2l0Y2godChoPGQpLHQoZDw9dS5uYyksdS5oYyl7Y2FzZSAyOkdBKGYscCwoZC1oKSpnLGMsbCk7YnJlYWs7Y2FzZSAwOnZhciBtPWgsdz1kLEI9Yyx5PWwsdj0oeD11KS5FYTswPT1tJiYoS0EoZixwLG51bGwsbnVsbCwxLEIseSksRyhmLHArMSwwLDAsdi0xLEIseSsxKSxwKz12LHkrPXYsKyttKTtmb3IodmFyIGI9MTw8eC5iLEM9Yi0xLF89UCh2LHguYiksaj14LksseD14LncrKG0+PnguYikqXzttPHc7KXt2YXIgRj1qLFE9eCxVPTE7Zm9yKFZBKGYscCxCLHktdiwxLEIseSk7VTx2Oyl7dmFyIEU9KFUmfkMpK2I7RT52JiYoRT12KSwoMCxZQVtGW1ErK10+PjgmMTVdKShmLHArICtVLEIseStVLXYsRS1VLEIseStVKSxVPUV9cCs9dix5Kz12LCsrbSZDfHwoeCs9Xyl9ZCE9dS5uYyYmcihjLGwtZyxjLGwrKGQtaC0xKSpnLGcpO2JyZWFrO2Nhc2UgMTpmb3IoZz1mLHc9cCx2PShmPXUuRWEpLSh5PWYmfihCPShwPTE8PHUuYiktMSkpLG09UChmLHUuYiksYj11LkssdT11LncrKGg+PnUuYikqbTtoPGQ7KXtmb3IoQz1iLF89dSxqPW5ldyBNLHg9dyt5LEY9dytmO3c8eDspcShDW18rK10saiksSkEoaixnLHcscCxjLGwpLHcrPXAsbCs9cDt3PEYmJihxKENbXysrXSxqKSxKQShqLGcsdyx2LGMsbCksdys9dixsKz12KSwrK2gmQnx8KHUrPW0pfWJyZWFrO2Nhc2UgMzppZihmPT1jJiZwPT1sJiYwPHUuYil7Zm9yKHc9YyxmPWc9bCsoZC1oKSpnLSh5PShkLWgpKlAodS5FYSx1LmIpKSxwPWMsQj1sLG09W10seT0odj15KS0xOzA8PXk7LS15KW1beV09cFtCK3ldO2Zvcih5PXYtMTswPD15Oy0teSl3W2YreV09bVt5XTt6QSh1LGgsZCxjLGcsYyxsKX1lbHNlIHpBKHUsaCxkLGYscCxjLGwpfWw9cyxjPW59YyE9biYmcihzLG4sbCxjLG8pfWZ1bmN0aW9uIGJlKGUsQSl7dmFyIHI9ZS5WLG49ZS5CYStlLmMqZS5DLHM9QS1lLkM7aWYodChBPD1lLmwubyksdCgxNj49cyksMDxzKXt2YXIgaT1lLmwsbz1lLlRhLGE9ZS5VYSxsPWkud2lkdGg7aWYodmUoZSxzLHIsbikscz1hPVthXSx0KChyPWUuQyk8KG49QSkpLHQoaS52PGkudmEpLG4+aS5vJiYobj1pLm8pLHI8aS5qKXt2YXIgYz1pLmotcjtyPWkuaixzWzBdKz1jKmx9aWYocj49bj9yPTA6KHNbMF0rPTQqaS52LGkua2E9ci1pLmosaS5VPWkudmEtaS52LGkuVD1uLXIscj0xKSxyKXtpZihhPWFbMF0sMTE+KHI9ZS5jYSkuUyl7dmFyIHU9ci5mLlJHQkEsaD0obj1yLlMscz1pLlUsaT1pLlQsYz11LmViLHUuQSksZD1pO2Zvcih1PXUuZmIrZS5NYSp1LkE7MDxkLS07KXt2YXIgZj1vLHA9YSxnPXMsbT1jLHc9dTtzd2l0Y2gobil7Y2FzZSBOcjpaQShmLHAsZyxtLHcpO2JyZWFrO2Nhc2Uga3I6JEEoZixwLGcsbSx3KTticmVhaztjYXNlIERyOiRBKGYscCxnLG0sdyksdnIobSx3LDAsZywxLDApO2JyZWFrO2Nhc2UgSHI6QXIoZixwLGcsbSx3KTticmVhaztjYXNlIFByOnRlKGYscCxnLG0sdywxKTticmVhaztjYXNlIFJyOnRlKGYscCxnLG0sdywxKSx2cihtLHcsMCxnLDEsMCk7YnJlYWs7Y2FzZSBUcjp0ZShmLHAsZyxtLHcsMCk7YnJlYWs7Y2FzZSBLcjp0ZShmLHAsZyxtLHcsMCksdnIobSx3LDEsZywxLDApO2JyZWFrO2Nhc2UgT3I6ZXIoZixwLGcsbSx3KTticmVhaztjYXNlIFZyOmVyKGYscCxnLG0sdyksYnIobSx3LGcsMSwwKTticmVhaztjYXNlIE1yOnRyKGYscCxnLG0sdyk7YnJlYWs7ZGVmYXVsdDp0KDApfWErPWwsdSs9aH1lLk1hKz1pfWVsc2UgYWxlcnQoInRvZG86RW1pdFJlc2NhbGVkUm93c1lVVkEiKTt0KGUuTWE8PXIuaGVpZ2h0KX19ZS5DPUEsdChlLkM8PWUuaSl9ZnVuY3Rpb24gQ2UoZSl7dmFyIHQ7aWYoMDxlLnVhKXJldHVybiAwO2Zvcih0PTA7dDxlLldiOysrdCl7dmFyIEE9ZS5ZYVt0XS5HLHI9ZS5ZYVt0XS5IO2lmKDA8QVsxXVtyWzFdKzBdLmd8fDA8QVsyXVtyWzJdKzBdLmd8fDA8QVszXVtyWzNdKzBdLmcpcmV0dXJuIDB9cmV0dXJuIDF9ZnVuY3Rpb24gX2UoZSxBLHIsbixzLGkpe2lmKDAhPWUuWil7dmFyIG89ZS5xZCxhPWUucmQ7Zm9yKHQobnVsbCE9cG5bZS5aXSk7QTxyOysrQSlwbltlLlpdKG8sYSxuLHMsbixzLGkpLG89bixhPXMscys9aTtlLnFkPW8sZS5yZD1hfX1mdW5jdGlvbiBqZShlLEEpe3ZhciByPWUubC5tYSxuPTA9PXIuWnx8MT09ci5aP2UubC5qOmUuQztpZihuPWUuQzxuP246ZS5DLHQoQTw9ZS5sLm8pLEE+bil7dmFyIHM9ZS5sLndpZHRoLGk9ci5jYSxvPXIudGIrcypuLGE9ZS5WLGw9ZS5CYStlLmMqbixjPWUuZ2M7dCgxPT1lLmFiKSx0KDM9PWNbMF0uaGMpLFdBKGNbMF0sbixBLGEsbCxpLG8pLF9lKHIsbixBLGksbyxzKX1lLkM9ZS5NYT1BfWZ1bmN0aW9uIHhlKGUsQSxyLG4scyxpLG8pe3ZhciBhPWUuJC9uLGw9ZS4kJW4sYz1lLm0sdT1lLnMsaD1yK2UuJCxkPWg7cz1yK24qczt2YXIgZj1yK24qaSxwPTI4MCt1LnVhLGc9ZS5QYj9hOjE2Nzc3MjE2LG09MDx1LnVhP3UuV2E6bnVsbCx3PXUud2MsQj1oPGY/eWUodSxsLGEpOm51bGw7dChlLkM8aSksdChmPD1zKTt2YXIgeT0hMTtlOmZvcig7Oyl7Zm9yKDt5fHxoPGY7KXt2YXIgdj0wO2lmKGE+PWcpe3ZhciB4PWgtcjt0KChnPWUpLlBiKSxnLndkPWcubSxnLnhkPXgsMDxnLnMudWEmJk4oZy5zLldhLGcucy52YiksZz1hK1pyfWlmKGwmd3x8KEI9eWUodSxsLGEpKSx0KG51bGwhPUIpLEIuUWImJihBW2hdPUIucWIseT0hMCksIXkpaWYoaihjKSxCLmpjKXt2PWMseD1BO3ZhciBGPWgsUT1CLnBkW2IodikmUEEtMV07dChCLmpjKSwyNTY+US5nPyhfKHYsdi51K1EuZykseFtGXT1RLnZhbHVlLHY9MCk6KF8odix2LnUrUS5nLTI1NiksdCgyNTY8PVEudmFsdWUpLHY9US52YWx1ZSksMD09diYmKHk9ITApfWVsc2Ugdj13ZShCLkdbMF0sQi5IWzBdLGMpO2lmKGMuaClicmVhaztpZih5fHwyNTY+dil7aWYoIXkpaWYoQi5uZClBW2hdPShCLnFifHY8PDgpPj4+MDtlbHNle2lmKGooYykseT13ZShCLkdbMV0sQi5IWzFdLGMpLGooYykseD13ZShCLkdbMl0sQi5IWzJdLGMpLEY9d2UoQi5HWzNdLEIuSFszXSxjKSxjLmgpYnJlYWs7QVtoXT0oRjw8MjR8eTw8MTZ8djw8OHx4KT4+PjB9aWYoeT0hMSwrK2gsKytsPj1uJiYobD0wLCsrYSxudWxsIT1vJiZhPD1pJiYhKGElMTYpJiZvKGUsYSksbnVsbCE9bSkpZm9yKDtkPGg7KXY9QVtkKytdLG0uWFsoNTA2ODMyODI5KnYmNDI5NDk2NzI5NSk+Pj5tLk1iXT12fWVsc2UgaWYoMjgwPnYpe2lmKHY9Z2Uodi0yNTYsYykseD13ZShCLkdbNF0sQi5IWzRdLGMpLGooYykseD1tZShuLHg9Z2UoeCxjKSksYy5oKWJyZWFrO2lmKGgtcjx4fHxzLWg8dilicmVhayBlO2ZvcihGPTA7Rjx2OysrRilBW2grRl09QVtoK0YteF07Zm9yKGgrPXYsbCs9djtsPj1uOylsLT1uLCsrYSxudWxsIT1vJiZhPD1pJiYhKGElMTYpJiZvKGUsYSk7aWYodChoPD1zKSxsJncmJihCPXllKHUsbCxhKSksbnVsbCE9bSlmb3IoO2Q8aDspdj1BW2QrK10sbS5YWyg1MDY4MzI4MjkqdiY0Mjk0OTY3Mjk1KT4+Pm0uTWJdPXZ9ZWxzZXtpZighKHY8cCkpYnJlYWsgZTtmb3IoeT12LTI4MCx0KG51bGwhPW0pO2Q8aDspdj1BW2QrK10sbS5YWyg1MDY4MzI4MjkqdiY0Mjk0OTY3Mjk1KT4+Pm0uTWJdPXY7dj1oLHQoISh5Pj4+KHg9bSkuWGEpKSxBW3ZdPXguWFt5XSx5PSEwfXl8fHQoYy5oPT1DKGMpKX1pZihlLlBiJiZjLmgmJmg8cyl0KGUubS5oKSxlLmE9NSxlLm09ZS53ZCxlLiQ9ZS54ZCwwPGUucy51YSYmTihlLnMudmIsZS5zLldhKTtlbHNle2lmKGMuaClicmVhayBlO251bGwhPW8mJm8oZSxhPmk/aTphKSxlLmE9MCxlLiQ9aC1yfXJldHVybiAxfXJldHVybiBlLmE9MywwfWZ1bmN0aW9uIEZlKGUpe3QobnVsbCE9ZSksZS52Yz1udWxsLGUueWM9bnVsbCxlLllhPW51bGw7dmFyIEE9ZS5XYTtudWxsIT1BJiYoQS5YPW51bGwpLGUudmI9bnVsbCx0KG51bGwhPWUpfWZ1bmN0aW9uIFFlKCl7dmFyIHQ9bmV3IHNBO3JldHVybiBudWxsPT10P251bGw6KHQuYT0wLHQueGI9Zm4sQWUoIlByZWRpY3RvciIsIlZQOExQcmVkaWN0b3JzIiksQWUoIlByZWRpY3RvciIsIlZQOExQcmVkaWN0b3JzX0MiKSxBZSgiUHJlZGljdG9yQWRkIiwiVlA4TFByZWRpY3RvcnNBZGQiKSxBZSgiUHJlZGljdG9yQWRkIiwiVlA4TFByZWRpY3RvcnNBZGRfQyIpLEdBPXosSkE9VyxaQT1ZLCRBPUosZXI9Wix0cj0kLEFyPWVlLGUuVlA4TE1hcENvbG9yMzJiPXFBLGUuVlA4TE1hcENvbG9yOGI9WEEsdCl9ZnVuY3Rpb24gVWUoZSxBLHIsbyxhKXt2YXIgbD0xLGg9W2VdLGY9W0FdLHA9by5tLGc9by5zLG09bnVsbCx3PTA7ZTpmb3IoOzspe2lmKHIpZm9yKDtsJiZCKHAsMSk7KXt2YXIgeT1oLHY9ZixDPW8seD0xLEY9Qy5tLFE9Qy5nY1tDLmFiXSxVPUIoRiwyKTtpZihDLk9jJjE8PFUpbD0wO2Vsc2V7c3dpdGNoKEMuT2N8PTE8PFUsUS5oYz1VLFEuRWE9eVswXSxRLm5jPXZbMF0sUS5LPVtudWxsXSwrK0MuYWIsdCg0Pj1DLmFiKSxVKXtjYXNlIDA6Y2FzZSAxOlEuYj1CKEYsMykrMix4PVVlKFAoUS5FYSxRLmIpLFAoUS5uYyxRLmIpLDAsQyxRLkspLFEuSz1RLktbMF07YnJlYWs7Y2FzZSAzOnZhciBFLFM9QihGLDgpKzEsTD0xNjxTPzA6NDxTPzE6MjxTPzI6MztpZih5WzBdPVAoUS5FYSxMKSxRLmI9TCxFPXg9VWUoUywxLDAsQyxRLkspKXt2YXIgTixrPVMsSD1RLE89MTw8KDg+PkguYiksTT1zKE8pO2lmKG51bGw9PU0pRT0wO2Vsc2V7dmFyIEQ9SC5LWzBdLFI9SC53O2ZvcihNWzBdPUguS1swXVswXSxOPTE7TjwxKms7KytOKU1bTl09VChEW1IrTl0sTVtOLTFdKTtmb3IoO048NCpPOysrTilNW05dPTA7SC5LWzBdPW51bGwsSC5LWzBdPU0sRT0xfX14PUU7YnJlYWs7Y2FzZSAyOmJyZWFrO2RlZmF1bHQ6dCgwKX1sPXh9fWlmKGg9aFswXSxmPWZbMF0sbCYmQihwLDEpJiYhKGw9MTw9KHc9QihwLDQpKSYmMTE+PXcpKXtvLmE9MzticmVhayBlfXZhciBLO2lmKEs9bCl0Ont2YXIgVixHLHoscT1vLFc9aCxYPWYsWT13LEo9cixaPXEubSwkPXEucyxlZT1bbnVsbF0sdGU9MSxBZT0wLHJlPUpyW1ldO0E6Zm9yKDs7KXtpZihKJiZCKFosMSkpe3ZhciBuZT1CKFosMykrMixzZT1QKFcsbmUpLGllPVAoWCxuZSksb2U9c2UqaWU7aWYoIVVlKHNlLGllLDAscSxlZSkpYnJlYWsgQTtmb3IoZWU9ZWVbMF0sJC54Yz1uZSxWPTA7VjxvZTsrK1Ype3ZhciBhZT1lZVtWXT4+OCY2NTUzNTtlZVtWXT1hZSxhZT49dGUmJih0ZT1hZSsxKX19aWYoWi5oKWJyZWFrIEE7Zm9yKEc9MDs1Pkc7KytHKXt2YXIgbGU9cXJbR107IUcmJjA8WSYmKGxlKz0xPDxZKSxBZTxsZSYmKEFlPWxlKX12YXIgY2U9aSh0ZSpyZSx1KSx1ZT10ZSxoZT1pKHVlLGQpO2lmKG51bGw9PWhlKXZhciBkZT1udWxsO2Vsc2UgdCg2NTUzNj49dWUpLGRlPWhlO3ZhciBmZT1zKEFlKTtpZihudWxsPT1kZXx8bnVsbD09ZmV8fG51bGw9PWNlKXtxLmE9MTticmVhayBBfXZhciBwZT1jZTtmb3IoVj16PTA7Vjx0ZTsrK1Ype3ZhciBnZT1kZVtWXSxtZT1nZS5HLHdlPWdlLkgseWU9MCx2ZT0xLGJlPTA7Zm9yKEc9MDs1Pkc7KytHKXtsZT1xcltHXSxtZVtHXT1wZSx3ZVtHXT16LCFHJiYwPFkmJihsZSs9MTw8WSk7cjp7dmFyIENlLF9lPWxlLGplPXEsUWU9ZmUsRWU9cGUsU2U9eixMZT0wLEllPWplLm0sTmU9QihJZSwxKTtpZihuKFFlLDAsMCxfZSksTmUpe3ZhciBrZT1CKEllLDEpKzEsSGU9QihJZSwxKSxQZT1CKEllLDA9PUhlPzE6OCk7UWVbUGVdPTEsMj09a2UmJihRZVtQZT1CKEllLDgpXT0xKTt2YXIgVGU9MX1lbHNle3ZhciBPZT1zKDE5KSxNZT1CKEllLDQpKzQ7aWYoMTk8TWUpe2plLmE9Mzt2YXIgRGU9MDticmVhayByfWZvcihDZT0wO0NlPE1lOysrQ2UpT2VbWHJbQ2VdXT1CKEllLDMpO3ZhciBSZT12b2lkIDAsS2U9dm9pZCAwLFZlPWplLEdlPU9lLHplPV9lLHFlPVFlLFdlPTAsWGU9VmUubSxZZT04LEplPWkoMTI4LHUpO246Zm9yKDtjKEplLDAsNyxHZSwxOSk7KXtpZihCKFhlLDEpKXt2YXIgWmU9MisyKkIoWGUsMyk7aWYoKFJlPTIrQihYZSxaZSkpPnplKWJyZWFrIG59ZWxzZSBSZT16ZTtmb3IoS2U9MDtLZTx6ZSYmUmUtLTspe2ooWGUpO3ZhciAkZT1KZVswKygxMjcmYihYZSkpXTtfKFhlLFhlLnUrJGUuZyk7dmFyIGV0PSRlLnZhbHVlO2lmKDE2PmV0KXFlW0tlKytdPWV0LDAhPWV0JiYoWWU9ZXQpO2Vsc2V7dmFyIHR0PTE2PT1ldCxBdD1ldC0xNixydD16cltBdF0sbnQ9QihYZSxHcltBdF0pK3J0O2lmKEtlK250PnplKWJyZWFrIG47Zm9yKHZhciBzdD10dD9ZZTowOzA8bnQtLTspcWVbS2UrK109c3R9fVdlPTE7YnJlYWsgbn1XZXx8KFZlLmE9MyksVGU9V2V9KFRlPVRlJiYhSWUuaCkmJihMZT1jKEVlLFNlLDgsUWUsX2UpKSxUZSYmMCE9TGU/RGU9TGU6KGplLmE9MyxEZT0wKX1pZigwPT1EZSlicmVhayBBO2lmKHZlJiYxPT1XcltHXSYmKHZlPTA9PXBlW3pdLmcpLHllKz1wZVt6XS5nLHorPURlLDM+PUcpe3ZhciBpdCxvdD1mZVswXTtmb3IoaXQ9MTtpdDxsZTsrK2l0KWZlW2l0XT5vdCYmKG90PWZlW2l0XSk7YmUrPW90fX1pZihnZS5uZD12ZSxnZS5RYj0wLHZlJiYoZ2UucWI9KG1lWzNdW3dlWzNdKzBdLnZhbHVlPDwyNHxtZVsxXVt3ZVsxXSswXS52YWx1ZTw8MTZ8bWVbMl1bd2VbMl0rMF0udmFsdWUpPj4+MCwwPT15ZSYmMjU2Pm1lWzBdW3dlWzBdKzBdLnZhbHVlJiYoZ2UuUWI9MSxnZS5xYis9bWVbMF1bd2VbMF0rMF0udmFsdWU8PDgpKSxnZS5qYz0hZ2UuUWImJjY+YmUsZ2UuamMpe3ZhciBhdCxsdD1nZTtmb3IoYXQ9MDthdDxQQTsrK2F0KXt2YXIgY3Q9YXQsdXQ9bHQucGRbY3RdLGh0PWx0LkdbMF1bbHQuSFswXStjdF07MjU2PD1odC52YWx1ZT8odXQuZz1odC5nKzI1Nix1dC52YWx1ZT1odC52YWx1ZSk6KHV0Lmc9MCx1dC52YWx1ZT0wLGN0Pj49QmUoaHQsOCx1dCksY3Q+Pj1CZShsdC5HWzFdW2x0LkhbMV0rY3RdLDE2LHV0KSxjdD4+PUJlKGx0LkdbMl1bbHQuSFsyXStjdF0sMCx1dCksQmUobHQuR1szXVtsdC5IWzNdK2N0XSwyNCx1dCkpfX19JC52Yz1lZSwkLldiPXRlLCQuWWE9ZGUsJC55Yz1jZSxLPTE7YnJlYWsgdH1LPTB9aWYoIShsPUspKXtvLmE9MzticmVhayBlfWlmKDA8dyl7aWYoZy51YT0xPDx3LCFJKGcuV2Esdykpe28uYT0xLGw9MDticmVhayBlfX1lbHNlIGcudWE9MDt2YXIgZHQ9byxmdD1oLHB0PWYsZ3Q9ZHQucyxtdD1ndC54YztpZihkdC5jPWZ0LGR0Lmk9cHQsZ3QubWQ9UChmdCxtdCksZ3Qud2M9MD09bXQ/LTE6KDE8PG10KS0xLHIpe28ueGI9ZG47YnJlYWsgZX1pZihudWxsPT0obT1zKGgqZikpKXtvLmE9MSxsPTA7YnJlYWsgZX1sPShsPXhlKG8sbSwwLGgsZixmLG51bGwpKSYmIXAuaDticmVhayBlfXJldHVybiBsPyhudWxsIT1hP2FbMF09bToodChudWxsPT1tKSx0KHIpKSxvLiQ9MCxyfHxGZShnKSk6RmUoZyksbH1mdW5jdGlvbiBFZShlLEEpe3ZhciByPWUuYyplLmksbj1yK0ErMTYqQTtyZXR1cm4gdChlLmM8PUEpLGUuVj1zKG4pLG51bGw9PWUuVj8oZS5UYT1udWxsLGUuVWE9MCxlLmE9MSwwKTooZS5UYT1lLlYsZS5VYT1lLkJhK3IrQSwxKX1mdW5jdGlvbiBTZShlLEEpe3ZhciByPWUuQyxuPUEtcixzPWUuVixpPWUuQmErZS5jKnI7Zm9yKHQoQTw9ZS5sLm8pOzA8bjspe3ZhciBvPTE2PG4/MTY6bixhPWUubC5tYSxsPWUubC53aWR0aCxjPWwqbyx1PWEuY2EsaD1hLnRiK2wqcixkPWUuVGEsZj1lLlVhO3ZlKGUsbyxzLGkpLF9yKGQsZix1LGgsYyksX2UoYSxyLHIrbyx1LGgsbCksbi09byxzKz1vKmUuYyxyKz1vfXQocj09QSksZS5DPWUuTWE9QX1mdW5jdGlvbiBMZSgpe3RoaXMudWI9dGhpcy55ZD10aGlzLnRkPXRoaXMuUmI9MH1mdW5jdGlvbiBJZSgpe3RoaXMuS2Q9dGhpcy5MZD10aGlzLlVkPXRoaXMuVGQ9dGhpcy5pPXRoaXMuYz0wfWZ1bmN0aW9uIE5lKCl7dGhpcy5GYj10aGlzLkJiPXRoaXMuQ2I9MCx0aGlzLlpiPXMoNCksdGhpcy5MYj1zKDQpfWZ1bmN0aW9uIGtlKCl7dGhpcy5ZYj1mdW5jdGlvbigpe3ZhciBlPVtdO3JldHVybiBmdW5jdGlvbiBlKHQsQSxyKXtmb3IodmFyIG49cltBXSxzPTA7czxuJiYodC5wdXNoKHIubGVuZ3RoPkErMT9bXTowKSwhKHIubGVuZ3RoPEErMSkpO3MrKyllKHRbc10sQSsxLHIpfShlLDAsWzMsMTFdKSxlfSgpfWZ1bmN0aW9uIEhlKCl7dGhpcy5qYj1zKDMpLHRoaXMuV2M9byhbNCw4XSxrZSksdGhpcy5YYz1vKFs0LDE3XSxrZSl9ZnVuY3Rpb24gUGUoKXt0aGlzLlBjPXRoaXMud2I9dGhpcy5UYj10aGlzLnpkPTAsdGhpcy52ZD1uZXcgcyg0KSx0aGlzLm9kPW5ldyBzKDQpfWZ1bmN0aW9uIFRlKCl7dGhpcy5sZD10aGlzLkxhPXRoaXMuZGQ9dGhpcy50Yz0wfWZ1bmN0aW9uIE9lKCl7dGhpcy5OYT10aGlzLmxhPTB9ZnVuY3Rpb24gTWUoKXt0aGlzLlNjPVswLDBdLHRoaXMuRWI9WzAsMF0sdGhpcy5RYz1bMCwwXSx0aGlzLmlhPXRoaXMubGM9MH1mdW5jdGlvbiBEZSgpe3RoaXMuYWQ9cygzODQpLHRoaXMuWmE9MCx0aGlzLk9iPXMoMTYpLHRoaXMuJGI9dGhpcy5BZD10aGlzLmlhPXRoaXMuR2M9dGhpcy5IYz10aGlzLkRkPTB9ZnVuY3Rpb24gUmUoKXt0aGlzLnVjPXRoaXMuTT10aGlzLk5iPTAsdGhpcy53YT1BcnJheShuZXcgVGUpLHRoaXMuWT0wLHRoaXMueWE9QXJyYXkobmV3IERlKSx0aGlzLmFhPTAsdGhpcy5sPW5ldyB6ZX1mdW5jdGlvbiBLZSgpe3RoaXMueT1zKDE2KSx0aGlzLmY9cyg4KSx0aGlzLmVhPXMoOCl9ZnVuY3Rpb24gVmUoKXt0aGlzLmNiPXRoaXMuYT0wLHRoaXMuc2M9IiIsdGhpcy5tPW5ldyB5LHRoaXMuT2Q9bmV3IExlLHRoaXMuS2M9bmV3IEllLHRoaXMuZWQ9bmV3IFBlLHRoaXMuUWE9bmV3IE5lLHRoaXMuSWM9dGhpcy4kYz10aGlzLkFhPTAsdGhpcy5EPW5ldyBSZSx0aGlzLlhiPXRoaXMuVmE9dGhpcy5IYj10aGlzLnpiPXRoaXMueWI9dGhpcy5VYj10aGlzLnphPTAsdGhpcy5KYz1pKDgseSksdGhpcy5pYT0wLHRoaXMucGI9aSg0LE1lKSx0aGlzLlBhPW5ldyBIZSx0aGlzLkJkPXRoaXMua2M9MCx0aGlzLkFjPVtdLHRoaXMuQmM9MCx0aGlzLnpjPVswLDAsMCwwXSx0aGlzLkdkPUFycmF5KG5ldyBLZSksdGhpcy5IZD0wLHRoaXMucmI9QXJyYXkobmV3IE9lKSx0aGlzLnNiPTAsdGhpcy53YT1BcnJheShuZXcgVGUpLHRoaXMuWT0wLHRoaXMub2M9W10sdGhpcy5wYz0wLHRoaXMuc2E9W10sdGhpcy50YT0wLHRoaXMucWE9W10sdGhpcy5yYT0wLHRoaXMuSGE9W10sdGhpcy5CPXRoaXMuUj10aGlzLklhPTAsdGhpcy5FYz1bXSx0aGlzLk09dGhpcy5qYT10aGlzLlZiPXRoaXMuRmM9MCx0aGlzLnlhPUFycmF5KG5ldyBEZSksdGhpcy5MPXRoaXMuYWE9MCx0aGlzLmdkPW8oWzQsMl0sVGUpLHRoaXMuZ2E9bnVsbCx0aGlzLkZhPVtdLHRoaXMuQ2M9dGhpcy5xYz10aGlzLlA9MCx0aGlzLkdiPVtdLHRoaXMuVWM9MCx0aGlzLm1iPVtdLHRoaXMubmI9MCx0aGlzLnJjPVtdLHRoaXMuR2E9dGhpcy5WYz0wfWZ1bmN0aW9uIEdlKGUsdCl7cmV0dXJuIDA+ZT8wOmU+dD90OmV9ZnVuY3Rpb24gemUoKXt0aGlzLlQ9dGhpcy5VPXRoaXMua2E9dGhpcy5oZWlnaHQ9dGhpcy53aWR0aD0wLHRoaXMueT1bXSx0aGlzLmY9W10sdGhpcy5lYT1bXSx0aGlzLlJjPXRoaXMuZmE9dGhpcy5XPXRoaXMuTj10aGlzLk89MCx0aGlzLm1hPSJ2b2lkIix0aGlzLnB1dD0iVlA4SW9QdXRIb29rIix0aGlzLmFjPSJWUDhJb1NldHVwSG9vayIsdGhpcy5iYz0iVlA4SW9UZWFyZG93bkhvb2siLHRoaXMuaGE9dGhpcy5LYj0wLHRoaXMuZGF0YT1bXSx0aGlzLmhiPXRoaXMuaWI9dGhpcy5kYT10aGlzLm89dGhpcy5qPXRoaXMudmE9dGhpcy52PXRoaXMuRGE9dGhpcy5vYj10aGlzLnc9MCx0aGlzLkY9W10sdGhpcy5KPTB9ZnVuY3Rpb24gcWUoKXt2YXIgZT1uZXcgVmU7cmV0dXJuIG51bGwhPWUmJihlLmE9MCxlLnNjPSJPSyIsZS5jYj0wLGUuWGI9MCx0bnx8KHRuPUplKSksZX1mdW5jdGlvbiBXZShlLHQsQSl7cmV0dXJuIDA9PWUuYSYmKGUuYT10LGUuc2M9QSxlLmNiPTApLDB9ZnVuY3Rpb24gWGUoZSx0LEEpe3JldHVybiAzPD1BJiYxNTc9PWVbdCswXSYmMT09ZVt0KzFdJiY0Mj09ZVt0KzJdfWZ1bmN0aW9uIFllKGUsQSl7aWYobnVsbD09ZSlyZXR1cm4gMDtpZihlLmE9MCxlLnNjPSJPSyIsbnVsbD09QSlyZXR1cm4gV2UoZSwyLCJudWxsIFZQOElvIHBhc3NlZCB0byBWUDhHZXRIZWFkZXJzKCkiKTt2YXIgcj1BLmRhdGEscz1BLncsaT1BLmhhO2lmKDQ+aSlyZXR1cm4gV2UoZSw3LCJUcnVuY2F0ZWQgaGVhZGVyLiIpO3ZhciBvPXJbcyswXXxyW3MrMV08PDh8cltzKzJdPDwxNixhPWUuT2Q7aWYoYS5SYj0hKDEmbyksYS50ZD1vPj4xJjcsYS55ZD1vPj40JjEsYS51Yj1vPj41LDM8YS50ZClyZXR1cm4gV2UoZSwzLCJJbmNvcnJlY3Qga2V5ZnJhbWUgcGFyYW1ldGVycy4iKTtpZighYS55ZClyZXR1cm4gV2UoZSw0LCJGcmFtZSBub3QgZGlzcGxheWFibGUuIik7cys9MyxpLT0zO3ZhciBsPWUuS2M7aWYoYS5SYil7aWYoNz5pKXJldHVybiBXZShlLDcsImNhbm5vdCBwYXJzZSBwaWN0dXJlIGhlYWRlciIpO2lmKCFYZShyLHMsaSkpcmV0dXJuIFdlKGUsMywiQmFkIGNvZGUgd29yZCIpO2wuYz0xNjM4MyYocltzKzRdPDw4fHJbcyszXSksbC5UZD1yW3MrNF0+PjYsbC5pPTE2MzgzJihyW3MrNl08PDh8cltzKzVdKSxsLlVkPXJbcys2XT4+NixzKz03LGktPTcsZS56YT1sLmMrMTU+PjQsZS5VYj1sLmkrMTU+PjQsQS53aWR0aD1sLmMsQS5oZWlnaHQ9bC5pLEEuRGE9MCxBLmo9MCxBLnY9MCxBLnZhPUEud2lkdGgsQS5vPUEuaGVpZ2h0LEEuZGE9MCxBLmliPUEud2lkdGgsQS5oYj1BLmhlaWdodCxBLlU9QS53aWR0aCxBLlQ9QS5oZWlnaHQsbigobz1lLlBhKS5qYiwwLDI1NSxvLmpiLmxlbmd0aCksdChudWxsIT0obz1lLlFhKSksby5DYj0wLG8uQmI9MCxvLkZiPTEsbihvLlpiLDAsMCxvLlpiLmxlbmd0aCksbihvLkxiLDAsMCxvLkxiKX1pZihhLnViPmkpcmV0dXJuIFdlKGUsNywiYmFkIHBhcnRpdGlvbiBsZW5ndGgiKTtmKG89ZS5tLHIscyxhLnViKSxzKz1hLnViLGktPWEudWIsYS5SYiYmKGwuTGQ9RihvKSxsLktkPUYobykpLGw9ZS5RYTt2YXIgYyx1PWUuUGE7aWYodChudWxsIT1vKSx0KG51bGwhPWwpLGwuQ2I9RihvKSxsLkNiKXtpZihsLkJiPUYobyksRihvKSl7Zm9yKGwuRmI9RihvKSxjPTA7ND5jOysrYylsLlpiW2NdPUYobyk/ZyhvLDcpOjA7Zm9yKGM9MDs0PmM7KytjKWwuTGJbY109RihvKT9nKG8sNik6MH1pZihsLkJiKWZvcihjPTA7Mz5jOysrYyl1LmpiW2NdPUYobyk/cChvLDgpOjI1NX1lbHNlIGwuQmI9MDtpZihvLkthKXJldHVybiBXZShlLDMsImNhbm5vdCBwYXJzZSBzZWdtZW50IGhlYWRlciIpO2lmKChsPWUuZWQpLnpkPUYobyksbC5UYj1wKG8sNiksbC53Yj1wKG8sMyksbC5QYz1GKG8pLGwuUGMmJkYobykpe2Zvcih1PTA7ND51OysrdSlGKG8pJiYobC52ZFt1XT1nKG8sNikpO2Zvcih1PTA7ND51OysrdSlGKG8pJiYobC5vZFt1XT1nKG8sNikpfWlmKGUuTD0wPT1sLlRiPzA6bC56ZD8xOjIsby5LYSlyZXR1cm4gV2UoZSwzLCJjYW5ub3QgcGFyc2UgZmlsdGVyIGhlYWRlciIpO3ZhciBoPWk7aWYoaT1jPXMscz1jK2gsbD1oLGUuWGI9KDE8PHAoZS5tLDIpKS0xLGg8MyoodT1lLlhiKSlyPTc7ZWxzZXtmb3IoYys9Myp1LGwtPTMqdSxoPTA7aDx1OysraCl7dmFyIGQ9cltpKzBdfHJbaSsxXTw8OHxyW2krMl08PDE2O2Q+bCYmKGQ9bCksZihlLkpjWytoXSxyLGMsZCksYys9ZCxsLT1kLGkrPTN9ZihlLkpjWyt1XSxyLGMsbCkscj1jPHM/MDo1fWlmKDAhPXIpcmV0dXJuIFdlKGUsciwiY2Fubm90IHBhcnNlIHBhcnRpdGlvbnMiKTtmb3Iocj1wKGM9ZS5tLDcpLGk9RihjKT9nKGMsNCk6MCxzPUYoYyk/ZyhjLDQpOjAsbD1GKGMpP2coYyw0KTowLHU9RihjKT9nKGMsNCk6MCxjPUYoYyk/ZyhjLDQpOjAsaD1lLlFhLGQ9MDs0PmQ7KytkKXtpZihoLkNiKXt2YXIgbT1oLlpiW2RdO2guRmJ8fChtKz1yKX1lbHNle2lmKDA8ZCl7ZS5wYltkXT1lLnBiWzBdO2NvbnRpbnVlfW09cn12YXIgdz1lLnBiW2RdO3cuU2NbMF09JHJbR2UobStpLDEyNyldLHcuU2NbMV09ZW5bR2UobSswLDEyNyldLHcuRWJbMF09MiokcltHZShtK3MsMTI3KV0sdy5FYlsxXT0xMDE1ODEqZW5bR2UobStsLDEyNyldPj4xNiw4PncuRWJbMV0mJih3LkViWzFdPTgpLHcuUWNbMF09JHJbR2UobSt1LDExNyldLHcuUWNbMV09ZW5bR2UobStjLDEyNyldLHcubGM9bStjfWlmKCFhLlJiKXJldHVybiBXZShlLDQsIk5vdCBhIGtleSBmcmFtZS4iKTtmb3IoRihvKSxhPWUuUGEscj0wOzQ+cjsrK3Ipe2ZvcihpPTA7OD5pOysraSlmb3Iocz0wOzM+czsrK3MpZm9yKGw9MDsxMT5sOysrbCl1PVEobyxhbltyXVtpXVtzXVtsXSk/cChvLDgpOnNuW3JdW2ldW3NdW2xdLGEuV2Nbcl1baV0uWWJbc11bbF09dTtmb3IoaT0wOzE3Pmk7KytpKWEuWGNbcl1baV09YS5XY1tyXVtsbltpXV19cmV0dXJuIGUua2M9RihvKSxlLmtjJiYoZS5CZD1wKG8sOCkpLGUuY2I9MX1mdW5jdGlvbiBKZShlLHQsQSxyLG4scyxpKXt2YXIgbz10W25dLlliW0FdO2ZvcihBPTA7MTY+bjsrK24pe2lmKCFRKGUsb1tBKzBdKSlyZXR1cm4gbjtmb3IoOyFRKGUsb1tBKzFdKTspaWYobz10Wysrbl0uWWJbMF0sQT0wLDE2PT1uKXJldHVybiAxNjt2YXIgYT10W24rMV0uWWI7aWYoUShlLG9bQSsyXSkpe3ZhciBsPWUsYz0wO2lmKFEobCwoaD1vKVsodT1BKSszXSkpaWYoUShsLGhbdSs2XSkpe2ZvcihvPTAsdT0yKihjPVEobCxoW3UrOF0pKSsoaD1RKGwsaFt1KzkrY10pKSxjPTAsaD1Bblt1XTtoW29dOysrbyljKz1jK1EobCxoW29dKTtjKz0zKyg4PDx1KX1lbHNlIFEobCxoW3UrN10pPyhjPTcrMipRKGwsMTY1KSxjKz1RKGwsMTQ1KSk6Yz01K1EobCwxNTkpO2Vsc2UgYz1RKGwsaFt1KzRdKT8zK1EobCxoW3UrNV0pOjI7bz1hWzJdfWVsc2UgYz0xLG89YVsxXTthPWkrcm5bbl0sMD4obD1lKS5iJiZ4KGwpO3ZhciB1LGg9bC5iLGQ9KHU9bC5DYT4+MSktKGwuST4+aCk+PjMxOy0tbC5iLGwuQ2ErPWQsbC5DYXw9MSxsLkktPSh1KzEmZCk8PGgsc1thXT0oKGNeZCktZCkqclsoMDxuKSswXX1yZXR1cm4gMTZ9ZnVuY3Rpb24gWmUoZSl7dmFyIHQ9ZS5yYltlLnNiLTFdO3QubGE9MCx0Lk5hPTAsbihlLnpjLDAsMCxlLnpjLmxlbmd0aCksZS5qYT0wfWZ1bmN0aW9uICRlKGUsdCxBLHIsbil7bj1lW3QrQSszMipyXSsobj4+MyksZVt0K0ErMzIqcl09LTI1NiZuPzA+bj8wOjI1NTpufWZ1bmN0aW9uIGV0KGUsdCxBLHIsbixzKXskZShlLHQsMCxBLHIrbiksJGUoZSx0LDEsQSxyK3MpLCRlKGUsdCwyLEEsci1zKSwkZShlLHQsMyxBLHItbil9ZnVuY3Rpb24gdHQoZSl7cmV0dXJuKDIwMDkxKmU+PjE2KStlfWZ1bmN0aW9uIEF0KGUsdCxBLHIpe3ZhciBuLGk9MCxvPXMoMTYpO2ZvcihuPTA7ND5uOysrbil7dmFyIGE9ZVt0KzBdK2VbdCs4XSxsPWVbdCswXS1lW3QrOF0sYz0oMzU0NjgqZVt0KzRdPj4xNiktdHQoZVt0KzEyXSksdT10dChlW3QrNF0pKygzNTQ2OCplW3QrMTJdPj4xNik7b1tpKzBdPWErdSxvW2krMV09bCtjLG9baSsyXT1sLWMsb1tpKzNdPWEtdSxpKz00LHQrK31mb3Iobj1pPTA7ND5uOysrbilhPShlPW9baSswXSs0KStvW2krOF0sbD1lLW9baSs4XSxjPSgzNTQ2OCpvW2krNF0+PjE2KS10dChvW2krMTJdKSwkZShBLHIsMCwwLGErKHU9dHQob1tpKzRdKSsoMzU0Njgqb1tpKzEyXT4+MTYpKSksJGUoQSxyLDEsMCxsK2MpLCRlKEEsciwyLDAsbC1jKSwkZShBLHIsMywwLGEtdSksaSsrLHIrPTMyfWZ1bmN0aW9uIHJ0KGUsdCxBLHIpe3ZhciBuPWVbdCswXSs0LHM9MzU0NjgqZVt0KzRdPj4xNixpPXR0KGVbdCs0XSksbz0zNTQ2OCplW3QrMV0+PjE2O2V0KEEsciwwLG4raSxlPXR0KGVbdCsxXSksbyksZXQoQSxyLDEsbitzLGUsbyksZXQoQSxyLDIsbi1zLGUsbyksZXQoQSxyLDMsbi1pLGUsbyl9ZnVuY3Rpb24gbnQoZSx0LEEscixuKXtBdChlLHQsQSxyKSxuJiZBdChlLHQrMTYsQSxyKzQpfWZ1bmN0aW9uIHN0KGUsdCxBLHIpe25yKGUsdCswLEEsciwxKSxucihlLHQrMzIsQSxyKzEyOCwxKX1mdW5jdGlvbiBpdChlLHQsQSxyKXt2YXIgbjtmb3IoZT1lW3QrMF0rNCxuPTA7ND5uOysrbilmb3IodD0wOzQ+dDsrK3QpJGUoQSxyLHQsbixlKX1mdW5jdGlvbiBvdChlLHQsQSxyKXtlW3QrMF0mJm9yKGUsdCswLEEsciksZVt0KzE2XSYmb3IoZSx0KzE2LEEscis0KSxlW3QrMzJdJiZvcihlLHQrMzIsQSxyKzEyOCksZVt0KzQ4XSYmb3IoZSx0KzQ4LEEscisxMjgrNCl9ZnVuY3Rpb24gYXQoZSx0LEEscil7dmFyIG4saT1zKDE2KTtmb3Iobj0wOzQ+bjsrK24pe3ZhciBvPWVbdCswK25dK2VbdCsxMituXSxhPWVbdCs0K25dK2VbdCs4K25dLGw9ZVt0KzQrbl0tZVt0Kzgrbl0sYz1lW3QrMCtuXS1lW3QrMTIrbl07aVswK25dPW8rYSxpWzgrbl09by1hLGlbNCtuXT1jK2wsaVsxMituXT1jLWx9Zm9yKG49MDs0Pm47KytuKW89KGU9aVswKzQqbl0rMykraVszKzQqbl0sYT1pWzErNCpuXStpWzIrNCpuXSxsPWlbMSs0Km5dLWlbMis0Km5dLGM9ZS1pWzMrNCpuXSxBW3IrMF09bythPj4zLEFbcisxNl09YytsPj4zLEFbciszMl09by1hPj4zLEFbcis0OF09Yy1sPj4zLHIrPTY0fWZ1bmN0aW9uIGx0KGUsdCxBKXt2YXIgcixuPXQtMzIscz1McixpPTI1NS1lW24tMV07Zm9yKHI9MDtyPEE7KytyKXt2YXIgbyxhPXMsbD1pK2VbdC0xXTtmb3Iobz0wO288QTsrK28pZVt0K29dPWFbbCtlW24rb11dO3QrPTMyfX1mdW5jdGlvbiBjdChlLHQpe2x0KGUsdCw0KX1mdW5jdGlvbiB1dChlLHQpe2x0KGUsdCw4KX1mdW5jdGlvbiBodChlLHQpe2x0KGUsdCwxNil9ZnVuY3Rpb24gZHQoZSx0KXt2YXIgQTtmb3IoQT0wOzE2PkE7KytBKXIoZSx0KzMyKkEsZSx0LTMyLDE2KX1mdW5jdGlvbiBmdChlLHQpe3ZhciBBO2ZvcihBPTE2OzA8QTstLUEpbihlLHQsZVt0LTFdLDE2KSx0Kz0zMn1mdW5jdGlvbiBwdChlLHQsQSl7dmFyIHI7Zm9yKHI9MDsxNj5yOysrciluKHQsQSszMipyLGUsMTYpfWZ1bmN0aW9uIGd0KGUsdCl7dmFyIEEscj0xNjtmb3IoQT0wOzE2PkE7KytBKXIrPWVbdC0xKzMyKkFdK2VbdCtBLTMyXTtwdChyPj41LGUsdCl9ZnVuY3Rpb24gbXQoZSx0KXt2YXIgQSxyPTg7Zm9yKEE9MDsxNj5BOysrQSlyKz1lW3QtMSszMipBXTtwdChyPj40LGUsdCl9ZnVuY3Rpb24gd3QoZSx0KXt2YXIgQSxyPTg7Zm9yKEE9MDsxNj5BOysrQSlyKz1lW3QrQS0zMl07cHQocj4+NCxlLHQpfWZ1bmN0aW9uIEJ0KGUsdCl7cHQoMTI4LGUsdCl9ZnVuY3Rpb24geXQoZSx0LEEpe3JldHVybiBlKzIqdCtBKzI+PjJ9ZnVuY3Rpb24gdnQoZSx0KXt2YXIgQSxuPXQtMzI7Zm9yKG49bmV3IFVpbnQ4QXJyYXkoW3l0KGVbbi0xXSxlW24rMF0sZVtuKzFdKSx5dChlW24rMF0sZVtuKzFdLGVbbisyXSkseXQoZVtuKzFdLGVbbisyXSxlW24rM10pLHl0KGVbbisyXSxlW24rM10sZVtuKzRdKV0pLEE9MDs0PkE7KytBKXIoZSx0KzMyKkEsbiwwLG4ubGVuZ3RoKX1mdW5jdGlvbiBidChlLHQpe3ZhciBBPWVbdC0xXSxyPWVbdC0xKzMyXSxuPWVbdC0xKzY0XSxzPWVbdC0xKzk2XTtVKGUsdCswLDE2ODQzMDA5Knl0KGVbdC0xLTMyXSxBLHIpKSxVKGUsdCszMiwxNjg0MzAwOSp5dChBLHIsbikpLFUoZSx0KzY0LDE2ODQzMDA5Knl0KHIsbixzKSksVShlLHQrOTYsMTY4NDMwMDkqeXQobixzLHMpKX1mdW5jdGlvbiBDdChlLHQpe3ZhciBBLHI9NDtmb3IoQT0wOzQ+QTsrK0Epcis9ZVt0K0EtMzJdK2VbdC0xKzMyKkFdO2ZvcihyPj49MyxBPTA7ND5BOysrQSluKGUsdCszMipBLHIsNCl9ZnVuY3Rpb24gX3QoZSx0KXt2YXIgQT1lW3QtMSswXSxyPWVbdC0xKzMyXSxuPWVbdC0xKzY0XSxzPWVbdC0xLTMyXSxpPWVbdCswLTMyXSxvPWVbdCsxLTMyXSxhPWVbdCsyLTMyXSxsPWVbdCszLTMyXTtlW3QrMCs5Nl09eXQocixuLGVbdC0xKzk2XSksZVt0KzErOTZdPWVbdCswKzY0XT15dChBLHIsbiksZVt0KzIrOTZdPWVbdCsxKzY0XT1lW3QrMCszMl09eXQocyxBLHIpLGVbdCszKzk2XT1lW3QrMis2NF09ZVt0KzErMzJdPWVbdCswKzBdPXl0KGkscyxBKSxlW3QrMys2NF09ZVt0KzIrMzJdPWVbdCsxKzBdPXl0KG8saSxzKSxlW3QrMyszMl09ZVt0KzIrMF09eXQoYSxvLGkpLGVbdCszKzBdPXl0KGwsYSxvKX1mdW5jdGlvbiBqdChlLHQpe3ZhciBBPWVbdCsxLTMyXSxyPWVbdCsyLTMyXSxuPWVbdCszLTMyXSxzPWVbdCs0LTMyXSxpPWVbdCs1LTMyXSxvPWVbdCs2LTMyXSxhPWVbdCs3LTMyXTtlW3QrMCswXT15dChlW3QrMC0zMl0sQSxyKSxlW3QrMSswXT1lW3QrMCszMl09eXQoQSxyLG4pLGVbdCsyKzBdPWVbdCsxKzMyXT1lW3QrMCs2NF09eXQocixuLHMpLGVbdCszKzBdPWVbdCsyKzMyXT1lW3QrMSs2NF09ZVt0KzArOTZdPXl0KG4scyxpKSxlW3QrMyszMl09ZVt0KzIrNjRdPWVbdCsxKzk2XT15dChzLGksbyksZVt0KzMrNjRdPWVbdCsyKzk2XT15dChpLG8sYSksZVt0KzMrOTZdPXl0KG8sYSxhKX1mdW5jdGlvbiB4dChlLHQpe3ZhciBBPWVbdC0xKzBdLHI9ZVt0LTErMzJdLG49ZVt0LTErNjRdLHM9ZVt0LTEtMzJdLGk9ZVt0KzAtMzJdLG89ZVt0KzEtMzJdLGE9ZVt0KzItMzJdLGw9ZVt0KzMtMzJdO2VbdCswKzBdPWVbdCsxKzY0XT1zK2krMT4+MSxlW3QrMSswXT1lW3QrMis2NF09aStvKzE+PjEsZVt0KzIrMF09ZVt0KzMrNjRdPW8rYSsxPj4xLGVbdCszKzBdPWErbCsxPj4xLGVbdCswKzk2XT15dChuLHIsQSksZVt0KzArNjRdPXl0KHIsQSxzKSxlW3QrMCszMl09ZVt0KzErOTZdPXl0KEEscyxpKSxlW3QrMSszMl09ZVt0KzIrOTZdPXl0KHMsaSxvKSxlW3QrMiszMl09ZVt0KzMrOTZdPXl0KGksbyxhKSxlW3QrMyszMl09eXQobyxhLGwpfWZ1bmN0aW9uIEZ0KGUsdCl7dmFyIEE9ZVt0KzAtMzJdLHI9ZVt0KzEtMzJdLG49ZVt0KzItMzJdLHM9ZVt0KzMtMzJdLGk9ZVt0KzQtMzJdLG89ZVt0KzUtMzJdLGE9ZVt0KzYtMzJdLGw9ZVt0KzctMzJdO2VbdCswKzBdPUErcisxPj4xLGVbdCsxKzBdPWVbdCswKzY0XT1yK24rMT4+MSxlW3QrMiswXT1lW3QrMSs2NF09bitzKzE+PjEsZVt0KzMrMF09ZVt0KzIrNjRdPXMraSsxPj4xLGVbdCswKzMyXT15dChBLHIsbiksZVt0KzErMzJdPWVbdCswKzk2XT15dChyLG4scyksZVt0KzIrMzJdPWVbdCsxKzk2XT15dChuLHMsaSksZVt0KzMrMzJdPWVbdCsyKzk2XT15dChzLGksbyksZVt0KzMrNjRdPXl0KGksbyxhKSxlW3QrMys5Nl09eXQobyxhLGwpfWZ1bmN0aW9uIFF0KGUsdCl7dmFyIEE9ZVt0LTErMF0scj1lW3QtMSszMl0sbj1lW3QtMSs2NF0scz1lW3QtMSs5Nl07ZVt0KzArMF09QStyKzE+PjEsZVt0KzIrMF09ZVt0KzArMzJdPXIrbisxPj4xLGVbdCsyKzMyXT1lW3QrMCs2NF09bitzKzE+PjEsZVt0KzErMF09eXQoQSxyLG4pLGVbdCszKzBdPWVbdCsxKzMyXT15dChyLG4scyksZVt0KzMrMzJdPWVbdCsxKzY0XT15dChuLHMscyksZVt0KzMrNjRdPWVbdCsyKzY0XT1lW3QrMCs5Nl09ZVt0KzErOTZdPWVbdCsyKzk2XT1lW3QrMys5Nl09c31mdW5jdGlvbiBVdChlLHQpe3ZhciBBPWVbdC0xKzBdLHI9ZVt0LTErMzJdLG49ZVt0LTErNjRdLHM9ZVt0LTErOTZdLGk9ZVt0LTEtMzJdLG89ZVt0KzAtMzJdLGE9ZVt0KzEtMzJdLGw9ZVt0KzItMzJdO2VbdCswKzBdPWVbdCsyKzMyXT1BK2krMT4+MSxlW3QrMCszMl09ZVt0KzIrNjRdPXIrQSsxPj4xLGVbdCswKzY0XT1lW3QrMis5Nl09bityKzE+PjEsZVt0KzArOTZdPXMrbisxPj4xLGVbdCszKzBdPXl0KG8sYSxsKSxlW3QrMiswXT15dChpLG8sYSksZVt0KzErMF09ZVt0KzMrMzJdPXl0KEEsaSxvKSxlW3QrMSszMl09ZVt0KzMrNjRdPXl0KHIsQSxpKSxlW3QrMSs2NF09ZVt0KzMrOTZdPXl0KG4scixBKSxlW3QrMSs5Nl09eXQocyxuLHIpfWZ1bmN0aW9uIEV0KGUsdCl7dmFyIEE7Zm9yKEE9MDs4PkE7KytBKXIoZSx0KzMyKkEsZSx0LTMyLDgpfWZ1bmN0aW9uIFN0KGUsdCl7dmFyIEE7Zm9yKEE9MDs4PkE7KytBKW4oZSx0LGVbdC0xXSw4KSx0Kz0zMn1mdW5jdGlvbiBMdChlLHQsQSl7dmFyIHI7Zm9yKHI9MDs4PnI7KytyKW4odCxBKzMyKnIsZSw4KX1mdW5jdGlvbiBJdChlLHQpe3ZhciBBLHI9ODtmb3IoQT0wOzg+QTsrK0Epcis9ZVt0K0EtMzJdK2VbdC0xKzMyKkFdO0x0KHI+PjQsZSx0KX1mdW5jdGlvbiBOdChlLHQpe3ZhciBBLHI9NDtmb3IoQT0wOzg+QTsrK0Epcis9ZVt0K0EtMzJdO0x0KHI+PjMsZSx0KX1mdW5jdGlvbiBrdChlLHQpe3ZhciBBLHI9NDtmb3IoQT0wOzg+QTsrK0Epcis9ZVt0LTErMzIqQV07THQocj4+MyxlLHQpfWZ1bmN0aW9uIEh0KGUsdCl7THQoMTI4LGUsdCl9ZnVuY3Rpb24gUHQoZSx0LEEpe3ZhciByPWVbdC1BXSxuPWVbdCswXSxzPTMqKG4tcikrRXJbMTAyMCtlW3QtMipBXS1lW3QrQV1dLGk9U3JbMTEyKyhzKzQ+PjMpXTtlW3QtQV09THJbMjU1K3IrU3JbMTEyKyhzKzM+PjMpXV0sZVt0KzBdPUxyWzI1NStuLWldfWZ1bmN0aW9uIFR0KGUsdCxBLHIpe3ZhciBuPWVbdCswXSxzPWVbdCtBXTtyZXR1cm4gSXJbMjU1K2VbdC0yKkFdLWVbdC1BXV0+cnx8SXJbMjU1K3Mtbl0+cn1mdW5jdGlvbiBPdChlLHQsQSxyKXtyZXR1cm4gNCpJclsyNTUrZVt0LUFdLWVbdCswXV0rSXJbMjU1K2VbdC0yKkFdLWVbdCtBXV08PXJ9ZnVuY3Rpb24gTXQoZSx0LEEscixuKXt2YXIgcz1lW3QtMypBXSxpPWVbdC0yKkFdLG89ZVt0LUFdLGE9ZVt0KzBdLGw9ZVt0K0FdLGM9ZVt0KzIqQV0sdT1lW3QrMypBXTtyZXR1cm4gNCpJclsyNTUrby1hXStJclsyNTUraS1sXT5yPzA6SXJbMjU1K2VbdC00KkFdLXNdPD1uJiZJclsyNTUrcy1pXTw9biYmSXJbMjU1K2ktb108PW4mJklyWzI1NSt1LWNdPD1uJiZJclsyNTUrYy1sXTw9biYmSXJbMjU1K2wtYV08PW59ZnVuY3Rpb24gRHQoZSx0LEEscil7dmFyIG49MipyKzE7Zm9yKHI9MDsxNj5yOysrcilPdChlLHQrcixBLG4pJiZQdChlLHQrcixBKX1mdW5jdGlvbiBSdChlLHQsQSxyKXt2YXIgbj0yKnIrMTtmb3Iocj0wOzE2PnI7KytyKU90KGUsdCtyKkEsMSxuKSYmUHQoZSx0K3IqQSwxKX1mdW5jdGlvbiBLdChlLHQsQSxyKXt2YXIgbjtmb3Iobj0zOzA8bjstLW4pRHQoZSx0Kz00KkEsQSxyKX1mdW5jdGlvbiBWdChlLHQsQSxyKXt2YXIgbjtmb3Iobj0zOzA8bjstLW4pUnQoZSx0Kz00LEEscil9ZnVuY3Rpb24gR3QoZSx0LEEscixuLHMsaSxvKXtmb3Iocz0yKnMrMTswPG4tLTspe2lmKE10KGUsdCxBLHMsaSkpaWYoVHQoZSx0LEEsbykpUHQoZSx0LEEpO2Vsc2V7dmFyIGE9ZSxsPXQsYz1BLHU9YVtsLTIqY10saD1hW2wtY10sZD1hW2wrMF0sZj1hW2wrY10scD1hW2wrMipjXSxnPTI3Kih3PUVyWzEwMjArMyooZC1oKStFclsxMDIwK3UtZl1dKSs2Mz4+NyxtPTE4KncrNjM+Pjcsdz05KncrNjM+Pjc7YVtsLTMqY109THJbMjU1K2FbbC0zKmNdK3ddLGFbbC0yKmNdPUxyWzI1NSt1K21dLGFbbC1jXT1MclsyNTUraCtnXSxhW2wrMF09THJbMjU1K2QtZ10sYVtsK2NdPUxyWzI1NStmLW1dLGFbbCsyKmNdPUxyWzI1NStwLXddfXQrPXJ9fWZ1bmN0aW9uIHp0KGUsdCxBLHIsbixzLGksbyl7Zm9yKHM9MipzKzE7MDxuLS07KXtpZihNdChlLHQsQSxzLGkpKWlmKFR0KGUsdCxBLG8pKVB0KGUsdCxBKTtlbHNle3ZhciBhPWUsbD10LGM9QSx1PWFbbC1jXSxoPWFbbCswXSxkPWFbbCtjXSxmPVNyWzExMisoNCsocD0zKihoLXUpKT4+MyldLHA9U3JbMTEyKyhwKzM+PjMpXSxnPWYrMT4+MTthW2wtMipjXT1MclsyNTUrYVtsLTIqY10rZ10sYVtsLWNdPUxyWzI1NSt1K3BdLGFbbCswXT1MclsyNTUraC1mXSxhW2wrY109THJbMjU1K2QtZ119dCs9cn19ZnVuY3Rpb24gcXQoZSx0LEEscixuLHMpe0d0KGUsdCxBLDEsMTYscixuLHMpfWZ1bmN0aW9uIFd0KGUsdCxBLHIsbixzKXtHdChlLHQsMSxBLDE2LHIsbixzKX1mdW5jdGlvbiBYdChlLHQsQSxyLG4scyl7dmFyIGk7Zm9yKGk9MzswPGk7LS1pKXp0KGUsdCs9NCpBLEEsMSwxNixyLG4scyl9ZnVuY3Rpb24gWXQoZSx0LEEscixuLHMpe3ZhciBpO2ZvcihpPTM7MDxpOy0taSl6dChlLHQrPTQsMSxBLDE2LHIsbixzKX1mdW5jdGlvbiBKdChlLHQsQSxyLG4scyxpLG8pe0d0KGUsdCxuLDEsOCxzLGksbyksR3QoQSxyLG4sMSw4LHMsaSxvKX1mdW5jdGlvbiBadChlLHQsQSxyLG4scyxpLG8pe0d0KGUsdCwxLG4sOCxzLGksbyksR3QoQSxyLDEsbiw4LHMsaSxvKX1mdW5jdGlvbiAkdChlLHQsQSxyLG4scyxpLG8pe3p0KGUsdCs0Km4sbiwxLDgscyxpLG8pLHp0KEEscis0Km4sbiwxLDgscyxpLG8pfWZ1bmN0aW9uIGVBKGUsdCxBLHIsbixzLGksbyl7enQoZSx0KzQsMSxuLDgscyxpLG8pLHp0KEEscis0LDEsbiw4LHMsaSxvKX1mdW5jdGlvbiB0QSgpe3RoaXMuYmE9bmV3IGllLHRoaXMuZWM9W10sdGhpcy5jYz1bXSx0aGlzLk1jPVtdLHRoaXMuRGM9dGhpcy5OYz10aGlzLmRjPXRoaXMuZmM9MCx0aGlzLk9hPW5ldyBhZSx0aGlzLm1lbW9yeT0wLHRoaXMuSWI9Ik91dHB1dEZ1bmMiLHRoaXMuSmI9Ik91dHB1dEFscGhhRnVuYyIsdGhpcy5OZD0iT3V0cHV0Um93RnVuYyJ9ZnVuY3Rpb24gQUEoKXt0aGlzLmRhdGE9W10sdGhpcy5vZmZzZXQ9dGhpcy5rZD10aGlzLmhhPXRoaXMudz0wLHRoaXMubmE9W10sdGhpcy54YT10aGlzLmdiPXRoaXMuSmE9dGhpcy5TYT10aGlzLlA9MH1mdW5jdGlvbiByQSgpe3RoaXMubmM9dGhpcy5FYT10aGlzLmI9dGhpcy5oYz0wLHRoaXMuSz1bXSx0aGlzLnc9MH1mdW5jdGlvbiBuQSgpe3RoaXMudWE9MCx0aGlzLldhPW5ldyBrLHRoaXMudmI9bmV3IGssdGhpcy5tZD10aGlzLnhjPXRoaXMud2M9MCx0aGlzLnZjPVtdLHRoaXMuV2I9MCx0aGlzLllhPW5ldyBkLHRoaXMueWM9bmV3IHV9ZnVuY3Rpb24gc0EoKXt0aGlzLnhiPXRoaXMuYT0wLHRoaXMubD1uZXcgemUsdGhpcy5jYT1uZXcgaWUsdGhpcy5WPVtdLHRoaXMuQmE9MCx0aGlzLlRhPVtdLHRoaXMuVWE9MCx0aGlzLm09bmV3IHYsdGhpcy5QYj0wLHRoaXMud2Q9bmV3IHYsdGhpcy5NYT10aGlzLiQ9dGhpcy5DPXRoaXMuaT10aGlzLmM9dGhpcy54ZD0wLHRoaXMucz1uZXcgbkEsdGhpcy5hYj0wLHRoaXMuZ2M9aSg0LHJBKSx0aGlzLk9jPTB9ZnVuY3Rpb24gaUEoKXt0aGlzLkxjPXRoaXMuWj10aGlzLiRhPXRoaXMuaT10aGlzLmM9MCx0aGlzLmw9bmV3IHplLHRoaXMuaWM9MCx0aGlzLmNhPVtdLHRoaXMudGI9MCx0aGlzLnFkPW51bGwsdGhpcy5yZD0wfWZ1bmN0aW9uIG9BKGUsdCxBLHIsbixzLGkpe2ZvcihlPW51bGw9PWU/MDplW3QrMF0sdD0wO3Q8aTsrK3QpbltzK3RdPWUrQVtyK3RdJjI1NSxlPW5bcyt0XX1mdW5jdGlvbiBhQShlLHQsQSxyLG4scyxpKXt2YXIgbztpZihudWxsPT1lKW9BKG51bGwsbnVsbCxBLHIsbixzLGkpO2Vsc2UgZm9yKG89MDtvPGk7KytvKW5bcytvXT1lW3Qrb10rQVtyK29dJjI1NX1mdW5jdGlvbiBsQShlLHQsQSxyLG4scyxpKXtpZihudWxsPT1lKW9BKG51bGwsbnVsbCxBLHIsbixzLGkpO2Vsc2V7dmFyIG8sYT1lW3QrMF0sbD1hLGM9YTtmb3Iobz0wO288aTsrK28pbD1jKyhhPWVbdCtvXSktbCxjPUFbcitvXSsoLTI1NiZsPzA+bD8wOjI1NTpsKSYyNTUsbD1hLG5bcytvXT1jfX1mdW5jdGlvbiBjQShlLEEsbixpKXt2YXIgbz1BLndpZHRoLGE9QS5vO2lmKHQobnVsbCE9ZSYmbnVsbCE9QSksMD5ufHwwPj1pfHxuK2k+YSlyZXR1cm4gbnVsbDtpZighZS5DYyl7aWYobnVsbD09ZS5nYSl7dmFyIGw7aWYoZS5nYT1uZXcgaUEsKGw9bnVsbD09ZS5nYSl8fChsPUEud2lkdGgqQS5vLHQoMD09ZS5HYi5sZW5ndGgpLGUuR2I9cyhsKSxlLlVjPTAsbnVsbD09ZS5HYj9sPTA6KGUubWI9ZS5HYixlLm5iPWUuVWMsZS5yYz1udWxsLGw9MSksbD0hbCksIWwpe2w9ZS5nYTt2YXIgYz1lLkZhLHU9ZS5QLGg9ZS5xYyxkPWUubWIsZj1lLm5iLHA9dSsxLGc9aC0xLHc9bC5sO2lmKHQobnVsbCE9YyYmbnVsbCE9ZCYmbnVsbCE9QSkscG5bMF09bnVsbCxwblsxXT1vQSxwblsyXT1hQSxwblszXT1sQSxsLmNhPWQsbC50Yj1mLGwuYz1BLndpZHRoLGwuaT1BLmhlaWdodCx0KDA8bC5jJiYwPGwuaSksMT49aClBPTA7ZWxzZSBpZihsLiRhPTMmY1t1KzBdLGwuWj1jW3UrMF0+PjImMyxsLkxjPWNbdSswXT4+NCYzLHU9Y1t1KzBdPj42JjMsMD5sLiRhfHwxPGwuJGF8fDQ8PWwuWnx8MTxsLkxjfHx1KUE9MDtlbHNlIGlmKHcucHV0PWRlLHcuYWM9aGUsdy5iYz1mZSx3Lm1hPWwsdy53aWR0aD1BLndpZHRoLHcuaGVpZ2h0PUEuaGVpZ2h0LHcuRGE9QS5EYSx3LnY9QS52LHcudmE9QS52YSx3Lmo9QS5qLHcubz1BLm8sbC4kYSllOnt0KDE9PWwuJGEpLEE9UWUoKTt0OmZvcig7Oyl7aWYobnVsbD09QSl7QT0wO2JyZWFrIGV9aWYodChudWxsIT1sKSxsLm1jPUEsQS5jPWwuYyxBLmk9bC5pLEEubD1sLmwsQS5sLm1hPWwsQS5sLndpZHRoPWwuYyxBLmwuaGVpZ2h0PWwuaSxBLmE9MCxtKEEubSxjLHAsZyksIVVlKGwuYyxsLmksMSxBLG51bGwpKWJyZWFrIHQ7aWYoMT09QS5hYiYmMz09QS5nY1swXS5oYyYmQ2UoQS5zKT8obC5pYz0xLGM9QS5jKkEuaSxBLlRhPW51bGwsQS5VYT0wLEEuVj1zKGMpLEEuQmE9MCxudWxsPT1BLlY/KEEuYT0xLEE9MCk6QT0xKToobC5pYz0wLEE9RWUoQSxsLmMpKSwhQSlicmVhayB0O0E9MTticmVhayBlfWwubWM9bnVsbCxBPTB9ZWxzZSBBPWc+PWwuYypsLmk7bD0hQX1pZihsKXJldHVybiBudWxsOzEhPWUuZ2EuTGM/ZS5HYT0wOmk9YS1ufXQobnVsbCE9ZS5nYSksdChuK2k8PWEpO2U6e2lmKEE9KGM9ZS5nYSkuYyxhPWMubC5vLDA9PWMuJGEpe2lmKHA9ZS5yYyxnPWUuVmMsdz1lLkZhLHU9ZS5QKzErbipBLGg9ZS5tYixkPWUubmIrbipBLHQodTw9ZS5QK2UucWMpLDAhPWMuWilmb3IodChudWxsIT1wbltjLlpdKSxsPTA7bDxpOysrbClwbltjLlpdKHAsZyx3LHUsaCxkLEEpLHA9aCxnPWQsZCs9QSx1Kz1BO2Vsc2UgZm9yKGw9MDtsPGk7KytsKXIoaCxkLHcsdSxBKSxwPWgsZz1kLGQrPUEsdSs9QTtlLnJjPXAsZS5WYz1nfWVsc2V7aWYodChudWxsIT1jLm1jKSxBPW4raSx0KG51bGwhPShsPWMubWMpKSx0KEE8PWwuaSksbC5DPj1BKUE9MTtlbHNlIGlmKGMuaWN8fHBBKCksYy5pYyl7Yz1sLlYscD1sLkJhLGc9bC5jO3ZhciBCPWwuaSx5PSh3PTEsdT1sLiQvZyxoPWwuJCVnLGQ9bC5tLGY9bC5zLGwuJCksdj1nKkIsYj1nKkEsXz1mLndjLHg9eTxiP3llKGYsaCx1KTpudWxsO3QoeTw9diksdChBPD1CKSx0KENlKGYpKTt0OmZvcig7Oyl7Zm9yKDshZC5oJiZ5PGI7KXtpZihoJl98fCh4PXllKGYsaCx1KSksdChudWxsIT14KSxqKGQpLDI1Nj4oQj13ZSh4LkdbMF0seC5IWzBdLGQpKSljW3AreV09QiwrK3ksKytoPj1nJiYoaD0wLCsrdTw9QSYmISh1JTE2KSYmamUobCx1KSk7ZWxzZXtpZighKDI4MD5CKSl7dz0wO2JyZWFrIHR9Qj1nZShCLTI1NixkKTt2YXIgRixRPXdlKHguR1s0XSx4LkhbNF0sZCk7aWYoaihkKSwhKHk+PShRPW1lKGcsUT1nZShRLGQpKSkmJnYteT49Qikpe3c9MDticmVhayB0fWZvcihGPTA7RjxCOysrRiljW3AreStGXT1jW3AreStGLVFdO2Zvcih5Kz1CLGgrPUI7aD49ZzspaC09ZywrK3U8PUEmJiEodSUxNikmJmplKGwsdSk7eTxiJiZoJl8mJih4PXllKGYsaCx1KSl9dChkLmg9PUMoZCkpfWplKGwsdT5BP0E6dSk7YnJlYWsgdH0hd3x8ZC5oJiZ5PHY/KHc9MCxsLmE9ZC5oPzU6Myk6bC4kPXksQT13fWVsc2UgQT14ZShsLGwuVixsLkJhLGwuYyxsLmksQSxTZSk7aWYoIUEpe2k9MDticmVhayBlfX1uK2k+PWEmJihlLkNjPTEpLGk9MX1pZighaSlyZXR1cm4gbnVsbDtpZihlLkNjJiYobnVsbCE9KGk9ZS5nYSkmJihpLm1jPW51bGwpLGUuZ2E9bnVsbCwwPGUuR2EpKXJldHVybiBhbGVydCgidG9kbzpXZWJQRGVxdWFudGl6ZUxldmVscyIpLG51bGx9cmV0dXJuIGUubmIrbipvfWZ1bmN0aW9uIHVBKGUsdCxBLHIsbixzKXtmb3IoOzA8bi0tOyl7dmFyIGksbz1lLGE9dCsoQT8xOjApLGw9ZSxjPXQrKEE/MDozKTtmb3IoaT0wO2k8cjsrK2kpe3ZhciB1PWxbYys0KmldOzI1NSE9dSYmKHUqPTMyODk3LG9bYSs0KmkrMF09b1thKzQqaSswXSp1Pj4yMyxvW2ErNCppKzFdPW9bYSs0KmkrMV0qdT4+MjMsb1thKzQqaSsyXT1vW2ErNCppKzJdKnU+PjIzKX10Kz1zfX1mdW5jdGlvbiBoQShlLHQsQSxyLG4pe2Zvcig7MDxyLS07KXt2YXIgcztmb3Iocz0wO3M8QTsrK3Mpe3ZhciBpPWVbdCsyKnMrMF0sbz0xNSYobD1lW3QrMipzKzFdKSxhPTQzNjkqbyxsPSgyNDAmbHxsPj40KSphPj4xNjtlW3QrMipzKzBdPSgyNDAmaXxpPj40KSphPj4xNiYyNDB8KDE1Jml8aTw8NCkqYT4+MTY+PjQmMTUsZVt0KzIqcysxXT0yNDAmbHxvfXQrPW59fWZ1bmN0aW9uIGRBKGUsdCxBLHIsbixzLGksbyl7dmFyIGEsbCxjPTI1NTtmb3IobD0wO2w8bjsrK2wpe2ZvcihhPTA7YTxyOysrYSl7dmFyIHU9ZVt0K2FdO3NbaSs0KmFdPXUsYyY9dX10Kz1BLGkrPW99cmV0dXJuIDI1NSE9Y31mdW5jdGlvbiBmQShlLHQsQSxyLG4pe3ZhciBzO2ZvcihzPTA7czxuOysrcylBW3Irc109ZVt0K3NdPj44fWZ1bmN0aW9uIHBBKCl7dnI9dUEsYnI9aEEsQ3I9ZEEsX3I9ZkF9ZnVuY3Rpb24gZ0EoQSxyLG4pe2VbQV09ZnVuY3Rpb24oZSxBLHMsaSxvLGEsbCxjLHUsaCxkLGYscCxnLG0sdyxCKXt2YXIgeSx2PUItMT4+MSxiPW9bYSswXXxsW2MrMF08PDE2LEM9dVtoKzBdfGRbZiswXTw8MTY7dChudWxsIT1lKTt2YXIgXz0zKmIrQysxMzEwNzQ+PjI7Zm9yKHIoZVtBKzBdLDI1NSZfLF8+PjE2LHAsZyksbnVsbCE9cyYmKF89MypDK2IrMTMxMDc0Pj4yLHIoc1tpKzBdLDI1NSZfLF8+PjE2LG0sdykpLHk9MTt5PD12OysreSl7dmFyIGo9b1thK3ldfGxbYyt5XTw8MTYseD11W2greV18ZFtmK3ldPDwxNixGPWIraitDK3grNTI0Mjk2LFE9RisyKihqK0MpPj4zO189UStiPj4xLGI9KEY9RisyKihiK3gpPj4zKStqPj4xLHIoZVtBKzIqeS0xXSwyNTUmXyxfPj4xNixwLGcrKDIqeS0xKSpuKSxyKGVbQSsyKnktMF0sMjU1JmIsYj4+MTYscCxnKygyKnktMCkqbiksbnVsbCE9cyYmKF89RitDPj4xLGI9USt4Pj4xLHIoc1tpKzIqeS0xXSwyNTUmXyxfPj4xNixtLHcrKDIqeS0xKSpuKSxyKHNbaSsyKnkrMF0sMjU1JmIsYj4+MTYsbSx3KygyKnkrMCkqbikpLGI9aixDPXh9MSZCfHwoXz0zKmIrQysxMzEwNzQ+PjIscihlW0ErQi0xXSwyNTUmXyxfPj4xNixwLGcrKEItMSkqbiksbnVsbCE9cyYmKF89MypDK2IrMTMxMDc0Pj4yLHIoc1tpK0ItMV0sMjU1Jl8sXz4+MTYsbSx3KyhCLTEpKm4pKSl9fWZ1bmN0aW9uIG1BKCl7Z25bTnJdPW1uLGduW2tyXT1CbixnbltIcl09d24sZ25bUHJdPXluLGduW1RyXT12bixnbltPcl09Ym4sZ25bTXJdPUNuLGduW0RyXT1CbixnbltScl09eW4sZ25bS3JdPXZuLGduW1ZyXT1ibn1mdW5jdGlvbiB3QShlKXtyZXR1cm4gZSZ+VW4/MD5lPzA6MjU1OmU+PlFufWZ1bmN0aW9uIEJBKGUsdCl7cmV0dXJuIHdBKCgxOTA3NyplPj44KSsoMjYxNDkqdD4+OCktMTQyMzQpfWZ1bmN0aW9uIHlBKGUsdCxBKXtyZXR1cm4gd0EoKDE5MDc3KmU+PjgpLSg2NDE5KnQ+PjgpLSgxMzMyMCpBPj44KSs4NzA4KX1mdW5jdGlvbiB2QShlLHQpe3JldHVybiB3QSgoMTkwNzcqZT4+OCkrKDMzMDUwKnQ+PjgpLTE3Njg1KX1mdW5jdGlvbiBiQShlLHQsQSxyLG4pe3JbbiswXT1CQShlLEEpLHJbbisxXT15QShlLHQsQSkscltuKzJdPXZBKGUsdCl9ZnVuY3Rpb24gQ0EoZSx0LEEscixuKXtyW24rMF09dkEoZSx0KSxyW24rMV09eUEoZSx0LEEpLHJbbisyXT1CQShlLEEpfWZ1bmN0aW9uIF9BKGUsdCxBLHIsbil7dmFyIHM9eUEoZSx0LEEpO3Q9czw8MyYyMjR8dkEoZSx0KT4+MyxyW24rMF09MjQ4JkJBKGUsQSl8cz4+NSxyW24rMV09dH1mdW5jdGlvbiBqQShlLHQsQSxyLG4pe3ZhciBzPTI0MCZ2QShlLHQpfDE1O3JbbiswXT0yNDAmQkEoZSxBKXx5QShlLHQsQSk+PjQscltuKzFdPXN9ZnVuY3Rpb24geEEoZSx0LEEscixuKXtyW24rMF09MjU1LGJBKGUsdCxBLHIsbisxKX1mdW5jdGlvbiBGQShlLHQsQSxyLG4pe0NBKGUsdCxBLHIsbikscltuKzNdPTI1NX1mdW5jdGlvbiBRQShlLHQsQSxyLG4pe2JBKGUsdCxBLHIsbikscltuKzNdPTI1NX1mdW5jdGlvbiBHZShlLHQpe3JldHVybiAwPmU/MDplPnQ/dDplfWZ1bmN0aW9uIFVBKHQsQSxyKXtlW3RdPWZ1bmN0aW9uKGUsdCxuLHMsaSxvLGEsbCxjKXtmb3IodmFyIHU9bCsoLTImYykqcjtsIT11OylBKGVbdCswXSxuW3MrMF0saVtvKzBdLGEsbCksQShlW3QrMV0sbltzKzBdLGlbbyswXSxhLGwrciksdCs9MiwrK3MsKytvLGwrPTIqcjsxJmMmJkEoZVt0KzBdLG5bcyswXSxpW28rMF0sYSxsKX19ZnVuY3Rpb24gRUEoZSx0LEEpe3JldHVybiAwPT1BPzA9PWU/MD09dD82OjU6MD09dD80OjA6QX1mdW5jdGlvbiBTQShlLHQsQSxyLG4pe3N3aXRjaChlPj4+MzApe2Nhc2UgMzpucih0LEEscixuLDApO2JyZWFrO2Nhc2UgMjpzcih0LEEscixuKTticmVhaztjYXNlIDE6b3IodCxBLHIsbil9fWZ1bmN0aW9uIExBKGUsdCl7dmFyIEEscyxpPXQuTSxvPXQuTmIsYT1lLm9jLGw9ZS5wYys0MCxjPWUub2MsdT1lLnBjKzU4NCxoPWUub2MsZD1lLnBjKzYwMDtmb3IoQT0wOzE2PkE7KytBKWFbbCszMipBLTFdPTEyOTtmb3IoQT0wOzg+QTsrK0EpY1t1KzMyKkEtMV09MTI5LGhbZCszMipBLTFdPTEyOTtmb3IoMDxpP2FbbC0xLTMyXT1jW3UtMS0zMl09aFtkLTEtMzJdPTEyOToobihhLGwtMzItMSwxMjcsMjEpLG4oYyx1LTMyLTEsMTI3LDkpLG4oaCxkLTMyLTEsMTI3LDkpKSxzPTA7czxlLnphOysrcyl7dmFyIGY9dC55YVt0LmFhK3NdO2lmKDA8cyl7Zm9yKEE9LTE7MTY+QTsrK0EpcihhLGwrMzIqQS00LGEsbCszMipBKzEyLDQpO2ZvcihBPS0xOzg+QTsrK0EpcihjLHUrMzIqQS00LGMsdSszMipBKzQsNCkscihoLGQrMzIqQS00LGgsZCszMipBKzQsNCl9dmFyIHA9ZS5HZCxnPWUuSGQrcyxtPWYuYWQsdz1mLkhjO2lmKDA8aSYmKHIoYSxsLTMyLHBbZ10ueSwwLDE2KSxyKGMsdS0zMixwW2ddLmYsMCw4KSxyKGgsZC0zMixwW2ddLmVhLDAsOCkpLGYuWmEpe3ZhciBCPWEseT1sLTMyKzE2O2ZvcigwPGkmJihzPj1lLnphLTE/bihCLHkscFtnXS55WzE1XSw0KTpyKEIseSxwW2crMV0ueSwwLDQpKSxBPTA7ND5BO0ErKylCW3krMTI4K0FdPUJbeSsyNTYrQV09Qlt5KzM4NCtBXT1CW3krMCtBXTtmb3IoQT0wOzE2PkE7KytBLHc8PD0yKUI9YSx5PWwrUG5bQV0sdW5bZi5PYltBXV0oQix5KSxTQSh3LG0sMTYqK0EsQix5KX1lbHNlIGlmKEI9RUEocyxpLGYuT2JbMF0pLGNuW0JdKGEsbCksMCE9dylmb3IoQT0wOzE2PkE7KytBLHc8PD0yKVNBKHcsbSwxNiorQSxhLGwrUG5bQV0pO2ZvcihBPWYuR2MsQj1FQShzLGksZi5EZCksaG5bQl0oYyx1KSxobltCXShoLGQpLHc9bSxCPWMseT11LDI1NSYoZj0wfEEpJiYoMTcwJmY/aXIodywyNTYsQix5KTphcih3LDI1NixCLHkpKSxmPWgsdz1kLDI1NSYoQT4+PTgpJiYoMTcwJkE/aXIobSwzMjAsZix3KTphcihtLDMyMCxmLHcpKSxpPGUuVWItMSYmKHIocFtnXS55LDAsYSxsKzQ4MCwxNikscihwW2ddLmYsMCxjLHUrMjI0LDgpLHIocFtnXS5lYSwwLGgsZCsyMjQsOCkpLEE9OCpvKmUuQixwPWUuc2EsZz1lLnRhKzE2KnMrMTYqbyplLlIsbT1lLnFhLGY9ZS5yYSs4KnMrQSx3PWUuSGEsQj1lLklhKzgqcytBLEE9MDsxNj5BOysrQSlyKHAsZytBKmUuUixhLGwrMzIqQSwxNik7Zm9yKEE9MDs4PkE7KytBKXIobSxmK0EqZS5CLGMsdSszMipBLDgpLHIodyxCK0EqZS5CLGgsZCszMipBLDgpfX1mdW5jdGlvbiBJQShlLHIsbixzLGksbyxhLGwsYyl7dmFyIHU9WzBdLGg9WzBdLGQ9MCxmPW51bGwhPWM/Yy5rZDowLHA9bnVsbCE9Yz9jOm5ldyBBQTtpZihudWxsPT1lfHwxMj5uKXJldHVybiA3O3AuZGF0YT1lLHAudz1yLHAuaGE9bixyPVtyXSxuPVtuXSxwLmdiPVtwLmdiXTtlOnt2YXIgZz1yLHc9bixCPXAuZ2I7aWYodChudWxsIT1lKSx0KG51bGwhPXcpLHQobnVsbCE9QiksQlswXT0wLDEyPD13WzBdJiYhQShlLGdbMF0sIlJJRkYiKSl7aWYoQShlLGdbMF0rOCwiV0VCUCIpKXtCPTM7YnJlYWsgZX12YXIgeT1MKGUsZ1swXSs0KTtpZigxMj55fHw0Mjk0OTY3Mjg2PHkpe0I9MzticmVhayBlfWlmKGYmJnk+d1swXS04KXtCPTc7YnJlYWsgZX1CWzBdPXksZ1swXSs9MTIsd1swXS09MTJ9Qj0wfWlmKDAhPUIpcmV0dXJuIEI7Zm9yKHk9MDxwLmdiWzBdLG49blswXTs7KXtlOnt2YXIgYj1lO3c9cixCPW47dmFyIEM9dSxfPWgsaj1nPVswXTtpZigoUT1kPVtkXSlbMF09MCw4PkJbMF0pQj03O2Vsc2V7aWYoIUEoYix3WzBdLCJWUDhYIikpe2lmKDEwIT1MKGIsd1swXSs0KSl7Qj0zO2JyZWFrIGV9aWYoMTg+QlswXSl7Qj03O2JyZWFrIGV9dmFyIHg9TChiLHdbMF0rOCksRj0xK1MoYix3WzBdKzEyKTtpZigyMTQ3NDgzNjQ4PD1GKihiPTErUyhiLHdbMF0rMTUpKSl7Qj0zO2JyZWFrIGV9bnVsbCE9aiYmKGpbMF09eCksbnVsbCE9QyYmKENbMF09RiksbnVsbCE9XyYmKF9bMF09Yiksd1swXSs9MTgsQlswXS09MTgsUVswXT0xfUI9MH19aWYoZD1kWzBdLGc9Z1swXSwwIT1CKXJldHVybiBCO2lmKHc9ISEoMiZnKSwheSYmZClyZXR1cm4gMztpZihudWxsIT1vJiYob1swXT0hISgxNiZnKSksbnVsbCE9YSYmKGFbMF09dyksbnVsbCE9bCYmKGxbMF09MCksYT11WzBdLGc9aFswXSxkJiZ3JiZudWxsPT1jKXtCPTA7YnJlYWt9aWYoND5uKXtCPTc7YnJlYWt9aWYoeSYmZHx8IXkmJiFkJiYhQShlLHJbMF0sIkFMUEgiKSl7bj1bbl0scC5uYT1bcC5uYV0scC5QPVtwLlBdLHAuU2E9W3AuU2FdO2U6e3g9ZSxCPXIseT1uO3ZhciBRPXAuZ2I7Qz1wLm5hLF89cC5QLGo9cC5TYSxGPTIyLHQobnVsbCE9eCksdChudWxsIT15KSxiPUJbMF07dmFyIFU9eVswXTtmb3IodChudWxsIT1DKSx0KG51bGwhPWopLENbMF09bnVsbCxfWzBdPW51bGwsalswXT0wOzspe2lmKEJbMF09Yix5WzBdPVUsOD5VKXtCPTc7YnJlYWsgZX12YXIgRT1MKHgsYis0KTtpZig0Mjk0OTY3Mjg2PEUpe0I9MzticmVhayBlfXZhciBJPTgrRSsxJi0yO2lmKEYrPUksMDxRJiZGPlEpe0I9MzticmVhayBlfWlmKCFBKHgsYiwiVlA4ICIpfHwhQSh4LGIsIlZQOEwiKSl7Qj0wO2JyZWFrIGV9aWYoVVswXTxJKXtCPTc7YnJlYWsgZX1BKHgsYiwiQUxQSCIpfHwoQ1swXT14LF9bMF09Yis4LGpbMF09RSksYis9SSxVLT1JfX1pZihuPW5bMF0scC5uYT1wLm5hWzBdLHAuUD1wLlBbMF0scC5TYT1wLlNhWzBdLDAhPUIpYnJlYWt9bj1bbl0scC5KYT1bcC5KYV0scC54YT1bcC54YV07ZTppZihRPWUsQj1yLHk9bixDPXAuZ2JbMF0sXz1wLkphLGo9cC54YSx4PUJbMF0sYj0hQShRLHgsIlZQOCAiKSxGPSFBKFEseCwiVlA4TCIpLHQobnVsbCE9USksdChudWxsIT15KSx0KG51bGwhPV8pLHQobnVsbCE9aiksOD55WzBdKUI9NztlbHNle2lmKGJ8fEYpe2lmKFE9TChRLHgrNCksMTI8PUMmJlE+Qy0xMil7Qj0zO2JyZWFrIGV9aWYoZiYmUT55WzBdLTgpe0I9NzticmVhayBlfV9bMF09USxCWzBdKz04LHlbMF0tPTgsalswXT1GfWVsc2UgalswXT01PD15WzBdJiY0Nz09UVt4KzBdJiYhKFFbeCs0XT4+NSksX1swXT15WzBdO0I9MH1pZihuPW5bMF0scC5KYT1wLkphWzBdLHAueGE9cC54YVswXSxyPXJbMF0sMCE9QilicmVhaztpZig0Mjk0OTY3Mjg2PHAuSmEpcmV0dXJuIDM7aWYobnVsbD09bHx8d3x8KGxbMF09cC54YT8yOjEpLGE9W2FdLGc9W2ddLHAueGEpe2lmKDU+bil7Qj03O2JyZWFrfWw9YSxmPWcsdz1vLG51bGw9PWV8fDU+bj9lPTA6NTw9biYmNDc9PWVbciswXSYmIShlW3IrNF0+PjUpPyh5PVswXSxRPVswXSxDPVswXSxtKF89bmV3IHYsZSxyLG4pLHBlKF8seSxRLEMpPyhudWxsIT1sJiYobFswXT15WzBdKSxudWxsIT1mJiYoZlswXT1RWzBdKSxudWxsIT13JiYod1swXT1DWzBdKSxlPTEpOmU9MCk6ZT0wfWVsc2V7aWYoMTA+bil7Qj03O2JyZWFrfWw9ZyxudWxsPT1lfHwxMD5ufHwhWGUoZSxyKzMsbi0zKT9lPTA6KGY9ZVtyKzBdfGVbcisxXTw8OHxlW3IrMl08PDE2LHc9MTYzODMmKGVbcis3XTw8OHxlW3IrNl0pLGU9MTYzODMmKGVbcis5XTw8OHxlW3IrOF0pLDEmZnx8MzwoZj4+MSY3KXx8IShmPj40JjEpfHxmPj41Pj1wLkphfHwhd3x8IWU/ZT0wOihhJiYoYVswXT13KSxsJiYobFswXT1lKSxlPTEpKX1pZighZSlyZXR1cm4gMztpZihhPWFbMF0sZz1nWzBdLGQmJih1WzBdIT1hfHxoWzBdIT1nKSlyZXR1cm4gMztudWxsIT1jJiYoY1swXT1wLGMub2Zmc2V0PXItYy53LHQoNDI5NDk2NzI4Nj5yLWMudyksdChjLm9mZnNldD09Yy5oYS1uKSk7YnJlYWt9cmV0dXJuIDA9PUJ8fDc9PUImJmQmJm51bGw9PWM/KG51bGwhPW8mJihvWzBdfD1udWxsIT1wLm5hJiYwPHAubmEubGVuZ3RoKSxudWxsIT1zJiYoc1swXT1hKSxudWxsIT1pJiYoaVswXT1nKSwwKTpCfWZ1bmN0aW9uIE5BKGUsdCxBKXt2YXIgcj10LndpZHRoLG49dC5oZWlnaHQscz0wLGk9MCxvPXIsYT1uO2lmKHQuRGE9bnVsbCE9ZSYmMDxlLkRhLHQuRGEmJihvPWUuY2QsYT1lLmJkLHM9ZS52LGk9ZS5qLDExPkF8fChzJj0tMixpJj0tMiksMD5zfHwwPml8fDA+PW98fDA+PWF8fHMrbz5yfHxpK2E+bikpcmV0dXJuIDA7aWYodC52PXMsdC5qPWksdC52YT1zK28sdC5vPWkrYSx0LlU9byx0LlQ9YSx0LmRhPW51bGwhPWUmJjA8ZS5kYSx0LmRhKXtpZighSChvLGEsQT1bZS5pYl0scz1bZS5oYl0pKXJldHVybiAwO3QuaWI9QVswXSx0LmhiPXNbMF19cmV0dXJuIHQub2I9bnVsbCE9ZSYmZS5vYix0LktiPW51bGw9PWV8fCFlLlNkLHQuZGEmJih0Lm9iPXQuaWI8MypyLzQmJnQuaGI8MypuLzQsdC5LYj0wKSwxfWZ1bmN0aW9uIGtBKGUpe2lmKG51bGw9PWUpcmV0dXJuIDI7aWYoMTE+ZS5TKXt2YXIgdD1lLmYuUkdCQTt0LmZiKz0oZS5oZWlnaHQtMSkqdC5BLHQuQT0tdC5BfWVsc2UgdD1lLmYua2IsZT1lLmhlaWdodCx0Lk8rPShlLTEpKnQuZmEsdC5mYT0tdC5mYSx0Lk4rPShlLTE+PjEpKnQuQWIsdC5BYj0tdC5BYix0LlcrPShlLTE+PjEpKnQuRGIsdC5EYj0tdC5EYixudWxsIT10LkYmJih0LkorPShlLTEpKnQubGIsdC5sYj0tdC5sYik7cmV0dXJuIDB9ZnVuY3Rpb24gSEEoZSx0LEEscil7aWYobnVsbD09cnx8MD49ZXx8MD49dClyZXR1cm4gMjtpZihudWxsIT1BKXtpZihBLkRhKXt2YXIgbj1BLmNkLGk9QS5iZCxvPS0yJkEudixhPS0yJkEuajtpZigwPm98fDA+YXx8MD49bnx8MD49aXx8bytuPmV8fGEraT50KXJldHVybiAyO2U9bix0PWl9aWYoQS5kYSl7aWYoIUgoZSx0LG49W0EuaWJdLGk9W0EuaGJdKSlyZXR1cm4gMjtlPW5bMF0sdD1pWzBdfX1yLndpZHRoPWUsci5oZWlnaHQ9dDtlOnt2YXIgbD1yLndpZHRoLGM9ci5oZWlnaHQ7aWYoZT1yLlMsMD49bHx8MD49Y3x8IShlPj1OciYmMTM+ZSkpZT0yO2Vsc2V7aWYoMD49ci5SZCYmbnVsbD09ci5zZCl7bz1pPW49dD0wO3ZhciB1PShhPWwqTW5bZV0pKmM7aWYoMTE+ZXx8KGk9KGMrMSkvMioodD0obCsxKS8yKSwxMj09ZSYmKG89KG49bCkqYykpLG51bGw9PShjPXModSsyKmkrbykpKXtlPTE7YnJlYWsgZX1yLnNkPWMsMTE+ZT8oKGw9ci5mLlJHQkEpLmViPWMsbC5mYj0wLGwuQT1hLGwuc2l6ZT11KTooKGw9ci5mLmtiKS55PWMsbC5PPTAsbC5mYT1hLGwuRmQ9dSxsLmY9YyxsLk49MCt1LGwuQWI9dCxsLkNkPWksbC5lYT1jLGwuVz0wK3UraSxsLkRiPXQsbC5FZD1pLDEyPT1lJiYobC5GPWMsbC5KPTArdSsyKmkpLGwuVGM9byxsLmxiPW4pfWlmKHQ9MSxuPXIuUyxpPXIud2lkdGgsbz1yLmhlaWdodCxuPj1OciYmMTM+bilpZigxMT5uKWU9ci5mLlJHQkEsdCY9KGE9TWF0aC5hYnMoZS5BKSkqKG8tMSkraTw9ZS5zaXplLHQmPWE+PWkqTW5bbl0sdCY9bnVsbCE9ZS5lYjtlbHNle2U9ci5mLmtiLGE9KGkrMSkvMix1PShvKzEpLzIsbD1NYXRoLmFicyhlLmZhKSxjPU1hdGguYWJzKGUuQWIpO3ZhciBoPU1hdGguYWJzKGUuRGIpLGQ9TWF0aC5hYnMoZS5sYiksZj1kKihvLTEpK2k7dCY9bCooby0xKStpPD1lLkZkLHQmPWMqKHUtMSkrYTw9ZS5DZCx0PSh0Jj1oKih1LTEpK2E8PWUuRWQpJmw+PWkmYz49YSZoPj1hLHQmPW51bGwhPWUueSx0Jj1udWxsIT1lLmYsdCY9bnVsbCE9ZS5lYSwxMj09biYmKHQmPWQ+PWksdCY9Zjw9ZS5UYyx0Jj1udWxsIT1lLkYpfWVsc2UgdD0wO2U9dD8wOjJ9fXJldHVybiAwIT1lfHxudWxsIT1BJiZBLmZkJiYoZT1rQShyKSksZX12YXIgUEE9NjQsVEE9WzAsMSwzLDcsMTUsMzEsNjMsMTI3LDI1NSw1MTEsMTAyMywyMDQ3LDQwOTUsODE5MSwxNjM4MywzMjc2Nyw2NTUzNSwxMzEwNzEsMjYyMTQzLDUyNDI4NywxMDQ4NTc1LDIwOTcxNTEsNDE5NDMwMyw4Mzg4NjA3LDE2Nzc3MjE1XSxPQT0yNCxNQT0zMixEQT04LFJBPVswLDAsMSwxLDIsMiwyLDIsMywzLDMsMywzLDMsMywzLDQsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDQsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3XTtPKCJQcmVkaWN0b3IwIiwiUHJlZGljdG9yQWRkMCIpLGUuUHJlZGljdG9yMD1mdW5jdGlvbigpe3JldHVybiA0Mjc4MTkwMDgwfSxlLlByZWRpY3RvcjE9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LGUuUHJlZGljdG9yMj1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIHRbQSswXX0sZS5QcmVkaWN0b3IzPWZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gdFtBKzFdfSxlLlByZWRpY3RvcjQ9ZnVuY3Rpb24oZSx0LEEpe3JldHVybiB0W0EtMV19LGUuUHJlZGljdG9yNT1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIEQoRChlLHRbQSsxXSksdFtBKzBdKX0sZS5QcmVkaWN0b3I2PWZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gRChlLHRbQS0xXSl9LGUuUHJlZGljdG9yNz1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIEQoZSx0W0ErMF0pfSxlLlByZWRpY3Rvcjg9ZnVuY3Rpb24oZSx0LEEpe3JldHVybiBEKHRbQS0xXSx0W0ErMF0pfSxlLlByZWRpY3Rvcjk9ZnVuY3Rpb24oZSx0LEEpe3JldHVybiBEKHRbQSswXSx0W0ErMV0pfSxlLlByZWRpY3RvcjEwPWZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gRChEKGUsdFtBLTFdKSxEKHRbQSswXSx0W0ErMV0pKX0sZS5QcmVkaWN0b3IxMT1mdW5jdGlvbihlLHQsQSl7dmFyIHI9dFtBKzBdO3JldHVybiAwPj1WKHI+PjI0JjI1NSxlPj4yNCYyNTUsKHQ9dFtBLTFdKT4+MjQmMjU1KStWKHI+PjE2JjI1NSxlPj4xNiYyNTUsdD4+MTYmMjU1KStWKHI+PjgmMjU1LGU+PjgmMjU1LHQ+PjgmMjU1KStWKDI1NSZyLDI1NSZlLDI1NSZ0KT9yOmV9LGUuUHJlZGljdG9yMTI9ZnVuY3Rpb24oZSx0LEEpe3ZhciByPXRbQSswXTtyZXR1cm4oUigoZT4+MjQmMjU1KSsocj4+MjQmMjU1KS0oKHQ9dFtBLTFdKT4+MjQmMjU1KSk8PDI0fFIoKGU+PjE2JjI1NSkrKHI+PjE2JjI1NSktKHQ+PjE2JjI1NSkpPDwxNnxSKChlPj44JjI1NSkrKHI+PjgmMjU1KS0odD4+OCYyNTUpKTw8OHxSKCgyNTUmZSkrKDI1NSZyKS0oMjU1JnQpKSk+Pj4wfSxlLlByZWRpY3RvcjEzPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcj10W0EtMV07cmV0dXJuKEsoKGU9RChlLHRbQSswXSkpPj4yNCYyNTUscj4+MjQmMjU1KTw8MjR8SyhlPj4xNiYyNTUscj4+MTYmMjU1KTw8MTZ8SyhlPj44JjI1NSxyPj44JjI1NSk8PDh8SygyNTUmZSwyNTUmcikpPj4+MH07dmFyIEtBPWUuUHJlZGljdG9yQWRkMDtlLlByZWRpY3RvckFkZDE9RyxPKCJQcmVkaWN0b3IyIiwiUHJlZGljdG9yQWRkMiIpLE8oIlByZWRpY3RvcjMiLCJQcmVkaWN0b3JBZGQzIiksTygiUHJlZGljdG9yNCIsIlByZWRpY3RvckFkZDQiKSxPKCJQcmVkaWN0b3I1IiwiUHJlZGljdG9yQWRkNSIpLE8oIlByZWRpY3RvcjYiLCJQcmVkaWN0b3JBZGQ2IiksTygiUHJlZGljdG9yNyIsIlByZWRpY3RvckFkZDciKSxPKCJQcmVkaWN0b3I4IiwiUHJlZGljdG9yQWRkOCIpLE8oIlByZWRpY3RvcjkiLCJQcmVkaWN0b3JBZGQ5IiksTygiUHJlZGljdG9yMTAiLCJQcmVkaWN0b3JBZGQxMCIpLE8oIlByZWRpY3RvcjExIiwiUHJlZGljdG9yQWRkMTEiKSxPKCJQcmVkaWN0b3IxMiIsIlByZWRpY3RvckFkZDEyIiksTygiUHJlZGljdG9yMTMiLCJQcmVkaWN0b3JBZGQxMyIpO3ZhciBWQT1lLlByZWRpY3RvckFkZDI7WCgiQ29sb3JJbmRleEludmVyc2VUcmFuc2Zvcm0iLCJNYXBBUkdCIiwiMzJiIixmdW5jdGlvbihlKXtyZXR1cm4gZT4+OCYyNTV9LGZ1bmN0aW9uKGUpe3JldHVybiBlfSksWCgiVlA4TENvbG9ySW5kZXhJbnZlcnNlVHJhbnNmb3JtQWxwaGEiLCJNYXBBbHBoYSIsIjhiIixmdW5jdGlvbihlKXtyZXR1cm4gZX0sZnVuY3Rpb24oZSl7cmV0dXJuIGU+PjgmMjU1fSk7dmFyIEdBLHpBPWUuQ29sb3JJbmRleEludmVyc2VUcmFuc2Zvcm0scUE9ZS5NYXBBUkdCLFdBPWUuVlA4TENvbG9ySW5kZXhJbnZlcnNlVHJhbnNmb3JtQWxwaGEsWEE9ZS5NYXBBbHBoYSxZQT1lLlZQOExQcmVkaWN0b3JzQWRkPVtdO1lBLmxlbmd0aD0xNiwoZS5WUDhMUHJlZGljdG9ycz1bXSkubGVuZ3RoPTE2LChlLlZQOExQcmVkaWN0b3JzQWRkX0M9W10pLmxlbmd0aD0xNiwoZS5WUDhMUHJlZGljdG9yc19DPVtdKS5sZW5ndGg9MTY7dmFyIEpBLFpBLCRBLGVyLHRyLEFyLHJyLG5yLHNyLGlyLG9yLGFyLGxyLGNyLHVyLGhyLGRyLGZyLHByLGdyLG1yLHdyLEJyLHlyLHZyLGJyLENyLF9yLGpyPXMoNTExKSx4cj1zKDIwNDEpLEZyPXMoMjI1KSxRcj1zKDc2NyksVXI9MCxFcj14cixTcj1GcixMcj1RcixJcj1qcixOcj0wLGtyPTEsSHI9MixQcj0zLFRyPTQsT3I9NSxNcj02LERyPTcsUnI9OCxLcj05LFZyPTEwLEdyPVsyLDMsN10senI9WzMsMywxMV0scXI9WzI4MCwyNTYsMjU2LDI1Niw0MF0sV3I9WzAsMSwxLDEsMF0sWHI9WzE3LDE4LDAsMSwyLDMsNCw1LDE2LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTVdLFlyPVsyNCw3LDIzLDI1LDQwLDYsMzksNDEsMjIsMjYsMzgsNDIsNTYsNSw1NSw1NywyMSwyNyw1NCw1OCwzNyw0Myw3Miw0LDcxLDczLDIwLDI4LDUzLDU5LDcwLDc0LDM2LDQ0LDg4LDY5LDc1LDUyLDYwLDMsODcsODksMTksMjksODYsOTAsMzUsNDUsNjgsNzYsODUsOTEsNTEsNjEsMTA0LDIsMTAzLDEwNSwxOCwzMCwxMDIsMTA2LDM0LDQ2LDg0LDkyLDY3LDc3LDEwMSwxMDcsNTAsNjIsMTIwLDEsMTE5LDEyMSw4Myw5MywxNywzMSwxMDAsMTA4LDY2LDc4LDExOCwxMjIsMzMsNDcsMTE3LDEyMyw0OSw2Myw5OSwxMDksODIsOTQsMCwxMTYsMTI0LDY1LDc5LDE2LDMyLDk4LDExMCw0OCwxMTUsMTI1LDgxLDk1LDY0LDExNCwxMjYsOTcsMTExLDgwLDExMywxMjcsOTYsMTEyXSxKcj1bMjk1NCwyOTU2LDI5NTgsMjk2MiwyOTcwLDI5ODYsMzAxOCwzMDgyLDMyMTIsMzQ2OCwzOTgwLDUwMDRdLFpyPTgsJHI9WzQsNSw2LDcsOCw5LDEwLDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE3LDE4LDE5LDIwLDIwLDIxLDIxLDIyLDIyLDIzLDIzLDI0LDI1LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkxLDkzLDk1LDk2LDk4LDEwMCwxMDEsMTAyLDEwNCwxMDYsMTA4LDExMCwxMTIsMTE0LDExNiwxMTgsMTIyLDEyNCwxMjYsMTI4LDEzMCwxMzIsMTM0LDEzNiwxMzgsMTQwLDE0MywxNDUsMTQ4LDE1MSwxNTQsMTU3XSxlbj1bNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNjAsNjIsNjQsNjYsNjgsNzAsNzIsNzQsNzYsNzgsODAsODIsODQsODYsODgsOTAsOTIsOTQsOTYsOTgsMTAwLDEwMiwxMDQsMTA2LDEwOCwxMTAsMTEyLDExNCwxMTYsMTE5LDEyMiwxMjUsMTI4LDEzMSwxMzQsMTM3LDE0MCwxNDMsMTQ2LDE0OSwxNTIsMTU1LDE1OCwxNjEsMTY0LDE2NywxNzAsMTczLDE3NywxODEsMTg1LDE4OSwxOTMsMTk3LDIwMSwyMDUsMjA5LDIxMywyMTcsMjIxLDIyNSwyMjksMjM0LDIzOSwyNDUsMjQ5LDI1NCwyNTksMjY0LDI2OSwyNzQsMjc5LDI4NF0sdG49bnVsbCxBbj1bWzE3MywxNDgsMTQwLDBdLFsxNzYsMTU1LDE0MCwxMzUsMF0sWzE4MCwxNTcsMTQxLDEzNCwxMzAsMF0sWzI1NCwyNTQsMjQzLDIzMCwxOTYsMTc3LDE1MywxNDAsMTMzLDEzMCwxMjksMF1dLHJuPVswLDEsNCw4LDUsMiwzLDYsOSwxMiwxMywxMCw3LDExLDE0LDE1XSxubj1bLTAsMSwtMSwyLC0yLDMsNCw2LC0zLDUsLTQsLTUsLTYsNywtNyw4LC04LC05XSxzbj1bW1tbMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XV0sW1syNTMsMTM2LDI1NCwyNTUsMjI4LDIxOSwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTg5LDEyOSwyNDIsMjU1LDIyNywyMTMsMjU1LDIxOSwxMjgsMTI4LDEyOF0sWzEwNiwxMjYsMjI3LDI1MiwyMTQsMjA5LDI1NSwyNTUsMTI4LDEyOCwxMjhdXSxbWzEsOTgsMjQ4LDI1NSwyMzYsMjI2LDI1NSwyNTUsMTI4LDEyOCwxMjhdLFsxODEsMTMzLDIzOCwyNTQsMjIxLDIzNCwyNTUsMTU0LDEyOCwxMjgsMTI4XSxbNzgsMTM0LDIwMiwyNDcsMTk4LDE4MCwyNTUsMjE5LDEyOCwxMjgsMTI4XV0sW1sxLDE4NSwyNDksMjU1LDI0MywyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzE4NCwxNTAsMjQ3LDI1NSwyMzYsMjI0LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFs3NywxMTAsMjE2LDI1NSwyMzYsMjMwLDEyOCwxMjgsMTI4LDEyOCwxMjhdXSxbWzEsMTAxLDI1MSwyNTUsMjQxLDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTcwLDEzOSwyNDEsMjUyLDIzNiwyMDksMjU1LDI1NSwxMjgsMTI4LDEyOF0sWzM3LDExNiwxOTYsMjQzLDIyOCwyNTUsMjU1LDI1NSwxMjgsMTI4LDEyOF1dLFtbMSwyMDQsMjU0LDI1NSwyNDUsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsyMDcsMTYwLDI1MCwyNTUsMjM4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTAyLDEwMywyMzEsMjU1LDIxMSwxNzEsMTI4LDEyOCwxMjgsMTI4LDEyOF1dLFtbMSwxNTIsMjUyLDI1NSwyNDAsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsxNzcsMTM1LDI0MywyNTUsMjM0LDIyNSwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbODAsMTI5LDIxMSwyNTUsMTk0LDIyNCwxMjgsMTI4LDEyOCwxMjgsMTI4XV0sW1sxLDEsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsyNDYsMSwyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdXV0sW1tbMTk4LDM1LDIzNywyMjMsMTkzLDE4NywxNjIsMTYwLDE0NSwxNTUsNjJdLFsxMzEsNDUsMTk4LDIyMSwxNzIsMTc2LDIyMCwxNTcsMjUyLDIyMSwxXSxbNjgsNDcsMTQ2LDIwOCwxNDksMTY3LDIyMSwxNjIsMjU1LDIyMywxMjhdXSxbWzEsMTQ5LDI0MSwyNTUsMjIxLDIyNCwyNTUsMjU1LDEyOCwxMjgsMTI4XSxbMTg0LDE0MSwyMzQsMjUzLDIyMiwyMjAsMjU1LDE5OSwxMjgsMTI4LDEyOF0sWzgxLDk5LDE4MSwyNDIsMTc2LDE5MCwyNDksMjAyLDI1NSwyNTUsMTI4XV0sW1sxLDEyOSwyMzIsMjUzLDIxNCwxOTcsMjQyLDE5NiwyNTUsMjU1LDEyOF0sWzk5LDEyMSwyMTAsMjUwLDIwMSwxOTgsMjU1LDIwMiwxMjgsMTI4LDEyOF0sWzIzLDkxLDE2MywyNDIsMTcwLDE4NywyNDcsMjEwLDI1NSwyNTUsMTI4XV0sW1sxLDIwMCwyNDYsMjU1LDIzNCwyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzEwOSwxNzgsMjQxLDI1NSwyMzEsMjQ1LDI1NSwyNTUsMTI4LDEyOCwxMjhdLFs0NCwxMzAsMjAxLDI1MywyMDUsMTkyLDI1NSwyNTUsMTI4LDEyOCwxMjhdXSxbWzEsMTMyLDIzOSwyNTEsMjE5LDIwOSwyNTUsMTY1LDEyOCwxMjgsMTI4XSxbOTQsMTM2LDIyNSwyNTEsMjE4LDE5MCwyNTUsMjU1LDEyOCwxMjgsMTI4XSxbMjIsMTAwLDE3NCwyNDUsMTg2LDE2MSwyNTUsMTk5LDEyOCwxMjgsMTI4XV0sW1sxLDE4MiwyNDksMjU1LDIzMiwyMzUsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzEyNCwxNDMsMjQxLDI1NSwyMjcsMjM0LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFszNSw3NywxODEsMjUxLDE5MywyMTEsMjU1LDIwNSwxMjgsMTI4LDEyOF1dLFtbMSwxNTcsMjQ3LDI1NSwyMzYsMjMxLDI1NSwyNTUsMTI4LDEyOCwxMjhdLFsxMjEsMTQxLDIzNSwyNTUsMjI1LDIyNywyNTUsMjU1LDEyOCwxMjgsMTI4XSxbNDUsOTksMTg4LDI1MSwxOTUsMjE3LDI1NSwyMjQsMTI4LDEyOCwxMjhdXSxbWzEsMSwyNTEsMjU1LDIxMywyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzIwMywxLDI0OCwyNTUsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTM3LDEsMTc3LDI1NSwyMjQsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjhdXV0sW1tbMjUzLDksMjQ4LDI1MSwyMDcsMjA4LDI1NSwxOTIsMTI4LDEyOCwxMjhdLFsxNzUsMTMsMjI0LDI0MywxOTMsMTg1LDI0OSwxOTgsMjU1LDI1NSwxMjhdLFs3MywxNywxNzEsMjIxLDE2MSwxNzksMjM2LDE2NywyNTUsMjM0LDEyOF1dLFtbMSw5NSwyNDcsMjUzLDIxMiwxODMsMjU1LDI1NSwxMjgsMTI4LDEyOF0sWzIzOSw5MCwyNDQsMjUwLDIxMSwyMDksMjU1LDI1NSwxMjgsMTI4LDEyOF0sWzE1NSw3NywxOTUsMjQ4LDE4OCwxOTUsMjU1LDI1NSwxMjgsMTI4LDEyOF1dLFtbMSwyNCwyMzksMjUxLDIxOCwyMTksMjU1LDIwNSwxMjgsMTI4LDEyOF0sWzIwMSw1MSwyMTksMjU1LDE5NiwxODYsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzY5LDQ2LDE5MCwyMzksMjAxLDIxOCwyNTUsMjI4LDEyOCwxMjgsMTI4XV0sW1sxLDE5MSwyNTEsMjU1LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzIyMywxNjUsMjQ5LDI1NSwyMTMsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsxNDEsMTI0LDI0OCwyNTUsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XV0sW1sxLDE2LDI0OCwyNTUsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTkwLDM2LDIzMCwyNTUsMjM2LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTQ5LDEsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdXSxbWzEsMjI2LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMjQ3LDE5MiwyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzI0MCwxMjgsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdXSxbWzEsMTM0LDI1MiwyNTUsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMjEzLDYyLDI1MCwyNTUsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbNTUsOTMsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdXSxbWzEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF1dXSxbW1syMDIsMjQsMjEzLDIzNSwxODYsMTkxLDIyMCwxNjAsMjQwLDE3NSwyNTVdLFsxMjYsMzgsMTgyLDIzMiwxNjksMTg0LDIyOCwxNzQsMjU1LDE4NywxMjhdLFs2MSw0NiwxMzgsMjE5LDE1MSwxNzgsMjQwLDE3MCwyNTUsMjE2LDEyOF1dLFtbMSwxMTIsMjMwLDI1MCwxOTksMTkxLDI0NywxNTksMjU1LDI1NSwxMjhdLFsxNjYsMTA5LDIyOCwyNTIsMjExLDIxNSwyNTUsMTc0LDEyOCwxMjgsMTI4XSxbMzksNzcsMTYyLDIzMiwxNzIsMTgwLDI0NSwxNzgsMjU1LDI1NSwxMjhdXSxbWzEsNTIsMjIwLDI0NiwxOTgsMTk5LDI0OSwyMjAsMjU1LDI1NSwxMjhdLFsxMjQsNzQsMTkxLDI0MywxODMsMTkzLDI1MCwyMjEsMjU1LDI1NSwxMjhdLFsyNCw3MSwxMzAsMjE5LDE1NCwxNzAsMjQzLDE4MiwyNTUsMjU1LDEyOF1dLFtbMSwxODIsMjI1LDI0OSwyMTksMjQwLDI1NSwyMjQsMTI4LDEyOCwxMjhdLFsxNDksMTUwLDIyNiwyNTIsMjE2LDIwNSwyNTUsMTcxLDEyOCwxMjgsMTI4XSxbMjgsMTA4LDE3MCwyNDIsMTgzLDE5NCwyNTQsMjIzLDI1NSwyNTUsMTI4XV0sW1sxLDgxLDIzMCwyNTIsMjA0LDIwMywyNTUsMTkyLDEyOCwxMjgsMTI4XSxbMTIzLDEwMiwyMDksMjQ3LDE4OCwxOTYsMjU1LDIzMywxMjgsMTI4LDEyOF0sWzIwLDk1LDE1MywyNDMsMTY0LDE3MywyNTUsMjAzLDEyOCwxMjgsMTI4XV0sW1sxLDIyMiwyNDgsMjU1LDIxNiwyMTMsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzE2OCwxNzUsMjQ2LDI1MiwyMzUsMjA1LDI1NSwyNTUsMTI4LDEyOCwxMjhdLFs0NywxMTYsMjE1LDI1NSwyMTEsMjEyLDI1NSwyNTUsMTI4LDEyOCwxMjhdXSxbWzEsMTIxLDIzNiwyNTMsMjEyLDIxNCwyNTUsMjU1LDEyOCwxMjgsMTI4XSxbMTQxLDg0LDIxMywyNTIsMjAxLDIwMiwyNTUsMjE5LDEyOCwxMjgsMTI4XSxbNDIsODAsMTYwLDI0MCwxNjIsMTg1LDI1NSwyMDUsMTI4LDEyOCwxMjhdXSxbWzEsMSwyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzI0NCwxLDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMjM4LDEsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdXV1dLG9uPVtbWzIzMSwxMjAsNDgsODksMTE1LDExMywxMjAsMTUyLDExMl0sWzE1MiwxNzksNjQsMTI2LDE3MCwxMTgsNDYsNzAsOTVdLFsxNzUsNjksMTQzLDgwLDg1LDgyLDcyLDE1NSwxMDNdLFs1Niw1OCwxMCwxNzEsMjE4LDE4OSwxNywxMywxNTJdLFsxMTQsMjYsMTcsMTYzLDQ0LDE5NSwyMSwxMCwxNzNdLFsxMjEsMjQsODAsMTk1LDI2LDYyLDQ0LDY0LDg1XSxbMTQ0LDcxLDEwLDM4LDE3MSwyMTMsMTQ0LDM0LDI2XSxbMTcwLDQ2LDU1LDE5LDEzNiwxNjAsMzMsMjA2LDcxXSxbNjMsMjAsOCwxMTQsMTE0LDIwOCwxMiw5LDIyNl0sWzgxLDQwLDExLDk2LDE4Miw4NCwyOSwxNiwzNl1dLFtbMTM0LDE4Myw4OSwxMzcsOTgsMTAxLDEwNiwxNjUsMTQ4XSxbNzIsMTg3LDEwMCwxMzAsMTU3LDExMSwzMiw3NSw4MF0sWzY2LDEwMiwxNjcsOTksNzQsNjIsNDAsMjM0LDEyOF0sWzQxLDUzLDksMTc4LDI0MSwxNDEsMjYsOCwxMDddLFs3NCw0MywyNiwxNDYsNzMsMTY2LDQ5LDIzLDE1N10sWzY1LDM4LDEwNSwxNjAsNTEsNTIsMzEsMTE1LDEyOF0sWzEwNCw3OSwxMiwyNywyMTcsMjU1LDg3LDE3LDddLFs4Nyw2OCw3MSw0NCwxMTQsNTEsMTUsMTg2LDIzXSxbNDcsNDEsMTQsMTEwLDE4MiwxODMsMjEsMTcsMTk0XSxbNjYsNDUsMjUsMTAyLDE5NywxODksMjMsMTgsMjJdXSxbWzg4LDg4LDE0NywxNTAsNDIsNDYsNDUsMTk2LDIwNV0sWzQzLDk3LDE4MywxMTcsODUsMzgsMzUsMTc5LDYxXSxbMzksNTMsMjAwLDg3LDI2LDIxLDQzLDIzMiwxNzFdLFs1NiwzNCw1MSwxMDQsMTE0LDEwMiwyOSw5Myw3N10sWzM5LDI4LDg1LDE3MSw1OCwxNjUsOTAsOTgsNjRdLFszNCwyMiwxMTYsMjA2LDIzLDM0LDQzLDE2Niw3M10sWzEwNyw1NCwzMiwyNiw1MSwxLDgxLDQzLDMxXSxbNjgsMjUsMTA2LDIyLDY0LDE3MSwzNiwyMjUsMTE0XSxbMzQsMTksMjEsMTAyLDEzMiwxODgsMTYsNzYsMTI0XSxbNjIsMTgsNzgsOTUsODUsNTcsNTAsNDgsNTFdXSxbWzE5MywxMDEsMzUsMTU5LDIxNSwxMTEsODksNDYsMTExXSxbNjAsMTQ4LDMxLDE3MiwyMTksMjI4LDIxLDE4LDExMV0sWzExMiwxMTMsNzcsODUsMTc5LDI1NSwzOCwxMjAsMTE0XSxbNDAsNDIsMSwxOTYsMjQ1LDIwOSwxMCwyNSwxMDldLFs4OCw0MywyOSwxNDAsMTY2LDIxMywzNyw0MywxNTRdLFs2MSw2MywzMCwxNTUsNjcsNDUsNjgsMSwyMDldLFsxMDAsODAsOCw0MywxNTQsMSw1MSwyNiw3MV0sWzE0Miw3OCw3OCwxNiwyNTUsMTI4LDM0LDE5NywxNzFdLFs0MSw0MCw1LDEwMiwyMTEsMTgzLDQsMSwyMjFdLFs1MSw1MCwxNywxNjgsMjA5LDE5MiwyMywyNSw4Ml1dLFtbMTM4LDMxLDM2LDE3MSwyNywxNjYsMzgsNDQsMjI5XSxbNjcsODcsNTgsMTY5LDgyLDExNSwyNiw1OSwxNzldLFs2Myw1OSw5MCwxODAsNTksMTY2LDkzLDczLDE1NF0sWzQwLDQwLDIxLDExNiwxNDMsMjA5LDM0LDM5LDE3NV0sWzQ3LDE1LDE2LDE4MywzNCwyMjMsNDksNDUsMTgzXSxbNDYsMTcsMzMsMTgzLDYsOTgsMTUsMzIsMTgzXSxbNTcsNDYsMjIsMjQsMTI4LDEsNTQsMTcsMzddLFs2NSwzMiw3MywxMTUsMjgsMTI4LDIzLDEyOCwyMDVdLFs0MCwzLDksMTE1LDUxLDE5MiwxOCw2LDIyM10sWzg3LDM3LDksMTE1LDU5LDc3LDY0LDIxLDQ3XV0sW1sxMDQsNTUsNDQsMjE4LDksNTQsNTMsMTMwLDIyNl0sWzY0LDkwLDcwLDIwNSw0MCw0MSwyMywyNiw1N10sWzU0LDU3LDExMiwxODQsNSw0MSwzOCwxNjYsMjEzXSxbMzAsMzQsMjYsMTMzLDE1MiwxMTYsMTAsMzIsMTM0XSxbMzksMTksNTMsMjIxLDI2LDExNCwzMiw3MywyNTVdLFszMSw5LDY1LDIzNCwyLDE1LDEsMTE4LDczXSxbNzUsMzIsMTIsNTEsMTkyLDI1NSwxNjAsNDMsNTFdLFs4OCwzMSwzNSw2NywxMDIsODUsNTUsMTg2LDg1XSxbNTYsMjEsMjMsMTExLDU5LDIwNSw0NSwzNywxOTJdLFs1NSwzOCw3MCwxMjQsNzMsMTAyLDEsMzQsOThdXSxbWzEyNSw5OCw0Miw4OCwxMDQsODUsMTE3LDE3NSw4Ml0sWzk1LDg0LDUzLDg5LDEyOCwxMDAsMTEzLDEwMSw0NV0sWzc1LDc5LDEyMyw0Nyw1MSwxMjgsODEsMTcxLDFdLFs1NywxNyw1LDcxLDEwMiw1Nyw1Myw0MSw0OV0sWzM4LDMzLDEzLDEyMSw1Nyw3MywyNiwxLDg1XSxbNDEsMTAsNjcsMTM4LDc3LDExMCw5MCw0NywxMTRdLFsxMTUsMjEsMiwxMCwxMDIsMjU1LDE2NiwyMyw2XSxbMTAxLDI5LDE2LDEwLDg1LDEyOCwxMDEsMTk2LDI2XSxbNTcsMTgsMTAsMTAyLDEwMiwyMTMsMzQsMjAsNDNdLFsxMTcsMjAsMTUsMzYsMTYzLDEyOCw2OCwxLDI2XV0sW1sxMDIsNjEsNzEsMzcsMzQsNTMsMzEsMjQzLDE5Ml0sWzY5LDYwLDcxLDM4LDczLDExOSwyOCwyMjIsMzddLFs2OCw0NSwxMjgsMzQsMSw0NywxMSwyNDUsMTcxXSxbNjIsMTcsMTksNzAsMTQ2LDg1LDU1LDYyLDcwXSxbMzcsNDMsMzcsMTU0LDEwMCwxNjMsODUsMTYwLDFdLFs2Myw5LDkyLDEzNiwyOCw2NCwzMiwyMDEsODVdLFs3NSwxNSw5LDksNjQsMjU1LDE4NCwxMTksMTZdLFs4Niw2LDI4LDUsNjQsMjU1LDI1LDI0OCwxXSxbNTYsOCwxNywxMzIsMTM3LDI1NSw1NSwxMTYsMTI4XSxbNTgsMTUsMjAsODIsMTM1LDU3LDI2LDEyMSw0MF1dLFtbMTY0LDUwLDMxLDEzNywxNTQsMTMzLDI1LDM1LDIxOF0sWzUxLDEwMyw0NCwxMzEsMTMxLDEyMywzMSw2LDE1OF0sWzg2LDQwLDY0LDEzNSwxNDgsMjI0LDQ1LDE4MywxMjhdLFsyMiwyNiwxNywxMzEsMjQwLDE1NCwxNCwxLDIwOV0sWzQ1LDE2LDIxLDkxLDY0LDIyMiw3LDEsMTk3XSxbNTYsMjEsMzksMTU1LDYwLDEzOCwyMywxMDIsMjEzXSxbODMsMTIsMTMsNTQsMTkyLDI1NSw2OCw0NywyOF0sWzg1LDI2LDg1LDg1LDEyOCwxMjgsMzIsMTQ2LDE3MV0sWzE4LDExLDcsNjMsMTQ0LDE3MSw0LDQsMjQ2XSxbMzUsMjcsMTAsMTQ2LDE3NCwxNzEsMTIsMjYsMTI4XV0sW1sxOTAsODAsMzUsOTksMTgwLDgwLDEyNiw1NCw0NV0sWzg1LDEyNiw0Nyw4NywxNzYsNTEsNDEsMjAsMzJdLFsxMDEsNzUsMTI4LDEzOSwxMTgsMTQ2LDExNiwxMjgsODVdLFs1Niw0MSwxNSwxNzYsMjM2LDg1LDM3LDksNjJdLFs3MSwzMCwxNywxMTksMTE4LDI1NSwxNywxOCwxMzhdLFsxMDEsMzgsNjAsMTM4LDU1LDcwLDQzLDI2LDE0Ml0sWzE0NiwzNiwxOSwzMCwxNzEsMjU1LDk3LDI3LDIwXSxbMTM4LDQ1LDYxLDYyLDIxOSwxLDgxLDE4OCw2NF0sWzMyLDQxLDIwLDExNywxNTEsMTQyLDIwLDIxLDE2M10sWzExMiwxOSwxMiw2MSwxOTUsMTI4LDQ4LDQsMjRdXV0sYW49W1tbWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMTc2LDI0NiwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzIyMywyNDEsMjUyLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNDksMjUzLDI1MywyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjQ0LDI1MiwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjM0LDI1NCwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1MywyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNDYsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyMzksMjUzLDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU0LDI1NSwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI0OCwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1MSwyNTUsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjUzLDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjUxLDI1NCwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NCwyNTUsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTQsMjUzLDI1NSwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTAsMjU1LDI1NCwyNTUsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV1dLFtbWzIxNywyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyMjUsMjUyLDI0MSwyNTMsMjU1LDI1NSwyNTQsMjU1LDI1NSwyNTUsMjU1XSxbMjM0LDI1MCwyNDEsMjUwLDI1MywyNTUsMjUzLDI1NCwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzIyMywyNTQsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyMzgsMjUzLDI1NCwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjQ4LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjQ5LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTMsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNDcsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1MywyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1MiwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjU0LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjUzLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTQsMjUzLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTAsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV1dLFtbWzE4NiwyNTEsMjUwLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyMzQsMjUxLDI0NCwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjUxLDI1MSwyNDMsMjUzLDI1NCwyNTUsMjU0LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1MywyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzIzNiwyNTMsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTEsMjUzLDI1MywyNTQsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjU0LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU0LDI1NCwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTQsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV1dLFtbWzI0OCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTAsMjU0LDI1MiwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjQ4LDI1NCwyNDksMjUzLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1MywyNTMsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI0NiwyNTMsMjUzLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTIsMjU0LDI1MSwyNTQsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjU0LDI1MiwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjQ4LDI1NCwyNTMsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1MywyNTUsMjU0LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTEsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNDUsMjUxLDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjUzLDI1MywyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1MSwyNTMsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1MiwyNTMsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjUyLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjQ5LDI1NSwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTUsMjUzLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTAsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV1dXSxsbj1bMCwxLDIsMyw2LDQsNSw2LDYsNiw2LDYsNiw2LDYsNywwXSxjbj1bXSx1bj1bXSxobj1bXSxkbj0xLGZuPTIscG49W10sZ249W107Z0EoIlVwc2FtcGxlUmdiTGluZVBhaXIiLGJBLDMpLGdBKCJVcHNhbXBsZUJnckxpbmVQYWlyIixDQSwzKSxnQSgiVXBzYW1wbGVSZ2JhTGluZVBhaXIiLFFBLDQpLGdBKCJVcHNhbXBsZUJncmFMaW5lUGFpciIsRkEsNCksZ0EoIlVwc2FtcGxlQXJnYkxpbmVQYWlyIix4QSw0KSxnQSgiVXBzYW1wbGVSZ2JhNDQ0NExpbmVQYWlyIixqQSwyKSxnQSgiVXBzYW1wbGVSZ2I1NjVMaW5lUGFpciIsX0EsMik7dmFyIG1uPWUuVXBzYW1wbGVSZ2JMaW5lUGFpcix3bj1lLlVwc2FtcGxlQmdyTGluZVBhaXIsQm49ZS5VcHNhbXBsZVJnYmFMaW5lUGFpcix5bj1lLlVwc2FtcGxlQmdyYUxpbmVQYWlyLHZuPWUuVXBzYW1wbGVBcmdiTGluZVBhaXIsYm49ZS5VcHNhbXBsZVJnYmE0NDQ0TGluZVBhaXIsQ249ZS5VcHNhbXBsZVJnYjU2NUxpbmVQYWlyLF9uPTE2LGpuPTE8PF9uLTEseG49LTIyNyxGbj00ODIsUW49NixVbj0oMjU2PDxRbiktMSxFbj0wLFNuPXMoMjU2KSxMbj1zKDI1NiksSW49cygyNTYpLE5uPXMoMjU2KSxrbj1zKEZuLXhuKSxIbj1zKEZuLXhuKTtVQSgiWXV2VG9SZ2JSb3ciLGJBLDMpLFVBKCJZdXZUb0JnclJvdyIsQ0EsMyksVUEoIll1dlRvUmdiYVJvdyIsUUEsNCksVUEoIll1dlRvQmdyYVJvdyIsRkEsNCksVUEoIll1dlRvQXJnYlJvdyIseEEsNCksVUEoIll1dlRvUmdiYTQ0NDRSb3ciLGpBLDIpLFVBKCJZdXZUb1JnYjU2NVJvdyIsX0EsMik7dmFyIFBuPVswLDQsOCwxMiwxMjgsMTMyLDEzNiwxNDAsMjU2LDI2MCwyNjQsMjY4LDM4NCwzODgsMzkyLDM5Nl0sVG49WzAsMiw4XSxPbj1bOCw3LDYsNCw0LDIsMiwyLDEsMSwxLDFdO3RoaXMuV2ViUERlY29kZVJHQkE9ZnVuY3Rpb24oZSxBLG8sYSxsKXt2YXIgYz1rcix1PW5ldyB0QSxoPW5ldyBpZTt1LmJhPWgsaC5TPWMsaC53aWR0aD1baC53aWR0aF0saC5oZWlnaHQ9W2guaGVpZ2h0XTt2YXIgZD1oLndpZHRoLGY9aC5oZWlnaHQscD1uZXcgb2U7aWYobnVsbD09cHx8bnVsbD09ZSl2YXIgZz0yO2Vsc2UgdChudWxsIT1wKSxnPUlBKGUsQSxvLHAud2lkdGgscC5oZWlnaHQscC5QZCxwLlFkLHAuZm9ybWF0LG51bGwpO2lmKDAhPWc/ZD0wOihudWxsIT1kJiYoZFswXT1wLndpZHRoWzBdKSxudWxsIT1mJiYoZlswXT1wLmhlaWdodFswXSksZD0xKSxkKXtoLndpZHRoPWgud2lkdGhbMF0saC5oZWlnaHQ9aC5oZWlnaHRbMF0sbnVsbCE9YSYmKGFbMF09aC53aWR0aCksbnVsbCE9bCYmKGxbMF09aC5oZWlnaHQpO2U6e2lmKGE9bmV3IHplLChsPW5ldyBBQSkuZGF0YT1lLGwudz1BLGwuaGE9byxsLmtkPTEsQT1bMF0sdChudWxsIT1sKSwoMD09KGU9SUEobC5kYXRhLGwudyxsLmhhLG51bGwsbnVsbCxudWxsLEEsbnVsbCxsKSl8fDc9PWUpJiZBWzBdJiYoZT00KSwwPT0oQT1lKSl7aWYodChudWxsIT11KSxhLmRhdGE9bC5kYXRhLGEudz1sLncrbC5vZmZzZXQsYS5oYT1sLmhhLWwub2Zmc2V0LGEucHV0PWRlLGEuYWM9aGUsYS5iYz1mZSxhLm1hPXUsbC54YSl7aWYobnVsbD09KGU9UWUoKSkpe3U9MTticmVhayBlfWlmKGZ1bmN0aW9uKGUsQSl7dmFyIHI9WzBdLG49WzBdLHM9WzBdO3Q6Zm9yKDs7KXtpZihudWxsPT1lKXJldHVybiAwO2lmKG51bGw9PUEpcmV0dXJuIGUuYT0yLDA7aWYoZS5sPUEsZS5hPTAsbShlLm0sQS5kYXRhLEEudyxBLmhhKSwhcGUoZS5tLHIsbixzKSl7ZS5hPTM7YnJlYWsgdH1pZihlLnhiPWZuLEEud2lkdGg9clswXSxBLmhlaWdodD1uWzBdLCFVZShyWzBdLG5bMF0sMSxlLG51bGwpKWJyZWFrIHQ7cmV0dXJuIDF9cmV0dXJuIHQoMCE9ZS5hKSwwfShlLGEpKXtpZihhPTA9PShBPUhBKGEud2lkdGgsYS5oZWlnaHQsdS5PYSx1LmJhKSkpe3Q6e2E9ZTtBOmZvcig7Oyl7aWYobnVsbD09YSl7YT0wO2JyZWFrIHR9aWYodChudWxsIT1hLnMueWMpLHQobnVsbCE9YS5zLllhKSx0KDA8YS5zLldiKSx0KG51bGwhPShvPWEubCkpLHQobnVsbCE9KGw9by5tYSkpLDAhPWEueGIpe2lmKGEuY2E9bC5iYSxhLnRiPWwudGIsdChudWxsIT1hLmNhKSwhTkEobC5PYSxvLFByKSl7YS5hPTI7YnJlYWsgQX1pZighRWUoYSxvLndpZHRoKSlicmVhayBBO2lmKG8uZGEpYnJlYWsgQTtpZigoby5kYXx8cmUoYS5jYS5TKSkmJnBBKCksMTE+YS5jYS5TfHwoYWxlcnQoInRvZG86V2ViUEluaXRDb252ZXJ0QVJHQlRvWVVWIiksbnVsbCE9YS5jYS5mLmtiLkYmJnBBKCkpLGEuUGImJjA8YS5zLnVhJiZudWxsPT1hLnMudmIuWCYmIUkoYS5zLnZiLGEucy5XYS5YYSkpe2EuYT0xO2JyZWFrIEF9YS54Yj0wfWlmKCF4ZShhLGEuVixhLkJhLGEuYyxhLmksby5vLGJlKSlicmVhayBBO2wuRGM9YS5NYSxhPTE7YnJlYWsgdH10KDAhPWEuYSksYT0wfWE9IWF9YSYmKEE9ZS5hKX1lbHNlIEE9ZS5hfWVsc2V7aWYobnVsbD09KGU9bmV3IHFlKSl7dT0xO2JyZWFrIGV9aWYoZS5GYT1sLm5hLGUuUD1sLlAsZS5xYz1sLlNhLFllKGUsYSkpe2lmKDA9PShBPUhBKGEud2lkdGgsYS5oZWlnaHQsdS5PYSx1LmJhKSkpe2lmKGUuQWE9MCxvPXUuT2EsdChudWxsIT0obD1lKSksbnVsbCE9byl7aWYoMDwoZD0wPihkPW8uTWQpPzA6MTAwPGQ/MjU1OjI1NSpkLzEwMCkpe2ZvcihmPXA9MDs0PmY7KytmKTEyPihnPWwucGJbZl0pLmxjJiYoZy5pYT1kKk9uWzA+Zy5sYz8wOmcubGNdPj4zKSxwfD1nLmlhO3AmJihhbGVydCgidG9kbzpWUDhJbml0UmFuZG9tIiksbC5pYT0xKX1sLkdhPW8uSWQsMTAwPGwuR2E/bC5HYT0xMDA6MD5sLkdhJiYobC5HYT0wKX0oZnVuY3Rpb24oZSxBKXtpZihudWxsPT1lKXJldHVybiAwO2lmKG51bGw9PUEpcmV0dXJuIFdlKGUsMiwiTlVMTCBWUDhJbyBwYXJhbWV0ZXIgaW4gVlA4RGVjb2RlKCkuIik7aWYoIWUuY2ImJiFZZShlLEEpKXJldHVybiAwO2lmKHQoZS5jYiksbnVsbD09QS5hY3x8QS5hYyhBKSl7QS5vYiYmKGUuTD0wKTt2YXIgbz1UbltlLkxdO2lmKDI9PWUuTD8oZS55Yj0wLGUuemI9MCk6KGUueWI9QS52LW8+PjQsZS56Yj1BLmotbz4+NCwwPmUueWImJihlLnliPTApLDA+ZS56YiYmKGUuemI9MCkpLGUuVmE9QS5vKzE1K28+PjQsZS5IYj1BLnZhKzE1K28+PjQsZS5IYj5lLnphJiYoZS5IYj1lLnphKSxlLlZhPmUuVWImJihlLlZhPWUuVWIpLDA8ZS5MKXt2YXIgYT1lLmVkO2ZvcihvPTA7ND5vOysrbyl7dmFyIGw7aWYoZS5RYS5DYil7dmFyIGM9ZS5RYS5MYltvXTtlLlFhLkZifHwoYys9YS5UYil9ZWxzZSBjPWEuVGI7Zm9yKGw9MDsxPj1sOysrbCl7dmFyIHU9ZS5nZFtvXVtsXSxoPWM7aWYoYS5QYyYmKGgrPWEudmRbMF0sbCYmKGgrPWEub2RbMF0pKSwwPChoPTA+aD8wOjYzPGg/NjM6aCkpe3ZhciBkPWg7MDxhLndiJiYoZD00PGEud2I/ZD4+MjpkPj4xKT45LWEud2ImJihkPTktYS53YiksMT5kJiYoZD0xKSx1LmRkPWQsdS50Yz0yKmgrZCx1LmxkPTQwPD1oPzI6MTU8PWg/MTowfWVsc2UgdS50Yz0wO3UuTGE9bH19fW89MH1lbHNlIFdlKGUsNiwiRnJhbWUgc2V0dXAgZmFpbGVkIiksbz1lLmE7aWYobz0wPT1vKXtpZihvKXtlLiRjPTAsMDxlLkFhfHwoZS5JYz0xKTt0OntvPWUuSWMsYT00KihkPWUuemEpO3ZhciBmPTMyKmQscD1kKzEsZz0wPGUuTD9kKigwPGUuQWE/MjoxKTowLG09KDI9PWUuQWE/MjoxKSpkO2lmKCh1PWErODMyKyhsPTMqKDE2Km8rVG5bZS5MXSkvMipmKSsoYz1udWxsIT1lLkZhJiYwPGUuRmEubGVuZ3RoP2UuS2MuYyplLktjLmk6MCkpIT11KW89MDtlbHNle2lmKHU+ZS5WYil7aWYoZS5WYj0wLGUuRWM9cyh1KSxlLkZjPTAsbnVsbD09ZS5FYyl7bz1XZShlLDEsIm5vIG1lbW9yeSBkdXJpbmcgZnJhbWUgaW5pdGlhbGl6YXRpb24uIik7YnJlYWsgdH1lLlZiPXV9dT1lLkVjLGg9ZS5GYyxlLkFjPXUsZS5CYz1oLGgrPWEsZS5HZD1pKGYsS2UpLGUuSGQ9MCxlLnJiPWkocCsxLE9lKSxlLnNiPTEsZS53YT1nP2koZyxUZSk6bnVsbCxlLlk9MCxlLkQuTmI9MCxlLkQud2E9ZS53YSxlLkQuWT1lLlksMDxlLkFhJiYoZS5ELlkrPWQpLHQoITApLGUub2M9dSxlLnBjPWgsaCs9ODMyLGUueWE9aShtLERlKSxlLmFhPTAsZS5ELnlhPWUueWEsZS5ELmFhPWUuYWEsMj09ZS5BYSYmKGUuRC5hYSs9ZCksZS5SPTE2KmQsZS5CPTgqZCxkPShmPVRuW2UuTF0pKmUuUixmPWYvMiplLkIsZS5zYT11LGUudGE9aCtkLGUucWE9ZS5zYSxlLnJhPWUudGErMTYqbyplLlIrZixlLkhhPWUucWEsZS5JYT1lLnJhKzgqbyplLkIrZixlLiRjPTAsaCs9bCxlLm1iPWM/dTpudWxsLGUubmI9Yz9oOm51bGwsdChoK2M8PWUuRmMrZS5WYiksWmUoZSksbihlLkFjLGUuQmMsMCxhKSxvPTF9fWlmKG8pe2lmKEEua2E9MCxBLnk9ZS5zYSxBLk89ZS50YSxBLmY9ZS5xYSxBLk49ZS5yYSxBLmVhPWUuSGEsQS5WZD1lLklhLEEuZmE9ZS5SLEEuUmM9ZS5CLEEuRj1udWxsLEEuSj0wLCFVcil7Zm9yKG89LTI1NTsyNTU+PW87KytvKWpyWzI1NStvXT0wPm8/LW86bztmb3Iobz0tMTAyMDsxMDIwPj1vOysrbyl4clsxMDIwK29dPS0xMjg+bz8tMTI4OjEyNzxvPzEyNzpvO2ZvcihvPS0xMTI7MTEyPj1vOysrbylGclsxMTIrb109LTE2Pm8/LTE2OjE1PG8/MTU6bztmb3Iobz0tMjU1OzUxMD49bzsrK28pUXJbMjU1K29dPTA+bz8wOjI1NTxvPzI1NTpvO1VyPTF9cnI9YXQsbnI9bnQsaXI9c3Qsb3I9aXQsYXI9b3Qsc3I9cnQsbHI9cXQsY3I9V3QsdXI9SnQsaHI9WnQsZHI9WHQsZnI9WXQscHI9JHQsZ3I9ZUEsbXI9RHQsd3I9UnQsQnI9S3QseXI9VnQsdW5bMF09Q3QsdW5bMV09Y3QsdW5bMl09dnQsdW5bM109YnQsdW5bNF09X3QsdW5bNV09eHQsdW5bNl09anQsdW5bN109RnQsdW5bOF09VXQsdW5bOV09UXQsY25bMF09Z3QsY25bMV09aHQsY25bMl09ZHQsY25bM109ZnQsY25bNF09bXQsY25bNV09d3QsY25bNl09QnQsaG5bMF09SXQsaG5bMV09dXQsaG5bMl09RXQsaG5bM109U3QsaG5bNF09a3QsaG5bNV09TnQsaG5bNl09SHQsbz0xfWVsc2Ugbz0wfW8mJihvPWZ1bmN0aW9uKGUsQSl7Zm9yKGUuTT0wO2UuTTxlLlZhOysrZS5NKXt2YXIgaSxvPWUuSmNbZS5NJmUuWGJdLGE9ZS5tLGw9ZTtmb3IoaT0wO2k8bC56YTsrK2kpe3ZhciBjPWEsdT1sLGg9dS5BYyxkPXUuQmMrNCppLGY9dS56YyxwPXUueWFbdS5hYStpXTtpZih1LlFhLkJiP3AuJGI9UShjLHUuUGEuamJbMF0pPzIrUShjLHUuUGEuamJbMl0pOlEoYyx1LlBhLmpiWzFdKTpwLiRiPTAsdS5rYyYmKHAuQWQ9UShjLHUuQmQpKSxwLlphPSFRKGMsMTQ1KSswLHAuWmEpe3ZhciBnPXAuT2IsbT0wO2Zvcih1PTA7ND51OysrdSl7dmFyIHcsQj1mWzArdV07Zm9yKHc9MDs0Pnc7Kyt3KXtCPW9uW2hbZCt3XV1bQl07Zm9yKHZhciB5PW5uW1EoYyxCWzBdKV07MDx5Oyl5PW5uWzIqeStRKGMsQlt5XSldO0I9LXksaFtkK3ddPUJ9cihnLG0saCxkLDQpLG0rPTQsZlswK3VdPUJ9fWVsc2UgQj1RKGMsMTU2KT9RKGMsMTI4KT8xOjM6UShjLDE2Myk/MjowLHAuT2JbMF09QixuKGgsZCxCLDQpLG4oZiwwLEIsNCk7cC5EZD1RKGMsMTQyKT9RKGMsMTE0KT9RKGMsMTgzKT8xOjM6MjowfWlmKGwubS5LYSlyZXR1cm4gV2UoZSw3LCJQcmVtYXR1cmUgZW5kLW9mLXBhcnRpdGlvbjAgZW5jb3VudGVyZWQuIik7Zm9yKDtlLmphPGUuemE7KytlLmphKXtpZihsPW8sYz0oYT1lKS5yYlthLnNiLTFdLGg9YS5yYlthLnNiK2EuamFdLGk9YS55YVthLmFhK2EuamFdLGQ9YS5rYz9pLkFkOjApYy5sYT1oLmxhPTAsaS5aYXx8KGMuTmE9aC5OYT0wKSxpLkhjPTAsaS5HYz0wLGkuaWE9MDtlbHNle3ZhciB2LGI7aWYoYz1oLGg9bCxkPWEuUGEuWGMsZj1hLnlhW2EuYWErYS5qYV0scD1hLnBiW2YuJGJdLHU9Zi5hZCxnPTAsbT1hLnJiW2Euc2ItMV0sQj13PTAsbih1LGcsMCwzODQpLGYuWmEpdmFyIEM9MCxfPWRbM107ZWxzZXt5PXMoMTYpO3ZhciBqPWMuTmErbS5OYTtpZihqPXRuKGgsZFsxXSxqLHAuRWIsMCx5LDApLGMuTmE9bS5OYT0oMDxqKSswLDE8ailycih5LDAsdSxnKTtlbHNle3ZhciB4PXlbMF0rMz4+Mztmb3IoeT0wOzI1Nj55O3krPTE2KXVbZyt5XT14fUM9MSxfPWRbMF19dmFyIEY9MTUmYy5sYSxVPTE1Jm0ubGE7Zm9yKHk9MDs0Pnk7Kyt5KXt2YXIgRT0xJlU7Zm9yKHg9Yj0wOzQ+eDsrK3gpRj1GPj4xfChFPShqPXRuKGgsXyxqPUUrKDEmRikscC5TYyxDLHUsZykpPkMpPDw3LGI9Yjw8MnwoMzxqPzM6MTxqPzI6MCE9dVtnKzBdKSxnKz0xNjtGPj49NCxVPVU+PjF8RTw8Nyx3PSh3PDw4fGIpPj4+MH1mb3IoXz1GLEM9VT4+NCx2PTA7ND52O3YrPTIpe2ZvcihiPTAsRj1jLmxhPj40K3YsVT1tLmxhPj40K3YseT0wOzI+eTsrK3kpe2ZvcihFPTEmVSx4PTA7Mj54OysreClqPUUrKDEmRiksRj1GPj4xfChFPTA8KGo9dG4oaCxkWzJdLGoscC5RYywwLHUsZykpKTw8MyxiPWI8PDJ8KDM8aj8zOjE8aj8yOjAhPXVbZyswXSksZys9MTY7Rj4+PTIsVT1VPj4xfEU8PDV9Qnw9Yjw8NCp2LF98PUY8PDQ8PHYsQ3w9KDI0MCZVKTw8dn1jLmxhPV8sbS5sYT1DLGYuSGM9dyxmLkdjPUIsZi5pYT00MzY5MCZCPzA6cC5pYSxkPSEod3xCKX1pZigwPGEuTCYmKGEud2FbYS5ZK2EuamFdPWEuZ2RbaS4kYl1baS5aYV0sYS53YVthLlkrYS5qYV0uTGF8PSFkKSxsLkthKXJldHVybiBXZShlLDcsIlByZW1hdHVyZSBlbmQtb2YtZmlsZSBlbmNvdW50ZXJlZC4iKX1pZihaZShlKSxhPUEsbD0xLGk9KG89ZSkuRCxjPTA8by5MJiZvLk0+PW8uemImJm8uTTw9by5WYSwwPT1vLkFhKXQ6e2lmKGkuTT1vLk0saS51Yz1jLExBKG8saSksbD0xLGk9KGI9by5EKS5OYixjPShCPVRuW28uTF0pKm8uUixoPUIvMipvLkIseT0xNippKm8uUix4PTgqaSpvLkIsZD1vLnNhLGY9by50YS1jK3kscD1vLnFhLHU9by5yYS1oK3gsZz1vLkhhLG09by5JYS1oK3gsVT0wPT0oRj1iLk0pLHc9Rj49by5WYS0xLDI9PW8uQWEmJkxBKG8sYiksYi51Yylmb3IoRT0oaj1vKS5ELk0sdChqLkQudWMpLGI9ai55YjtiPGouSGI7KytiKXtDPWIsXz1FO3ZhciBTPShMPShEPWopLkQpLk5iO3Y9RC5SO3ZhciBMPUwud2FbTC5ZK0NdLEk9RC5zYSxOPUQudGErMTYqUyp2KzE2KkMsaz1MLmRkLEg9TC50YztpZigwIT1IKWlmKHQoMzw9SCksMT09RC5MKTA8QyYmd3IoSSxOLHYsSCs0KSxMLkxhJiZ5cihJLE4sdixIKSwwPF8mJm1yKEksTix2LEgrNCksTC5MYSYmQnIoSSxOLHYsSCk7ZWxzZXt2YXIgUD1ELkIsVD1ELnFhLE89RC5yYSs4KlMqUCs4KkMsTT1ELkhhLEQ9RC5JYSs4KlMqUCs4KkM7Uz1MLmxkLDA8QyYmKGNyKEksTix2LEgrNCxrLFMpLGhyKFQsTyxNLEQsUCxIKzQsayxTKSksTC5MYSYmKGZyKEksTix2LEgsayxTKSxncihULE8sTSxELFAsSCxrLFMpKSwwPF8mJihscihJLE4sdixIKzQsayxTKSx1cihULE8sTSxELFAsSCs0LGssUykpLEwuTGEmJihkcihJLE4sdixILGssUykscHIoVCxPLE0sRCxQLEgsayxTKSl9fWlmKG8uaWEmJmFsZXJ0KCJ0b2RvOkRpdGhlclJvdyIpLG51bGwhPWEucHV0KXtpZihiPTE2KkYsRj0xNiooRisxKSxVPyhhLnk9by5zYSxhLk89by50YSt5LGEuZj1vLnFhLGEuTj1vLnJhK3gsYS5lYT1vLkhhLGEuVz1vLklhK3gpOihiLT1CLGEueT1kLGEuTz1mLGEuZj1wLGEuTj11LGEuZWE9ZyxhLlc9bSksd3x8KEYtPUIpLEY+YS5vJiYoRj1hLm8pLGEuRj1udWxsLGEuSj1udWxsLG51bGwhPW8uRmEmJjA8by5GYS5sZW5ndGgmJmI8RiYmKGEuSj1jQShvLGEsYixGLWIpLGEuRj1vLm1iLG51bGw9PWEuRiYmMD09YS5GLmxlbmd0aCkpe2w9V2UobywzLCJDb3VsZCBub3QgZGVjb2RlIGFscGhhIGRhdGEuIik7YnJlYWsgdH1iPGEuaiYmKEI9YS5qLWIsYj1hLmosdCghKDEmQikpLGEuTys9by5SKkIsYS5OKz1vLkIqKEI+PjEpLGEuVys9by5CKihCPj4xKSxudWxsIT1hLkYmJihhLkorPWEud2lkdGgqQikpLGI8RiYmKGEuTys9YS52LGEuTis9YS52Pj4xLGEuVys9YS52Pj4xLG51bGwhPWEuRiYmKGEuSis9YS52KSxhLmthPWItYS5qLGEuVT1hLnZhLWEudixhLlQ9Ri1iLGw9YS5wdXQoYSkpfWkrMSE9by5JY3x8d3x8KHIoby5zYSxvLnRhLWMsZCxmKzE2Km8uUixjKSxyKG8ucWEsby5yYS1oLHAsdSs4Km8uQixoKSxyKG8uSGEsby5JYS1oLGcsbSs4Km8uQixoKSl9aWYoIWwpcmV0dXJuIFdlKGUsNiwiT3V0cHV0IGFib3J0ZWQuIil9cmV0dXJuIDF9KGUsQSkpLG51bGwhPUEuYmMmJkEuYmMoQSksbyY9MX1yZXR1cm4gbz8oZS5jYj0wLG8pOjB9KShlLGEpfHwoQT1lLmEpfX1lbHNlIEE9ZS5hfTA9PUEmJm51bGwhPXUuT2EmJnUuT2EuZmQmJihBPWtBKHUuYmEpKX11PUF9Yz0wIT11P251bGw6MTE+Yz9oLmYuUkdCQS5lYjpoLmYua2IueX1lbHNlIGM9bnVsbDtyZXR1cm4gY307dmFyIE1uPVszLDQsMyw0LDQsMiwyLDQsNCw0LDIsMSwxXX07ZnVuY3Rpb24gbChlLHQpe2Zvcih2YXIgQT0iIixyPTA7cjw0O3IrKylBKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbdCsrXSk7cmV0dXJuIEF9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiBlW3QrMF18ZVt0KzFdPDw4fWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4oZVt0KzBdfGVbdCsxXTw8OHxlW3QrMl08PDE2KT4+PjB9ZnVuY3Rpb24gaChlLHQpe3JldHVybihlW3QrMF18ZVt0KzFdPDw4fGVbdCsyXTw8MTZ8ZVt0KzNdPDwyNCk+Pj4wfW5ldyBhO3ZhciBkPVswXSxmPVswXSxwPVtdLGc9bmV3IGEsbT1lLHc9ZnVuY3Rpb24oZSx0KXt2YXIgQT17fSxyPTAsbj0hMSxzPTAsaT0wO2lmKEEuZnJhbWVzPVtdLCFmdW5jdGlvbihlLHQpe2Zvcih2YXIgQT0wO0E8NDtBKyspaWYoZVt0K0FdIT0iUklGRiIuY2hhckNvZGVBdChBKSlyZXR1cm4hMDtyZXR1cm4hMX0oZSx0KSl7Zm9yKGgoZSx0Kz00KSx0Kz04O3Q8ZS5sZW5ndGg7KXt2YXIgbz1sKGUsdCksYT1oKGUsdCs9NCk7dCs9NDt2YXIgZD1hKygxJmEpO3N3aXRjaChvKXtjYXNlIlZQOCAiOmNhc2UiVlA4TCI6dm9pZCAwPT09QS5mcmFtZXNbcl0mJihBLmZyYW1lc1tyXT17fSksKGc9QS5mcmFtZXNbcl0pLnNyY19vZmY9bj9pOnQtOCxnLnNyY19zaXplPXMrYSs4LHIrKyxuJiYobj0hMSxzPTAsaT0wKTticmVhaztjYXNlIlZQOFgiOihnPUEuaGVhZGVyPXt9KS5mZWF0dXJlX2ZsYWdzPWVbdF07dmFyIGY9dCs0O2cuY2FudmFzX3dpZHRoPTErdShlLGYpLGYrPTMsZy5jYW52YXNfaGVpZ2h0PTErdShlLGYpLGYrPTM7YnJlYWs7Y2FzZSJBTFBIIjpuPSEwLHM9ZCs4LGk9dC04O2JyZWFrO2Nhc2UiQU5JTSI6KGc9QS5oZWFkZXIpLmJnY29sb3I9aChlLHQpLGY9dCs0LGcubG9vcF9jb3VudD1jKGUsZiksZis9MjticmVhaztjYXNlIkFOTUYiOnZhciBwLGc7KGc9QS5mcmFtZXNbcl09e30pLm9mZnNldF94PTIqdShlLHQpLHQrPTMsZy5vZmZzZXRfeT0yKnUoZSx0KSx0Kz0zLGcud2lkdGg9MSt1KGUsdCksdCs9MyxnLmhlaWdodD0xK3UoZSx0KSx0Kz0zLGcuZHVyYXRpb249dShlLHQpLHQrPTMscD1lW3QrK10sZy5kaXNwb3NlPTEmcCxnLmJsZW5kPXA+PjEmMX0iQU5NRiIhPW8mJih0Kz1kKX1yZXR1cm4gQX19KG0sMCk7dy5yZXNwb25zZT1tLHcucmdiYW91dHB1dD0hMCx3LmRhdGF1cmw9ITE7dmFyIEI9dy5oZWFkZXI/dy5oZWFkZXI6bnVsbCx5PXcuZnJhbWVzP3cuZnJhbWVzOm51bGw7aWYoQil7Qi5sb29wX2NvdW50ZXI9Qi5sb29wX2NvdW50LGQ9W0IuY2FudmFzX2hlaWdodF0sZj1bQi5jYW52YXNfd2lkdGhdO2Zvcih2YXIgdj0wO3Y8eS5sZW5ndGgmJjAhPXlbdl0uYmxlbmQ7disrKTt9dmFyIGI9eVswXSxDPWcuV2ViUERlY29kZVJHQkEobSxiLnNyY19vZmYsYi5zcmNfc2l6ZSxmLGQpO2IucmdiYT1DLGIuaW1nd2lkdGg9ZlswXSxiLmltZ2hlaWdodD1kWzBdO2Zvcih2YXIgXz0wO188ZlswXSpkWzBdKjQ7XysrKXBbX109Q1tfXTtyZXR1cm4gdGhpcy53aWR0aD1mLHRoaXMuaGVpZ2h0PWQsdGhpcy5kYXRhPXAsdGhpc30hZnVuY3Rpb24oZSl7dmFyIHQsQSxuLHMsaSxvLGEsYyx1LGg9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9ZXx8e30sdGhpcy5pc1N0cm9rZVRyYW5zcGFyZW50PWUuaXNTdHJva2VUcmFuc3BhcmVudHx8ITEsdGhpcy5zdHJva2VPcGFjaXR5PWUuc3Ryb2tlT3BhY2l0eXx8MSx0aGlzLnN0cm9rZVN0eWxlPWUuc3Ryb2tlU3R5bGV8fCIjMDAwMDAwIix0aGlzLmZpbGxTdHlsZT1lLmZpbGxTdHlsZXx8IiMwMDAwMDAiLHRoaXMuaXNGaWxsVHJhbnNwYXJlbnQ9ZS5pc0ZpbGxUcmFuc3BhcmVudHx8ITEsdGhpcy5maWxsT3BhY2l0eT1lLmZpbGxPcGFjaXR5fHwxLHRoaXMuZm9udD1lLmZvbnR8fCIxMHB4IHNhbnMtc2VyaWYiLHRoaXMudGV4dEJhc2VsaW5lPWUudGV4dEJhc2VsaW5lfHwiYWxwaGFiZXRpYyIsdGhpcy50ZXh0QWxpZ249ZS50ZXh0QWxpZ258fCJsZWZ0Iix0aGlzLmxpbmVXaWR0aD1lLmxpbmVXaWR0aHx8MSx0aGlzLmxpbmVKb2luPWUubGluZUpvaW58fCJtaXRlciIsdGhpcy5saW5lQ2FwPWUubGluZUNhcHx8ImJ1dHQiLHRoaXMucGF0aD1lLnBhdGh8fFtdLHRoaXMudHJhbnNmb3JtPXZvaWQgMCE9PWUudHJhbnNmb3JtP2UudHJhbnNmb3JtLmNsb25lKCk6bmV3IGMsdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249ZS5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb258fCJub3JtYWwiLHRoaXMuZ2xvYmFsQWxwaGE9ZS5nbG9iYWxBbHBoYXx8MSx0aGlzLmNsaXBfcGF0aD1lLmNsaXBfcGF0aHx8W10sdGhpcy5jdXJyZW50UG9pbnQ9ZS5jdXJyZW50UG9pbnR8fG5ldyBvLHRoaXMubWl0ZXJMaW1pdD1lLm1pdGVyTGltaXR8fDEwLHRoaXMubGFzdFBvaW50PWUubGFzdFBvaW50fHxuZXcgbyx0aGlzLmxpbmVEYXNoT2Zmc2V0PWUubGluZURhc2hPZmZzZXR8fDAsdGhpcy5saW5lRGFzaD1lLmxpbmVEYXNofHxbXSx0aGlzLm1hcmdpbj1lLm1hcmdpbnx8WzAsMCwwLDBdLHRoaXMucHJldlBhZ2VMYXN0RWxlbU9mZnNldD1lLnByZXZQYWdlTGFzdEVsZW1PZmZzZXR8fDAsdGhpcy5pZ25vcmVDbGVhclJlY3Q9ImJvb2xlYW4iIT10eXBlb2YgZS5pZ25vcmVDbGVhclJlY3R8fGUuaWdub3JlQ2xlYXJSZWN0LHRoaXN9O2UuZXZlbnRzLnB1c2goWyJpbml0aWFsaXplZCIsZnVuY3Rpb24oKXt0aGlzLmNvbnRleHQyZD1uZXcgZCh0aGlzKSx0PXRoaXMuaW50ZXJuYWwuZjIsQT10aGlzLmludGVybmFsLmdldENvb3JkaW5hdGVTdHJpbmcsbj10aGlzLmludGVybmFsLmdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZyxzPXRoaXMuaW50ZXJuYWwuZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGUsaT10aGlzLmludGVybmFsLmdldFZlcnRpY2FsQ29vcmRpbmF0ZSxvPXRoaXMuaW50ZXJuYWwuUG9pbnQsYT10aGlzLmludGVybmFsLlJlY3RhbmdsZSxjPXRoaXMuaW50ZXJuYWwuTWF0cml4LHU9bmV3IGh9XSk7dmFyIGQ9ZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhbnZhcyIse2dldDpmdW5jdGlvbigpe3JldHVybntwYXJlbnROb2RlOiExLHN0eWxlOiExfX19KTt2YXIgdD1lO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwZGYiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH19KTt2YXIgQT0hMTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFnZVdyYXBYRW5hYmxlZCIse2dldDpmdW5jdGlvbigpe3JldHVybiBBfSxzZXQ6ZnVuY3Rpb24oZSl7QT1Cb29sZWFuKGUpfX0pO3ZhciByPSExO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwYWdlV3JhcFlFbmFibGVkIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHNldDpmdW5jdGlvbihlKXtyPUJvb2xlYW4oZSl9fSk7dmFyIG49MDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicG9zWCIse2dldDpmdW5jdGlvbigpe3JldHVybiBufSxzZXQ6ZnVuY3Rpb24oZSl7aXNOYU4oZSl8fChuPWUpfX0pO3ZhciBzPTA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBvc1kiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gc30sc2V0OmZ1bmN0aW9uKGUpe2lzTmFOKGUpfHwocz1lKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibWFyZ2luIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUubWFyZ2lufSxzZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ7Im51bWJlciI9PXR5cGVvZiBlP3Q9W2UsZSxlLGVdOigodD1uZXcgQXJyYXkoNCkpWzBdPWVbMF0sdFsxXT1lLmxlbmd0aD49Mj9lWzFdOnRbMF0sdFsyXT1lLmxlbmd0aD49Mz9lWzJdOnRbMF0sdFszXT1lLmxlbmd0aD49ND9lWzNdOnRbMV0pLHUubWFyZ2luPXR9fSk7dmFyIGk9ITE7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImF1dG9QYWdpbmciLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sc2V0OmZ1bmN0aW9uKGUpe2k9ZX19KTt2YXIgbz0wO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsYXN0QnJlYWsiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb30sc2V0OmZ1bmN0aW9uKGUpe289ZX19KTt2YXIgYT1bXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFnZUJyZWFrcyIse2dldDpmdW5jdGlvbigpe3JldHVybiBhfSxzZXQ6ZnVuY3Rpb24oZSl7YT1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdHgiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX0sc2V0OmZ1bmN0aW9uKGUpe2UgaW5zdGFuY2VvZiBoJiYodT1lKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGF0aCIse2dldDpmdW5jdGlvbigpe3JldHVybiB1LnBhdGh9LHNldDpmdW5jdGlvbihlKXt1LnBhdGg9ZX19KTt2YXIgbD1bXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3R4U3RhY2siLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbH0sc2V0OmZ1bmN0aW9uKGUpe2w9ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZmlsbFN0eWxlIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3R4LmZpbGxTdHlsZX0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0O3Q9cChlKSx0aGlzLmN0eC5maWxsU3R5bGU9dC5zdHlsZSx0aGlzLmN0eC5pc0ZpbGxUcmFuc3BhcmVudD0wPT09dC5hLHRoaXMuY3R4LmZpbGxPcGFjaXR5PXQuYSx0aGlzLnBkZi5zZXRGaWxsQ29sb3IodC5yLHQuZyx0LmIse2E6dC5hfSksdGhpcy5wZGYuc2V0VGV4dENvbG9yKHQucix0LmcsdC5iLHthOnQuYX0pfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzdHJva2VTdHlsZSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN0eC5zdHJva2VTdHlsZX0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0PXAoZSk7dGhpcy5jdHguc3Ryb2tlU3R5bGU9dC5zdHlsZSx0aGlzLmN0eC5pc1N0cm9rZVRyYW5zcGFyZW50PTA9PT10LmEsdGhpcy5jdHguc3Ryb2tlT3BhY2l0eT10LmEsMD09PXQuYT90aGlzLnBkZi5zZXREcmF3Q29sb3IoMjU1LDI1NSwyNTUpOih0LmEsdGhpcy5wZGYuc2V0RHJhd0NvbG9yKHQucix0LmcsdC5iKSl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxpbmVDYXAiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHgubGluZUNhcH0sc2V0OmZ1bmN0aW9uKGUpey0xIT09WyJidXR0Iiwicm91bmQiLCJzcXVhcmUiXS5pbmRleE9mKGUpJiYodGhpcy5jdHgubGluZUNhcD1lLHRoaXMucGRmLnNldExpbmVDYXAoZSkpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsaW5lV2lkdGgiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHgubGluZVdpZHRofSxzZXQ6ZnVuY3Rpb24oZSl7aXNOYU4oZSl8fCh0aGlzLmN0eC5saW5lV2lkdGg9ZSx0aGlzLnBkZi5zZXRMaW5lV2lkdGgoZSkpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsaW5lSm9pbiIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN0eC5saW5lSm9pbn0sc2V0OmZ1bmN0aW9uKGUpey0xIT09WyJiZXZlbCIsInJvdW5kIiwibWl0ZXIiXS5pbmRleE9mKGUpJiYodGhpcy5jdHgubGluZUpvaW49ZSx0aGlzLnBkZi5zZXRMaW5lSm9pbihlKSl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm1pdGVyTGltaXQiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHgubWl0ZXJMaW1pdH0sc2V0OmZ1bmN0aW9uKGUpe2lzTmFOKGUpfHwodGhpcy5jdHgubWl0ZXJMaW1pdD1lLHRoaXMucGRmLnNldE1pdGVyTGltaXQoZSkpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0ZXh0QmFzZWxpbmUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHgudGV4dEJhc2VsaW5lfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5jdHgudGV4dEJhc2VsaW5lPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRleHRBbGlnbiIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN0eC50ZXh0QWxpZ259LHNldDpmdW5jdGlvbihlKXstMSE9PVsicmlnaHQiLCJlbmQiLCJjZW50ZXIiLCJsZWZ0Iiwic3RhcnQiXS5pbmRleE9mKGUpJiYodGhpcy5jdHgudGV4dEFsaWduPWUpfX0pO3ZhciBjPW51bGwsZD1udWxsO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmb250RmFjZXMiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sc2V0OmZ1bmN0aW9uKGUpe2M9bnVsbCxkPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZvbnQiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHguZm9udH0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0O2lmKHRoaXMuY3R4LmZvbnQ9ZSxudWxsIT09KHQ9L15ccyooPz0oPzooPzpbLWEtel0rXHMqKXswLDJ9KGl0YWxpY3xvYmxpcXVlKSk/KSg/PSg/Oig/OlstYS16XStccyopezAsMn0oc21hbGwtY2FwcykpPykoPz0oPzooPzpbLWEtel0rXHMqKXswLDJ9KGJvbGQoPzplcik/fGxpZ2h0ZXJ8WzEtOV0wMCkpPykoPzooPzpub3JtYWx8XDF8XDJ8XDMpXHMqKXswLDN9KCg/Onh4Py0pPyg/OnNtYWxsfGxhcmdlKXxtZWRpdW18c21hbGxlcnxsYXJnZXJ8Wy5cZF0rKD86XCV8aW58W2NlbV1tfGV4fHBbY3R4XSkpKD86XHMqXC9ccyoobm9ybWFsfFsuXGRdKyg/OlwlfGlufFtjZW1dbXxleHxwW2N0eF0pKSk/XHMqKFstXyxcIlwnXHNhLXpdKz8pXHMqJC9pLmV4ZWMoZSkpKXt2YXIgQT10WzFdO3RbMl07dmFyIHI9dFszXSxuPXRbNF07dFs1XTt2YXIgcz10WzZdLGk9L14oWy5cZF0rKSgoPzolfGlufFtjZW1dbXxleHxwW2N0eF0pKSQvaS5leGVjKG4pWzJdO249InB4Ij09PWk/TWF0aC5mbG9vcihwYXJzZUZsb2F0KG4pKnRoaXMucGRmLmludGVybmFsLnNjYWxlRmFjdG9yKToiZW0iPT09aT9NYXRoLmZsb29yKHBhcnNlRmxvYXQobikqdGhpcy5wZGYuZ2V0Rm9udFNpemUoKSk6TWF0aC5mbG9vcihwYXJzZUZsb2F0KG4pKnRoaXMucGRmLmludGVybmFsLnNjYWxlRmFjdG9yKSx0aGlzLnBkZi5zZXRGb250U2l6ZShuKTt2YXIgbz1mdW5jdGlvbihlKXt2YXIgdCxBLHI9W10sbj1lLnRyaW0oKTtpZigiIj09PW4pcmV0dXJuIFplO2lmKG4gaW4gT2UpcmV0dXJuW09lW25dXTtmb3IoOyIiIT09bjspe3N3aXRjaChBPW51bGwsdD0obj1EZShuKSkuY2hhckF0KDApKXtjYXNlJyInOmNhc2UiJyI6QT1SZShuLnN1YnN0cmluZygxKSx0KTticmVhaztkZWZhdWx0OkE9S2Uobil9aWYobnVsbD09PUEpcmV0dXJuIFplO2lmKHIucHVzaChBWzBdKSwiIiE9PShuPURlKEFbMV0pKSYmIiwiIT09bi5jaGFyQXQoMCkpcmV0dXJuIFplO249bi5yZXBsYWNlKC9eLC8sIiIpfXJldHVybiByfShzKTtpZih0aGlzLmZvbnRGYWNlcyl7dmFyIGE9ZnVuY3Rpb24oZSx0KXtpZihudWxsPT09Yyl7dmFyIEE9ZnVuY3Rpb24oZSl7dmFyIHQ9W107cmV0dXJuIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oQSl7ZVtBXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciByPW51bGw7c3dpdGNoKGUpe2Nhc2UiYm9sZCI6cj17ZmFtaWx5OkEsd2VpZ2h0OiJib2xkIn07YnJlYWs7Y2FzZSJpdGFsaWMiOnI9e2ZhbWlseTpBLHN0eWxlOiJpdGFsaWMifTticmVhaztjYXNlImJvbGRpdGFsaWMiOnI9e2ZhbWlseTpBLHdlaWdodDoiYm9sZCIsc3R5bGU6Iml0YWxpYyJ9O2JyZWFrO2Nhc2UiIjpjYXNlIm5vcm1hbCI6cj17ZmFtaWx5OkF9fW51bGwhPT1yJiYoci5yZWY9e25hbWU6QSxzdHlsZTplfSx0LnB1c2gocikpfSl9KSx0fShlLmdldEZvbnRMaXN0KCkpO2M9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXt9LEE9MDtBPGUubGVuZ3RoOysrQSl7dmFyIHI9SGUoZVtBXSksbj1yLmZhbWlseSxzPXIuc3RyZXRjaCxpPXIuc3R5bGUsbz1yLndlaWdodDt0W25dPXRbbl18fHt9LHRbbl1bc109dFtuXVtzXXx8e30sdFtuXVtzXVtpXT10W25dW3NdW2ldfHx7fSx0W25dW3NdW2ldW29dPXJ9cmV0dXJuIHR9KEEuY29uY2F0KHQpKX1yZXR1cm4gY30odGhpcy5wZGYsdGhpcy5mb250RmFjZXMpLGw9by5tYXAoZnVuY3Rpb24oZSl7cmV0dXJue2ZhbWlseTplLHN0cmV0Y2g6Im5vcm1hbCIsd2VpZ2h0OnIsc3R5bGU6QX19KSx1PWZ1bmN0aW9uKGUsdCxBKXtmb3IodmFyIHI9KEE9QXx8e30pLmRlZmF1bHRGb250RmFtaWx5fHwidGltZXMiLG49T2JqZWN0LmFzc2lnbih7fSxUZSxBLmdlbmVyaWNGb250RmFtaWxpZXN8fHt9KSxzPW51bGwsaT1udWxsLG89MDtvPHQubGVuZ3RoOysrbylpZihuWyhzPUhlKHRbb10pKS5mYW1pbHldJiYocy5mYW1pbHk9bltzLmZhbWlseV0pLGUuaGFzT3duUHJvcGVydHkocy5mYW1pbHkpKXtpPWVbcy5mYW1pbHldO2JyZWFrfWlmKCEoaT1pfHxlW3JdKSl0aHJvdyBuZXcgRXJyb3IoIkNvdWxkIG5vdCBmaW5kIGEgZm9udC1mYW1pbHkgZm9yIHRoZSBydWxlICciK01lKHMpKyInIGFuZCBkZWZhdWx0IGZhbWlseSAnIityKyInLiIpO2lmKGk9ZnVuY3Rpb24oZSx0KXtpZih0W2VdKXJldHVybiB0W2VdO3ZhciBBPUllW2VdLHI9QTw9SWUubm9ybWFsPy0xOjEsbj1QZSh0LExlLEEscik7aWYoIW4pdGhyb3cgbmV3IEVycm9yKCJDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIGZvbnQtc3RyZXRjaCB2YWx1ZSBmb3IgIitlKTtyZXR1cm4gbn0ocy5zdHJldGNoLGkpLGk9ZnVuY3Rpb24oZSx0KXtpZih0W2VdKXJldHVybiB0W2VdO2Zvcih2YXIgQT1TZVtlXSxyPTA7cjxBLmxlbmd0aDsrK3IpaWYodFtBW3JdXSlyZXR1cm4gdFtBW3JdXTt0aHJvdyBuZXcgRXJyb3IoIkNvdWxkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgZm9udC1zdHlsZSBmb3IgIitlKX0ocy5zdHlsZSxpKSwhKGk9ZnVuY3Rpb24oZSx0KXtpZih0W2VdKXJldHVybiB0W2VdO2lmKDQwMD09PWUmJnRbNTAwXSlyZXR1cm4gdFs1MDBdO2lmKDUwMD09PWUmJnRbNDAwXSlyZXR1cm4gdFs0MDBdO3ZhciBBPWtlW2VdLHI9UGUodCxOZSxBLGU8NDAwPy0xOjEpO2lmKCFyKXRocm93IG5ldyBFcnJvcigiQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyBmb250LXdlaWdodCBmb3IgdmFsdWUgIitlKTtyZXR1cm4gcn0ocy53ZWlnaHQsaSkpKXRocm93IG5ldyBFcnJvcigiRmFpbGVkIHRvIHJlc29sdmUgYSBmb250IGZvciB0aGUgcnVsZSAnIitNZShzKSsiJy4iKTtyZXR1cm4gaX0oYSxsKTt0aGlzLnBkZi5zZXRGb250KHUucmVmLm5hbWUsdS5yZWYuc3R5bGUpfWVsc2V7dmFyIGg9IiI7KCJib2xkIj09PXJ8fHBhcnNlSW50KHIsMTApPj03MDB8fCJib2xkIj09PUEpJiYoaD0iYm9sZCIpLCJpdGFsaWMiPT09QSYmKGgrPSJpdGFsaWMiKSwwPT09aC5sZW5ndGgmJihoPSJub3JtYWwiKTtmb3IodmFyIGQ9IiIsZj17YXJpYWw6IkhlbHZldGljYSIsQXJpYWw6IkhlbHZldGljYSIsdmVyZGFuYToiSGVsdmV0aWNhIixWZXJkYW5hOiJIZWx2ZXRpY2EiLGhlbHZldGljYToiSGVsdmV0aWNhIixIZWx2ZXRpY2E6IkhlbHZldGljYSIsInNhbnMtc2VyaWYiOiJIZWx2ZXRpY2EiLGZpeGVkOiJDb3VyaWVyIixtb25vc3BhY2U6IkNvdXJpZXIiLHRlcm1pbmFsOiJDb3VyaWVyIixjdXJzaXZlOiJUaW1lcyIsZmFudGFzeToiVGltZXMiLHNlcmlmOiJUaW1lcyJ9LHA9MDtwPG8ubGVuZ3RoO3ArKyl7aWYodm9pZCAwIT09dGhpcy5wZGYuaW50ZXJuYWwuZ2V0Rm9udChvW3BdLGgse25vRmFsbGJhY2s6ITAsZGlzYWJsZVdhcm5pbmc6ITB9KSl7ZD1vW3BdO2JyZWFrfWlmKCJib2xkaXRhbGljIj09PWgmJnZvaWQgMCE9PXRoaXMucGRmLmludGVybmFsLmdldEZvbnQob1twXSwiYm9sZCIse25vRmFsbGJhY2s6ITAsZGlzYWJsZVdhcm5pbmc6ITB9KSlkPW9bcF0saD0iYm9sZCI7ZWxzZSBpZih2b2lkIDAhPT10aGlzLnBkZi5pbnRlcm5hbC5nZXRGb250KG9bcF0sIm5vcm1hbCIse25vRmFsbGJhY2s6ITAsZGlzYWJsZVdhcm5pbmc6ITB9KSl7ZD1vW3BdLGg9Im5vcm1hbCI7YnJlYWt9fWlmKCIiPT09ZClmb3IodmFyIGc9MDtnPG8ubGVuZ3RoO2crKylpZihmW29bZ11dKXtkPWZbb1tnXV07YnJlYWt9ZD0iIj09PWQ/IlRpbWVzIjpkLHRoaXMucGRmLnNldEZvbnQoZCxoKX19fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9ufSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImdsb2JhbEFscGhhIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3R4Lmdsb2JhbEFscGhhfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5jdHguZ2xvYmFsQWxwaGE9ZX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibGluZURhc2hPZmZzZXQiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHgubGluZURhc2hPZmZzZXR9LHNldDpmdW5jdGlvbihlKXt0aGlzLmN0eC5saW5lRGFzaE9mZnNldD1lLE0uY2FsbCh0aGlzKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibGluZURhc2giLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHgubGluZURhc2h9LHNldDpmdW5jdGlvbihlKXt0aGlzLmN0eC5saW5lRGFzaD1lLE0uY2FsbCh0aGlzKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaWdub3JlQ2xlYXJSZWN0Iix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3R4Lmlnbm9yZUNsZWFyUmVjdH0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuY3R4Lmlnbm9yZUNsZWFyUmVjdD1Cb29sZWFuKGUpfX0pfTtkLnByb3RvdHlwZS5zZXRMaW5lRGFzaD1mdW5jdGlvbihlKXt0aGlzLmxpbmVEYXNoPWV9LGQucHJvdG90eXBlLmdldExpbmVEYXNoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZURhc2gubGVuZ3RoJTI/dGhpcy5saW5lRGFzaC5jb25jYXQodGhpcy5saW5lRGFzaCk6dGhpcy5saW5lRGFzaC5zbGljZSgpfSxkLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKCl7Qy5jYWxsKHRoaXMsImZpbGwiLCExKX0sZC5wcm90b3R5cGUuc3Ryb2tlPWZ1bmN0aW9uKCl7Qy5jYWxsKHRoaXMsInN0cm9rZSIsITEpfSxkLnByb3RvdHlwZS5iZWdpblBhdGg9ZnVuY3Rpb24oKXt0aGlzLnBhdGg9W3t0eXBlOiJiZWdpbiJ9XX0sZC5wcm90b3R5cGUubW92ZVRvPWZ1bmN0aW9uKGUsdCl7aWYoaXNOYU4oZSl8fGlzTmFOKHQpKXRocm93IGwuZXJyb3IoImpzUERGLmNvbnRleHQyZC5tb3ZlVG86IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5tb3ZlVG8iKTt2YXIgQT10aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBvKGUsdCkpO3RoaXMucGF0aC5wdXNoKHt0eXBlOiJtdCIseDpBLngseTpBLnl9KSx0aGlzLmN0eC5sYXN0UG9pbnQ9bmV3IG8oZSx0KX0sZC5wcm90b3R5cGUuY2xvc2VQYXRoPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IG8oMCwwKSx0PTA7Zm9yKHQ9dGhpcy5wYXRoLmxlbmd0aC0xOy0xIT09dDt0LS0paWYoImJlZ2luIj09PXRoaXMucGF0aFt0XS50eXBlJiYib2JqZWN0Ij09PSgwLHIuZGVmYXVsdCkodGhpcy5wYXRoW3QrMV0pJiYibnVtYmVyIj09dHlwZW9mIHRoaXMucGF0aFt0KzFdLngpe2U9bmV3IG8odGhpcy5wYXRoW3QrMV0ueCx0aGlzLnBhdGhbdCsxXS55KTticmVha310aGlzLnBhdGgucHVzaCh7dHlwZToiY2xvc2UifSksdGhpcy5jdHgubGFzdFBvaW50PW5ldyBvKGUueCxlLnkpfSxkLnByb3RvdHlwZS5saW5lVG89ZnVuY3Rpb24oZSx0KXtpZihpc05hTihlKXx8aXNOYU4odCkpdGhyb3cgbC5lcnJvcigianNQREYuY29udGV4dDJkLmxpbmVUbzogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLmxpbmVUbyIpO3ZhciBBPXRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IG8oZSx0KSk7dGhpcy5wYXRoLnB1c2goe3R5cGU6Imx0Iix4OkEueCx5OkEueX0pLHRoaXMuY3R4Lmxhc3RQb2ludD1uZXcgbyhBLngsQS55KX0sZC5wcm90b3R5cGUuY2xpcD1mdW5jdGlvbigpe3RoaXMuY3R4LmNsaXBfcGF0aD1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGF0aCkpLEMuY2FsbCh0aGlzLG51bGwsITApfSxkLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvPWZ1bmN0aW9uKGUsdCxBLHIpe2lmKGlzTmFOKEEpfHxpc05hTihyKXx8aXNOYU4oZSl8fGlzTmFOKHQpKXRocm93IGwuZXJyb3IoImpzUERGLmNvbnRleHQyZC5xdWFkcmF0aWNDdXJ2ZVRvOiBJbnZhbGlkIGFyZ3VtZW50cyIsYXJndW1lbnRzKSxuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQucXVhZHJhdGljQ3VydmVUbyIpO3ZhciBuPXRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IG8oQSxyKSkscz10aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBvKGUsdCkpO3RoaXMucGF0aC5wdXNoKHt0eXBlOiJxY3QiLHgxOnMueCx5MTpzLnkseDpuLngseTpuLnl9KSx0aGlzLmN0eC5sYXN0UG9pbnQ9bmV3IG8obi54LG4ueSl9LGQucHJvdG90eXBlLmJlemllckN1cnZlVG89ZnVuY3Rpb24oZSx0LEEscixuLHMpe2lmKGlzTmFOKG4pfHxpc05hTihzKXx8aXNOYU4oZSl8fGlzTmFOKHQpfHxpc05hTihBKXx8aXNOYU4ocikpdGhyb3cgbC5lcnJvcigianNQREYuY29udGV4dDJkLmJlemllckN1cnZlVG86IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5iZXppZXJDdXJ2ZVRvIik7dmFyIGk9dGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5VG9Qb2ludChuZXcgbyhuLHMpKSxhPXRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IG8oZSx0KSksYz10aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBvKEEscikpO3RoaXMucGF0aC5wdXNoKHt0eXBlOiJiY3QiLHgxOmEueCx5MTphLnkseDI6Yy54LHkyOmMueSx4OmkueCx5OmkueX0pLHRoaXMuY3R4Lmxhc3RQb2ludD1uZXcgbyhpLngsaS55KX0sZC5wcm90b3R5cGUuYXJjPWZ1bmN0aW9uKGUsdCxBLHIsbixzKXtpZihpc05hTihlKXx8aXNOYU4odCl8fGlzTmFOKEEpfHxpc05hTihyKXx8aXNOYU4obikpdGhyb3cgbC5lcnJvcigianNQREYuY29udGV4dDJkLmFyYzogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLmFyYyIpO2lmKHM9Qm9vbGVhbihzKSwhdGhpcy5jdHgudHJhbnNmb3JtLmlzSWRlbnRpdHkpe3ZhciBpPXRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IG8oZSx0KSk7ZT1pLngsdD1pLnk7dmFyIGE9dGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5VG9Qb2ludChuZXcgbygwLEEpKSxjPXRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IG8oMCwwKSk7QT1NYXRoLnNxcnQoTWF0aC5wb3coYS54LWMueCwyKStNYXRoLnBvdyhhLnktYy55LDIpKX1NYXRoLmFicyhuLXIpPj0yKk1hdGguUEkmJihyPTAsbj0yKk1hdGguUEkpLHRoaXMucGF0aC5wdXNoKHt0eXBlOiJhcmMiLHg6ZSx5OnQscmFkaXVzOkEsc3RhcnRBbmdsZTpyLGVuZEFuZ2xlOm4sY291bnRlcmNsb2Nrd2lzZTpzfSl9LGQucHJvdG90eXBlLmFyY1RvPWZ1bmN0aW9uKGUsdCxBLHIsbil7dGhyb3cgbmV3IEVycm9yKCJhcmNUbyBub3QgaW1wbGVtZW50ZWQuIil9LGQucHJvdG90eXBlLnJlY3Q9ZnVuY3Rpb24oZSx0LEEscil7aWYoaXNOYU4oZSl8fGlzTmFOKHQpfHxpc05hTihBKXx8aXNOYU4ocikpdGhyb3cgbC5lcnJvcigianNQREYuY29udGV4dDJkLnJlY3Q6IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5yZWN0Iik7dGhpcy5tb3ZlVG8oZSx0KSx0aGlzLmxpbmVUbyhlK0EsdCksdGhpcy5saW5lVG8oZStBLHQrciksdGhpcy5saW5lVG8oZSx0K3IpLHRoaXMubGluZVRvKGUsdCksdGhpcy5saW5lVG8oZStBLHQpLHRoaXMubGluZVRvKGUsdCl9LGQucHJvdG90eXBlLmZpbGxSZWN0PWZ1bmN0aW9uKGUsdCxBLHIpe2lmKGlzTmFOKGUpfHxpc05hTih0KXx8aXNOYU4oQSl8fGlzTmFOKHIpKXRocm93IGwuZXJyb3IoImpzUERGLmNvbnRleHQyZC5maWxsUmVjdDogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLmZpbGxSZWN0Iik7aWYoIWcuY2FsbCh0aGlzKSl7dmFyIG49e307ImJ1dHQiIT09dGhpcy5saW5lQ2FwJiYobi5saW5lQ2FwPXRoaXMubGluZUNhcCx0aGlzLmxpbmVDYXA9ImJ1dHQiKSwibWl0ZXIiIT09dGhpcy5saW5lSm9pbiYmKG4ubGluZUpvaW49dGhpcy5saW5lSm9pbix0aGlzLmxpbmVKb2luPSJtaXRlciIpLHRoaXMuYmVnaW5QYXRoKCksdGhpcy5yZWN0KGUsdCxBLHIpLHRoaXMuZmlsbCgpLG4uaGFzT3duUHJvcGVydHkoImxpbmVDYXAiKSYmKHRoaXMubGluZUNhcD1uLmxpbmVDYXApLG4uaGFzT3duUHJvcGVydHkoImxpbmVKb2luIikmJih0aGlzLmxpbmVKb2luPW4ubGluZUpvaW4pfX0sZC5wcm90b3R5cGUuc3Ryb2tlUmVjdD1mdW5jdGlvbihlLHQsQSxyKXtpZihpc05hTihlKXx8aXNOYU4odCl8fGlzTmFOKEEpfHxpc05hTihyKSl0aHJvdyBsLmVycm9yKCJqc1BERi5jb250ZXh0MmQuc3Ryb2tlUmVjdDogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLnN0cm9rZVJlY3QiKTttLmNhbGwodGhpcyl8fCh0aGlzLmJlZ2luUGF0aCgpLHRoaXMucmVjdChlLHQsQSxyKSx0aGlzLnN0cm9rZSgpKX0sZC5wcm90b3R5cGUuY2xlYXJSZWN0PWZ1bmN0aW9uKGUsdCxBLHIpe2lmKGlzTmFOKGUpfHxpc05hTih0KXx8aXNOYU4oQSl8fGlzTmFOKHIpKXRocm93IGwuZXJyb3IoImpzUERGLmNvbnRleHQyZC5jbGVhclJlY3Q6IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5jbGVhclJlY3QiKTt0aGlzLmlnbm9yZUNsZWFyUmVjdHx8KHRoaXMuZmlsbFN0eWxlPSIjZmZmZmZmIix0aGlzLmZpbGxSZWN0KGUsdCxBLHIpKX0sZC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbihlKXtlPSJib29sZWFuIiE9dHlwZW9mIGV8fGU7Zm9yKHZhciB0PXRoaXMucGRmLmludGVybmFsLmdldEN1cnJlbnRQYWdlSW5mbygpLnBhZ2VOdW1iZXIsQT0wO0E8dGhpcy5wZGYuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpO0ErKyl0aGlzLnBkZi5zZXRQYWdlKEErMSksdGhpcy5wZGYuaW50ZXJuYWwub3V0KCJxIik7aWYodGhpcy5wZGYuc2V0UGFnZSh0KSxlKXt0aGlzLmN0eC5mb250U2l6ZT10aGlzLnBkZi5pbnRlcm5hbC5nZXRGb250U2l6ZSgpO3ZhciByPW5ldyBoKHRoaXMuY3R4KTt0aGlzLmN0eFN0YWNrLnB1c2godGhpcy5jdHgpLHRoaXMuY3R4PXJ9fSxkLnByb3RvdHlwZS5yZXN0b3JlPWZ1bmN0aW9uKGUpe2U9ImJvb2xlYW4iIT10eXBlb2YgZXx8ZTtmb3IodmFyIHQ9dGhpcy5wZGYuaW50ZXJuYWwuZ2V0Q3VycmVudFBhZ2VJbmZvKCkucGFnZU51bWJlcixBPTA7QTx0aGlzLnBkZi5pbnRlcm5hbC5nZXROdW1iZXJPZlBhZ2VzKCk7QSsrKXRoaXMucGRmLnNldFBhZ2UoQSsxKSx0aGlzLnBkZi5pbnRlcm5hbC5vdXQoIlEiKTt0aGlzLnBkZi5zZXRQYWdlKHQpLGUmJjAhPT10aGlzLmN0eFN0YWNrLmxlbmd0aCYmKHRoaXMuY3R4PXRoaXMuY3R4U3RhY2sucG9wKCksdGhpcy5maWxsU3R5bGU9dGhpcy5jdHguZmlsbFN0eWxlLHRoaXMuc3Ryb2tlU3R5bGU9dGhpcy5jdHguc3Ryb2tlU3R5bGUsdGhpcy5mb250PXRoaXMuY3R4LmZvbnQsdGhpcy5saW5lQ2FwPXRoaXMuY3R4LmxpbmVDYXAsdGhpcy5saW5lV2lkdGg9dGhpcy5jdHgubGluZVdpZHRoLHRoaXMubGluZUpvaW49dGhpcy5jdHgubGluZUpvaW4sdGhpcy5saW5lRGFzaD10aGlzLmN0eC5saW5lRGFzaCx0aGlzLmxpbmVEYXNoT2Zmc2V0PXRoaXMuY3R4LmxpbmVEYXNoT2Zmc2V0KX0sZC5wcm90b3R5cGUudG9EYXRhVVJMPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKCJ0b0RhdGFVcmwgbm90IGltcGxlbWVudGVkLiIpfTt2YXIgcD1mdW5jdGlvbihlKXt2YXIgdCxBLHIsbjtpZighMD09PWUuaXNDYW52YXNHcmFkaWVudCYmKGU9ZS5nZXRDb2xvcigpKSwhZSlyZXR1cm57cjowLGc6MCxiOjAsYTowLHN0eWxlOmV9O2lmKC90cmFuc3BhcmVudHxyZ2JhXHMqXChccyooXGQrKVxzKixccyooXGQrKVxzKixccyooXGQrKVxzKixccyowK1xzKlwpLy50ZXN0KGUpKXQ9MCxBPTAscj0wLG49MDtlbHNle3ZhciBzPS9yZ2JccypcKFxzKihcZCspXHMqLFxzKihcZCspXHMqLFxzKihcZCspXHMqXCkvLmV4ZWMoZSk7aWYobnVsbCE9PXMpdD1wYXJzZUludChzWzFdKSxBPXBhcnNlSW50KHNbMl0pLHI9cGFyc2VJbnQoc1szXSksbj0xO2Vsc2UgaWYobnVsbCE9PShzPS9yZ2JhXHMqXChccyooXGQrKVxzKixccyooXGQrKVxzKixccyooXGQrKVxzKixccyooW1xkLl0rKVxzKlwpLy5leGVjKGUpKSl0PXBhcnNlSW50KHNbMV0pLEE9cGFyc2VJbnQoc1syXSkscj1wYXJzZUludChzWzNdKSxuPXBhcnNlRmxvYXQoc1s0XSk7ZWxzZXtpZihuPTEsInN0cmluZyI9PXR5cGVvZiBlJiYiIyIhPT1lLmNoYXJBdCgwKSl7dmFyIGk9bmV3IGYoZSk7ZT1pLm9rP2kudG9IZXgoKToiIzAwMDAwMCJ9ND09PWUubGVuZ3RoPyh0PWUuc3Vic3RyaW5nKDEsMiksdCs9dCxBPWUuc3Vic3RyaW5nKDIsMyksQSs9QSxyPWUuc3Vic3RyaW5nKDMsNCkscis9cik6KHQ9ZS5zdWJzdHJpbmcoMSwzKSxBPWUuc3Vic3RyaW5nKDMsNSkscj1lLnN1YnN0cmluZyg1LDcpKSx0PXBhcnNlSW50KHQsMTYpLEE9cGFyc2VJbnQoQSwxNikscj1wYXJzZUludChyLDE2KX19cmV0dXJue3I6dCxnOkEsYjpyLGE6bixzdHlsZTplfX0sZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN0eC5pc0ZpbGxUcmFuc3BhcmVudHx8MD09dGhpcy5nbG9iYWxBbHBoYX0sbT1mdW5jdGlvbigpe3JldHVybiBCb29sZWFuKHRoaXMuY3R4LmlzU3Ryb2tlVHJhbnNwYXJlbnR8fDA9PXRoaXMuZ2xvYmFsQWxwaGEpfTtkLnByb3RvdHlwZS5maWxsVGV4dD1mdW5jdGlvbihlLHQsQSxyKXtpZihpc05hTih0KXx8aXNOYU4oQSl8fCJzdHJpbmciIT10eXBlb2YgZSl0aHJvdyBsLmVycm9yKCJqc1BERi5jb250ZXh0MmQuZmlsbFRleHQ6IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5maWxsVGV4dCIpO2lmKHI9aXNOYU4ocik/dm9pZCAwOnIsIWcuY2FsbCh0aGlzKSl7dmFyIG49UCh0aGlzLmN0eC50cmFuc2Zvcm0ucm90YXRpb24pLHM9dGhpcy5jdHgudHJhbnNmb3JtLnNjYWxlWDtTLmNhbGwodGhpcyx7dGV4dDplLHg6dCx5OkEsc2NhbGU6cyxhbmdsZTpuLGFsaWduOnRoaXMudGV4dEFsaWduLG1heFdpZHRoOnJ9KX19LGQucHJvdG90eXBlLnN0cm9rZVRleHQ9ZnVuY3Rpb24oZSx0LEEscil7aWYoaXNOYU4odCl8fGlzTmFOKEEpfHwic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbC5lcnJvcigianNQREYuY29udGV4dDJkLnN0cm9rZVRleHQ6IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5zdHJva2VUZXh0Iik7aWYoIW0uY2FsbCh0aGlzKSl7cj1pc05hTihyKT92b2lkIDA6cjt2YXIgbj1QKHRoaXMuY3R4LnRyYW5zZm9ybS5yb3RhdGlvbikscz10aGlzLmN0eC50cmFuc2Zvcm0uc2NhbGVYO1MuY2FsbCh0aGlzLHt0ZXh0OmUseDp0LHk6QSxzY2FsZTpzLHJlbmRlcmluZ01vZGU6InN0cm9rZSIsYW5nbGU6bixhbGlnbjp0aGlzLnRleHRBbGlnbixtYXhXaWR0aDpyfSl9fSxkLnByb3RvdHlwZS5tZWFzdXJlVGV4dD1mdW5jdGlvbihlKXtpZigic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbC5lcnJvcigianNQREYuY29udGV4dDJkLm1lYXN1cmVUZXh0OiBJbnZhbGlkIGFyZ3VtZW50cyIsYXJndW1lbnRzKSxuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQubWVhc3VyZVRleHQiKTt2YXIgdD10aGlzLnBkZixBPXRoaXMucGRmLmludGVybmFsLnNjYWxlRmFjdG9yLHI9dC5pbnRlcm5hbC5nZXRGb250U2l6ZSgpLG49dC5nZXRTdHJpbmdVbml0V2lkdGgoZSkqci90LmludGVybmFsLnNjYWxlRmFjdG9yO3JldHVybiBuZXcgZnVuY3Rpb24oZSl7dmFyIHQ9KGU9ZXx8e30pLndpZHRofHwwO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywid2lkdGgiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH19KSx0aGlzfSh7d2lkdGg6bio9TWF0aC5yb3VuZCg5NipBLzcyKjFlNCkvMWU0fSl9LGQucHJvdG90eXBlLnNjYWxlPWZ1bmN0aW9uKGUsdCl7aWYoaXNOYU4oZSl8fGlzTmFOKHQpKXRocm93IGwuZXJyb3IoImpzUERGLmNvbnRleHQyZC5zY2FsZTogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLnNjYWxlIik7dmFyIEE9bmV3IGMoZSwwLDAsdCwwLDApO3RoaXMuY3R4LnRyYW5zZm9ybT10aGlzLmN0eC50cmFuc2Zvcm0ubXVsdGlwbHkoQSl9LGQucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbihlKXtpZihpc05hTihlKSl0aHJvdyBsLmVycm9yKCJqc1BERi5jb250ZXh0MmQucm90YXRlOiBJbnZhbGlkIGFyZ3VtZW50cyIsYXJndW1lbnRzKSxuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQucm90YXRlIik7dmFyIHQ9bmV3IGMoTWF0aC5jb3MoZSksTWF0aC5zaW4oZSksLU1hdGguc2luKGUpLE1hdGguY29zKGUpLDAsMCk7dGhpcy5jdHgudHJhbnNmb3JtPXRoaXMuY3R4LnRyYW5zZm9ybS5tdWx0aXBseSh0KX0sZC5wcm90b3R5cGUudHJhbnNsYXRlPWZ1bmN0aW9uKGUsdCl7aWYoaXNOYU4oZSl8fGlzTmFOKHQpKXRocm93IGwuZXJyb3IoImpzUERGLmNvbnRleHQyZC50cmFuc2xhdGU6IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC50cmFuc2xhdGUiKTt2YXIgQT1uZXcgYygxLDAsMCwxLGUsdCk7dGhpcy5jdHgudHJhbnNmb3JtPXRoaXMuY3R4LnRyYW5zZm9ybS5tdWx0aXBseShBKX0sZC5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKGUsdCxBLHIsbixzKXtpZihpc05hTihlKXx8aXNOYU4odCl8fGlzTmFOKEEpfHxpc05hTihyKXx8aXNOYU4obil8fGlzTmFOKHMpKXRocm93IGwuZXJyb3IoImpzUERGLmNvbnRleHQyZC50cmFuc2Zvcm06IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC50cmFuc2Zvcm0iKTt2YXIgaT1uZXcgYyhlLHQsQSxyLG4scyk7dGhpcy5jdHgudHJhbnNmb3JtPXRoaXMuY3R4LnRyYW5zZm9ybS5tdWx0aXBseShpKX0sZC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtPWZ1bmN0aW9uKGUsdCxBLHIsbixzKXtlPWlzTmFOKGUpPzE6ZSx0PWlzTmFOKHQpPzA6dCxBPWlzTmFOKEEpPzA6QSxyPWlzTmFOKHIpPzE6cixuPWlzTmFOKG4pPzA6bixzPWlzTmFOKHMpPzA6cyx0aGlzLmN0eC50cmFuc2Zvcm09bmV3IGMoZSx0LEEscixuLHMpfTt2YXIgdz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcmdpblswXT4wfHx0aGlzLm1hcmdpblsxXT4wfHx0aGlzLm1hcmdpblsyXT4wfHx0aGlzLm1hcmdpblszXT4wfTtkLnByb3RvdHlwZS5kcmF3SW1hZ2U9ZnVuY3Rpb24oZSx0LEEscixuLHMsaSxvLGwpe3ZhciB1PXRoaXMucGRmLmdldEltYWdlUHJvcGVydGllcyhlKSxoPTEsZD0xLGY9MSxwPTE7dm9pZCAwIT09ciYmdm9pZCAwIT09byYmKGY9by9yLHA9bC9uLGg9dS53aWR0aC9yKm8vcixkPXUuaGVpZ2h0L24qbC9uKSx2b2lkIDA9PT1zJiYocz10LGk9QSx0PTAsQT0wKSx2b2lkIDAhPT1yJiZ2b2lkIDA9PT1vJiYobz1yLGw9biksdm9pZCAwPT09ciYmdm9pZCAwPT09byYmKG89dS53aWR0aCxsPXUuaGVpZ2h0KTtmb3IodmFyIGcsbT10aGlzLmN0eC50cmFuc2Zvcm0uZGVjb21wb3NlKCkseT1QKG0ucm90YXRlLnNoeCksQz1uZXcgYyxqPShDPShDPShDPUMubXVsdGlwbHkobS50cmFuc2xhdGUpKS5tdWx0aXBseShtLnNrZXcpKS5tdWx0aXBseShtLnNjYWxlKSkuYXBwbHlUb1JlY3RhbmdsZShuZXcgYShzLXQqZixpLUEqcCxyKmgsbipkKSkseD1CLmNhbGwodGhpcyxqKSxGPVtdLFE9MDtRPHgubGVuZ3RoO1ErPTEpLTE9PT1GLmluZGV4T2YoeFtRXSkmJkYucHVzaCh4W1FdKTtpZihiKEYpLHRoaXMuYXV0b1BhZ2luZylmb3IodmFyIFU9RlswXSxFPUZbRi5sZW5ndGgtMV0sUz1VO1M8RSsxO1MrKyl7dGhpcy5wZGYuc2V0UGFnZShTKTt2YXIgTD10aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS53aWR0aC10aGlzLm1hcmdpblszXS10aGlzLm1hcmdpblsxXSxJPTE9PT1TP3RoaXMucG9zWSt0aGlzLm1hcmdpblswXTp0aGlzLm1hcmdpblswXSxOPXRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLmhlaWdodC10aGlzLnBvc1ktdGhpcy5tYXJnaW5bMF0tdGhpcy5tYXJnaW5bMl0saz10aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQtdGhpcy5tYXJnaW5bMF0tdGhpcy5tYXJnaW5bMl0sSD0xPT09Uz8wOk4rKFMtMikqaztpZigwIT09dGhpcy5jdHguY2xpcF9wYXRoLmxlbmd0aCl7dmFyIFQ9dGhpcy5wYXRoO2c9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmN0eC5jbGlwX3BhdGgpKSx0aGlzLnBhdGg9dihnLHRoaXMucG9zWCt0aGlzLm1hcmdpblszXSwtSCtJK3RoaXMuY3R4LnByZXZQYWdlTGFzdEVsZW1PZmZzZXQpLF8uY2FsbCh0aGlzLCJmaWxsIiwhMCksdGhpcy5wYXRoPVR9dmFyIE89SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShqKSk7Tz12KFtPXSx0aGlzLnBvc1grdGhpcy5tYXJnaW5bM10sLUgrSSt0aGlzLmN0eC5wcmV2UGFnZUxhc3RFbGVtT2Zmc2V0KVswXTt2YXIgTT0oUz5VfHxTPEUpJiZ3LmNhbGwodGhpcyk7TSYmKHRoaXMucGRmLnNhdmVHcmFwaGljc1N0YXRlKCksdGhpcy5wZGYucmVjdCh0aGlzLm1hcmdpblszXSx0aGlzLm1hcmdpblswXSxMLGssbnVsbCkuY2xpcCgpLmRpc2NhcmRQYXRoKCkpLHRoaXMucGRmLmFkZEltYWdlKGUsIkpQRUciLE8ueCxPLnksTy53LE8uaCxudWxsLG51bGwseSksTSYmdGhpcy5wZGYucmVzdG9yZUdyYXBoaWNzU3RhdGUoKX1lbHNlIHRoaXMucGRmLmFkZEltYWdlKGUsIkpQRUciLGoueCxqLnksai53LGouaCxudWxsLG51bGwseSl9O3ZhciBCPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcj1bXTt0PXR8fHRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLndpZHRoLEE9QXx8dGhpcy5wZGYuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0LXRoaXMubWFyZ2luWzBdLXRoaXMubWFyZ2luWzJdO3ZhciBuPXRoaXMucG9zWSt0aGlzLmN0eC5wcmV2UGFnZUxhc3RFbGVtT2Zmc2V0O3N3aXRjaChlLnR5cGUpe2RlZmF1bHQ6Y2FzZSJtdCI6Y2FzZSJsdCI6ci5wdXNoKE1hdGguZmxvb3IoKGUueStuKS9BKSsxKTticmVhaztjYXNlImFyYyI6ci5wdXNoKE1hdGguZmxvb3IoKGUueStuLWUucmFkaXVzKS9BKSsxKSxyLnB1c2goTWF0aC5mbG9vcigoZS55K24rZS5yYWRpdXMpL0EpKzEpO2JyZWFrO2Nhc2UicWN0Ijp2YXIgcz1UKHRoaXMuY3R4Lmxhc3RQb2ludC54LHRoaXMuY3R4Lmxhc3RQb2ludC55LGUueDEsZS55MSxlLngsZS55KTtyLnB1c2goTWF0aC5mbG9vcigocy55K24pL0EpKzEpLHIucHVzaChNYXRoLmZsb29yKChzLnkrcy5oK24pL0EpKzEpO2JyZWFrO2Nhc2UiYmN0Ijp2YXIgaT1PKHRoaXMuY3R4Lmxhc3RQb2ludC54LHRoaXMuY3R4Lmxhc3RQb2ludC55LGUueDEsZS55MSxlLngyLGUueTIsZS54LGUueSk7ci5wdXNoKE1hdGguZmxvb3IoKGkueStuKS9BKSsxKSxyLnB1c2goTWF0aC5mbG9vcigoaS55K2kuaCtuKS9BKSsxKTticmVhaztjYXNlInJlY3QiOnIucHVzaChNYXRoLmZsb29yKChlLnkrbikvQSkrMSksci5wdXNoKE1hdGguZmxvb3IoKGUueStlLmgrbikvQSkrMSl9Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKz0xKWZvcig7dGhpcy5wZGYuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpPHJbb107KXkuY2FsbCh0aGlzKTtyZXR1cm4gcn0seT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuZmlsbFN0eWxlLHQ9dGhpcy5zdHJva2VTdHlsZSxBPXRoaXMuZm9udCxyPXRoaXMubGluZUNhcCxuPXRoaXMubGluZVdpZHRoLHM9dGhpcy5saW5lSm9pbjt0aGlzLnBkZi5hZGRQYWdlKCksdGhpcy5maWxsU3R5bGU9ZSx0aGlzLnN0cm9rZVN0eWxlPXQsdGhpcy5mb250PUEsdGhpcy5saW5lQ2FwPXIsdGhpcy5saW5lV2lkdGg9bix0aGlzLmxpbmVKb2luPXN9LHY9ZnVuY3Rpb24oZSx0LEEpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXN3aXRjaChlW3JdLnR5cGUpe2Nhc2UiYmN0IjplW3JdLngyKz10LGVbcl0ueTIrPUE7Y2FzZSJxY3QiOmVbcl0ueDErPXQsZVtyXS55MSs9QTtkZWZhdWx0OmVbcl0ueCs9dCxlW3JdLnkrPUF9cmV0dXJuIGV9LGI9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc29ydChmdW5jdGlvbihlLHQpe3JldHVybiBlLXR9KX0sQz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgQSxyLG49dGhpcy5maWxsU3R5bGUscz10aGlzLnN0cm9rZVN0eWxlLGk9dGhpcy5saW5lQ2FwLG89dGhpcy5saW5lV2lkdGgsYT1NYXRoLmFicyhvKnRoaXMuY3R4LnRyYW5zZm9ybS5zY2FsZVgpLGw9dGhpcy5saW5lSm9pbixjPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXRoKSksdT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGF0aCkpLGg9W10sZD0wO2Q8dS5sZW5ndGg7ZCsrKWlmKHZvaWQgMCE9PXVbZF0ueClmb3IodmFyIGY9Qi5jYWxsKHRoaXMsdVtkXSkscD0wO3A8Zi5sZW5ndGg7cCs9MSktMT09PWguaW5kZXhPZihmW3BdKSYmaC5wdXNoKGZbcF0pO2Zvcih2YXIgZz0wO2c8aC5sZW5ndGg7ZysrKWZvcig7dGhpcy5wZGYuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpPGhbZ107KXkuY2FsbCh0aGlzKTtpZihiKGgpLHRoaXMuYXV0b1BhZ2luZylmb3IodmFyIG09aFswXSxDPWhbaC5sZW5ndGgtMV0saj1tO2o8QysxO2orKyl7dGhpcy5wZGYuc2V0UGFnZShqKSx0aGlzLmZpbGxTdHlsZT1uLHRoaXMuc3Ryb2tlU3R5bGU9cyx0aGlzLmxpbmVDYXA9aSx0aGlzLmxpbmVXaWR0aD1hLHRoaXMubGluZUpvaW49bDt2YXIgeD10aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS53aWR0aC10aGlzLm1hcmdpblszXS10aGlzLm1hcmdpblsxXSxGPTE9PT1qP3RoaXMucG9zWSt0aGlzLm1hcmdpblswXTp0aGlzLm1hcmdpblswXSxRPXRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLmhlaWdodC10aGlzLnBvc1ktdGhpcy5tYXJnaW5bMF0tdGhpcy5tYXJnaW5bMl0sVT10aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQtdGhpcy5tYXJnaW5bMF0tdGhpcy5tYXJnaW5bMl0sRT0xPT09aj8wOlErKGotMikqVTtpZigwIT09dGhpcy5jdHguY2xpcF9wYXRoLmxlbmd0aCl7dmFyIFM9dGhpcy5wYXRoO0E9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmN0eC5jbGlwX3BhdGgpKSx0aGlzLnBhdGg9dihBLHRoaXMucG9zWCt0aGlzLm1hcmdpblszXSwtRStGK3RoaXMuY3R4LnByZXZQYWdlTGFzdEVsZW1PZmZzZXQpLF8uY2FsbCh0aGlzLGUsITApLHRoaXMucGF0aD1TfWlmKHI9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjKSksdGhpcy5wYXRoPXYocix0aGlzLnBvc1grdGhpcy5tYXJnaW5bM10sLUUrRit0aGlzLmN0eC5wcmV2UGFnZUxhc3RFbGVtT2Zmc2V0KSwhMT09PXR8fDA9PT1qKXt2YXIgTD0oaj5tfHxqPEMpJiZ3LmNhbGwodGhpcyk7TCYmKHRoaXMucGRmLnNhdmVHcmFwaGljc1N0YXRlKCksdGhpcy5wZGYucmVjdCh0aGlzLm1hcmdpblszXSx0aGlzLm1hcmdpblswXSx4LFUsbnVsbCkuY2xpcCgpLmRpc2NhcmRQYXRoKCkpLF8uY2FsbCh0aGlzLGUsdCksTCYmdGhpcy5wZGYucmVzdG9yZUdyYXBoaWNzU3RhdGUoKX10aGlzLmxpbmVXaWR0aD1vfWVsc2UgdGhpcy5saW5lV2lkdGg9YSxfLmNhbGwodGhpcyxlLHQpLHRoaXMubGluZVdpZHRoPW87dGhpcy5wYXRoPWN9LF89ZnVuY3Rpb24oZSx0KXtpZigoInN0cm9rZSIhPT1lfHx0fHwhbS5jYWxsKHRoaXMpKSYmKCJzdHJva2UiPT09ZXx8dHx8IWcuY2FsbCh0aGlzKSkpe2Zvcih2YXIgQSxyLG49W10scz10aGlzLnBhdGgsaT0wO2k8cy5sZW5ndGg7aSsrKXt2YXIgbz1zW2ldO3N3aXRjaChvLnR5cGUpe2Nhc2UiYmVnaW4iOm4ucHVzaCh7YmVnaW46ITB9KTticmVhaztjYXNlImNsb3NlIjpuLnB1c2goe2Nsb3NlOiEwfSk7YnJlYWs7Y2FzZSJtdCI6bi5wdXNoKHtzdGFydDpvLGRlbHRhczpbXSxhYnM6W119KTticmVhaztjYXNlImx0Ijp2YXIgYT1uLmxlbmd0aDtpZihzW2ktMV0mJiFpc05hTihzW2ktMV0ueCkmJihBPVtvLngtc1tpLTFdLngsby55LXNbaS0xXS55XSxhPjApKWZvcig7YT49MDthLS0paWYoITAhPT1uW2EtMV0uY2xvc2UmJiEwIT09blthLTFdLmJlZ2luKXtuW2EtMV0uZGVsdGFzLnB1c2goQSksblthLTFdLmFicy5wdXNoKG8pO2JyZWFrfWJyZWFrO2Nhc2UiYmN0IjpBPVtvLngxLXNbaS0xXS54LG8ueTEtc1tpLTFdLnksby54Mi1zW2ktMV0ueCxvLnkyLXNbaS0xXS55LG8ueC1zW2ktMV0ueCxvLnktc1tpLTFdLnldLG5bbi5sZW5ndGgtMV0uZGVsdGFzLnB1c2goQSk7YnJlYWs7Y2FzZSJxY3QiOnZhciBsPXNbaS0xXS54KzIvMyooby54MS1zW2ktMV0ueCksYz1zW2ktMV0ueSsyLzMqKG8ueTEtc1tpLTFdLnkpLHU9by54KzIvMyooby54MS1vLngpLGg9by55KzIvMyooby55MS1vLnkpLGQ9by54LGY9by55O0E9W2wtc1tpLTFdLngsYy1zW2ktMV0ueSx1LXNbaS0xXS54LGgtc1tpLTFdLnksZC1zW2ktMV0ueCxmLXNbaS0xXS55XSxuW24ubGVuZ3RoLTFdLmRlbHRhcy5wdXNoKEEpO2JyZWFrO2Nhc2UiYXJjIjpuLnB1c2goe2RlbHRhczpbXSxhYnM6W10sYXJjOiEwfSksQXJyYXkuaXNBcnJheShuW24ubGVuZ3RoLTFdLmFicykmJm5bbi5sZW5ndGgtMV0uYWJzLnB1c2gobyl9fXI9dD9udWxsOiJzdHJva2UiPT09ZT8ic3Ryb2tlIjoiZmlsbCI7Zm9yKHZhciBwPSExLHc9MDt3PG4ubGVuZ3RoO3crKylpZihuW3ddLmFyYylmb3IodmFyIEI9blt3XS5hYnMseT0wO3k8Qi5sZW5ndGg7eSsrKXt2YXIgdj1CW3ldOyJhcmMiPT09di50eXBlP0YuY2FsbCh0aGlzLHYueCx2Lnksdi5yYWRpdXMsdi5zdGFydEFuZ2xlLHYuZW5kQW5nbGUsdi5jb3VudGVyY2xvY2t3aXNlLHZvaWQgMCx0LCFwKTpMLmNhbGwodGhpcyx2Lngsdi55KSxwPSEwfWVsc2UgaWYoITA9PT1uW3ddLmNsb3NlKXRoaXMucGRmLmludGVybmFsLm91dCgiaCIpLHA9ITE7ZWxzZSBpZighMCE9PW5bd10uYmVnaW4pe3ZhciBiPW5bd10uc3RhcnQueCxDPW5bd10uc3RhcnQueTtJLmNhbGwodGhpcyxuW3ddLmRlbHRhcyxiLEMpLHA9ITB9ciYmUS5jYWxsKHRoaXMsciksdCYmVS5jYWxsKHRoaXMpfX0saj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnBkZi5pbnRlcm5hbC5nZXRGb250U2l6ZSgpL3RoaXMucGRmLmludGVybmFsLnNjYWxlRmFjdG9yLEE9dCoodGhpcy5wZGYuaW50ZXJuYWwuZ2V0TGluZUhlaWdodEZhY3RvcigpLTEpO3N3aXRjaCh0aGlzLmN0eC50ZXh0QmFzZWxpbmUpe2Nhc2UiYm90dG9tIjpyZXR1cm4gZS1BO2Nhc2UidG9wIjpyZXR1cm4gZSt0LUE7Y2FzZSJoYW5naW5nIjpyZXR1cm4gZSt0LTIqQTtjYXNlIm1pZGRsZSI6cmV0dXJuIGUrdC8yLUE7ZGVmYXVsdDpyZXR1cm4gZX19LHg9ZnVuY3Rpb24oZSl7cmV0dXJuIGUrdGhpcy5wZGYuaW50ZXJuYWwuZ2V0Rm9udFNpemUoKS90aGlzLnBkZi5pbnRlcm5hbC5zY2FsZUZhY3RvcioodGhpcy5wZGYuaW50ZXJuYWwuZ2V0TGluZUhlaWdodEZhY3RvcigpLTEpfTtkLnByb3RvdHlwZS5jcmVhdGVMaW5lYXJHcmFkaWVudD1mdW5jdGlvbigpe3ZhciBlPWZ1bmN0aW9uKCl7fTtyZXR1cm4gZS5jb2xvclN0b3BzPVtdLGUuYWRkQ29sb3JTdG9wPWZ1bmN0aW9uKGUsdCl7dGhpcy5jb2xvclN0b3BzLnB1c2goW2UsdF0pfSxlLmdldENvbG9yPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmNvbG9yU3RvcHMubGVuZ3RoPyIjMDAwMDAwIjp0aGlzLmNvbG9yU3RvcHNbMF1bMV19LGUuaXNDYW52YXNHcmFkaWVudD0hMCxlfSxkLnByb3RvdHlwZS5jcmVhdGVQYXR0ZXJuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyR3JhZGllbnQoKX0sZC5wcm90b3R5cGUuY3JlYXRlUmFkaWFsR3JhZGllbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJHcmFkaWVudCgpfTt2YXIgRj1mdW5jdGlvbihlLHQsQSxyLG4scyxpLG8sYSl7Zm9yKHZhciBsPWsuY2FsbCh0aGlzLEEscixuLHMpLGM9MDtjPGwubGVuZ3RoO2MrKyl7dmFyIHU9bFtjXTswPT09YyYmKGE/RS5jYWxsKHRoaXMsdS54MStlLHUueTErdCk6TC5jYWxsKHRoaXMsdS54MStlLHUueTErdCkpLE4uY2FsbCh0aGlzLGUsdCx1LngyLHUueTIsdS54Myx1LnkzLHUueDQsdS55NCl9bz9VLmNhbGwodGhpcyk6US5jYWxsKHRoaXMsaSl9LFE9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2Uic3Ryb2tlIjp0aGlzLnBkZi5pbnRlcm5hbC5vdXQoIlMiKTticmVhaztjYXNlImZpbGwiOnRoaXMucGRmLmludGVybmFsLm91dCgiZiIpfX0sVT1mdW5jdGlvbigpe3RoaXMucGRmLmNsaXAoKSx0aGlzLnBkZi5kaXNjYXJkUGF0aCgpfSxFPWZ1bmN0aW9uKGUsdCl7dGhpcy5wZGYuaW50ZXJuYWwub3V0KEEoZSkrIiAiK24odCkrIiBtIil9LFM9ZnVuY3Rpb24oZSl7dmFyIHQ7c3dpdGNoKGUuYWxpZ24pe2Nhc2UicmlnaHQiOmNhc2UiZW5kIjp0PSJyaWdodCI7YnJlYWs7Y2FzZSJjZW50ZXIiOnQ9ImNlbnRlciI7YnJlYWs7ZGVmYXVsdDp0PSJsZWZ0In12YXIgQT10aGlzLnBkZi5nZXRUZXh0RGltZW5zaW9ucyhlLnRleHQpLHI9ai5jYWxsKHRoaXMsZS55KSxuPXguY2FsbCh0aGlzLHIpLUEuaCxzPXRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IG8oZS54LHIpKSxpPXRoaXMuY3R4LnRyYW5zZm9ybS5kZWNvbXBvc2UoKSxsPW5ldyBjO2w9KGw9KGw9bC5tdWx0aXBseShpLnRyYW5zbGF0ZSkpLm11bHRpcGx5KGkuc2tldykpLm11bHRpcGx5KGkuc2NhbGUpO2Zvcih2YXIgdSxoLGQsZj10aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1JlY3RhbmdsZShuZXcgYShlLngscixBLncsQS5oKSkscD1sLmFwcGx5VG9SZWN0YW5nbGUobmV3IGEoZS54LG4sQS53LEEuaCkpLGc9Qi5jYWxsKHRoaXMscCksbT1bXSx5PTA7eTxnLmxlbmd0aDt5Kz0xKS0xPT09bS5pbmRleE9mKGdbeV0pJiZtLnB1c2goZ1t5XSk7aWYoYihtKSx0aGlzLmF1dG9QYWdpbmcpZm9yKHZhciBDPW1bMF0sRj1tW20ubGVuZ3RoLTFdLFE9QztRPEYrMTtRKyspe3RoaXMucGRmLnNldFBhZ2UoUSk7dmFyIFU9MT09PVE/dGhpcy5wb3NZK3RoaXMubWFyZ2luWzBdOnRoaXMubWFyZ2luWzBdLEU9dGhpcy5wZGYuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0LXRoaXMucG9zWS10aGlzLm1hcmdpblswXS10aGlzLm1hcmdpblsyXSxTPXRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLmhlaWdodC10aGlzLm1hcmdpblsyXSxMPVMtdGhpcy5tYXJnaW5bMF0sST10aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS53aWR0aC10aGlzLm1hcmdpblsxXSxOPUktdGhpcy5tYXJnaW5bM10saz0xPT09UT8wOkUrKFEtMikqTDtpZigwIT09dGhpcy5jdHguY2xpcF9wYXRoLmxlbmd0aCl7dmFyIEg9dGhpcy5wYXRoO3U9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmN0eC5jbGlwX3BhdGgpKSx0aGlzLnBhdGg9dih1LHRoaXMucG9zWCt0aGlzLm1hcmdpblszXSwtMSprK1UpLF8uY2FsbCh0aGlzLCJmaWxsIiwhMCksdGhpcy5wYXRoPUh9dmFyIFA9dihbSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwKSldLHRoaXMucG9zWCt0aGlzLm1hcmdpblszXSwtaytVK3RoaXMuY3R4LnByZXZQYWdlTGFzdEVsZW1PZmZzZXQpWzBdO2Uuc2NhbGU+PS4wMSYmKGg9dGhpcy5wZGYuaW50ZXJuYWwuZ2V0Rm9udFNpemUoKSx0aGlzLnBkZi5zZXRGb250U2l6ZShoKmUuc2NhbGUpLGQ9dGhpcy5saW5lV2lkdGgsdGhpcy5saW5lV2lkdGg9ZCplLnNjYWxlKTt2YXIgVD0idGV4dCIhPT10aGlzLmF1dG9QYWdpbmc7aWYoVHx8UC55K1AuaDw9Uyl7aWYoVHx8UC55Pj1VJiZQLng8PUkpe3ZhciBPPVQ/ZS50ZXh0OnRoaXMucGRmLnNwbGl0VGV4dFRvU2l6ZShlLnRleHQsZS5tYXhXaWR0aHx8SS1QLngpWzBdLE09dihbSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShmKSldLHRoaXMucG9zWCt0aGlzLm1hcmdpblszXSwtaytVK3RoaXMuY3R4LnByZXZQYWdlTGFzdEVsZW1PZmZzZXQpWzBdLEQ9VCYmKFE+Q3x8UTxGKSYmdy5jYWxsKHRoaXMpO0QmJih0aGlzLnBkZi5zYXZlR3JhcGhpY3NTdGF0ZSgpLHRoaXMucGRmLnJlY3QodGhpcy5tYXJnaW5bM10sdGhpcy5tYXJnaW5bMF0sTixMLG51bGwpLmNsaXAoKS5kaXNjYXJkUGF0aCgpKSx0aGlzLnBkZi50ZXh0KE8sTS54LE0ueSx7YW5nbGU6ZS5hbmdsZSxhbGlnbjp0LHJlbmRlcmluZ01vZGU6ZS5yZW5kZXJpbmdNb2RlfSksRCYmdGhpcy5wZGYucmVzdG9yZUdyYXBoaWNzU3RhdGUoKX19ZWxzZSBQLnk8UyYmKHRoaXMuY3R4LnByZXZQYWdlTGFzdEVsZW1PZmZzZXQrPVMtUC55KTtlLnNjYWxlPj0uMDEmJih0aGlzLnBkZi5zZXRGb250U2l6ZShoKSx0aGlzLmxpbmVXaWR0aD1kKX1lbHNlIGUuc2NhbGU+PS4wMSYmKGg9dGhpcy5wZGYuaW50ZXJuYWwuZ2V0Rm9udFNpemUoKSx0aGlzLnBkZi5zZXRGb250U2l6ZShoKmUuc2NhbGUpLGQ9dGhpcy5saW5lV2lkdGgsdGhpcy5saW5lV2lkdGg9ZCplLnNjYWxlKSx0aGlzLnBkZi50ZXh0KGUudGV4dCxzLngrdGhpcy5wb3NYLHMueSt0aGlzLnBvc1kse2FuZ2xlOmUuYW5nbGUsYWxpZ246dCxyZW5kZXJpbmdNb2RlOmUucmVuZGVyaW5nTW9kZSxtYXhXaWR0aDplLm1heFdpZHRofSksZS5zY2FsZT49LjAxJiYodGhpcy5wZGYuc2V0Rm9udFNpemUoaCksdGhpcy5saW5lV2lkdGg9ZCl9LEw9ZnVuY3Rpb24oZSx0LHIscyl7cj1yfHwwLHM9c3x8MCx0aGlzLnBkZi5pbnRlcm5hbC5vdXQoQShlK3IpKyIgIituKHQrcykrIiBsIil9LEk9ZnVuY3Rpb24oZSx0LEEpe3JldHVybiB0aGlzLnBkZi5saW5lcyhlLHQsQSxudWxsLG51bGwpfSxOPWZ1bmN0aW9uKGUsQSxyLG4sbyxhLGwsYyl7dGhpcy5wZGYuaW50ZXJuYWwub3V0KFt0KHMocitlKSksdChpKG4rQSkpLHQocyhvK2UpKSx0KGkoYStBKSksdChzKGwrZSkpLHQoaShjK0EpKSwiYyJdLmpvaW4oIiAiKSl9LGs9ZnVuY3Rpb24oZSx0LEEscil7Zm9yKHZhciBuPTIqTWF0aC5QSSxzPU1hdGguUEkvMjt0PkE7KXQtPW47dmFyIGk9TWF0aC5hYnMoQS10KTtpPG4mJnImJihpPW4taSk7Zm9yKHZhciBvPVtdLGE9cj8tMToxLGw9dDtpPjFlLTU7KXt2YXIgYz1sK2EqTWF0aC5taW4oaSxzKTtvLnB1c2goSC5jYWxsKHRoaXMsZSxsLGMpKSxpLT1NYXRoLmFicyhjLWwpLGw9Y31yZXR1cm4gb30sSD1mdW5jdGlvbihlLHQsQSl7dmFyIHI9KEEtdCkvMixuPWUqTWF0aC5jb3Mocikscz1lKk1hdGguc2luKHIpLGk9bixvPS1zLGE9aSppK28qbyxsPWEraSpuK28qcyxjPTQvMyooTWF0aC5zcXJ0KDIqYSpsKS1sKS8oaSpzLW8qbiksdT1pLWMqbyxoPW8rYyppLGQ9dSxmPS1oLHA9cit0LGc9TWF0aC5jb3MocCksbT1NYXRoLnNpbihwKTtyZXR1cm57eDE6ZSpNYXRoLmNvcyh0KSx5MTplKk1hdGguc2luKHQpLHgyOnUqZy1oKm0seTI6dSptK2gqZyx4MzpkKmctZiptLHkzOmQqbStmKmcseDQ6ZSpNYXRoLmNvcyhBKSx5NDplKk1hdGguc2luKEEpfX0sUD1mdW5jdGlvbihlKXtyZXR1cm4gMTgwKmUvTWF0aC5QSX0sVD1mdW5jdGlvbihlLHQsQSxyLG4scyl7dmFyIGk9ZSsuNSooQS1lKSxvPXQrLjUqKHItdCksbD1uKy41KihBLW4pLGM9cysuNSooci1zKSx1PU1hdGgubWluKGUsbixpLGwpLGg9TWF0aC5tYXgoZSxuLGksbCksZD1NYXRoLm1pbih0LHMsbyxjKSxmPU1hdGgubWF4KHQscyxvLGMpO3JldHVybiBuZXcgYSh1LGQsaC11LGYtZCl9LE89ZnVuY3Rpb24oZSx0LEEscixuLHMsaSxvKXt2YXIgbCxjLHUsaCxkLGYscCxnLG0sdyxCLHksdixiLEM9QS1lLF89ci10LGo9bi1BLHg9cy1yLEY9aS1uLFE9by1zO2ZvcihjPTA7Yzw0MTtjKyspbT0ocD0odT1lKyhsPWMvNDApKkMpK2wqKChkPUErbCpqKS11KSkrbCooZCtsKihuK2wqRi1kKS1wKSx3PShnPShoPXQrbCpfKStsKigoZj1yK2wqeCktaCkpK2wqKGYrbCoocytsKlEtZiktZyksMD09Yz8oQj1tLHk9dyx2PW0sYj13KTooQj1NYXRoLm1pbihCLG0pLHk9TWF0aC5taW4oeSx3KSx2PU1hdGgubWF4KHYsbSksYj1NYXRoLm1heChiLHcpKTtyZXR1cm4gbmV3IGEoTWF0aC5yb3VuZChCKSxNYXRoLnJvdW5kKHkpLE1hdGgucm91bmQodi1CKSxNYXRoLnJvdW5kKGIteSkpfSxNPWZ1bmN0aW9uKCl7aWYodGhpcy5wcmV2TGluZURhc2h8fHRoaXMuY3R4LmxpbmVEYXNoLmxlbmd0aHx8dGhpcy5jdHgubGluZURhc2hPZmZzZXQpe3ZhciBlLHQsQT0oZT10aGlzLmN0eC5saW5lRGFzaCx0PXRoaXMuY3R4LmxpbmVEYXNoT2Zmc2V0LEpTT04uc3RyaW5naWZ5KHtsaW5lRGFzaDplLGxpbmVEYXNoT2Zmc2V0OnR9KSk7dGhpcy5wcmV2TGluZURhc2ghPT1BJiYodGhpcy5wZGYuc2V0TGluZURhc2godGhpcy5jdHgubGluZURhc2gsdGhpcy5jdHgubGluZURhc2hPZmZzZXQpLHRoaXMucHJldkxpbmVEYXNoPUEpfX19KE0uQVBJKSxmdW5jdGlvbihlKXt2YXIgdD1mdW5jdGlvbihlKXt2YXIgdCxBLHIsbixzLGksbyxhLGwsYztmb3IoL1teXHgwMC1ceEZGXS8udGVzdChlKSxBPVtdLHI9MCxuPShlKz10PSJcMFwwXDBcMCIuc2xpY2UoZS5sZW5ndGglNHx8NCkpLmxlbmd0aDtuPnI7cis9NCkwIT09KHM9KGUuY2hhckNvZGVBdChyKTw8MjQpKyhlLmNoYXJDb2RlQXQocisxKTw8MTYpKyhlLmNoYXJDb2RlQXQocisyKTw8OCkrZS5jaGFyQ29kZUF0KHIrMykpPyhpPShzPSgocz0oKHM9KChzPShzLShjPXMlODUpKS84NSktKGw9cyU4NSkpLzg1KS0oYT1zJTg1KSkvODUpLShvPXMlODUpKS84NSklODUsQS5wdXNoKGkrMzMsbyszMyxhKzMzLGwrMzMsYyszMykpOkEucHVzaCgxMjIpO3JldHVybiBmdW5jdGlvbihlLHQpe2Zvcih2YXIgQT10O0E+MDtBLS0pZS5wb3AoKX0oQSx0Lmxlbmd0aCksU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsQSkrIn4+In0sQT1mdW5jdGlvbihlKXt2YXIgdCxBLHIsbixzLGk9U3RyaW5nLG89Imxlbmd0aCIsYT0yNTUsbD0iY2hhckNvZGVBdCIsYz0ic2xpY2UiLHU9InJlcGxhY2UiO2ZvcihlW2NdKC0yKSxlPWVbY10oMCwtMilbdV0oL1xzL2csIiIpW3VdKCJ6IiwiISEhISEiKSxyPVtdLG49MCxzPShlKz10PSJ1dXV1dSJbY10oZVtvXSU1fHw1KSlbb107cz5uO24rPTUpQT01MjIwMDYyNSooZVtsXShuKS0zMykrNjE0MTI1KihlW2xdKG4rMSktMzMpKzcyMjUqKGVbbF0obisyKS0zMykrODUqKGVbbF0obiszKS0zMykrKGVbbF0obis0KS0zMyksci5wdXNoKGEmQT4+MjQsYSZBPj4xNixhJkE+PjgsYSZBKTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtmb3IodmFyIEE9dDtBPjA7QS0tKWUucG9wKCl9KHIsdFtvXSksaS5mcm9tQ2hhckNvZGUuYXBwbHkoaSxyKX0scj1mdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdCgiIikubWFwKGZ1bmN0aW9uKGUpe3JldHVybigiMCIrZS5jaGFyQ29kZUF0KCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMil9KS5qb2luKCIiKSsiPiJ9LHM9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFJlZ0V4cCgvXihbMC05QS1GYS1mXXsyfSkrJC8pO2lmKC0xIT09KGU9ZS5yZXBsYWNlKC9ccy9nLCIiKSkuaW5kZXhPZigiPiIpJiYoZT1lLnN1YnN0cigwLGUuaW5kZXhPZigiPiIpKSksZS5sZW5ndGglMiYmKGUrPSIwIiksITE9PT10LnRlc3QoZSkpcmV0dXJuIiI7Zm9yKHZhciBBPSIiLHI9MDtyPGUubGVuZ3RoO3IrPTIpQSs9U3RyaW5nLmZyb21DaGFyQ29kZSgiMHgiKyhlW3JdK2VbcisxXSkpO3JldHVybiBBfSxpPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1uZXcgVWludDhBcnJheShlLmxlbmd0aCksQT1lLmxlbmd0aDtBLS07KXRbQV09ZS5jaGFyQ29kZUF0KEEpO3JldHVybih0PSgwLG4uemxpYlN5bmMpKHQpKS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZStTdHJpbmcuZnJvbUNoYXJDb2RlKHQpfSwiIil9O2UucHJvY2Vzc0RhdGFCeUZpbHRlcnM9ZnVuY3Rpb24oZSxuKXt2YXIgbz0wLGE9ZXx8IiIsbD1bXTtmb3IoInN0cmluZyI9PXR5cGVvZihuPW58fFtdKSYmKG49W25dKSxvPTA7bzxuLmxlbmd0aDtvKz0xKXN3aXRjaChuW29dKXtjYXNlIkFTQ0lJODVEZWNvZGUiOmNhc2UiL0FTQ0lJODVEZWNvZGUiOmE9QShhKSxsLnB1c2goIi9BU0NJSTg1RW5jb2RlIik7YnJlYWs7Y2FzZSJBU0NJSTg1RW5jb2RlIjpjYXNlIi9BU0NJSTg1RW5jb2RlIjphPXQoYSksbC5wdXNoKCIvQVNDSUk4NURlY29kZSIpO2JyZWFrO2Nhc2UiQVNDSUlIZXhEZWNvZGUiOmNhc2UiL0FTQ0lJSGV4RGVjb2RlIjphPXMoYSksbC5wdXNoKCIvQVNDSUlIZXhFbmNvZGUiKTticmVhaztjYXNlIkFTQ0lJSGV4RW5jb2RlIjpjYXNlIi9BU0NJSUhleEVuY29kZSI6YT1yKGEpLGwucHVzaCgiL0FTQ0lJSGV4RGVjb2RlIik7YnJlYWs7Y2FzZSJGbGF0ZUVuY29kZSI6Y2FzZSIvRmxhdGVFbmNvZGUiOmE9aShhKSxsLnB1c2goIi9GbGF0ZURlY29kZSIpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCdUaGUgZmlsdGVyOiAiJytuW29dKyciIGlzIG5vdCBpbXBsZW1lbnRlZCcpfXJldHVybntkYXRhOmEscmV2ZXJzZUNoYWluOmwucmV2ZXJzZSgpLmpvaW4oIiAiKX19fShNLkFQSSksZnVuY3Rpb24oZSl7ZS5sb2FkRmlsZT1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxBKXt0PSExIT09dCxBPSJmdW5jdGlvbiI9PXR5cGVvZiBBP0E6ZnVuY3Rpb24oKXt9O3ZhciByPXZvaWQgMDt0cnl7cj1mdW5jdGlvbihlLHQsQSl7dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0LG49MCxzPWZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoLEE9W10scj1TdHJpbmcuZnJvbUNoYXJDb2RlO2ZvcihuPTA7bjx0O24rPTEpQS5wdXNoKHIoMjU1JmUuY2hhckNvZGVBdChuKSkpO3JldHVybiBBLmpvaW4oIiIpfTtpZihyLm9wZW4oIkdFVCIsZSwhdCksci5vdmVycmlkZU1pbWVUeXBlKCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkIiksITE9PT10JiYoci5vbmxvYWQ9ZnVuY3Rpb24oKXsyMDA9PT1yLnN0YXR1cz9BKHModGhpcy5yZXNwb25zZVRleHQpKTpBKHZvaWQgMCl9KSxyLnNlbmQobnVsbCksdCYmMjAwPT09ci5zdGF0dXMpcmV0dXJuIHMoci5yZXNwb25zZVRleHQpfShlLHQsQSl9Y2F0Y2goZSl7fXJldHVybiByfShlLHQsQSl9LGUubG9hZEltYWdlRmlsZT1lLmxvYWRGaWxlfShNLkFQSSksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybihvLmh0bWwyY2FudmFzP1Byb21pc2UucmVzb2x2ZShvLmh0bWwyY2FudmFzKTpQcm9taXNlLnJlc29sdmUoKS50aGVuKEEudC5iaW5kKEEsIi4vbm9kZV9tb2R1bGVzL2h0bWwyY2FudmFzL2Rpc3QvaHRtbDJjYW52YXMuanMiLDIzKSkpLmNhdGNoKGZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoIkNvdWxkIG5vdCBsb2FkIGh0bWwyY2FudmFzOiAiK2UpKX0pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGVmYXVsdD9lLmRlZmF1bHQ6ZX0pfWZ1bmN0aW9uIG4oKXtyZXR1cm4oby5ET01QdXJpZnk/UHJvbWlzZS5yZXNvbHZlKG8uRE9NUHVyaWZ5KTpQcm9taXNlLnJlc29sdmUoKS50aGVuKEEuYmluZChBLCIuL25vZGVfbW9kdWxlcy9kb21wdXJpZnkvZGlzdC9wdXJpZnkuZXMubWpzIikpKS5jYXRjaChmdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCJDb3VsZCBub3QgbG9hZCBkb21wdXJpZnk6ICIrZSkpfSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZS5kZWZhdWx0P2UuZGVmYXVsdDplfSl9dmFyIHM9ZnVuY3Rpb24oZSl7dmFyIHQ9KDAsci5kZWZhdWx0KShlKTtyZXR1cm4idW5kZWZpbmVkIj09PXQ/InVuZGVmaW5lZCI6InN0cmluZyI9PT10fHxlIGluc3RhbmNlb2YgU3RyaW5nPyJzdHJpbmciOiJudW1iZXIiPT09dHx8ZSBpbnN0YW5jZW9mIE51bWJlcj8ibnVtYmVyIjoiZnVuY3Rpb24iPT09dHx8ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uPyJmdW5jdGlvbiI6ZSYmZS5jb25zdHJ1Y3Rvcj09PUFycmF5PyJhcnJheSI6ZSYmMT09PWUubm9kZVR5cGU/ImVsZW1lbnQiOiJvYmplY3QiPT09dD8ib2JqZWN0IjoidW5rbm93biJ9LGk9ZnVuY3Rpb24oZSx0KXt2YXIgQT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpO2Zvcih2YXIgciBpbiB0LmNsYXNzTmFtZSYmKEEuY2xhc3NOYW1lPXQuY2xhc3NOYW1lKSx0LmlubmVySFRNTCYmdC5kb21wdXJpZnkmJihBLmlubmVySFRNTD10LmRvbXB1cmlmeS5zYW5pdGl6ZSh0LmlubmVySFRNTCkpLHQuc3R5bGUpQS5zdHlsZVtyXT10LnN0eWxlW3JdO3JldHVybiBBfSxhPWZ1bmN0aW9uIGUodCxBKXtmb3IodmFyIHI9Mz09PXQubm9kZVR5cGU/ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodC5ub2RlVmFsdWUpOnQuY2xvbmVOb2RlKCExKSxuPXQuZmlyc3RDaGlsZDtuO249bi5uZXh0U2libGluZykhMCE9PUEmJjE9PT1uLm5vZGVUeXBlJiYiU0NSSVBUIj09PW4ubm9kZU5hbWV8fHIuYXBwZW5kQ2hpbGQoZShuLEEpKTtyZXR1cm4gMT09PXQubm9kZVR5cGUmJigiQ0FOVkFTIj09PXQubm9kZU5hbWU/KHIud2lkdGg9dC53aWR0aCxyLmhlaWdodD10LmhlaWdodCxyLmdldENvbnRleHQoIjJkIikuZHJhd0ltYWdlKHQsMCwwKSk6IlRFWFRBUkVBIiE9PXQubm9kZU5hbWUmJiJTRUxFQ1QiIT09dC5ub2RlTmFtZXx8KHIudmFsdWU9dC52YWx1ZSksci5hZGRFdmVudExpc3RlbmVyKCJsb2FkIixmdW5jdGlvbigpe3Iuc2Nyb2xsVG9wPXQuc2Nyb2xsVG9wLHIuc2Nyb2xsTGVmdD10LnNjcm9sbExlZnR9LCEwKSkscn0sbD1mdW5jdGlvbiBlKHQpe3ZhciBBPU9iamVjdC5hc3NpZ24oZS5jb252ZXJ0KFByb21pc2UucmVzb2x2ZSgpKSxKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGUudGVtcGxhdGUpKSkscj1lLmNvbnZlcnQoUHJvbWlzZS5yZXNvbHZlKCksQSk7cmV0dXJuKHI9ci5zZXRQcm9ncmVzcygxLGUsMSxbZV0pKS5zZXQodCl9OyhsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFByb21pc2UucHJvdG90eXBlKSkuY29uc3RydWN0b3I9bCxsLmNvbnZlcnQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dHx8bC5wcm90b3R5cGUsZX0sbC50ZW1wbGF0ZT17cHJvcDp7c3JjOm51bGwsY29udGFpbmVyOm51bGwsb3ZlcmxheTpudWxsLGNhbnZhczpudWxsLGltZzpudWxsLHBkZjpudWxsLHBhZ2VTaXplOm51bGwsY2FsbGJhY2s6ZnVuY3Rpb24oKXt9fSxwcm9ncmVzczp7dmFsOjAsc3RhdGU6bnVsbCxuOjAsc3RhY2s6W119LG9wdDp7ZmlsZW5hbWU6ImZpbGUucGRmIixtYXJnaW46WzAsMCwwLDBdLGVuYWJsZUxpbmtzOiEwLHg6MCx5OjAsaHRtbDJjYW52YXM6e30sanNQREY6e30sYmFja2dyb3VuZENvbG9yOiJ0cmFuc3BhcmVudCJ9fSxsLnByb3RvdHlwZS5mcm9tPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbigpe3N3aXRjaCh0PXR8fGZ1bmN0aW9uKGUpe3N3aXRjaChzKGUpKXtjYXNlInN0cmluZyI6cmV0dXJuInN0cmluZyI7Y2FzZSJlbGVtZW50IjpyZXR1cm4iY2FudmFzIj09PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT8iY2FudmFzIjoiZWxlbWVudCI7ZGVmYXVsdDpyZXR1cm4idW5rbm93biJ9fShlKSx0KXtjYXNlInN0cmluZyI6cmV0dXJuIHRoaXMudGhlbihuKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNldCh7c3JjOmkoImRpdiIse2lubmVySFRNTDplLGRvbXB1cmlmeTp0fSl9KX0pO2Nhc2UiZWxlbWVudCI6cmV0dXJuIHRoaXMuc2V0KHtzcmM6ZX0pO2Nhc2UiY2FudmFzIjpyZXR1cm4gdGhpcy5zZXQoe2NhbnZhczplfSk7Y2FzZSJpbWciOnJldHVybiB0aGlzLnNldCh7aW1nOmV9KTtkZWZhdWx0OnJldHVybiB0aGlzLmVycm9yKCJVbmtub3duIHNvdXJjZSB0eXBlLiIpfX0pfSxsLnByb3RvdHlwZS50bz1mdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZSJjb250YWluZXIiOnJldHVybiB0aGlzLnRvQ29udGFpbmVyKCk7Y2FzZSJjYW52YXMiOnJldHVybiB0aGlzLnRvQ2FudmFzKCk7Y2FzZSJpbWciOnJldHVybiB0aGlzLnRvSW1nKCk7Y2FzZSJwZGYiOnJldHVybiB0aGlzLnRvUGRmKCk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5lcnJvcigiSW52YWxpZCB0YXJnZXQuIil9fSxsLnByb3RvdHlwZS50b0NvbnRhaW5lcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3Auc3JjfHx0aGlzLmVycm9yKCJDYW5ub3QgZHVwbGljYXRlIC0gbm8gc291cmNlIEhUTUwuIil9LGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcC5wYWdlU2l6ZXx8dGhpcy5zZXRQYWdlU2l6ZSgpfV0pLnRoZW4oZnVuY3Rpb24oKXt2YXIgZT17cG9zaXRpb246InJlbGF0aXZlIixkaXNwbGF5OiJpbmxpbmUtYmxvY2siLHdpZHRoOigibnVtYmVyIiE9dHlwZW9mIHRoaXMub3B0LndpZHRofHxpc05hTih0aGlzLm9wdC53aWR0aCl8fCJudW1iZXIiIT10eXBlb2YgdGhpcy5vcHQud2luZG93V2lkdGh8fGlzTmFOKHRoaXMub3B0LndpbmRvd1dpZHRoKT9NYXRoLm1heCh0aGlzLnByb3Auc3JjLmNsaWVudFdpZHRoLHRoaXMucHJvcC5zcmMuc2Nyb2xsV2lkdGgsdGhpcy5wcm9wLnNyYy5vZmZzZXRXaWR0aCk6dGhpcy5vcHQud2luZG93V2lkdGgpKyJweCIsbGVmdDowLHJpZ2h0OjAsdG9wOjAsbWFyZ2luOiJhdXRvIixiYWNrZ3JvdW5kQ29sb3I6dGhpcy5vcHQuYmFja2dyb3VuZENvbG9yfSx0PWEodGhpcy5wcm9wLnNyYyx0aGlzLm9wdC5odG1sMmNhbnZhcy5qYXZhc2NyaXB0RW5hYmxlZCk7IkJPRFkiPT09dC50YWdOYW1lJiYoZS5oZWlnaHQ9TWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQpKyJweCIpLHRoaXMucHJvcC5vdmVybGF5PWkoImRpdiIse2NsYXNzTmFtZToiaHRtbDJwZGZfX292ZXJsYXkiLHN0eWxlOntwb3NpdGlvbjoiZml4ZWQiLG92ZXJmbG93OiJoaWRkZW4iLHpJbmRleDoxZTMsbGVmdDoiLTEwMDAwMHB4IixyaWdodDowLGJvdHRvbTowLHRvcDowfX0pLHRoaXMucHJvcC5jb250YWluZXI9aSgiZGl2Iix7Y2xhc3NOYW1lOiJodG1sMnBkZl9fY29udGFpbmVyIixzdHlsZTplfSksdGhpcy5wcm9wLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0KSx0aGlzLnByb3AuY29udGFpbmVyLmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQoaSgiZGl2Iix7c3R5bGU6e2NsZWFyOiJib3RoIixib3JkZXI6IjAgbm9uZSB0cmFuc3BhcmVudCIsbWFyZ2luOjAscGFkZGluZzowLGhlaWdodDowfX0pKSx0aGlzLnByb3AuY29udGFpbmVyLnN0eWxlLmZsb2F0PSJub25lIix0aGlzLnByb3Aub3ZlcmxheS5hcHBlbmRDaGlsZCh0aGlzLnByb3AuY29udGFpbmVyKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucHJvcC5vdmVybGF5KSx0aGlzLnByb3AuY29udGFpbmVyLmZpcnN0Q2hpbGQuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIix0aGlzLnByb3AuY29udGFpbmVyLmhlaWdodD1NYXRoLm1heCh0aGlzLnByb3AuY29udGFpbmVyLmZpcnN0Q2hpbGQuY2xpZW50SGVpZ2h0LHRoaXMucHJvcC5jb250YWluZXIuZmlyc3RDaGlsZC5zY3JvbGxIZWlnaHQsdGhpcy5wcm9wLmNvbnRhaW5lci5maXJzdENoaWxkLm9mZnNldEhlaWdodCkrInB4In0pfSxsLnByb3RvdHlwZS50b0NhbnZhcz1mdW5jdGlvbigpe3ZhciBlPVtmdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMucHJvcC5jb250YWluZXIpfHx0aGlzLnRvQ29udGFpbmVyKCl9XTtyZXR1cm4gdGhpcy50aGVuTGlzdChlKS50aGVuKHQpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9T2JqZWN0LmFzc2lnbih7fSx0aGlzLm9wdC5odG1sMmNhbnZhcyk7cmV0dXJuIGRlbGV0ZSB0Lm9ucmVuZGVyZWQsZSh0aGlzLnByb3AuY29udGFpbmVyLHQpfSkudGhlbihmdW5jdGlvbihlKXsodGhpcy5vcHQuaHRtbDJjYW52YXMub25yZW5kZXJlZHx8ZnVuY3Rpb24oKXt9KShlKSx0aGlzLnByb3AuY2FudmFzPWUsZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLnByb3Aub3ZlcmxheSl9KX0sbC5wcm90b3R5cGUudG9Db250ZXh0MmQ9ZnVuY3Rpb24oKXt2YXIgZT1bZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnByb3AuY29udGFpbmVyKXx8dGhpcy50b0NvbnRhaW5lcigpfV07cmV0dXJuIHRoaXMudGhlbkxpc3QoZSkudGhlbih0KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMub3B0LmpzUERGLEE9dGhpcy5vcHQuZm9udEZhY2VzLHI9Im51bWJlciIhPXR5cGVvZiB0aGlzLm9wdC53aWR0aHx8aXNOYU4odGhpcy5vcHQud2lkdGgpfHwibnVtYmVyIiE9dHlwZW9mIHRoaXMub3B0LndpbmRvd1dpZHRofHxpc05hTih0aGlzLm9wdC53aW5kb3dXaWR0aCk/MTp0aGlzLm9wdC53aWR0aC90aGlzLm9wdC53aW5kb3dXaWR0aCxuPU9iamVjdC5hc3NpZ24oe2FzeW5jOiEwLGFsbG93VGFpbnQ6ITAsc2NhbGU6cixzY3JvbGxYOnRoaXMub3B0LnNjcm9sbFh8fDAsc2Nyb2xsWTp0aGlzLm9wdC5zY3JvbGxZfHwwLGJhY2tncm91bmRDb2xvcjoiI2ZmZmZmZiIsaW1hZ2VUaW1lb3V0OjE1ZTMsbG9nZ2luZzohMCxwcm94eTpudWxsLHJlbW92ZUNvbnRhaW5lcjohMCxmb3JlaWduT2JqZWN0UmVuZGVyaW5nOiExLHVzZUNPUlM6ITF9LHRoaXMub3B0Lmh0bWwyY2FudmFzKTtpZihkZWxldGUgbi5vbnJlbmRlcmVkLHQuY29udGV4dDJkLmF1dG9QYWdpbmc9dm9pZCAwPT09dGhpcy5vcHQuYXV0b1BhZ2luZ3x8dGhpcy5vcHQuYXV0b1BhZ2luZyx0LmNvbnRleHQyZC5wb3NYPXRoaXMub3B0LngsdC5jb250ZXh0MmQucG9zWT10aGlzLm9wdC55LHQuY29udGV4dDJkLm1hcmdpbj10aGlzLm9wdC5tYXJnaW4sdC5jb250ZXh0MmQuZm9udEZhY2VzPUEsQSlmb3IodmFyIHM9MDtzPEEubGVuZ3RoOysrcyl7dmFyIGk9QVtzXSxvPWkuc3JjLmZpbmQoZnVuY3Rpb24oZSl7cmV0dXJuInRydWV0eXBlIj09PWUuZm9ybWF0fSk7byYmdC5hZGRGb250KG8udXJsLGkucmVmLm5hbWUsaS5yZWYuc3R5bGUpfXJldHVybiBuLndpbmRvd0hlaWdodD1uLndpbmRvd0hlaWdodHx8MCxuLndpbmRvd0hlaWdodD0wPT1uLndpbmRvd0hlaWdodD9NYXRoLm1heCh0aGlzLnByb3AuY29udGFpbmVyLmNsaWVudEhlaWdodCx0aGlzLnByb3AuY29udGFpbmVyLnNjcm9sbEhlaWdodCx0aGlzLnByb3AuY29udGFpbmVyLm9mZnNldEhlaWdodCk6bi53aW5kb3dIZWlnaHQsdC5jb250ZXh0MmQuc2F2ZSghMCksZSh0aGlzLnByb3AuY29udGFpbmVyLG4pfSkudGhlbihmdW5jdGlvbihlKXt0aGlzLm9wdC5qc1BERi5jb250ZXh0MmQucmVzdG9yZSghMCksKHRoaXMub3B0Lmh0bWwyY2FudmFzLm9ucmVuZGVyZWR8fGZ1bmN0aW9uKCl7fSkoZSksdGhpcy5wcm9wLmNhbnZhcz1lLGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5wcm9wLm92ZXJsYXkpfSl9LGwucHJvdG90eXBlLnRvSW1nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhlbkxpc3QoW2Z1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcC5jYW52YXN8fHRoaXMudG9DYW52YXMoKX1dKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wLmNhbnZhcy50b0RhdGFVUkwoImltYWdlLyIrdGhpcy5vcHQuaW1hZ2UudHlwZSx0aGlzLm9wdC5pbWFnZS5xdWFsaXR5KTt0aGlzLnByb3AuaW1nPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpLHRoaXMucHJvcC5pbWcuc3JjPWV9KX0sbC5wcm90b3R5cGUudG9QZGY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGVuTGlzdChbZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b0NvbnRleHQyZCgpfV0pLnRoZW4oZnVuY3Rpb24oKXt0aGlzLnByb3AucGRmPXRoaXMucHJvcC5wZGZ8fHRoaXMub3B0LmpzUERGfSl9LGwucHJvdG90eXBlLm91dHB1dD1mdW5jdGlvbihlLHQsQSl7cmV0dXJuImltZyI9PT0oQT1BfHwicGRmIikudG9Mb3dlckNhc2UoKXx8ImltYWdlIj09PUEudG9Mb3dlckNhc2UoKT90aGlzLm91dHB1dEltZyhlLHQpOnRoaXMub3V0cHV0UGRmKGUsdCl9LGwucHJvdG90eXBlLm91dHB1dFBkZj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AucGRmfHx0aGlzLnRvUGRmKCl9XSkudGhlbihmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AucGRmLm91dHB1dChlLHQpfSl9LGwucHJvdG90eXBlLm91dHB1dEltZz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aGVuTGlzdChbZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wLmltZ3x8dGhpcy50b0ltZygpfV0pLnRoZW4oZnVuY3Rpb24oKXtzd2l0Y2goZSl7Y2FzZSB2b2lkIDA6Y2FzZSJpbWciOnJldHVybiB0aGlzLnByb3AuaW1nO2Nhc2UiZGF0YXVyaXN0cmluZyI6Y2FzZSJkYXRhdXJsc3RyaW5nIjpyZXR1cm4gdGhpcy5wcm9wLmltZy5zcmM7Y2FzZSJkYXRhdXJpIjpjYXNlImRhdGF1cmwiOnJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmPXRoaXMucHJvcC5pbWcuc3JjO2RlZmF1bHQ6dGhyb3cnSW1hZ2Ugb3V0cHV0IHR5cGUgIicrZSsnIiBpcyBub3Qgc3VwcG9ydGVkLid9fSl9LGwucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhlbkxpc3QoW2Z1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcC5wZGZ8fHRoaXMudG9QZGYoKX1dKS5zZXQoZT97ZmlsZW5hbWU6ZX06bnVsbCkudGhlbihmdW5jdGlvbigpe3RoaXMucHJvcC5wZGYuc2F2ZSh0aGlzLm9wdC5maWxlbmFtZSl9KX0sbC5wcm90b3R5cGUuZG9DYWxsYmFjaz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AucGRmfHx0aGlzLnRvUGRmKCl9XSkudGhlbihmdW5jdGlvbigpe3RoaXMucHJvcC5jYWxsYmFjayh0aGlzLnByb3AucGRmKX0pfSxsLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oZSl7aWYoIm9iamVjdCIhPT1zKGUpKXJldHVybiB0aGlzO3ZhciB0PU9iamVjdC5rZXlzKGV8fHt9KS5tYXAoZnVuY3Rpb24odCl7aWYodCBpbiBsLnRlbXBsYXRlLnByb3ApcmV0dXJuIGZ1bmN0aW9uKCl7dGhpcy5wcm9wW3RdPWVbdF19O3N3aXRjaCh0KXtjYXNlIm1hcmdpbiI6cmV0dXJuIHRoaXMuc2V0TWFyZ2luLmJpbmQodGhpcyxlLm1hcmdpbik7Y2FzZSJqc1BERiI6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0LmpzUERGPWUuanNQREYsdGhpcy5zZXRQYWdlU2l6ZSgpfTtjYXNlInBhZ2VTaXplIjpyZXR1cm4gdGhpcy5zZXRQYWdlU2l6ZS5iaW5kKHRoaXMsZS5wYWdlU2l6ZSk7ZGVmYXVsdDpyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLm9wdFt0XT1lW3RdfX19LHRoaXMpO3JldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGVuTGlzdCh0KX0pfSxsLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKCl7dmFyIEE9ZSBpbiBsLnRlbXBsYXRlLnByb3A/dGhpcy5wcm9wW2VdOnRoaXMub3B0W2VdO3JldHVybiB0P3QoQSk6QX0pfSxsLnByb3RvdHlwZS5zZXRNYXJnaW49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbigpe3N3aXRjaChzKGUpKXtjYXNlIm51bWJlciI6ZT1bZSxlLGUsZV07Y2FzZSJhcnJheSI6aWYoMj09PWUubGVuZ3RoJiYoZT1bZVswXSxlWzFdLGVbMF0sZVsxXV0pLDQ9PT1lLmxlbmd0aClicmVhaztkZWZhdWx0OnJldHVybiB0aGlzLmVycm9yKCJJbnZhbGlkIG1hcmdpbiBhcnJheS4iKX10aGlzLm9wdC5tYXJnaW49ZX0pLnRoZW4odGhpcy5zZXRQYWdlU2l6ZSl9LGwucHJvdG90eXBlLnNldFBhZ2VTaXplPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSx0KXtyZXR1cm4gTWF0aC5mbG9vcihlKnQvNzIqOTYpfXJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24oKXsoZT1lfHxNLmdldFBhZ2VTaXplKHRoaXMub3B0LmpzUERGKSkuaGFzT3duUHJvcGVydHkoImlubmVyIil8fChlLmlubmVyPXt3aWR0aDplLndpZHRoLXRoaXMub3B0Lm1hcmdpblsxXS10aGlzLm9wdC5tYXJnaW5bM10saGVpZ2h0OmUuaGVpZ2h0LXRoaXMub3B0Lm1hcmdpblswXS10aGlzLm9wdC5tYXJnaW5bMl19LGUuaW5uZXIucHg9e3dpZHRoOnQoZS5pbm5lci53aWR0aCxlLmspLGhlaWdodDp0KGUuaW5uZXIuaGVpZ2h0LGUuayl9LGUuaW5uZXIucmF0aW89ZS5pbm5lci5oZWlnaHQvZS5pbm5lci53aWR0aCksdGhpcy5wcm9wLnBhZ2VTaXplPWV9KX0sbC5wcm90b3R5cGUuc2V0UHJvZ3Jlc3M9ZnVuY3Rpb24oZSx0LEEscil7cmV0dXJuIG51bGwhPWUmJih0aGlzLnByb2dyZXNzLnZhbD1lKSxudWxsIT10JiYodGhpcy5wcm9ncmVzcy5zdGF0ZT10KSxudWxsIT1BJiYodGhpcy5wcm9ncmVzcy5uPUEpLG51bGwhPXImJih0aGlzLnByb2dyZXNzLnN0YWNrPXIpLHRoaXMucHJvZ3Jlc3MucmF0aW89dGhpcy5wcm9ncmVzcy52YWwvdGhpcy5wcm9ncmVzcy5zdGF0ZSx0aGlzfSxsLnByb3RvdHlwZS51cGRhdGVQcm9ncmVzcz1mdW5jdGlvbihlLHQsQSxyKXtyZXR1cm4gdGhpcy5zZXRQcm9ncmVzcyhlP3RoaXMucHJvZ3Jlc3MudmFsK2U6bnVsbCx0fHxudWxsLEE/dGhpcy5wcm9ncmVzcy5uK0E6bnVsbCxyP3RoaXMucHJvZ3Jlc3Muc3RhY2suY29uY2F0KHIpOm51bGwpfSxsLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKGUsdCl7dmFyIEE9dGhpcztyZXR1cm4gdGhpcy50aGVuQ29yZShlLHQsZnVuY3Rpb24oZSx0KXtyZXR1cm4gQS51cGRhdGVQcm9ncmVzcyhudWxsLG51bGwsMSxbZV0pLFByb21pc2UucHJvdG90eXBlLnRoZW4uY2FsbCh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBBLnVwZGF0ZVByb2dyZXNzKG51bGwsZSksdH0pLnRoZW4oZSx0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBBLnVwZGF0ZVByb2dyZXNzKDEpLGV9KX0pfSxsLnByb3RvdHlwZS50aGVuQ29yZT1mdW5jdGlvbihlLHQsQSl7QT1BfHxQcm9taXNlLnByb3RvdHlwZS50aGVuO3ZhciByPXRoaXM7ZSYmKGU9ZS5iaW5kKHIpKSx0JiYodD10LmJpbmQocikpO3ZhciBuPS0xIT09UHJvbWlzZS50b1N0cmluZygpLmluZGV4T2YoIltuYXRpdmUgY29kZV0iKSYmIlByb21pc2UiPT09UHJvbWlzZS5uYW1lP3I6bC5jb252ZXJ0KE9iamVjdC5hc3NpZ24oe30sciksUHJvbWlzZS5wcm90b3R5cGUpLHM9QS5jYWxsKG4sZSx0KTtyZXR1cm4gbC5jb252ZXJ0KHMsci5fX3Byb3RvX18pfSxsLnByb3RvdHlwZS50aGVuRXh0ZXJuYWw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5jYWxsKHRoaXMsZSx0KX0sbC5wcm90b3R5cGUudGhlbkxpc3Q9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3Q9dC50aGVuQ29yZShlKX0pLHR9LGwucHJvdG90eXBlLmNhdGNoPWZ1bmN0aW9uKGUpe2UmJihlPWUuYmluZCh0aGlzKSk7dmFyIHQ9UHJvbWlzZS5wcm90b3R5cGUuY2F0Y2guY2FsbCh0aGlzLGUpO3JldHVybiBsLmNvbnZlcnQodCx0aGlzKX0sbC5wcm90b3R5cGUuY2F0Y2hFeHRlcm5hbD1mdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2guY2FsbCh0aGlzLGUpfSxsLnByb3RvdHlwZS5lcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKGUpfSl9LGwucHJvdG90eXBlLnVzaW5nPWwucHJvdG90eXBlLnNldCxsLnByb3RvdHlwZS5zYXZlQXM9bC5wcm90b3R5cGUuc2F2ZSxsLnByb3RvdHlwZS5leHBvcnQ9bC5wcm90b3R5cGUub3V0cHV0LGwucHJvdG90eXBlLnJ1bj1sLnByb3RvdHlwZS50aGVuLE0uZ2V0UGFnZVNpemU9ZnVuY3Rpb24oZSx0LEEpe2lmKCJvYmplY3QiPT09KDAsci5kZWZhdWx0KShlKSl7dmFyIG49ZTtlPW4ub3JpZW50YXRpb24sdD1uLnVuaXR8fHQsQT1uLmZvcm1hdHx8QX10PXR8fCJtbSIsQT1BfHwiYTQiLGU9KCIiKyhlfHwiUCIpKS50b0xvd2VyQ2FzZSgpO3ZhciBzLGk9KCIiK0EpLnRvTG93ZXJDYXNlKCksbz17YTA6WzIzODMuOTQsMzM3MC4zOV0sYTE6WzE2ODMuNzgsMjM4My45NF0sYTI6WzExOTAuNTUsMTY4My43OF0sYTM6Wzg0MS44OSwxMTkwLjU1XSxhNDpbNTk1LjI4LDg0MS44OV0sYTU6WzQxOS41Myw1OTUuMjhdLGE2OlsyOTcuNjQsNDE5LjUzXSxhNzpbMjA5Ljc2LDI5Ny42NF0sYTg6WzE0Ny40LDIwOS43Nl0sYTk6WzEwNC44OCwxNDcuNF0sYTEwOls3My43LDEwNC44OF0sYjA6WzI4MzQuNjUsNDAwOC4xOV0sYjE6WzIwMDQuMDksMjgzNC42NV0sYjI6WzE0MTcuMzIsMjAwNC4wOV0sYjM6WzEwMDAuNjMsMTQxNy4zMl0sYjQ6WzcwOC42NiwxMDAwLjYzXSxiNTpbNDk4LjksNzA4LjY2XSxiNjpbMzU0LjMzLDQ5OC45XSxiNzpbMjQ5LjQ1LDM1NC4zM10sYjg6WzE3NS43NSwyNDkuNDVdLGI5OlsxMjQuNzIsMTc1Ljc1XSxiMTA6Wzg3Ljg3LDEyNC43Ml0sYzA6WzI1OTkuMzcsMzY3Ni41NF0sYzE6WzE4MzYuODUsMjU5OS4zN10sYzI6WzEyOTguMjcsMTgzNi44NV0sYzM6WzkxOC40MywxMjk4LjI3XSxjNDpbNjQ5LjEzLDkxOC40M10sYzU6WzQ1OS4yMSw2NDkuMTNdLGM2OlszMjMuMTUsNDU5LjIxXSxjNzpbMjI5LjYxLDMyMy4xNV0sYzg6WzE2MS41NywyMjkuNjFdLGM5OlsxMTMuMzksMTYxLjU3XSxjMTA6Wzc5LjM3LDExMy4zOV0sZGw6WzMxMS44MSw2MjMuNjJdLGxldHRlcjpbNjEyLDc5Ml0sImdvdmVybm1lbnQtbGV0dGVyIjpbNTc2LDc1Nl0sbGVnYWw6WzYxMiwxMDA4XSwianVuaW9yLWxlZ2FsIjpbNTc2LDM2MF0sbGVkZ2VyOlsxMjI0LDc5Ml0sdGFibG9pZDpbNzkyLDEyMjRdLCJjcmVkaXQtY2FyZCI6WzE1MywyNDNdfTtzd2l0Y2godCl7Y2FzZSJwdCI6cz0xO2JyZWFrO2Nhc2UibW0iOnM9NzIvMjUuNDticmVhaztjYXNlImNtIjpzPTcyLzIuNTQ7YnJlYWs7Y2FzZSJpbiI6cz03MjticmVhaztjYXNlInB4IjpzPS43NTticmVhaztjYXNlInBjIjpjYXNlImVtIjpzPTEyO2JyZWFrO2Nhc2UiZXgiOnM9NjticmVhaztkZWZhdWx0OnRocm93IkludmFsaWQgdW5pdDogIit0fXZhciBhLGw9MCxjPTA7aWYoby5oYXNPd25Qcm9wZXJ0eShpKSlsPW9baV1bMV0vcyxjPW9baV1bMF0vcztlbHNlIHRyeXtsPUFbMV0sYz1BWzBdfWNhdGNoKGUpe3Rocm93IG5ldyBFcnJvcigiSW52YWxpZCBmb3JtYXQ6ICIrQSl9aWYoInAiPT09ZXx8InBvcnRyYWl0Ij09PWUpZT0icCIsYz5sJiYoYT1jLGM9bCxsPWEpO2Vsc2V7aWYoImwiIT09ZSYmImxhbmRzY2FwZSIhPT1lKXRocm93IkludmFsaWQgb3JpZW50YXRpb246ICIrZTtlPSJsIixsPmMmJihhPWMsYz1sLGw9YSl9cmV0dXJue3dpZHRoOmMsaGVpZ2h0OmwsdW5pdDp0LGs6cyxvcmllbnRhdGlvbjplfX0sZS5odG1sPWZ1bmN0aW9uKGUsdCl7KHQ9dHx8e30pLmNhbGxiYWNrPXQuY2FsbGJhY2t8fGZ1bmN0aW9uKCl7fSx0Lmh0bWwyY2FudmFzPXQuaHRtbDJjYW52YXN8fHt9LHQuaHRtbDJjYW52YXMuY2FudmFzPXQuaHRtbDJjYW52YXMuY2FudmFzfHx0aGlzLmNhbnZhcyx0LmpzUERGPXQuanNQREZ8fHRoaXMsdC5mb250RmFjZXM9dC5mb250RmFjZXM/dC5mb250RmFjZXMubWFwKEhlKTpudWxsO3ZhciBBPW5ldyBsKHQpO3JldHVybiB0Lndvcmtlcj9BOkEuZnJvbShlKS5kb0NhbGxiYWNrKCl9fShNLkFQSSksTS5BUEkuYWRkSlM9ZnVuY3Rpb24oZSl7cmV0dXJuIHplPWUsdGhpcy5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKCJwb3N0UHV0UmVzb3VyY2VzIixmdW5jdGlvbigpe1ZlPXRoaXMuaW50ZXJuYWwubmV3T2JqZWN0KCksdGhpcy5pbnRlcm5hbC5vdXQoIjw8IiksdGhpcy5pbnRlcm5hbC5vdXQoIi9OYW1lcyBbKEVtYmVkZGVkSlMpICIrKFZlKzEpKyIgMCBSXSIpLHRoaXMuaW50ZXJuYWwub3V0KCI+PiIpLHRoaXMuaW50ZXJuYWwub3V0KCJlbmRvYmoiKSxHZT10aGlzLmludGVybmFsLm5ld09iamVjdCgpLHRoaXMuaW50ZXJuYWwub3V0KCI8PCIpLHRoaXMuaW50ZXJuYWwub3V0KCIvUyAvSmF2YVNjcmlwdCIpLHRoaXMuaW50ZXJuYWwub3V0KCIvSlMgKCIremUrIikiKSx0aGlzLmludGVybmFsLm91dCgiPj4iKSx0aGlzLmludGVybmFsLm91dCgiZW5kb2JqIil9KSx0aGlzLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInB1dENhdGFsb2ciLGZ1bmN0aW9uKCl7dm9pZCAwIT09VmUmJnZvaWQgMCE9PUdlJiZ0aGlzLmludGVybmFsLm91dCgiL05hbWVzIDw8L0phdmFTY3JpcHQgIitWZSsiIDAgUj4+Iil9KSx0aGlzfSxmdW5jdGlvbihlKXt2YXIgdDtlLmV2ZW50cy5wdXNoKFsicG9zdFB1dFJlc291cmNlcyIsZnVuY3Rpb24oKXt2YXIgZT10aGlzLEE9L14oXGQrKSAwIG9iaiQvO2lmKHRoaXMub3V0bGluZS5yb290LmNoaWxkcmVuLmxlbmd0aD4wKWZvcih2YXIgcj1lLm91dGxpbmUucmVuZGVyKCkuc3BsaXQoL1xyXG4vKSxuPTA7bjxyLmxlbmd0aDtuKyspe3ZhciBzPXJbbl0saT1BLmV4ZWMocyk7aWYobnVsbCE9aSl7dmFyIG89aVsxXTtlLmludGVybmFsLm5ld09iamVjdERlZmVycmVkQmVnaW4obywhMSl9ZS5pbnRlcm5hbC53cml0ZShzKX1pZih0aGlzLm91dGxpbmUuY3JlYXRlTmFtZWREZXN0aW5hdGlvbnMpe3ZhciBhPXRoaXMuaW50ZXJuYWwucGFnZXMubGVuZ3RoLGw9W107Zm9yKG49MDtuPGE7bisrKXt2YXIgYz1lLmludGVybmFsLm5ld09iamVjdCgpO2wucHVzaChjKTt2YXIgdT1lLmludGVybmFsLmdldFBhZ2VJbmZvKG4rMSk7ZS5pbnRlcm5hbC53cml0ZSgiPDwgL0RbIit1Lm9iaklkKyIgMCBSIC9YWVogbnVsbCBudWxsIG51bGxdPj4gZW5kb2JqIil9dmFyIGg9ZS5pbnRlcm5hbC5uZXdPYmplY3QoKTtmb3IoZS5pbnRlcm5hbC53cml0ZSgiPDwgL05hbWVzIFsgIiksbj0wO248bC5sZW5ndGg7bisrKWUuaW50ZXJuYWwud3JpdGUoIihwYWdlXyIrKG4rMSkrIikiK2xbbl0rIiAwIFIiKTtlLmludGVybmFsLndyaXRlKCIgXSA+PiIsImVuZG9iaiIpLHQ9ZS5pbnRlcm5hbC5uZXdPYmplY3QoKSxlLmludGVybmFsLndyaXRlKCI8PCAvRGVzdHMgIitoKyIgMCBSIiksZS5pbnRlcm5hbC53cml0ZSgiPj4iLCJlbmRvYmoiKX19XSksZS5ldmVudHMucHVzaChbInB1dENhdGFsb2ciLGZ1bmN0aW9uKCl7dmFyIGU9dGhpcztlLm91dGxpbmUucm9vdC5jaGlsZHJlbi5sZW5ndGg+MCYmKGUuaW50ZXJuYWwud3JpdGUoIi9PdXRsaW5lcyIsdGhpcy5vdXRsaW5lLm1ha2VSZWYodGhpcy5vdXRsaW5lLnJvb3QpKSx0aGlzLm91dGxpbmUuY3JlYXRlTmFtZWREZXN0aW5hdGlvbnMmJmUuaW50ZXJuYWwud3JpdGUoIi9OYW1lcyAiK3QrIiAwIFIiKSl9XSksZS5ldmVudHMucHVzaChbImluaXRpYWxpemVkIixmdW5jdGlvbigpe3ZhciBlPXRoaXM7ZS5vdXRsaW5lPXtjcmVhdGVOYW1lZERlc3RpbmF0aW9uczohMSxyb290OntjaGlsZHJlbjpbXX19LGUub3V0bGluZS5hZGQ9ZnVuY3Rpb24oZSx0LEEpe3ZhciByPXt0aXRsZTp0LG9wdGlvbnM6QSxjaGlsZHJlbjpbXX07cmV0dXJuIG51bGw9PWUmJihlPXRoaXMucm9vdCksZS5jaGlsZHJlbi5wdXNoKHIpLHJ9LGUub3V0bGluZS5yZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHg9e30sdGhpcy5jdHgudmFsPSIiLHRoaXMuY3R4LnBkZj1lLHRoaXMuZ2VuSWRzX3IodGhpcy5yb290KSx0aGlzLnJlbmRlclJvb3QodGhpcy5yb290KSx0aGlzLnJlbmRlckl0ZW1zKHRoaXMucm9vdCksdGhpcy5jdHgudmFsfSxlLm91dGxpbmUuZ2VuSWRzX3I9ZnVuY3Rpb24odCl7dC5pZD1lLmludGVybmFsLm5ld09iamVjdERlZmVycmVkKCk7Zm9yKHZhciBBPTA7QTx0LmNoaWxkcmVuLmxlbmd0aDtBKyspdGhpcy5nZW5JZHNfcih0LmNoaWxkcmVuW0FdKX0sZS5vdXRsaW5lLnJlbmRlclJvb3Q9ZnVuY3Rpb24oZSl7dGhpcy5vYmpTdGFydChlKSx0aGlzLmxpbmUoIi9UeXBlIC9PdXRsaW5lcyIpLGUuY2hpbGRyZW4ubGVuZ3RoPjAmJih0aGlzLmxpbmUoIi9GaXJzdCAiK3RoaXMubWFrZVJlZihlLmNoaWxkcmVuWzBdKSksdGhpcy5saW5lKCIvTGFzdCAiK3RoaXMubWFrZVJlZihlLmNoaWxkcmVuW2UuY2hpbGRyZW4ubGVuZ3RoLTFdKSkpLHRoaXMubGluZSgiL0NvdW50ICIrdGhpcy5jb3VudF9yKHtjb3VudDowfSxlKSksdGhpcy5vYmpFbmQoKX0sZS5vdXRsaW5lLnJlbmRlckl0ZW1zPWZ1bmN0aW9uKHQpe2Zvcih2YXIgQT10aGlzLmN0eC5wZGYuaW50ZXJuYWwuZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nLHI9MDtyPHQuY2hpbGRyZW4ubGVuZ3RoO3IrKyl7dmFyIG49dC5jaGlsZHJlbltyXTt0aGlzLm9ialN0YXJ0KG4pLHRoaXMubGluZSgiL1RpdGxlICIrdGhpcy5tYWtlU3RyaW5nKG4udGl0bGUpKSx0aGlzLmxpbmUoIi9QYXJlbnQgIit0aGlzLm1ha2VSZWYodCkpLHI+MCYmdGhpcy5saW5lKCIvUHJldiAiK3RoaXMubWFrZVJlZih0LmNoaWxkcmVuW3ItMV0pKSxyPHQuY2hpbGRyZW4ubGVuZ3RoLTEmJnRoaXMubGluZSgiL05leHQgIit0aGlzLm1ha2VSZWYodC5jaGlsZHJlbltyKzFdKSksbi5jaGlsZHJlbi5sZW5ndGg+MCYmKHRoaXMubGluZSgiL0ZpcnN0ICIrdGhpcy5tYWtlUmVmKG4uY2hpbGRyZW5bMF0pKSx0aGlzLmxpbmUoIi9MYXN0ICIrdGhpcy5tYWtlUmVmKG4uY2hpbGRyZW5bbi5jaGlsZHJlbi5sZW5ndGgtMV0pKSk7dmFyIHM9dGhpcy5jb3VudD10aGlzLmNvdW50X3Ioe2NvdW50OjB9LG4pO2lmKHM+MCYmdGhpcy5saW5lKCIvQ291bnQgIitzKSxuLm9wdGlvbnMmJm4ub3B0aW9ucy5wYWdlTnVtYmVyKXt2YXIgaT1lLmludGVybmFsLmdldFBhZ2VJbmZvKG4ub3B0aW9ucy5wYWdlTnVtYmVyKTt0aGlzLmxpbmUoIi9EZXN0IFsiK2kub2JqSWQrIiAwIFIgL1hZWiAwICIrQSgwKSsiIDBdIil9dGhpcy5vYmpFbmQoKX1mb3IodmFyIG89MDtvPHQuY2hpbGRyZW4ubGVuZ3RoO28rKyl0aGlzLnJlbmRlckl0ZW1zKHQuY2hpbGRyZW5bb10pfSxlLm91dGxpbmUubGluZT1mdW5jdGlvbihlKXt0aGlzLmN0eC52YWwrPWUrIlxyXG4ifSxlLm91dGxpbmUubWFrZVJlZj1mdW5jdGlvbihlKXtyZXR1cm4gZS5pZCsiIDAgUiJ9LGUub3V0bGluZS5tYWtlU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiIoIitlLmludGVybmFsLnBkZkVzY2FwZSh0KSsiKSJ9LGUub3V0bGluZS5vYmpTdGFydD1mdW5jdGlvbihlKXt0aGlzLmN0eC52YWwrPSJcclxuIitlLmlkKyIgMCBvYmpcclxuPDxcclxuIn0sZS5vdXRsaW5lLm9iakVuZD1mdW5jdGlvbigpe3RoaXMuY3R4LnZhbCs9Ij4+IFxyXG5lbmRvYmpcclxuIn0sZS5vdXRsaW5lLmNvdW50X3I9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIEE9MDtBPHQuY2hpbGRyZW4ubGVuZ3RoO0ErKyllLmNvdW50KyssdGhpcy5jb3VudF9yKGUsdC5jaGlsZHJlbltBXSk7cmV0dXJuIGUuY291bnR9fV0pfShNLkFQSSksZnVuY3Rpb24oZSl7dmFyIHQ9WzE5MiwxOTMsMTk0LDE5NSwxOTYsMTk3LDE5OCwxOTldO2UucHJvY2Vzc0pQRUc9ZnVuY3Rpb24oZSxBLHIsbixzLGkpe3ZhciBvLGE9dGhpcy5kZWNvZGUuRENUX0RFQ09ERSxsPW51bGw7aWYoInN0cmluZyI9PXR5cGVvZiBlfHx0aGlzLl9fYWRkaW1hZ2VfXy5pc0FycmF5QnVmZmVyKGUpfHx0aGlzLl9fYWRkaW1hZ2VfXy5pc0FycmF5QnVmZmVyVmlldyhlKSl7c3dpdGNoKGU9c3x8ZSxlPXRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXIoZSk/bmV3IFVpbnQ4QXJyYXkoZSk6ZSxvPWZ1bmN0aW9uKGUpe2Zvcih2YXIgQSxyPTI1NiplLmNoYXJDb2RlQXQoNCkrZS5jaGFyQ29kZUF0KDUpLG49ZS5sZW5ndGgscz17d2lkdGg6MCxoZWlnaHQ6MCxudW1jb21wb25lbnRzOjF9LGk9NDtpPG47aSs9Mil7aWYoaSs9ciwtMSE9PXQuaW5kZXhPZihlLmNoYXJDb2RlQXQoaSsxKSkpe0E9MjU2KmUuY2hhckNvZGVBdChpKzUpK2UuY2hhckNvZGVBdChpKzYpLHM9e3dpZHRoOjI1NiplLmNoYXJDb2RlQXQoaSs3KStlLmNoYXJDb2RlQXQoaSs4KSxoZWlnaHQ6QSxudW1jb21wb25lbnRzOmUuY2hhckNvZGVBdChpKzkpfTticmVha31yPTI1NiplLmNoYXJDb2RlQXQoaSsyKStlLmNoYXJDb2RlQXQoaSszKX1yZXR1cm4gc30oZT10aGlzLl9fYWRkaW1hZ2VfXy5pc0FycmF5QnVmZmVyVmlldyhlKT90aGlzLl9fYWRkaW1hZ2VfXy5hcnJheUJ1ZmZlclRvQmluYXJ5U3RyaW5nKGUpOmUpLG8ubnVtY29tcG9uZW50cyl7Y2FzZSAxOmk9dGhpcy5jb2xvcl9zcGFjZXMuREVWSUNFX0dSQVk7YnJlYWs7Y2FzZSA0Omk9dGhpcy5jb2xvcl9zcGFjZXMuREVWSUNFX0NNWUs7YnJlYWs7Y2FzZSAzOmk9dGhpcy5jb2xvcl9zcGFjZXMuREVWSUNFX1JHQn1sPXtkYXRhOmUsd2lkdGg6by53aWR0aCxoZWlnaHQ6by5oZWlnaHQsY29sb3JTcGFjZTppLGJpdHNQZXJDb21wb25lbnQ6OCxmaWx0ZXI6YSxpbmRleDpBLGFsaWFzOnJ9fXJldHVybiBsfX0oTS5BUEkpLE0uQVBJLnByb2Nlc3NQTkc9ZnVuY3Rpb24oZSx0LEEscil7aWYodGhpcy5fX2FkZGltYWdlX18uaXNBcnJheUJ1ZmZlcihlKSYmKGU9bmV3IFVpbnQ4QXJyYXkoZSkpLHRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXJWaWV3KGUpKXt2YXIgbyxhPSgwLGkuZGVjb2RlKShlLHtjaGVja0NyYzohMH0pLGw9YS53aWR0aCxjPWEuaGVpZ2h0LHU9YS5jaGFubmVscyxoPWEucGFsZXR0ZSxkPWEuZGVwdGg7bz1oJiYxPT09dT9mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS53aWR0aCxBPWUuaGVpZ2h0LHI9ZS5kYXRhLG49ZS5wYWxldHRlLGk9ZS5kZXB0aCxvPSExLGE9W10sbD1bXSxjPXZvaWQgMCx1PSExLGg9MCxkPTA7ZDxuLmxlbmd0aDtkKyspe3ZhciBmPSgwLHMuZGVmYXVsdCkobltkXSw0KSxwPWZbMF0sZz1mWzFdLG09ZlsyXSx3PWZbM107YS5wdXNoKHAsZyxtKSxudWxsIT13JiYoMD09PXc/KGgrKyxsLmxlbmd0aDwxJiZsLnB1c2goZCkpOnc8MjU1JiYodT0hMCkpfWlmKHV8fGg+MSl7bz0hMCxsPXZvaWQgMDt2YXIgQj10KkE7Yz1uZXcgVWludDhBcnJheShCKTtmb3IodmFyIHk9bmV3IERhdGFWaWV3KHIuYnVmZmVyKSx2PTA7djxCO3YrKyl7dmFyIGI9b3QoeSx2LGkpLEM9KDAscy5kZWZhdWx0KShuW2JdLDQpWzNdO2Nbdl09Q319cmV0dXJue2NvbG9yU3BhY2U6IkluZGV4ZWQiLGNvbG9yc1BlclBpeGVsOjEsY29sb3JCeXRlczpyLGFscGhhQnl0ZXM6YyxuZWVkU01hc2s6byxwYWxldHRlOmEsbWFzazpsfX0oYSk6Mj09PXV8fDQ9PT11P2Z1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmRhdGEsQT1lLndpZHRoLHI9ZS5oZWlnaHQsbj1lLmNoYW5uZWxzLHM9ZS5kZXB0aCxpPTI9PT1uPyJEZXZpY2VHcmF5IjoiRGV2aWNlUkdCIixvPW4tMSxhPUEqcixsPW8sYz1hKmwsdT0xKmEsaD1NYXRoLmNlaWwoYypzLzgpLGQ9TWF0aC5jZWlsKHUqcy84KSxmPW5ldyBVaW50OEFycmF5KGgpLHA9bmV3IFVpbnQ4QXJyYXkoZCksZz1uZXcgRGF0YVZpZXcodC5idWZmZXIpLG09bmV3IERhdGFWaWV3KGYuYnVmZmVyKSx3PW5ldyBEYXRhVmlldyhwLmJ1ZmZlciksQj0hMSx5PTA7eTxhO3krKyl7Zm9yKHZhciB2PXkqbixiPTA7YjxsO2IrKylhdChtLG90KGcsditiLHMpLHkqbCtiLHMpO3ZhciBDPW90KGcsditsLHMpO0M8KDE8PHMpLTEmJihCPSEwKSxhdCh3LEMsMSp5LHMpfXJldHVybntjb2xvclNwYWNlOmksY29sb3JzUGVyUGl4ZWw6byxjb2xvckJ5dGVzOmYsYWxwaGFCeXRlczpwLG5lZWRTTWFzazpCfX0oYSk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5kYXRhLEE9MT09PWUuY2hhbm5lbHM/IkRldmljZUdyYXkiOiJEZXZpY2VSR0IiO3JldHVybntjb2xvclNwYWNlOkEsY29sb3JzUGVyUGl4ZWw6IkRldmljZUdyYXkiPT09QT8xOjMsY29sb3JCeXRlczp0IGluc3RhbmNlb2YgVWludDhBcnJheT90Om5ldyBVaW50OEFycmF5KHQuYnVmZmVyKSxuZWVkU01hc2s6ITF9fShhKTt2YXIgZixwLGcsbT1vLHc9bS5jb2xvclNwYWNlLEI9bS5jb2xvcnNQZXJQaXhlbCx5PW0uY29sb3JCeXRlcyx2PW0uYWxwaGFCeXRlcyxiPW0ubmVlZFNNYXNrLEM9bS5wYWxldHRlLF89bS5tYXNrLGo9bnVsbDtyZXR1cm4gciE9PU0uQVBJLmltYWdlX2NvbXByZXNzaW9uLk5PTkUmJiJmdW5jdGlvbiI9PXR5cGVvZiBuLnpsaWJTeW5jPyhqPWZ1bmN0aW9uKGUpe3ZhciB0O3N3aXRjaChlKXtjYXNlIE0uQVBJLmltYWdlX2NvbXByZXNzaW9uLkZBU1Q6dD0xMTticmVhaztjYXNlIE0uQVBJLmltYWdlX2NvbXByZXNzaW9uLk1FRElVTTp0PTEzO2JyZWFrO2Nhc2UgTS5BUEkuaW1hZ2VfY29tcHJlc3Npb24uU0xPVzp0PTE0O2JyZWFrO2RlZmF1bHQ6dD0xMn1yZXR1cm4gdH0ociksZj10aGlzLmRlY29kZS5GTEFURV9ERUNPREUscD0iL1ByZWRpY3RvciAiLmNvbmNhdChqLCIgIiksZT0kZSh5LGwqQixCLHIpLGImJihnPSRlKHYsbCwxLHIpKSk6KGY9dm9pZCAwLHA9IiIsZT15LGImJihnPXYpKSxwKz0iL0NvbG9ycyAiLmNvbmNhdChCLCIgL0JpdHNQZXJDb21wb25lbnQgIikuY29uY2F0KGQsIiAvQ29sdW1ucyAiKS5jb25jYXQobCksKHRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXIoZSl8fHRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXJWaWV3KGUpKSYmKGU9dGhpcy5fX2FkZGltYWdlX18uYXJyYXlCdWZmZXJUb0JpbmFyeVN0cmluZyhlKSksKGcmJnRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXIoZyl8fHRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXJWaWV3KGcpKSYmKGc9dGhpcy5fX2FkZGltYWdlX18uYXJyYXlCdWZmZXJUb0JpbmFyeVN0cmluZyhnKSkse2FsaWFzOkEsZGF0YTplLGluZGV4OnQsZmlsdGVyOmYsZGVjb2RlUGFyYW1ldGVyczpwLHRyYW5zcGFyZW5jeTpfLHBhbGV0dGU6QyxzTWFzazpnLHByZWRpY3RvcjpqLHdpZHRoOmwsaGVpZ2h0OmMsYml0c1BlckNvbXBvbmVudDpkLGNvbG9yU3BhY2U6d319fSxmdW5jdGlvbihlKXtlLnByb2Nlc3NHSUY4OUE9ZnVuY3Rpb24odCxBLHIsbil7dmFyIHM9bmV3IGN0KHQpLGk9cy53aWR0aCxvPXMuaGVpZ2h0LGE9W107cy5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBKDAsYSk7dmFyIGw9e2RhdGE6YSx3aWR0aDppLGhlaWdodDpvfSxjPW5ldyBodCgxMDApLmVuY29kZShsLDEwMCk7cmV0dXJuIGUucHJvY2Vzc0pQRUcuY2FsbCh0aGlzLGMsQSxyLG4pfSxlLnByb2Nlc3NHSUY4N0E9ZS5wcm9jZXNzR0lGODlBfShNLkFQSSksZHQucHJvdG90eXBlLnBhcnNlSGVhZGVyPWZ1bmN0aW9uKCl7aWYodGhpcy5maWxlU2l6ZT10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5yZXNlcnZlZD10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5vZmZzZXQ9dGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsITApLHRoaXMucG9zKz00LHRoaXMuaGVhZGVyU2l6ZT10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy53aWR0aD10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5oZWlnaHQ9dGhpcy5kYXRhdi5nZXRJbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5wbGFuZXM9dGhpcy5kYXRhdi5nZXRVaW50MTYodGhpcy5wb3MsITApLHRoaXMucG9zKz0yLHRoaXMuYml0UFA9dGhpcy5kYXRhdi5nZXRVaW50MTYodGhpcy5wb3MsITApLHRoaXMucG9zKz0yLHRoaXMuY29tcHJlc3M9dGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsITApLHRoaXMucG9zKz00LHRoaXMucmF3U2l6ZT10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5ocj10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy52cj10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5jb2xvcnM9dGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsITApLHRoaXMucG9zKz00LHRoaXMuaW1wb3J0YW50Q29sb3JzPXRoaXMuZGF0YXYuZ2V0VWludDMyKHRoaXMucG9zLCEwKSx0aGlzLnBvcys9NCwxNj09PXRoaXMuYml0UFAmJnRoaXMuaXNfd2l0aF9hbHBoYSYmKHRoaXMuYml0UFA9MTUpLHRoaXMuYml0UFA8MTUpe3ZhciBlPTA9PT10aGlzLmNvbG9ycz8xPDx0aGlzLmJpdFBQOnRoaXMuY29sb3JzO3RoaXMucGFsZXR0ZT1uZXcgQXJyYXkoZSk7Zm9yKHZhciB0PTA7dDxlO3QrKyl7dmFyIEE9dGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCEwKSxyPXRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywhMCksbj10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLHM9dGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCEwKTt0aGlzLnBhbGV0dGVbdF09e3JlZDpuLGdyZWVuOnIsYmx1ZTpBLHF1YWQ6c319fXRoaXMuaGVpZ2h0PDAmJih0aGlzLmhlaWdodCo9LTEsdGhpcy5ib3R0b21fdXA9ITEpfSxkdC5wcm90b3R5cGUucGFyc2VCR1I9ZnVuY3Rpb24oKXt0aGlzLnBvcz10aGlzLm9mZnNldDt0cnl7dmFyIGU9ImJpdCIrdGhpcy5iaXRQUCx0PXRoaXMud2lkdGgqdGhpcy5oZWlnaHQqNDt0aGlzLmRhdGE9bmV3IFVpbnQ4QXJyYXkodCksdGhpc1tlXSgpfWNhdGNoKGUpe2wubG9nKCJiaXQgZGVjb2RlIGVycm9yOiIrZSl9fSxkdC5wcm90b3R5cGUuYml0MT1mdW5jdGlvbigpe3ZhciBlLHQ9TWF0aC5jZWlsKHRoaXMud2lkdGgvOCksQT10JTQ7Zm9yKGU9dGhpcy5oZWlnaHQtMTtlPj0wO2UtLSl7Zm9yKHZhciByPXRoaXMuYm90dG9tX3VwP2U6dGhpcy5oZWlnaHQtMS1lLG49MDtuPHQ7bisrKWZvcih2YXIgcz10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLGk9cip0aGlzLndpZHRoKjQrOCpuKjQsbz0wO288OCYmOCpuK288dGhpcy53aWR0aDtvKyspe3ZhciBhPXRoaXMucGFsZXR0ZVtzPj43LW8mMV07dGhpcy5kYXRhW2krNCpvXT1hLmJsdWUsdGhpcy5kYXRhW2krNCpvKzFdPWEuZ3JlZW4sdGhpcy5kYXRhW2krNCpvKzJdPWEucmVkLHRoaXMuZGF0YVtpKzQqbyszXT0yNTV9MCE9PUEmJih0aGlzLnBvcys9NC1BKX19LGR0LnByb3RvdHlwZS5iaXQ0PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPU1hdGguY2VpbCh0aGlzLndpZHRoLzIpLHQ9ZSU0LEE9dGhpcy5oZWlnaHQtMTtBPj0wO0EtLSl7Zm9yKHZhciByPXRoaXMuYm90dG9tX3VwP0E6dGhpcy5oZWlnaHQtMS1BLG49MDtuPGU7bisrKXt2YXIgcz10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLGk9cip0aGlzLndpZHRoKjQrMipuKjQsbz1zPj40LGE9MTUmcyxsPXRoaXMucGFsZXR0ZVtvXTtpZih0aGlzLmRhdGFbaV09bC5ibHVlLHRoaXMuZGF0YVtpKzFdPWwuZ3JlZW4sdGhpcy5kYXRhW2krMl09bC5yZWQsdGhpcy5kYXRhW2krM109MjU1LDIqbisxPj10aGlzLndpZHRoKWJyZWFrO2w9dGhpcy5wYWxldHRlW2FdLHRoaXMuZGF0YVtpKzRdPWwuYmx1ZSx0aGlzLmRhdGFbaSs0KzFdPWwuZ3JlZW4sdGhpcy5kYXRhW2krNCsyXT1sLnJlZCx0aGlzLmRhdGFbaSs0KzNdPTI1NX0wIT09dCYmKHRoaXMucG9zKz00LXQpfX0sZHQucHJvdG90eXBlLmJpdDg9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy53aWR0aCU0LHQ9dGhpcy5oZWlnaHQtMTt0Pj0wO3QtLSl7Zm9yKHZhciBBPXRoaXMuYm90dG9tX3VwP3Q6dGhpcy5oZWlnaHQtMS10LHI9MDtyPHRoaXMud2lkdGg7cisrKXt2YXIgbj10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLHM9QSp0aGlzLndpZHRoKjQrNCpyO2lmKG48dGhpcy5wYWxldHRlLmxlbmd0aCl7dmFyIGk9dGhpcy5wYWxldHRlW25dO3RoaXMuZGF0YVtzXT1pLnJlZCx0aGlzLmRhdGFbcysxXT1pLmdyZWVuLHRoaXMuZGF0YVtzKzJdPWkuYmx1ZSx0aGlzLmRhdGFbcyszXT0yNTV9ZWxzZSB0aGlzLmRhdGFbc109MjU1LHRoaXMuZGF0YVtzKzFdPTI1NSx0aGlzLmRhdGFbcysyXT0yNTUsdGhpcy5kYXRhW3MrM109MjU1fTAhPT1lJiYodGhpcy5wb3MrPTQtZSl9fSxkdC5wcm90b3R5cGUuYml0MTU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy53aWR0aCUzLHQ9cGFyc2VJbnQoIjExMTExIiwyKSxBPXRoaXMuaGVpZ2h0LTE7QT49MDtBLS0pe2Zvcih2YXIgcj10aGlzLmJvdHRvbV91cD9BOnRoaXMuaGVpZ2h0LTEtQSxuPTA7bjx0aGlzLndpZHRoO24rKyl7dmFyIHM9dGhpcy5kYXRhdi5nZXRVaW50MTYodGhpcy5wb3MsITApO3RoaXMucG9zKz0yO3ZhciBpPShzJnQpL3QqMjU1fDAsbz0ocz4+NSZ0KS90KjI1NXwwLGE9KHM+PjEwJnQpL3QqMjU1fDAsbD1zPj4xNT8yNTU6MCxjPXIqdGhpcy53aWR0aCo0KzQqbjt0aGlzLmRhdGFbY109YSx0aGlzLmRhdGFbYysxXT1vLHRoaXMuZGF0YVtjKzJdPWksdGhpcy5kYXRhW2MrM109bH10aGlzLnBvcys9ZX19LGR0LnByb3RvdHlwZS5iaXQxNj1mdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLndpZHRoJTMsdD1wYXJzZUludCgiMTExMTEiLDIpLEE9cGFyc2VJbnQoIjExMTExMSIsMikscj10aGlzLmhlaWdodC0xO3I+PTA7ci0tKXtmb3IodmFyIG49dGhpcy5ib3R0b21fdXA/cjp0aGlzLmhlaWdodC0xLXIscz0wO3M8dGhpcy53aWR0aDtzKyspe3ZhciBpPXRoaXMuZGF0YXYuZ2V0VWludDE2KHRoaXMucG9zLCEwKTt0aGlzLnBvcys9Mjt2YXIgbz0oaSZ0KS90KjI1NXwwLGE9KGk+PjUmQSkvQSoyNTV8MCxsPShpPj4xMSkvdCoyNTV8MCxjPW4qdGhpcy53aWR0aCo0KzQqczt0aGlzLmRhdGFbY109bCx0aGlzLmRhdGFbYysxXT1hLHRoaXMuZGF0YVtjKzJdPW8sdGhpcy5kYXRhW2MrM109MjU1fXRoaXMucG9zKz1lfX0sZHQucHJvdG90eXBlLmJpdDI0PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuaGVpZ2h0LTE7ZT49MDtlLS0pe2Zvcih2YXIgdD10aGlzLmJvdHRvbV91cD9lOnRoaXMuaGVpZ2h0LTEtZSxBPTA7QTx0aGlzLndpZHRoO0ErKyl7dmFyIHI9dGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCEwKSxuPXRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywhMCkscz10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLGk9dCp0aGlzLndpZHRoKjQrNCpBO3RoaXMuZGF0YVtpXT1zLHRoaXMuZGF0YVtpKzFdPW4sdGhpcy5kYXRhW2krMl09cix0aGlzLmRhdGFbaSszXT0yNTV9dGhpcy5wb3MrPXRoaXMud2lkdGglNH19LGR0LnByb3RvdHlwZS5iaXQzMj1mdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLmhlaWdodC0xO2U+PTA7ZS0tKWZvcih2YXIgdD10aGlzLmJvdHRvbV91cD9lOnRoaXMuaGVpZ2h0LTEtZSxBPTA7QTx0aGlzLndpZHRoO0ErKyl7dmFyIHI9dGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCEwKSxuPXRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywhMCkscz10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLGk9dGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCEwKSxvPXQqdGhpcy53aWR0aCo0KzQqQTt0aGlzLmRhdGFbb109cyx0aGlzLmRhdGFbbysxXT1uLHRoaXMuZGF0YVtvKzJdPXIsdGhpcy5kYXRhW28rM109aX19LGR0LnByb3RvdHlwZS5nZXREYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sZnVuY3Rpb24oZSl7ZS5wcm9jZXNzQk1QPWZ1bmN0aW9uKHQsQSxyLG4pe3ZhciBzPW5ldyBkdCh0LCExKSxpPXMud2lkdGgsbz1zLmhlaWdodCxhPXtkYXRhOnMuZ2V0RGF0YSgpLHdpZHRoOmksaGVpZ2h0Om99LGw9bmV3IGh0KDEwMCkuZW5jb2RlKGEsMTAwKTtyZXR1cm4gZS5wcm9jZXNzSlBFRy5jYWxsKHRoaXMsbCxBLHIsbil9fShNLkFQSSksZnQucHJvdG90eXBlLmdldERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxmdW5jdGlvbihlKXtlLnByb2Nlc3NXRUJQPWZ1bmN0aW9uKHQsQSxyLG4pe3ZhciBzPW5ldyBmdCh0KSxpPXMud2lkdGgsbz1zLmhlaWdodCxhPXtkYXRhOnMuZ2V0RGF0YSgpLHdpZHRoOmksaGVpZ2h0Om99LGw9bmV3IGh0KDEwMCkuZW5jb2RlKGEsMTAwKTtyZXR1cm4gZS5wcm9jZXNzSlBFRy5jYWxsKHRoaXMsbCxBLHIsbil9fShNLkFQSSksTS5BUEkucHJvY2Vzc1JHQkE9ZnVuY3Rpb24oZSx0LEEpe2Zvcih2YXIgcj1lLmRhdGEsbj1yLmxlbmd0aCxzPW5ldyBVaW50OEFycmF5KG4vNCozKSxpPW5ldyBVaW50OEFycmF5KG4vNCksbz0wLGE9MCxsPTA7bDxuO2wrPTQpe3ZhciBjPXJbbF0sdT1yW2wrMV0saD1yW2wrMl0sZD1yW2wrM107c1tvKytdPWMsc1tvKytdPXUsc1tvKytdPWgsaVthKytdPWR9dmFyIGY9dGhpcy5fX2FkZGltYWdlX18uYXJyYXlCdWZmZXJUb0JpbmFyeVN0cmluZyhzKTtyZXR1cm57YWxwaGE6dGhpcy5fX2FkZGltYWdlX18uYXJyYXlCdWZmZXJUb0JpbmFyeVN0cmluZyhpKSxkYXRhOmYsaW5kZXg6dCxhbGlhczpBLGNvbG9yU3BhY2U6IkRldmljZVJHQiIsYml0c1BlckNvbXBvbmVudDo4LHdpZHRoOmUud2lkdGgsaGVpZ2h0OmUuaGVpZ2h0fX0sTS5BUEkuc2V0TGFuZ3VhZ2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PXRoaXMuaW50ZXJuYWwubGFuZ3VhZ2VTZXR0aW5ncyYmKHRoaXMuaW50ZXJuYWwubGFuZ3VhZ2VTZXR0aW5ncz17fSx0aGlzLmludGVybmFsLmxhbmd1YWdlU2V0dGluZ3MuaXNTdWJzY3JpYmVkPSExKSx2b2lkIDAhPT17YWY6IkFmcmlrYWFucyIsc3E6IkFsYmFuaWFuIixhcjoiQXJhYmljIChTdGFuZGFyZCkiLCJhci1EWiI6IkFyYWJpYyAoQWxnZXJpYSkiLCJhci1CSCI6IkFyYWJpYyAoQmFocmFpbikiLCJhci1FRyI6IkFyYWJpYyAoRWd5cHQpIiwiYXItSVEiOiJBcmFiaWMgKElyYXEpIiwiYXItSk8iOiJBcmFiaWMgKEpvcmRhbikiLCJhci1LVyI6IkFyYWJpYyAoS3V3YWl0KSIsImFyLUxCIjoiQXJhYmljIChMZWJhbm9uKSIsImFyLUxZIjoiQXJhYmljIChMaWJ5YSkiLCJhci1NQSI6IkFyYWJpYyAoTW9yb2NjbykiLCJhci1PTSI6IkFyYWJpYyAoT21hbikiLCJhci1RQSI6IkFyYWJpYyAoUWF0YXIpIiwiYXItU0EiOiJBcmFiaWMgKFNhdWRpIEFyYWJpYSkiLCJhci1TWSI6IkFyYWJpYyAoU3lyaWEpIiwiYXItVE4iOiJBcmFiaWMgKFR1bmlzaWEpIiwiYXItQUUiOiJBcmFiaWMgKFUuQS5FLikiLCJhci1ZRSI6IkFyYWJpYyAoWWVtZW4pIixhbjoiQXJhZ29uZXNlIixoeToiQXJtZW5pYW4iLGFzOiJBc3NhbWVzZSIsYXN0OiJBc3R1cmlhbiIsYXo6IkF6ZXJiYWlqYW5pIixldToiQmFzcXVlIixiZToiQmVsYXJ1c2lhbiIsYm46IkJlbmdhbGkiLGJzOiJCb3NuaWFuIixicjoiQnJldG9uIixiZzoiQnVsZ2FyaWFuIixteToiQnVybWVzZSIsY2E6IkNhdGFsYW4iLGNoOiJDaGFtb3JybyIsY2U6IkNoZWNoZW4iLHpoOiJDaGluZXNlIiwiemgtSEsiOiJDaGluZXNlIChIb25nIEtvbmcpIiwiemgtQ04iOiJDaGluZXNlIChQUkMpIiwiemgtU0ciOiJDaGluZXNlIChTaW5nYXBvcmUpIiwiemgtVFciOiJDaGluZXNlIChUYWl3YW4pIixjdjoiQ2h1dmFzaCIsY286IkNvcnNpY2FuIixjcjoiQ3JlZSIsaHI6IkNyb2F0aWFuIixjczoiQ3plY2giLGRhOiJEYW5pc2giLG5sOiJEdXRjaCAoU3RhbmRhcmQpIiwibmwtQkUiOiJEdXRjaCAoQmVsZ2lhbikiLGVuOiJFbmdsaXNoIiwiZW4tQVUiOiJFbmdsaXNoIChBdXN0cmFsaWEpIiwiZW4tQloiOiJFbmdsaXNoIChCZWxpemUpIiwiZW4tQ0EiOiJFbmdsaXNoIChDYW5hZGEpIiwiZW4tSUUiOiJFbmdsaXNoIChJcmVsYW5kKSIsImVuLUpNIjoiRW5nbGlzaCAoSmFtYWljYSkiLCJlbi1OWiI6IkVuZ2xpc2ggKE5ldyBaZWFsYW5kKSIsImVuLVBIIjoiRW5nbGlzaCAoUGhpbGlwcGluZXMpIiwiZW4tWkEiOiJFbmdsaXNoIChTb3V0aCBBZnJpY2EpIiwiZW4tVFQiOiJFbmdsaXNoIChUcmluaWRhZCAmIFRvYmFnbykiLCJlbi1HQiI6IkVuZ2xpc2ggKFVuaXRlZCBLaW5nZG9tKSIsImVuLVVTIjoiRW5nbGlzaCAoVW5pdGVkIFN0YXRlcykiLCJlbi1aVyI6IkVuZ2xpc2ggKFppbWJhYndlKSIsZW86IkVzcGVyYW50byIsZXQ6IkVzdG9uaWFuIixmbzoiRmFlcm9lc2UiLGZqOiJGaWppYW4iLGZpOiJGaW5uaXNoIixmcjoiRnJlbmNoIChTdGFuZGFyZCkiLCJmci1CRSI6IkZyZW5jaCAoQmVsZ2l1bSkiLCJmci1DQSI6IkZyZW5jaCAoQ2FuYWRhKSIsImZyLUZSIjoiRnJlbmNoIChGcmFuY2UpIiwiZnItTFUiOiJGcmVuY2ggKEx1eGVtYm91cmcpIiwiZnItTUMiOiJGcmVuY2ggKE1vbmFjbykiLCJmci1DSCI6IkZyZW5jaCAoU3dpdHplcmxhbmQpIixmeToiRnJpc2lhbiIsZnVyOiJGcml1bGlhbiIsZ2Q6IkdhZWxpYyAoU2NvdHMpIiwiZ2QtSUUiOiJHYWVsaWMgKElyaXNoKSIsZ2w6IkdhbGFjaWFuIixrYToiR2VvcmdpYW4iLGRlOiJHZXJtYW4gKFN0YW5kYXJkKSIsImRlLUFUIjoiR2VybWFuIChBdXN0cmlhKSIsImRlLURFIjoiR2VybWFuIChHZXJtYW55KSIsImRlLUxJIjoiR2VybWFuIChMaWVjaHRlbnN0ZWluKSIsImRlLUxVIjoiR2VybWFuIChMdXhlbWJvdXJnKSIsImRlLUNIIjoiR2VybWFuIChTd2l0emVybGFuZCkiLGVsOiJHcmVlayIsZ3U6Ikd1anVyYXRpIixodDoiSGFpdGlhbiIsaGU6IkhlYnJldyIsaGk6IkhpbmRpIixodToiSHVuZ2FyaWFuIixpczoiSWNlbGFuZGljIixpZDoiSW5kb25lc2lhbiIsaXU6IkludWt0aXR1dCIsZ2E6IklyaXNoIixpdDoiSXRhbGlhbiAoU3RhbmRhcmQpIiwiaXQtQ0giOiJJdGFsaWFuIChTd2l0emVybGFuZCkiLGphOiJKYXBhbmVzZSIsa246Ikthbm5hZGEiLGtzOiJLYXNobWlyaSIsa2s6IkthemFraCIsa206IktobWVyIixreToiS2lyZ2hpeiIsdGxoOiJLbGluZ29uIixrbzoiS29yZWFuIiwia28tS1AiOiJLb3JlYW4gKE5vcnRoIEtvcmVhKSIsImtvLUtSIjoiS29yZWFuIChTb3V0aCBLb3JlYSkiLGxhOiJMYXRpbiIsbHY6IkxhdHZpYW4iLGx0OiJMaXRodWFuaWFuIixsYjoiTHV4ZW1ib3VyZ2lzaCIsbWs6Ik5vcnRoIE1hY2Vkb25pYSIsbXM6Ik1hbGF5IixtbDoiTWFsYXlhbGFtIixtdDoiTWFsdGVzZSIsbWk6Ik1hb3JpIixtcjoiTWFyYXRoaSIsbW86Ik1vbGRhdmlhbiIsbnY6Ik5hdmFqbyIsbmc6Ik5kb25nYSIsbmU6Ik5lcGFsaSIsbm86Ik5vcndlZ2lhbiIsbmI6Ik5vcndlZ2lhbiAoQm9rbWFsKSIsbm46Ik5vcndlZ2lhbiAoTnlub3JzaykiLG9jOiJPY2NpdGFuIixvcjoiT3JpeWEiLG9tOiJPcm9tbyIsZmE6IlBlcnNpYW4iLCJmYS1JUiI6IlBlcnNpYW4vSXJhbiIscGw6IlBvbGlzaCIscHQ6IlBvcnR1Z3Vlc2UiLCJwdC1CUiI6IlBvcnR1Z3Vlc2UgKEJyYXppbCkiLHBhOiJQdW5qYWJpIiwicGEtSU4iOiJQdW5qYWJpIChJbmRpYSkiLCJwYS1QSyI6IlB1bmphYmkgKFBha2lzdGFuKSIscXU6IlF1ZWNodWEiLHJtOiJSaGFldG8tUm9tYW5pYyIscm86IlJvbWFuaWFuIiwicm8tTU8iOiJSb21hbmlhbiAoTW9sZGF2aWEpIixydToiUnVzc2lhbiIsInJ1LU1PIjoiUnVzc2lhbiAoTW9sZGF2aWEpIixzejoiU2FtaSAoTGFwcGlzaCkiLHNnOiJTYW5nbyIsc2E6IlNhbnNrcml0IixzYzoiU2FyZGluaWFuIixzZDoiU2luZGhpIixzaToiU2luZ2hhbGVzZSIsc3I6IlNlcmJpYW4iLHNrOiJTbG92YWsiLHNsOiJTbG92ZW5pYW4iLHNvOiJTb21hbmkiLHNiOiJTb3JiaWFuIixlczoiU3BhbmlzaCIsImVzLUFSIjoiU3BhbmlzaCAoQXJnZW50aW5hKSIsImVzLUJPIjoiU3BhbmlzaCAoQm9saXZpYSkiLCJlcy1DTCI6IlNwYW5pc2ggKENoaWxlKSIsImVzLUNPIjoiU3BhbmlzaCAoQ29sb21iaWEpIiwiZXMtQ1IiOiJTcGFuaXNoIChDb3N0YSBSaWNhKSIsImVzLURPIjoiU3BhbmlzaCAoRG9taW5pY2FuIFJlcHVibGljKSIsImVzLUVDIjoiU3BhbmlzaCAoRWN1YWRvcikiLCJlcy1TViI6IlNwYW5pc2ggKEVsIFNhbHZhZG9yKSIsImVzLUdUIjoiU3BhbmlzaCAoR3VhdGVtYWxhKSIsImVzLUhOIjoiU3BhbmlzaCAoSG9uZHVyYXMpIiwiZXMtTVgiOiJTcGFuaXNoIChNZXhpY28pIiwiZXMtTkkiOiJTcGFuaXNoIChOaWNhcmFndWEpIiwiZXMtUEEiOiJTcGFuaXNoIChQYW5hbWEpIiwiZXMtUFkiOiJTcGFuaXNoIChQYXJhZ3VheSkiLCJlcy1QRSI6IlNwYW5pc2ggKFBlcnUpIiwiZXMtUFIiOiJTcGFuaXNoIChQdWVydG8gUmljbykiLCJlcy1FUyI6IlNwYW5pc2ggKFNwYWluKSIsImVzLVVZIjoiU3BhbmlzaCAoVXJ1Z3VheSkiLCJlcy1WRSI6IlNwYW5pc2ggKFZlbmV6dWVsYSkiLHN4OiJTdXR1IixzdzoiU3dhaGlsaSIsc3Y6IlN3ZWRpc2giLCJzdi1GSSI6IlN3ZWRpc2ggKEZpbmxhbmQpIiwic3YtU1YiOiJTd2VkaXNoIChTd2VkZW4pIix0YToiVGFtaWwiLHR0OiJUYXRhciIsdGU6IlRlbHVnYSIsdGg6IlRoYWkiLHRpZzoiVGlncmUiLHRzOiJUc29uZ2EiLHRuOiJUc3dhbmEiLHRyOiJUdXJraXNoIix0azoiVHVya21lbiIsdWs6IlVrcmFpbmlhbiIsaHNiOiJVcHBlciBTb3JiaWFuIix1cjoiVXJkdSIsdmU6IlZlbmRhIix2aToiVmlldG5hbWVzZSIsdm86IlZvbGFwdWsiLHdhOiJXYWxsb29uIixjeToiV2Vsc2giLHhoOiJYaG9zYSIsamk6IllpZGRpc2giLHp1OiJadWx1In1bZV0mJih0aGlzLmludGVybmFsLmxhbmd1YWdlU2V0dGluZ3MubGFuZ3VhZ2VDb2RlPWUsITE9PT10aGlzLmludGVybmFsLmxhbmd1YWdlU2V0dGluZ3MuaXNTdWJzY3JpYmVkJiYodGhpcy5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKCJwdXRDYXRhbG9nIixmdW5jdGlvbigpe3RoaXMuaW50ZXJuYWwud3JpdGUoIi9MYW5nICgiK3RoaXMuaW50ZXJuYWwubGFuZ3VhZ2VTZXR0aW5ncy5sYW5ndWFnZUNvZGUrIikiKX0pLHRoaXMuaW50ZXJuYWwubGFuZ3VhZ2VTZXR0aW5ncy5pc1N1YnNjcmliZWQ9ITApKSx0aGlzfSxxZT1NLkFQSSxXZT1xZS5nZXRDaGFyV2lkdGhzQXJyYXk9ZnVuY3Rpb24oZSx0KXt2YXIgQSxuLHM9KHQ9dHx8e30pLmZvbnR8fHRoaXMuaW50ZXJuYWwuZ2V0Rm9udCgpLGk9dC5mb250U2l6ZXx8dGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpLG89dC5jaGFyU3BhY2V8fHRoaXMuaW50ZXJuYWwuZ2V0Q2hhclNwYWNlKCksYT10LndpZHRocz90LndpZHRoczpzLm1ldGFkYXRhLlVuaWNvZGUud2lkdGhzLGw9YS5mb2Y/YS5mb2Y6MSxjPXQua2VybmluZz90Lmtlcm5pbmc6cy5tZXRhZGF0YS5Vbmljb2RlLmtlcm5pbmcsdT1jLmZvZj9jLmZvZjoxLGg9ITEhPT10LmRvS2VybmluZyxkPTAsZj1lLmxlbmd0aCxwPTAsZz1hWzBdfHxsLG09W107Zm9yKEE9MDtBPGY7QSsrKW49ZS5jaGFyQ29kZUF0KEEpLCJmdW5jdGlvbiI9PXR5cGVvZiBzLm1ldGFkYXRhLndpZHRoT2ZTdHJpbmc/bS5wdXNoKChzLm1ldGFkYXRhLndpZHRoT2ZHbHlwaChzLm1ldGFkYXRhLmNoYXJhY3RlclRvR2x5cGgobikpK28qKDFlMy9pKXx8MCkvMWUzKTooZD1oJiYib2JqZWN0Ij09PSgwLHIuZGVmYXVsdCkoY1tuXSkmJiFpc05hTihwYXJzZUludChjW25dW3BdLDEwKSk/Y1tuXVtwXS91OjAsbS5wdXNoKChhW25dfHxnKS9sK2QpKSxwPW47cmV0dXJuIG19LFhlPXFlLmdldFN0cmluZ1VuaXRXaWR0aD1mdW5jdGlvbihlLHQpe3ZhciBBPSh0PXR8fHt9KS5mb250U2l6ZXx8dGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpLHI9dC5mb250fHx0aGlzLmludGVybmFsLmdldEZvbnQoKSxuPXQuY2hhclNwYWNlfHx0aGlzLmludGVybmFsLmdldENoYXJTcGFjZSgpO3JldHVybiBxZS5wcm9jZXNzQXJhYmljJiYoZT1xZS5wcm9jZXNzQXJhYmljKGUpKSwiZnVuY3Rpb24iPT10eXBlb2Ygci5tZXRhZGF0YS53aWR0aE9mU3RyaW5nP3IubWV0YWRhdGEud2lkdGhPZlN0cmluZyhlLEEsbikvQTpXZS5hcHBseSh0aGlzLGFyZ3VtZW50cykucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdH0sMCl9LFllPWZ1bmN0aW9uKGUsdCxBLHIpe2Zvcih2YXIgbj1bXSxzPTAsaT1lLmxlbmd0aCxvPTA7cyE9PWkmJm8rdFtzXTxBOylvKz10W3NdLHMrKztuLnB1c2goZS5zbGljZSgwLHMpKTt2YXIgYT1zO2ZvcihvPTA7cyE9PWk7KW8rdFtzXT5yJiYobi5wdXNoKGUuc2xpY2UoYSxzKSksbz0wLGE9cyksbys9dFtzXSxzKys7cmV0dXJuIGEhPT1zJiZuLnB1c2goZS5zbGljZShhLHMpKSxufSxKZT1mdW5jdGlvbihlLHQsQSl7QXx8KEE9e30pO3ZhciByLG4scyxpLG8sYSxsLGM9W10sdT1bY10saD1BLnRleHRJbmRlbnR8fDAsZD0wLGY9MCxwPWUuc3BsaXQoIiAiKSxnPVdlLmFwcGx5KHRoaXMsWyIgIixBXSlbMF07aWYoYT0tMT09PUEubGluZUluZGVudD9wWzBdLmxlbmd0aCsyOkEubGluZUluZGVudHx8MCl7dmFyIG09QXJyYXkoYSkuam9pbigiICIpLHc9W107cC5tYXAoZnVuY3Rpb24oZSl7KGU9ZS5zcGxpdCgvXHMqXG4vKSkubGVuZ3RoPjE/dz13LmNvbmNhdChlLm1hcChmdW5jdGlvbihlLHQpe3JldHVybih0JiZlLmxlbmd0aD8iXG4iOiIiKStlfSkpOncucHVzaChlWzBdKX0pLHA9dyxhPVhlLmFwcGx5KHRoaXMsW20sQV0pfWZvcihzPTAsaT1wLmxlbmd0aDtzPGk7cysrKXt2YXIgQj0wO2lmKHI9cFtzXSxhJiYiXG4iPT1yWzBdJiYocj1yLnN1YnN0cigxKSxCPTEpLGgrZCsoZj0obj1XZS5hcHBseSh0aGlzLFtyLEFdKSkucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdH0sMCkpPnR8fEIpe2lmKGY+dCl7Zm9yKG89WWUuYXBwbHkodGhpcyxbcixuLHQtKGgrZCksdF0pLGMucHVzaChvLnNoaWZ0KCkpLGM9W28ucG9wKCldO28ubGVuZ3RoOyl1LnB1c2goW28uc2hpZnQoKV0pO2Y9bi5zbGljZShyLmxlbmd0aC0oY1swXT9jWzBdLmxlbmd0aDowKSkucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdH0sMCl9ZWxzZSBjPVtyXTt1LnB1c2goYyksaD1mK2EsZD1nfWVsc2UgYy5wdXNoKHIpLGgrPWQrZixkPWd9cmV0dXJuIGw9YT9mdW5jdGlvbihlLHQpe3JldHVybih0P206IiIpK2Uuam9pbigiICIpfTpmdW5jdGlvbihlKXtyZXR1cm4gZS5qb2luKCIgIil9LHUubWFwKGwpfSxxZS5zcGxpdFRleHRUb1NpemU9ZnVuY3Rpb24oZSx0LEEpe3ZhciByLG49KEE9QXx8e30pLmZvbnRTaXplfHx0aGlzLmludGVybmFsLmdldEZvbnRTaXplKCkscz1mdW5jdGlvbihlKXtpZihlLndpZHRocyYmZS5rZXJuaW5nKXJldHVybnt3aWR0aHM6ZS53aWR0aHMsa2VybmluZzplLmtlcm5pbmd9O3ZhciB0PXRoaXMuaW50ZXJuYWwuZ2V0Rm9udChlLmZvbnROYW1lLGUuZm9udFN0eWxlKSxBPSJVbmljb2RlIjtyZXR1cm4gdC5tZXRhZGF0YVtBXT97d2lkdGhzOnQubWV0YWRhdGFbQV0ud2lkdGhzfHx7MDoxfSxrZXJuaW5nOnQubWV0YWRhdGFbQV0ua2VybmluZ3x8e319Ontmb250OnQubWV0YWRhdGEsZm9udFNpemU6dGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpLGNoYXJTcGFjZTp0aGlzLmludGVybmFsLmdldENoYXJTcGFjZSgpfX0uY2FsbCh0aGlzLEEpO3I9QXJyYXkuaXNBcnJheShlKT9lOlN0cmluZyhlKS5zcGxpdCgvXHI/XG4vKTt2YXIgaT0xKnRoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3IqdC9uO3MudGV4dEluZGVudD1BLnRleHRJbmRlbnQ/MSpBLnRleHRJbmRlbnQqdGhpcy5pbnRlcm5hbC5zY2FsZUZhY3Rvci9uOjAscy5saW5lSW5kZW50PUEubGluZUluZGVudDt2YXIgbyxhLGw9W107Zm9yKG89MCxhPXIubGVuZ3RoO288YTtvKyspbD1sLmNvbmNhdChKZS5hcHBseSh0aGlzLFtyW29dLGksc10pKTtyZXR1cm4gbH0sZnVuY3Rpb24oZSl7ZS5fX2ZvbnRtZXRyaWNzX189ZS5fX2ZvbnRtZXRyaWNzX198fHt9O2Zvcih2YXIgdD0iMDEyMzQ1Njc4OWFiY2RlZiIsQT0ia2xtbm9wcXJzdHV2d3h5eiIsbj17fSxzPXt9LGk9MDtpPDE2O2krKyluW0FbaV1dPXRbaV0sc1t0W2ldXT1BW2ldO3ZhciBvPWZ1bmN0aW9uKGUpe3JldHVybiIweCIrcGFyc2VJbnQoZSwxMCkudG9TdHJpbmcoMTYpfSxhPWUuX19mb250bWV0cmljc19fLmNvbXByZXNzPWZ1bmN0aW9uKGUpe3ZhciB0LEEsbixpLGw9WyJ7Il07Zm9yKHZhciBjIGluIGUpe2lmKHQ9ZVtjXSxpc05hTihwYXJzZUludChjLDEwKSk/QT0iJyIrYysiJyI6KGM9cGFyc2VJbnQoYywxMCksQT0oQT1vKGMpLnNsaWNlKDIpKS5zbGljZSgwLC0xKStzW0Euc2xpY2UoLTEpXSksIm51bWJlciI9PXR5cGVvZiB0KXQ8MD8obj1vKHQpLnNsaWNlKDMpLGk9Ii0iKToobj1vKHQpLnNsaWNlKDIpLGk9IiIpLG49aStuLnNsaWNlKDAsLTEpK3Nbbi5zbGljZSgtMSldO2Vsc2V7aWYoIm9iamVjdCIhPT0oMCxyLmRlZmF1bHQpKHQpKXRocm93IG5ldyBFcnJvcigiRG9uJ3Qga25vdyB3aGF0IHRvIGRvIHdpdGggdmFsdWUgdHlwZSAiKygwLHIuZGVmYXVsdCkodCkrIi4iKTtuPWEodCl9bC5wdXNoKEErbil9cmV0dXJuIGwucHVzaCgifSIpLGwuam9pbigiIil9LGw9ZS5fX2ZvbnRtZXRyaWNzX18udW5jb21wcmVzcz1mdW5jdGlvbihlKXtpZigic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byB1bmNvbXByZXNzLiIpO2Zvcih2YXIgdCxBLHIscyxpPXt9LG89MSxhPWksbD1bXSxjPSIiLHU9IiIsaD1lLmxlbmd0aC0xLGQ9MTtkPGg7ZCs9MSkiJyI9PShzPWVbZF0pP3Q/KHI9dC5qb2luKCIiKSx0PXZvaWQgMCk6dD1bXTp0P3QucHVzaChzKToieyI9PXM/KGwucHVzaChbYSxyXSksYT17fSxyPXZvaWQgMCk6In0iPT1zPygoQT1sLnBvcCgpKVswXVtBWzFdXT1hLHI9dm9pZCAwLGE9QVswXSk6Ii0iPT1zP289LTE6dm9pZCAwPT09cj9uLmhhc093blByb3BlcnR5KHMpPyhjKz1uW3NdLHI9cGFyc2VJbnQoYywxNikqbyxvPTEsYz0iIik6Yys9czpuLmhhc093blByb3BlcnR5KHMpPyh1Kz1uW3NdLGFbcl09cGFyc2VJbnQodSwxNikqbyxvPTEscj12b2lkIDAsdT0iIik6dSs9cztyZXR1cm4gaX0sYz17Y29kZVBhZ2VzOlsiV2luQW5zaUVuY29kaW5nIl0sV2luQW5zaUVuY29kaW5nOmwoInsxOW04bjIwMW45cTIwMW85cjIwMXM5bDIwMXQ5bTIwMXU4bTIwMXc5bjIwMXg5bzIwMXk4bzIwMms4cTIwMmw4cjIwMm05cDIwMnE4cDIwYXc4azIwM2s4dDIwM3Q4djIwM3U5djJjcThzMjEybTl0MTVtOHcxNW45dzJkdzlzMTZrOHUxNmw5dTE3czl6MTd4OHkxN3k5eX0iKX0sdT17VW5pY29kZTp7Q291cmllcjpjLCJDb3VyaWVyLUJvbGQiOmMsIkNvdXJpZXItQm9sZE9ibGlxdWUiOmMsIkNvdXJpZXItT2JsaXF1ZSI6YyxIZWx2ZXRpY2E6YywiSGVsdmV0aWNhLUJvbGQiOmMsIkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI6YywiSGVsdmV0aWNhLU9ibGlxdWUiOmMsIlRpbWVzLVJvbWFuIjpjLCJUaW1lcy1Cb2xkIjpjLCJUaW1lcy1Cb2xkSXRhbGljIjpjLCJUaW1lcy1JdGFsaWMiOmN9fSxoPXtVbmljb2RlOnsiQ291cmllci1PYmxpcXVlIjpsKCJ7J3dpZHRocyd7azN3J2ZvZic2b30na2VybmluZyd7J2ZvZictNm99fSIpLCJUaW1lcy1Cb2xkSXRhbGljIjpsKCJ7J3dpZHRocyd7azNvMnE0eWN4MnIyMDFuM20yMDFvNm8yMDFzMmwyMDF0MmwyMDF1MmwyMDF3M20yMDF4M20yMDF5M20yazF0MmwycjIwMm0ybjJuM20ybzNtMnA1bjIwMnE2bzJyMXcyczJsMnQybDJ1M20ydjN0MncxdDJ4MmwyeTF0MnoxdzNrM20zbDNtM20zbTNuM20zbzNtM3AzbTNxM20zcjNtM3MzbTIwM3QybDIwM3UybDN2MmwzdzN0M3gzdDN5M3QzejNtNGs1bjRsNG00bTRtNG40bTRvNHM0cDRtNHE0bTRyNHM0czR5NHQycjR1M200djRtNHczeDR4NXQ0eTRzNHo0czVrM3g1bDRzNW00bTVuM3I1bzN4NXA0czVxNG01cjV0NXM0bTV0M3g1dTN4NXYybDV3MXc1eDJsNXkzdDV6M202azJsNmwzbTZtM202bjJ3Nm8zbTZwMnc2cTJsNnIzbTZzM3I2dDF3NnUxdzZ2M202dzF3Nng0eTZ5M3I2ejNtN2szbTdsM203bTJyN24ycjdvMXc3cDNyN3EydzdyNG03czNtN3Qydzd1MnI3djJuN3cxcTd4Mm43eTN0MjAybDNtY2w0bWFsMnJhbTNtYW4zbWFvM21hcDNtYXIzbWFzMmxhdDR1YXUxdWF2M21hdzN3YXk0dWF6MmxiazJzYmwzdCdmb2YnNm9ibzJsYnAzdGJxM21icjF0YnMybGJ1MXlidjNtYnozbWNrNG0yMDJrM21jbTRtY240bWNvNG1jcDRtY3E1eWNyNG1jczRtY3Q0bWN1NG1jdjRtY3cycjJtM3JjeTJyY3oycmRsNHNkbTRzZG40c2RvNHNkcDRzZHE0c2RzNHNkdDRzZHU0c2R2NHNkdzRzZHozbWVrM21lbDNtZW0zbWVuM21lbzNtZXAzbWVxNHNlcjJ3ZXMyd2V0MndldTJ3ZXYyd2V3MXdleDF3ZXkxd2V6MXdmbDNyZm0zbWZuM21mbzNtZnAzbWZxM21mcjN0ZnMzbWZ0M3JmdTNyZnYzcmZ3M3JmejJ3MjAzazZvMjEybTZvMmR3MmwyY3EybDN0M20zdTJsMTdzM3gxOW0zbX0na2VybmluZyd7Y2x7NHF1NWt0NXF0NXJzMTdzczV0c30yMDFzezIwMXNzfTIwMXR7Y2tzNGxzY21zY25zY29zY3BzY2xzMnd1Mnl1MjAxdHN9MjAxeHsyd3UyeXV9Mmt7MjAxdHN9Mnd7NHF4NWt4NW91NXF4NXJzMTdzdTV0dX0yeHsxN3N1NXR1NW91fTJ5ezRxeDVreDVvdTVxeDVyczE3c3M1dHN9J2ZvZictNm9mbnsxN3N3NXR3NW91NXF3NXJzfTd0e2Nrc2Nsc2Ntc2Nuc2Nvc2NwczRsc30zdXsxN3N1NXR1NW9zNXFzfTN2ezE3c3U1dHU1b3M1cXN9N3B7MTdzdTV0dX1ja3s0cXU1a3Q1cXQ1cnMxN3NzNXRzfTRsezRxdTVrdDVxdDVyczE3c3M1dHN9Y217NHF1NWt0NXF0NXJzMTdzczV0c31jbns0cXU1a3Q1cXQ1cnMxN3NzNXRzfWNvezRxdTVrdDVxdDVyczE3c3M1dHN9Y3B7NHF1NWt0NXF0NXJzMTdzczV0c302bHs0cXU1b3U1cXc1cnQxN3N1NXR1fTVxe2NrdWNsdWNtdWNudWNvdWNwdTRsdX01cntja3VjbHVjbXVjbnVjb3VjcHU0bHV9N3F7Y2tzY2xzY21zY25zY29zY3BzNGxzfTZwezRxdTVvdTVxdzVydDE3c3c1dHd9ZWt7NHF1NW91NXF3NXJ0MTdzdTV0dX1lbHs0cXU1b3U1cXc1cnQxN3N1NXR1fWVtezRxdTVvdTVxdzVydDE3c3U1dHV9ZW57NHF1NW91NXF3NXJ0MTdzdTV0dX1lb3s0cXU1b3U1cXc1cnQxN3N1NXR1fWVwezRxdTVvdTVxdzVydDE3c3U1dHV9ZXN7MTdzczV0czVxczRxdX1ldHs0cXU1b3U1cXc1cnQxN3N3NXR3fWV1ezRxdTVvdTVxdzVydDE3c3M1dHN9ZXZ7MTdzczV0czVxczRxdX02ensxN3N3NXR3NW91NXF3NXJzfWZtezE3c3c1dHc1b3U1cXc1cnN9N257MjAxdHN9Zm97MTdzdzV0dzVvdTVxdzVyc31mcHsxN3N3NXR3NW91NXF3NXJzfWZxezE3c3c1dHc1b3U1cXc1cnN9N3J7Y2tzY2xzY21zY25zY29zY3BzNGxzfWZzezE3c3c1dHc1b3U1cXc1cnN9ZnR7MTdzdTV0dX1mdXsxN3N1NXR1fWZ2ezE3c3U1dHV9Znd7MTdzdTV0dX1mentja3NjbHNjbXNjbnNjb3NjcHM0bHN9fX0iKSwiSGVsdmV0aWNhLUJvbGQiOmwoInsnd2lkdGhzJ3trM3MycTRzY3gxdzIwMW4zcjIwMW82bzIwMXMxdzIwMXQxdzIwMXUxdzIwMXczbTIwMXgzbTIwMXkzbTJrMXcybDJsMjAybTJuMm4zcjJvM3IycDV0MjAycTZvMnIxczJzMmwydDJsMnUycjJ2M3UydzF3MngybDJ5MXcyejF3M2szcjNsM3IzbTNyM24zcjNvM3IzcDNyM3EzcjNyM3IzczNyMjAzdDJsMjAzdTJsM3YybDN3M3UzeDN1M3kzdTN6M3g0azZsNGw0czRtNHM0bjRzNG80czRwNG00cTN4NHI0eTRzNHM0dDF3NHUzcjR2NHM0dzN4NHg1bjR5NHM0ejR5NWs0bTVsNHk1bTRzNW40bTVvM3g1cDRzNXE0bTVyNXk1czRtNXQ0bTV1M3g1djJsNXcxdzV4Mmw1eTN1NXozcjZrMmw2bDNyNm0zeDZuM3I2bzN4NnAzcjZxMmw2cjN4NnMzeDZ0MXc2dTF3NnYzcjZ3MXc2eDV0NnkzeDZ6M3g3azN4N2wzeDdtMnI3bjNyN28ybDdwM3g3cTNyN3I0eTdzM3I3dDNyN3UzbTd2MnI3dzF3N3gycjd5M3UyMDJsM3JjbDRzYWwybGFtM3JhbjNyYW8zcmFwM3JhcjNyYXMybGF0NHRhdTJwYXYzcmF3M3VheTR0YXoybGJrMnNibDN1J2ZvZic2b2JvMmxicDN4YnEzcmJyMXdiczJsYnUyb2J2M3JiejN4Y2s0czIwMmszcmNtNHNjbjRzY280c2NwNHNjcTZvY3I0c2NzNG1jdDRtY3U0bWN2NG1jdzF3Mm0yemN5MXdjejF3ZGw0c2RtNHlkbjR5ZG80eWRwNHlkcTR5ZHM0eWR0NHNkdTRzZHY0c2R3NHNkejN4ZWszcmVsM3JlbTNyZW4zcmVvM3JlcDNyZXE1dGVyM3JlczNyZXQzcmV1M3JldjNyZXcxd2V4MXdleTF3ZXoxd2ZsM3hmbTN4Zm4zeGZvM3hmcDN4ZnEzeGZyM3VmczN4ZnQzeGZ1M3hmdjN4ZnczeGZ6M3IyMDNrNm8yMTJtNm8yZHcybDJjcTJsM3QzcjN1MmwxN3M0bTE5bTNyfSdrZXJuaW5nJ3tjbHs0cXM1a3U1b3Q1cXMxN3N2NXR2fTIwMXR7Mnd3NHd5Mnl3fTIwMXd7MmtzfTIwMXh7Mnd3NHd5Mnl3fTJrezIwMXRzMjAxeHN9Mnd7N3FzNHF1NWt3NW9zNXF3NXJzMTdzdTV0dTd0c2Z6c30yeHs1b3c1cXN9Mnl7N3FzNHF1NWt3NW9zNXF3NXJzMTdzdTV0dTd0c2Z6c30nZm9mJy02bzdwezE3c3U1dHU1b3R9Y2t7NHFzNWt1NW90NXFzMTdzdjV0dn00bHs0cXM1a3U1b3Q1cXMxN3N2NXR2fWNtezRxczVrdTVvdDVxczE3c3Y1dHZ9Y257NHFzNWt1NW90NXFzMTdzdjV0dn1jb3s0cXM1a3U1b3Q1cXMxN3N2NXR2fWNwezRxczVrdTVvdDVxczE3c3Y1dHZ9Nmx7MTdzdDV0dDVvc30xN3N7Mmt3Y2x2Y212Y252Y292Y3B2NGx2NHd3Y2t2fTVvezJrdWNsdGNtdGNudGNvdGNwdDRsdDR3dGNrdH01cXsya3NjbHNjbXNjbnNjb3NjcHM0bHM0d3Zja3N9NXJ7MmtzNHdzfTV0ezJrd2NsdmNtdmNudmNvdmNwdjRsdjR3d2Nrdn1lb3sxN3N0NXR0NW9zfWZ1ezE3c3U1dHU1b3R9NnB7MTdzczV0c31la3sxN3N0NXR0NW9zfWVsezE3c3Q1dHQ1b3N9ZW17MTdzdDV0dDVvc31lbnsxN3N0NXR0NW9zfTZvezIwMXRzfWVwezE3c3Q1dHQ1b3N9ZXN7MTdzczV0c31ldHsxN3NzNXRzfWV1ezE3c3M1dHN9ZXZ7MTdzczV0c302ensxN3N1NXR1NW9zNXF0fWZtezE3c3U1dHU1b3M1cXR9Zm57MTdzdTV0dTVvczVxdH1mb3sxN3N1NXR1NW9zNXF0fWZwezE3c3U1dHU1b3M1cXR9ZnF7MTdzdTV0dTVvczVxdH1mc3sxN3N1NXR1NW9zNXF0fWZ0ezE3c3U1dHU1b3R9N217NW9zfWZ2ezE3c3U1dHU1b3R9Znd7MTdzdTV0dTVvdH19fSIpLENvdXJpZXI6bCgieyd3aWR0aHMne2szdydmb2YnNm99J2tlcm5pbmcneydmb2YnLTZvfX0iKSwiQ291cmllci1Cb2xkT2JsaXF1ZSI6bCgieyd3aWR0aHMne2szdydmb2YnNm99J2tlcm5pbmcneydmb2YnLTZvfX0iKSwiVGltZXMtQm9sZCI6bCgieyd3aWR0aHMne2szcTJxNW5jeDJyMjAxbjNtMjAxbzZvMjAxczJsMjAxdDJsMjAxdTJsMjAxdzNtMjAxeDNtMjAxeTNtMmsxdDJsMmwyMDJtMm4ybjNtMm8zbTJwNm8yMDJxNm8ycjF3MnMybDJ0MmwydTNtMnYzdDJ3MXQyeDJsMnkxdDJ6MXczazNtM2wzbTNtM20zbjNtM28zbTNwM20zcTNtM3IzbTNzM20yMDN0MmwyMDN1MmwzdjJsM3czdDN4M3QzeTN0M3ozbTRrNXg0bDRzNG00bTRuNHM0bzRzNHA0bTRxM3g0cjR5NHM0eTR0MnI0dTNtNHY0eTR3NG00eDV5NHk0czR6NHk1azN4NWw0eTVtNHM1bjNyNW80bTVwNHM1cTRzNXI2bzVzNHM1dDRzNXU0bTV2Mmw1dzF3NXgybDV5M3U1ejNtNmsybDZsM202bTNyNm4ydzZvM3I2cDJ3NnEybDZyM202czNyNnQxdzZ1Mmw2djNyNncxdzZ4NW42eTNyNnozbTdrM3I3bDNyN20ydzduMnI3bzJsN3AzcjdxM203cjRzN3MzbTd0M203dTJ3N3Yycjd3MXE3eDJyN3kzbzIwMmwzbWNsNHNhbDJsYW0zbWFuM21hbzNtYXAzbWFyM21hczJsYXQ0dWF1MXlhdjNtYXczdGF5NHVhejJsYmsyc2JsM3QnZm9mJzZvYm8ybGJwM3JicjF0YnMybGJ1MmxidjNtYnozbWNrNHMyMDJrM21jbTRzY240c2NvNHNjcDRzY3E2b2NyNHNjczRtY3Q0bWN1NG1jdjRtY3cycjJtM3JjeTJyY3oycmRsNHNkbTR5ZG40eWRvNHlkcDR5ZHE0eWRzNHlkdDRzZHU0c2R2NHNkdzRzZHozcmVrM21lbDNtZW0zbWVuM21lbzNtZXAzbWVxNHNlcjJ3ZXMyd2V0MndldTJ3ZXYyd2V3MXdleDF3ZXkxd2V6MXdmbDNyZm0zbWZuM21mbzNtZnAzbWZxM21mcjN0ZnMzbWZ0M3JmdTNyZnYzcmZ3M3JmejNtMjAzazZvMjEybTZvMmR3MmwyY3EybDN0M20zdTJsMTdzNHMxOW0zbX0na2VybmluZyd7Y2x7NHF0NWtzNW90NXF5NXJ3MTdzdjV0dn0yMDF0e2NrczRsc2Ntc2Nuc2Nvc2Nwc2NsczR3dn0ya3syMDF0c30yd3s0cXU1a3U3bXU1b3M1cXg1cnUxN3N1NXR1fTJ4ezE3c3U1dHU1b3U1cXN9Mnl7NHF2NWt2N211NW90NXF6NXJ1MTdzdTV0dX0nZm9mJy02bzd0e2Nrc2Nsc2Ntc2Nuc2Nvc2NwczRsc30zdXsxN3N1NXR1NW9zNXF1fTN2ezE3c3U1dHU1b3M1cXV9ZnV7MTdzdTV0dTVvdTVxdX03cHsxN3N1NXR1NW91NXF1fWNrezRxdDVrczVvdDVxeTVydzE3c3Y1dHZ9NGx7NHF0NWtzNW90NXF5NXJ3MTdzdjV0dn1jbXs0cXQ1a3M1b3Q1cXk1cncxN3N2NXR2fWNuezRxdDVrczVvdDVxeTVydzE3c3Y1dHZ9Y297NHF0NWtzNW90NXF5NXJ3MTdzdjV0dn1jcHs0cXQ1a3M1b3Q1cXk1cncxN3N2NXR2fTZsezE3c3Q1dHQ1b3U1cXV9MTdze2NrdWNsdWNtdWNudWNvdWNwdTRsdTR3dX01b3tja3VjbHVjbXVjbnVjb3VjcHU0bHU0d3V9NXF7Y2t6Y2x6Y216Y256Y296Y3B6NGx6NHd1fTVye2NreGNseGNteGNueGNveGNweDRseDR3dX01dHtja3VjbHVjbXVjbnVjb3VjcHU0bHU0d3V9N3F7Y2t1Y2x1Y211Y251Y291Y3B1NGx1fTZwezE3c3c1dHc1b3U1cXV9ZWt7MTdzdDV0dDVxdX1lbHsxN3N0NXR0NW91NXF1fWVtezE3c3Q1dHQ1cXV9ZW57MTdzdDV0dDVxdX1lb3sxN3N0NXR0NXF1fWVwezE3c3Q1dHQ1b3U1cXV9ZXN7MTdzczV0czVxdX1ldHsxN3N3NXR3NW91NXF1fWV1ezE3c3c1dHc1b3U1cXV9ZXZ7MTdzczV0czVxdX02ensxN3N3NXR3NW91NXF1NXJzfWZtezE3c3c1dHc1b3U1cXU1cnN9Zm57MTdzdzV0dzVvdTVxdTVyc31mb3sxN3N3NXR3NW91NXF1NXJzfWZwezE3c3c1dHc1b3U1cXU1cnN9ZnF7MTdzdzV0dzVvdTVxdTVyc303cntja3RjbHRjbXRjbnRjb3RjcHQ0bHQ1b3N9ZnN7MTdzdzV0dzVvdTVxdTVyc31mdHsxN3N1NXR1NW91NXF1fTdtezVvc31mdnsxN3N1NXR1NW91NXF1fWZ3ezE3c3U1dHU1b3U1cXV9Znp7Y2tzY2xzY21zY25zY29zY3BzNGxzfX19IiksU3ltYm9sOmwoInsnd2lkdGhzJ3trM3VhdzRyMTltM20yazF0MmwybDIwMm0yeTJuM20ycDVuMjAycTZvM2szbTJzMmwydDJsMnYzcjJ3MXQzbTNtMnkxdDJ6MXdiazJzYmwzcidmb2YnNm8zbjNtM28zbTNwM20zcTNtM3IzbTNzM20zdDNtM3UxdzN2MXczdzNyM3gzcjN5M3IzejJ3YnAzdDNsM201djJsNXgybDV6M20ycTR5ZnIzcjd2M2s3dzFvN3gza30na2VybmluZyd7J2ZvZictNm99fSIpLEhlbHZldGljYTpsKCJ7J3dpZHRocyd7azNwMnE0bWN4MXcyMDFuM3IyMDFvNm8yMDFzMXEyMDF0MXEyMDF1MXEyMDF3MmwyMDF4MmwyMDF5MmwyazF3MmwxdzIwMm0ybjJuM3IybzNyMnA1dDIwMnE2bzJyMW4yczJsMnQybDJ1MnIydjN1MncxdzJ4MmwyeTF3MnoxdzNrM3IzbDNyM20zcjNuM3IzbzNyM3AzcjNxM3IzcjNyM3MzcjIwM3QybDIwM3UybDN2MXczdzN1M3gzdTN5M3UzejNyNGs2cDRsNG00bTRtNG40czRvNHM0cDRtNHEzeDRyNHk0czRzNHQxdzR1M200djRtNHczcjR4NW40eTRzNHo0eTVrNG01bDR5NW00czVuNG01bzN4NXA0czVxNG01cjV5NXM0bTV0NG01dTN4NXYxdzV3MXc1eDF3NXkyejV6M3I2azJsNmwzcjZtM3I2bjNtNm8zcjZwM3I2cTF3NnIzcjZzM3I2dDFxNnUxcTZ2M202dzFxNng1bjZ5M3I2ejNyN2szcjdsM3I3bTJsN24zbTdvMXc3cDNyN3EzbTdyNHM3czNtN3QzbTd1M203djJsN3cxdTd4Mmw3eTN1MjAybDNyY2w0bWFsMmxhbTNyYW4zcmFvM3JhcDNyYXIzcmFzMmxhdDR0YXUycGF2M3JhdzN1YXk0dGF6MmxiazJzYmwzdSdmb2YnNm9ibzJsYnAzcmJyMXdiczJsYnUyb2J2M3JiejN4Y2s0bTIwMmszcmNtNG1jbjRtY280bWNwNG1jcTZvY3I0c2NzNG1jdDRtY3U0bWN2NG1jdzF3Mm0ybmN5MXdjejF3ZGw0c2RtNHlkbjR5ZG80eWRwNHlkcTR5ZHM0eWR0NHNkdTRzZHY0c2R3NHNkejN4ZWszcmVsM3JlbTNyZW4zcmVvM3JlcDNyZXE1dGVyM21lczNyZXQzcmV1M3JldjNyZXcxd2V4MXdleTF3ZXoxd2ZsM3JmbTNyZm4zcmZvM3JmcDNyZnEzcmZyM3VmczN4ZnQzcmZ1M3JmdjNyZnczcmZ6M20yMDNrNm8yMTJtNm8yZHcybDJjcTJsM3QzcjN1MXcxN3M0bTE5bTNyfSdrZXJuaW5nJ3s1cXs0d3Z9Y2x7NHFzNWt3NW93NXFzMTdzdjV0dn0yMDF0ezJ3dTR3MWsyeXV9MjAxeHsyd3U0d3kyeXV9MTdzezJrdGNsdWNtdWNudTRvdGNwdTRsdTR3eWNvdWNrdX0yd3s3cXM0cXo1azFtMTdzeTVvdzVxeDVyc2ZzdTV0eTd0dWZ6dX0yeHsxN3N5NXR5NW95NXFzfTJ5ezdxczRxejVrMW0xN3N5NW93NXF4NXJzZnN1NXR5N3R1Znp1fSdmb2YnLTZvN3B7MTdzdjV0djVvd31ja3s0cXM1a3c1b3c1cXMxN3N2NXR2fTRsezRxczVrdzVvdzVxczE3c3Y1dHZ9Y217NHFzNWt3NW93NXFzMTdzdjV0dn1jbns0cXM1a3c1b3c1cXMxN3N2NXR2fWNvezRxczVrdzVvdzVxczE3c3Y1dHZ9Y3B7NHFzNWt3NW93NXFzMTdzdjV0dn02bHsxN3N5NXR5NW93fWRvezE3c3Q1dHR9NHp7MTdzdDV0dH03c3tmc3R9ZG17MTdzdDV0dH1kbnsxN3N0NXR0fTVve2Nrd2Nsd2Ntd2Nud2Nvd2NwdzRsdzR3dn1kcHsxN3N0NXR0fWRxezE3c3Q1dHR9N3R7NW93fWRzezE3c3Q1dHR9NXR7Mmt0Y2x1Y211Y251NG90Y3B1NGx1NHd5Y291Y2t1fWZ1ezE3c3Y1dHY1b3d9NnB7MTdzeTV0eTVvdzVxc31la3sxN3N5NXR5NW93fWVsezE3c3k1dHk1b3d9ZW17MTdzeTV0eTVvd31lbns1dHl9ZW97MTdzeTV0eTVvd31lcHsxN3N5NXR5NW93fWVzezE3c3k1dHk1cXN9ZXR7MTdzeTV0eTVvdzVxc31ldXsxN3N5NXR5NW93NXFzfWV2ezE3c3k1dHk1b3c1cXN9Nnp7MTdzeTV0eTVvdzVxc31mbXsxN3N5NXR5NW93NXFzfWZuezE3c3k1dHk1b3c1cXN9Zm97MTdzeTV0eTVvdzVxc31mcHsxN3N5NXR5NXFzfWZxezE3c3k1dHk1b3c1cXN9N3J7NW93fWZzezE3c3k1dHk1b3c1cXN9ZnR7MTdzdjV0djVvd303bXs1b3d9ZnZ7MTdzdjV0djVvd31md3sxN3N2NXR2NW93fX19IiksIkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI6bCgieyd3aWR0aHMne2szczJxNHNjeDF3MjAxbjNyMjAxbzZvMjAxczF3MjAxdDF3MjAxdTF3MjAxdzNtMjAxeDNtMjAxeTNtMmsxdzJsMmwyMDJtMm4ybjNyMm8zcjJwNXQyMDJxNm8ycjFzMnMybDJ0MmwydTJyMnYzdTJ3MXcyeDJsMnkxdzJ6MXczazNyM2wzcjNtM3IzbjNyM28zcjNwM3IzcTNyM3IzcjNzM3IyMDN0MmwyMDN1MmwzdjJsM3czdTN4M3UzeTN1M3ozeDRrNmw0bDRzNG00czRuNHM0bzRzNHA0bTRxM3g0cjR5NHM0czR0MXc0dTNyNHY0czR3M3g0eDVuNHk0czR6NHk1azRtNWw0eTVtNHM1bjRtNW8zeDVwNHM1cTRtNXI1eTVzNG01dDRtNXUzeDV2Mmw1dzF3NXgybDV5M3U1ejNyNmsybDZsM3I2bTN4Nm4zcjZvM3g2cDNyNnEybDZyM3g2czN4NnQxdzZ1MXc2djNyNncxdzZ4NXQ2eTN4NnozeDdrM3g3bDN4N20ycjduM3I3bzJsN3AzeDdxM3I3cjR5N3Mzcjd0M3I3dTNtN3Yycjd3MXc3eDJyN3kzdTIwMmwzcmNsNHNhbDJsYW0zcmFuM3JhbzNyYXAzcmFyM3JhczJsYXQ0dGF1MnBhdjNyYXczdWF5NHRhejJsYmsyc2JsM3UnZm9mJzZvYm8ybGJwM3hicTNyYnIxd2JzMmxidTJvYnYzcmJ6M3hjazRzMjAyazNyY200c2NuNHNjbzRzY3A0c2NxNm9jcjRzY3M0bWN0NG1jdTRtY3Y0bWN3MXcybTJ6Y3kxd2N6MXdkbDRzZG00eWRuNHlkbzR5ZHA0eWRxNHlkczR5ZHQ0c2R1NHNkdjRzZHc0c2R6M3hlazNyZWwzcmVtM3JlbjNyZW8zcmVwM3JlcTV0ZXIzcmVzM3JldDNyZXUzcmV2M3JldzF3ZXgxd2V5MXdlejF3ZmwzeGZtM3hmbjN4Zm8zeGZwM3hmcTN4ZnIzdWZzM3hmdDN4ZnUzeGZ2M3hmdzN4ZnozcjIwM2s2bzIxMm02bzJkdzJsMmNxMmwzdDNyM3UybDE3czRtMTltM3J9J2tlcm5pbmcne2NsezRxczVrdTVvdDVxczE3c3Y1dHZ9MjAxdHsyd3c0d3kyeXd9MjAxd3sya3N9MjAxeHsyd3c0d3kyeXd9Mmt7MjAxdHMyMDF4c30yd3s3cXM0cXU1a3c1b3M1cXc1cnMxN3N1NXR1N3RzZnpzfTJ4ezVvdzVxc30yeXs3cXM0cXU1a3c1b3M1cXc1cnMxN3N1NXR1N3RzZnpzfSdmb2YnLTZvN3B7MTdzdTV0dTVvdH1ja3s0cXM1a3U1b3Q1cXMxN3N2NXR2fTRsezRxczVrdTVvdDVxczE3c3Y1dHZ9Y217NHFzNWt1NW90NXFzMTdzdjV0dn1jbns0cXM1a3U1b3Q1cXMxN3N2NXR2fWNvezRxczVrdTVvdDVxczE3c3Y1dHZ9Y3B7NHFzNWt1NW90NXFzMTdzdjV0dn02bHsxN3N0NXR0NW9zfTE3c3sya3djbHZjbXZjbnZjb3ZjcHY0bHY0d3dja3Z9NW97Mmt1Y2x0Y210Y250Y290Y3B0NGx0NHd0Y2t0fTVxezJrc2Nsc2Ntc2Nuc2Nvc2NwczRsczR3dmNrc301cnsya3M0d3N9NXR7Mmt3Y2x2Y212Y252Y292Y3B2NGx2NHd3Y2t2fWVvezE3c3Q1dHQ1b3N9ZnV7MTdzdTV0dTVvdH02cHsxN3NzNXRzfWVrezE3c3Q1dHQ1b3N9ZWx7MTdzdDV0dDVvc31lbXsxN3N0NXR0NW9zfWVuezE3c3Q1dHQ1b3N9Nm97MjAxdHN9ZXB7MTdzdDV0dDVvc31lc3sxN3NzNXRzfWV0ezE3c3M1dHN9ZXV7MTdzczV0c31ldnsxN3NzNXRzfTZ6ezE3c3U1dHU1b3M1cXR9Zm17MTdzdTV0dTVvczVxdH1mbnsxN3N1NXR1NW9zNXF0fWZvezE3c3U1dHU1b3M1cXR9ZnB7MTdzdTV0dTVvczVxdH1mcXsxN3N1NXR1NW9zNXF0fWZzezE3c3U1dHU1b3M1cXR9ZnR7MTdzdTV0dTVvdH03bXs1b3N9ZnZ7MTdzdTV0dTVvdH1md3sxN3N1NXR1NW90fX19IiksWmFwZkRpbmdiYXRzOmwoInsnd2lkdGhzJ3trNHUyazF3J2ZvZic2b30na2VybmluZyd7J2ZvZictNm99fSIpLCJDb3VyaWVyLUJvbGQiOmwoInsnd2lkdGhzJ3trM3cnZm9mJzZvfSdrZXJuaW5nJ3snZm9mJy02b319IiksIlRpbWVzLUl0YWxpYyI6bCgieyd3aWR0aHMne2szbjJxNHljeDJsMjAxbjNtMjAxbzV0MjAxczJsMjAxdDJsMjAxdTJsMjAxdzNyMjAxeDNyMjAxeTNyMmsxdDJsMmwyMDJtMm4ybjNtMm8zbTJwNW4yMDJxNXQycjFwMnMybDJ0MmwydTNtMnY0bjJ3MXQyeDJsMnkxdDJ6MXczazNtM2wzbTNtM20zbjNtM28zbTNwM20zcTNtM3IzbTNzM20yMDN0MmwyMDN1MmwzdjJsM3c0bjN4NG4zeTRuM3ozbTRrNXc0bDN4NG0zeDRuNG00bzRzNHAzeDRxM3g0cjRzNHM0czR0Mmw0dTJ3NHY0bTR3M3I0eDVuNHk0bTR6NHM1azN4NWw0czVtM3g1bjNtNW8zcjVwNHM1cTN4NXI1bjVzM3g1dDNyNXUzcjV2MnI1dzF3NXgycjV5MnU1ejNtNmsybDZsM202bTNtNm4ydzZvM202cDJ3NnExdzZyM202czNtNnQxdzZ1MXc2djJ3NncxdzZ4NHM2eTNtNnozbTdrM203bDNtN20ycjduMnI3bzF3N3AzbTdxMnc3cjRtN3Mydzd0Mnc3dTJyN3Yyczd3MXY3eDJzN3kzcTIwMmwzbWNsM3hhbDJyYW0zbWFuM21hbzNtYXAzbWFyM21hczJsYXQ0d2F1MXZhdjNtYXc0bmF5NHdhejJsYmsyc2JsNG4nZm9mJzZvYm8ybGJwM21icTNvYnIxdGJzMmxidTF6YnYzbWJ6M21jazN4MjAyazNtY20zeGNuM3hjbzN4Y3AzeGNxNXRjcjRtY3MzeGN0M3hjdTN4Y3YzeGN3MmwybTJ1Y3kybGN6MmxkbDRtZG00c2RuNHNkbzRzZHA0c2RxNHNkczRzZHQ0c2R1NHNkdjRzZHc0c2R6M21lazNtZWwzbWVtM21lbjNtZW8zbWVwM21lcTRtZXIyd2VzMndldDJ3ZXUyd2V2MndldzF3ZXgxd2V5MXdlejF3ZmwzbWZtM21mbjNtZm8zbWZwM21mcTNtZnI0bmZzM21mdDNtZnUzbWZ2M21mdzNtZnoydzIwM2s2bzIxMm02bTJkdzJsMmNxMmwzdDNtM3UybDE3czNyMTltM219J2tlcm5pbmcne2NsezVrdDRxd30yMDFzezIwMXN3fTIwMXR7MjAxdHcyd3kyeXk2cS10fTIwMXh7Mnd5Mnl5fTJrezIwMXR3fTJ3ezdxczRxeTdyczVreTdtdzVvczVxeDVydTE3c3U1dHV9Mnh7MTdzczV0czVvc30yeXs3cXM0cXk3cnM1a3k3bXc1b3M1cXg1cnUxN3N1NXR1fSdmb2YnLTZvNnR7MTdzczV0czVxc303dHs1b3N9M3Z7NXFzfTdwezE3c3U1dHU1cXN9Y2t7NWt0NHF3fTRsezVrdDRxd31jbXs1a3Q0cXd9Y257NWt0NHF3fWNvezVrdDRxd31jcHs1a3Q0cXd9Nmx7NHFzNWtzNW91NXF3NXJ1MTdzdTV0dX0xN3N7MmtzfTVxe2NrdmNsdmNtdmNudmNvdmNwdjRsdn01cntja3VjbHVjbXVjbnVjb3VjcHU0bHV9NXR7MmtzfTZwezRxczVrczVvdTVxdzVydTE3c3U1dHV9ZWt7NHFzNWtzNW91NXF3NXJ1MTdzdTV0dX1lbHs0cXM1a3M1b3U1cXc1cnUxN3N1NXR1fWVtezRxczVrczVvdTVxdzVydTE3c3U1dHV9ZW57NHFzNWtzNW91NXF3NXJ1MTdzdTV0dX1lb3s0cXM1a3M1b3U1cXc1cnUxN3N1NXR1fWVwezRxczVrczVvdTVxdzVydTE3c3U1dHV9ZXN7NWtzNXFzNHFzfWV0ezRxczVrczVvdTVxdzVydTE3c3U1dHV9ZXV7NHFzNWtzNXF3NXJ1MTdzdTV0dX1ldns1a3M1cXM0cXN9ZXh7MTdzczV0czVxc302ens0cXY1a3M1b3U1cXc1cnUxN3N1NXR1fWZtezRxdjVrczVvdTVxdzVydTE3c3U1dHV9Zm57NHF2NWtzNW91NXF3NXJ1MTdzdTV0dX1mb3s0cXY1a3M1b3U1cXc1cnUxN3N1NXR1fWZwezRxdjVrczVvdTVxdzVydTE3c3U1dHV9ZnF7NHF2NWtzNW91NXF3NXJ1MTdzdTV0dX03cns1b3N9ZnN7NHF2NWtzNW91NXF3NXJ1MTdzdTV0dX1mdHsxN3N1NXR1NXFzfWZ1ezE3c3U1dHU1cXN9ZnZ7MTdzdTV0dTVxc31md3sxN3N1NXR1NXFzfX19IiksIlRpbWVzLVJvbWFuIjpsKCJ7J3dpZHRocyd7azNuMnE0eWN4MmwyMDFuM20yMDFvNm8yMDFzMmwyMDF0MmwyMDF1MmwyMDF3MncyMDF4MncyMDF5MncyazF0MmwybDIwMm0ybjJuM20ybzNtMnA1bjIwMnE2bzJyMW0yczJsMnQybDJ1M20ydjNzMncxdDJ4MmwyeTF0MnoxdzNrM20zbDNtM20zbTNuM20zbzNtM3AzbTNxM20zcjNtM3MzbTIwM3QybDIwM3UybDN2MXczdzNzM3gzczN5M3MzejJ3NGs1dzRsNHM0bTRtNG40bTRvNHM0cDN4NHEzcjRyNHM0czRzNHQybDR1MnI0djRzNHczeDR4NXQ0eTRzNHo0czVrM3I1bDRzNW00bTVuM3I1bzN4NXA0czVxNHM1cjV5NXM0czV0NHM1dTN4NXYybDV3MXc1eDJsNXkyejV6M202azJsNmwydzZtM202bjJ3Nm8zbTZwMnc2cTJsNnIzbTZzM202dDF3NnUxdzZ2M202dzF3Nng0eTZ5M202ejNtN2szbTdsM203bTJsN24ycjdvMXc3cDNtN3EzbTdyNHM3czNtN3QzbTd1Mnc3djNrN3cxbzd4M2s3eTNxMjAybDNtY2w0c2FsMmxhbTNtYW4zbWFvM21hcDNtYXIzbWFzMmxhdDR3YXUxdmF2M21hdzNzYXk0d2F6MmxiazJzYmwzcydmb2YnNm9ibzJsYnAzbWJxMnhicjF0YnMybGJ1MXpidjNtYnoyd2NrNHMyMDJrM21jbTRzY240c2NvNHNjcDRzY3E1dGNyNG1jczN4Y3QzeGN1M3hjdjN4Y3cybDJtMnRjeTJsY3oybGRsNHNkbTRzZG40c2RvNHNkcDRzZHE0c2RzNHNkdDRzZHU0c2R2NHNkdzRzZHozbWVrMndlbDJ3ZW0yd2VuMndlbzJ3ZXAyd2VxNG1lcjJ3ZXMyd2V0MndldTJ3ZXYyd2V3MXdleDF3ZXkxd2V6MXdmbDNtZm0zbWZuM21mbzNtZnAzbWZxM21mcjNzZnMzbWZ0M21mdTNtZnYzbWZ3M21mejNtMjAzazZvMjEybTZtMmR3MmwyY3EybDN0M20zdTF3MTdzNHMxOW0zbX0na2VybmluZyd7Y2x7NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9MjAxc3syMDFzc30yMDF0e2NrdzRsd2Ntd2Nud2Nvd2Nwd2NsdzR3dTIwMXRzfTJrezIwMXRzfTJ3ezRxczVrdzVvczVxeDVydTE3c3g1dHh9Mnh7MTdzdzV0dzVvdTVxdX0yeXs0cXM1a3c1b3M1cXg1cnUxN3N4NXR4fSdmb2YnLTZvN3R7Y2t1Y2x1Y211Y251Y291Y3B1NGx1NW9zNXJzfTN1ezE3c3U1dHU1cXN9M3Z7MTdzdTV0dTVxc303cHsxN3N3NXR3NXFzfWNrezRxczVrdTE3c3c1b3U1cXk1cncyMDFzczV0dzIwMXdzfTRsezRxczVrdTE3c3c1b3U1cXk1cncyMDFzczV0dzIwMXdzfWNtezRxczVrdTE3c3c1b3U1cXk1cncyMDFzczV0dzIwMXdzfWNuezRxczVrdTE3c3c1b3U1cXk1cncyMDFzczV0dzIwMXdzfWNvezRxczVrdTE3c3c1b3U1cXk1cncyMDFzczV0dzIwMXdzfWNwezRxczVrdTE3c3c1b3U1cXk1cncyMDFzczV0dzIwMXdzfTZsezE3c3U1dHU1b3M1cXc1cnN9MTdzezJrdGNsdmNtdmNudmNvdmNwdjRsdjR3dWNrdn01b3tja3djbHdjbXdjbndjb3djcHc0bHc0d3V9NXF7Y2t5Y2x5Y215Y255Y295Y3B5NGx5NHd1NW1zfTVye2NrdGNsdGNtdGNudGNvdGNwdDRsdDR3c301dHsya3RjbHZjbXZjbnZjb3ZjcHY0bHY0d3Vja3Z9N3F7Y2tzY2xzY21zY25zY29zY3BzNGxzfTZwezE3c3U1dHU1cXc1cnN9ZWt7NXFzNXJzfWVsezE3c3U1dHU1b3M1cXc1cnN9ZW17MTdzdTV0dTVvczVxczVyc31lbnsxN3N1NXFzNXJzfWVvezVxczVyc31lcHsxN3N1NXR1NW9zNXF3NXJzfWVzezVxc31ldHsxN3N1NXR1NXF3NXJzfWV1ezE3c3U1dHU1cXM1cnN9ZXZ7NXFzfTZ6ezE3c3Y1dHY1b3M1cXg1cnN9Zm17NW9zNXF0NXJzfWZuezE3c3Y1dHY1b3M1cXg1cnN9Zm97MTdzdjV0djVvczVxeDVyc31mcHs1b3M1cXQ1cnN9ZnF7NW9zNXF0NXJzfTdye2NrdWNsdWNtdWNudWNvdWNwdTRsdTVvc31mc3sxN3N2NXR2NW9zNXF4NXJzfWZ0ezE3c3M1dHM1cXN9ZnV7MTdzdzV0dzVxc31mdnsxN3N3NXR3NXFzfWZ3ezE3c3M1dHM1cXN9Znp7Y2t1Y2x1Y211Y251Y291Y3B1NGx1NW9zNXJzfX19IiksIkhlbHZldGljYS1PYmxpcXVlIjpsKCJ7J3dpZHRocyd7azNwMnE0bWN4MXcyMDFuM3IyMDFvNm8yMDFzMXEyMDF0MXEyMDF1MXEyMDF3MmwyMDF4MmwyMDF5MmwyazF3MmwxdzIwMm0ybjJuM3IybzNyMnA1dDIwMnE2bzJyMW4yczJsMnQybDJ1MnIydjN1MncxdzJ4MmwyeTF3MnoxdzNrM3IzbDNyM20zcjNuM3IzbzNyM3AzcjNxM3IzcjNyM3MzcjIwM3QybDIwM3UybDN2MXczdzN1M3gzdTN5M3UzejNyNGs2cDRsNG00bTRtNG40czRvNHM0cDRtNHEzeDRyNHk0czRzNHQxdzR1M200djRtNHczcjR4NW40eTRzNHo0eTVrNG01bDR5NW00czVuNG01bzN4NXA0czVxNG01cjV5NXM0bTV0NG01dTN4NXYxdzV3MXc1eDF3NXkyejV6M3I2azJsNmwzcjZtM3I2bjNtNm8zcjZwM3I2cTF3NnIzcjZzM3I2dDFxNnUxcTZ2M202dzFxNng1bjZ5M3I2ejNyN2szcjdsM3I3bTJsN24zbTdvMXc3cDNyN3EzbTdyNHM3czNtN3QzbTd1M203djJsN3cxdTd4Mmw3eTN1MjAybDNyY2w0bWFsMmxhbTNyYW4zcmFvM3JhcDNyYXIzcmFzMmxhdDR0YXUycGF2M3JhdzN1YXk0dGF6MmxiazJzYmwzdSdmb2YnNm9ibzJsYnAzcmJyMXdiczJsYnUyb2J2M3JiejN4Y2s0bTIwMmszcmNtNG1jbjRtY280bWNwNG1jcTZvY3I0c2NzNG1jdDRtY3U0bWN2NG1jdzF3Mm0ybmN5MXdjejF3ZGw0c2RtNHlkbjR5ZG80eWRwNHlkcTR5ZHM0eWR0NHNkdTRzZHY0c2R3NHNkejN4ZWszcmVsM3JlbTNyZW4zcmVvM3JlcDNyZXE1dGVyM21lczNyZXQzcmV1M3JldjNyZXcxd2V4MXdleTF3ZXoxd2ZsM3JmbTNyZm4zcmZvM3JmcDNyZnEzcmZyM3VmczN4ZnQzcmZ1M3JmdjNyZnczcmZ6M20yMDNrNm8yMTJtNm8yZHcybDJjcTJsM3QzcjN1MXcxN3M0bTE5bTNyfSdrZXJuaW5nJ3s1cXs0d3Z9Y2x7NHFzNWt3NW93NXFzMTdzdjV0dn0yMDF0ezJ3dTR3MWsyeXV9MjAxeHsyd3U0d3kyeXV9MTdzezJrdGNsdWNtdWNudTRvdGNwdTRsdTR3eWNvdWNrdX0yd3s3cXM0cXo1azFtMTdzeTVvdzVxeDVyc2ZzdTV0eTd0dWZ6dX0yeHsxN3N5NXR5NW95NXFzfTJ5ezdxczRxejVrMW0xN3N5NW93NXF4NXJzZnN1NXR5N3R1Znp1fSdmb2YnLTZvN3B7MTdzdjV0djVvd31ja3s0cXM1a3c1b3c1cXMxN3N2NXR2fTRsezRxczVrdzVvdzVxczE3c3Y1dHZ9Y217NHFzNWt3NW93NXFzMTdzdjV0dn1jbns0cXM1a3c1b3c1cXMxN3N2NXR2fWNvezRxczVrdzVvdzVxczE3c3Y1dHZ9Y3B7NHFzNWt3NW93NXFzMTdzdjV0dn02bHsxN3N5NXR5NW93fWRvezE3c3Q1dHR9NHp7MTdzdDV0dH03c3tmc3R9ZG17MTdzdDV0dH1kbnsxN3N0NXR0fTVve2Nrd2Nsd2Ntd2Nud2Nvd2NwdzRsdzR3dn1kcHsxN3N0NXR0fWRxezE3c3Q1dHR9N3R7NW93fWRzezE3c3Q1dHR9NXR7Mmt0Y2x1Y211Y251NG90Y3B1NGx1NHd5Y291Y2t1fWZ1ezE3c3Y1dHY1b3d9NnB7MTdzeTV0eTVvdzVxc31la3sxN3N5NXR5NW93fWVsezE3c3k1dHk1b3d9ZW17MTdzeTV0eTVvd31lbns1dHl9ZW97MTdzeTV0eTVvd31lcHsxN3N5NXR5NW93fWVzezE3c3k1dHk1cXN9ZXR7MTdzeTV0eTVvdzVxc31ldXsxN3N5NXR5NW93NXFzfWV2ezE3c3k1dHk1b3c1cXN9Nnp7MTdzeTV0eTVvdzVxc31mbXsxN3N5NXR5NW93NXFzfWZuezE3c3k1dHk1b3c1cXN9Zm97MTdzeTV0eTVvdzVxc31mcHsxN3N5NXR5NXFzfWZxezE3c3k1dHk1b3c1cXN9N3J7NW93fWZzezE3c3k1dHk1b3c1cXN9ZnR7MTdzdjV0djVvd303bXs1b3d9ZnZ7MTdzdjV0djVvd31md3sxN3N2NXR2NW93fX19Iil9fTtlLmV2ZW50cy5wdXNoKFsiYWRkRm9udCIsZnVuY3Rpb24oZSl7dmFyIHQ9ZS5mb250LEE9aC5Vbmljb2RlW3QucG9zdFNjcmlwdE5hbWVdO0EmJih0Lm1ldGFkYXRhLlVuaWNvZGU9e30sdC5tZXRhZGF0YS5Vbmljb2RlLndpZHRocz1BLndpZHRocyx0Lm1ldGFkYXRhLlVuaWNvZGUua2VybmluZz1BLmtlcm5pbmcpO3ZhciByPXUuVW5pY29kZVt0LnBvc3RTY3JpcHROYW1lXTtyJiYodC5tZXRhZGF0YS5Vbmljb2RlLmVuY29kaW5nPXIsdC5lbmNvZGluZz1yLmNvZGVQYWdlc1swXSl9XSl9KE0uQVBJKSxmdW5jdGlvbihlKXt2YXIgdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5sZW5ndGgsQT1uZXcgVWludDhBcnJheSh0KSxyPTA7cjx0O3IrKylBW3JdPWUuY2hhckNvZGVBdChyKTtyZXR1cm4gQX07ZS5BUEkuZXZlbnRzLnB1c2goWyJhZGRGb250IixmdW5jdGlvbihBKXt2YXIgcj12b2lkIDAsbj1BLmZvbnQscz1BLmluc3RhbmNlO2lmKCFuLmlzU3RhbmRhcmRGb250KXtpZih2b2lkIDA9PT1zKXRocm93IG5ldyBFcnJvcigiRm9udCBkb2VzIG5vdCBleGlzdCBpbiB2RlMsIGltcG9ydCBmb250cyBvciByZW1vdmUgZGVjbGFyYXRpb24gZG9jLmFkZEZvbnQoJyIrbi5wb3N0U2NyaXB0TmFtZSsiJykuIik7aWYoInN0cmluZyIhPXR5cGVvZihyPSExPT09cy5leGlzdHNGaWxlSW5WRlMobi5wb3N0U2NyaXB0TmFtZSk/cy5sb2FkRmlsZShuLnBvc3RTY3JpcHROYW1lKTpzLmdldEZpbGVGcm9tVkZTKG4ucG9zdFNjcmlwdE5hbWUpKSl0aHJvdyBuZXcgRXJyb3IoIkZvbnQgaXMgbm90IHN0b3JlZCBhcyBzdHJpbmctZGF0YSBpbiB2RlMsIGltcG9ydCBmb250cyBvciByZW1vdmUgZGVjbGFyYXRpb24gZG9jLmFkZEZvbnQoJyIrbi5wb3N0U2NyaXB0TmFtZSsiJykuIik7IWZ1bmN0aW9uKEEscil7cj0vXlx4MDBceDAxXHgwMFx4MDAvLnRlc3Qocik/dChyKTp0KHAocikpLEEubWV0YWRhdGE9ZS5BUEkuVFRGRm9udC5vcGVuKHIpLEEubWV0YWRhdGEuVW5pY29kZT1BLm1ldGFkYXRhLlVuaWNvZGV8fHtlbmNvZGluZzp7fSxrZXJuaW5nOnt9LHdpZHRoczpbXX0sQS5tZXRhZGF0YS5nbHlJZHNVc2VkPVswXX0obixyKX19XSl9KE0pLE0uQVBJLmFkZFN2Z0FzSW1hZ2U9ZnVuY3Rpb24oZSx0LHIsbixzLGksYSxjKXtpZihpc05hTih0KXx8aXNOYU4ocikpdGhyb3cgbC5lcnJvcigianNQREYuYWRkU3ZnQXNJbWFnZTogSW52YWxpZCBjb29yZGluYXRlcyIsYXJndW1lbnRzKSxuZXcgRXJyb3IoIkludmFsaWQgY29vcmRpbmF0ZXMgcGFzc2VkIHRvIGpzUERGLmFkZFN2Z0FzSW1hZ2UiKTtpZihpc05hTihuKXx8aXNOYU4ocykpdGhyb3cgbC5lcnJvcigianNQREYuYWRkU3ZnQXNJbWFnZTogSW52YWxpZCBtZWFzdXJlbWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIG1lYXN1cmVtZW50cyAod2lkdGggYW5kL29yIGhlaWdodCkgcGFzc2VkIHRvIGpzUERGLmFkZFN2Z0FzSW1hZ2UiKTt2YXIgdT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKTt1LndpZHRoPW4sdS5oZWlnaHQ9czt2YXIgaD11LmdldENvbnRleHQoIjJkIik7aC5maWxsU3R5bGU9IiNmZmYiLGguZmlsbFJlY3QoMCwwLHUud2lkdGgsdS5oZWlnaHQpO3ZhciBkPXtpZ25vcmVNb3VzZTohMCxpZ25vcmVBbmltYXRpb246ITAsaWdub3JlRGltZW5zaW9uczohMH0sZj10aGlzO3JldHVybihvLmNhbnZnP1Byb21pc2UucmVzb2x2ZShvLmNhbnZnKTpQcm9taXNlLnJlc29sdmUoKS50aGVuKEEuYmluZChBLCIuL25vZGVfbW9kdWxlcy9jYW52Zy9saWIvaW5kZXguZXMuanMiKSkpLmNhdGNoKGZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoIkNvdWxkIG5vdCBsb2FkIGNhbnZnOiAiK2UpKX0pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGVmYXVsdD9lLmRlZmF1bHQ6ZX0pLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIHQuZnJvbVN0cmluZyhoLGUsZCl9LGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcigiQ291bGQgbm90IGxvYWQgY2FudmcuIikpfSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZS5yZW5kZXIoZCl9KS50aGVuKGZ1bmN0aW9uKCl7Zi5hZGRJbWFnZSh1LnRvRGF0YVVSTCgiaW1hZ2UvanBlZyIsMSksdCxyLG4scyxhLGMpfSl9LE0uQVBJLnB1dFRvdGFsUGFnZXM9ZnVuY3Rpb24oZSl7dmFyIHQsQT0wO3BhcnNlSW50KHRoaXMuaW50ZXJuYWwuZ2V0Rm9udCgpLmlkLnN1YnN0cigxKSwxMCk8MTU/KHQ9bmV3IFJlZ0V4cChlLCJnIiksQT10aGlzLmludGVybmFsLmdldE51bWJlck9mUGFnZXMoKSk6KHQ9bmV3IFJlZ0V4cCh0aGlzLnBkZkVzY2FwZTE2KGUsdGhpcy5pbnRlcm5hbC5nZXRGb250KCkpLCJnIiksQT10aGlzLnBkZkVzY2FwZTE2KHRoaXMuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpKyIiLHRoaXMuaW50ZXJuYWwuZ2V0Rm9udCgpKSk7Zm9yKHZhciByPTE7cjw9dGhpcy5pbnRlcm5hbC5nZXROdW1iZXJPZlBhZ2VzKCk7cisrKWZvcih2YXIgbj0wO248dGhpcy5pbnRlcm5hbC5wYWdlc1tyXS5sZW5ndGg7bisrKXRoaXMuaW50ZXJuYWwucGFnZXNbcl1bbl09dGhpcy5pbnRlcm5hbC5wYWdlc1tyXVtuXS5yZXBsYWNlKHQsQSk7cmV0dXJuIHRoaXN9LE0uQVBJLnZpZXdlclByZWZlcmVuY2VzPWZ1bmN0aW9uKGUsdCl7dmFyIEE7ZT1lfHx7fSx0PXR8fCExO3ZhciBuLHMsaSxvPXtIaWRlVG9vbGJhcjp7ZGVmYXVsdFZhbHVlOiExLHZhbHVlOiExLHR5cGU6ImJvb2xlYW4iLGV4cGxpY2l0U2V0OiExLHZhbHVlU2V0OlshMCwhMV0scGRmVmVyc2lvbjoxLjN9LEhpZGVNZW51YmFyOntkZWZhdWx0VmFsdWU6ITEsdmFsdWU6ITEsdHlwZToiYm9vbGVhbiIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyEwLCExXSxwZGZWZXJzaW9uOjEuM30sSGlkZVdpbmRvd1VJOntkZWZhdWx0VmFsdWU6ITEsdmFsdWU6ITEsdHlwZToiYm9vbGVhbiIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyEwLCExXSxwZGZWZXJzaW9uOjEuM30sRml0V2luZG93OntkZWZhdWx0VmFsdWU6ITEsdmFsdWU6ITEsdHlwZToiYm9vbGVhbiIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyEwLCExXSxwZGZWZXJzaW9uOjEuM30sQ2VudGVyV2luZG93OntkZWZhdWx0VmFsdWU6ITEsdmFsdWU6ITEsdHlwZToiYm9vbGVhbiIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyEwLCExXSxwZGZWZXJzaW9uOjEuM30sRGlzcGxheURvY1RpdGxlOntkZWZhdWx0VmFsdWU6ITEsdmFsdWU6ITEsdHlwZToiYm9vbGVhbiIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyEwLCExXSxwZGZWZXJzaW9uOjEuNH0sTm9uRnVsbFNjcmVlblBhZ2VNb2RlOntkZWZhdWx0VmFsdWU6IlVzZU5vbmUiLHZhbHVlOiJVc2VOb25lIix0eXBlOiJuYW1lIixleHBsaWNpdFNldDohMSx2YWx1ZVNldDpbIlVzZU5vbmUiLCJVc2VPdXRsaW5lcyIsIlVzZVRodW1icyIsIlVzZU9DIl0scGRmVmVyc2lvbjoxLjN9LERpcmVjdGlvbjp7ZGVmYXVsdFZhbHVlOiJMMlIiLHZhbHVlOiJMMlIiLHR5cGU6Im5hbWUiLGV4cGxpY2l0U2V0OiExLHZhbHVlU2V0OlsiTDJSIiwiUjJMIl0scGRmVmVyc2lvbjoxLjN9LFZpZXdBcmVhOntkZWZhdWx0VmFsdWU6IkNyb3BCb3giLHZhbHVlOiJDcm9wQm94Iix0eXBlOiJuYW1lIixleHBsaWNpdFNldDohMSx2YWx1ZVNldDpbIk1lZGlhQm94IiwiQ3JvcEJveCIsIlRyaW1Cb3giLCJCbGVlZEJveCIsIkFydEJveCJdLHBkZlZlcnNpb246MS40fSxWaWV3Q2xpcDp7ZGVmYXVsdFZhbHVlOiJDcm9wQm94Iix2YWx1ZToiQ3JvcEJveCIsdHlwZToibmFtZSIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyJNZWRpYUJveCIsIkNyb3BCb3giLCJUcmltQm94IiwiQmxlZWRCb3giLCJBcnRCb3giXSxwZGZWZXJzaW9uOjEuNH0sUHJpbnRBcmVhOntkZWZhdWx0VmFsdWU6IkNyb3BCb3giLHZhbHVlOiJDcm9wQm94Iix0eXBlOiJuYW1lIixleHBsaWNpdFNldDohMSx2YWx1ZVNldDpbIk1lZGlhQm94IiwiQ3JvcEJveCIsIlRyaW1Cb3giLCJCbGVlZEJveCIsIkFydEJveCJdLHBkZlZlcnNpb246MS40fSxQcmludENsaXA6e2RlZmF1bHRWYWx1ZToiQ3JvcEJveCIsdmFsdWU6IkNyb3BCb3giLHR5cGU6Im5hbWUiLGV4cGxpY2l0U2V0OiExLHZhbHVlU2V0OlsiTWVkaWFCb3giLCJDcm9wQm94IiwiVHJpbUJveCIsIkJsZWVkQm94IiwiQXJ0Qm94Il0scGRmVmVyc2lvbjoxLjR9LFByaW50U2NhbGluZzp7ZGVmYXVsdFZhbHVlOiJBcHBEZWZhdWx0Iix2YWx1ZToiQXBwRGVmYXVsdCIsdHlwZToibmFtZSIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyJBcHBEZWZhdWx0IiwiTm9uZSJdLHBkZlZlcnNpb246MS42fSxEdXBsZXg6e2RlZmF1bHRWYWx1ZToiIix2YWx1ZToibm9uZSIsdHlwZToibmFtZSIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyJTaW1wbGV4IiwiRHVwbGV4RmxpcFNob3J0RWRnZSIsIkR1cGxleEZsaXBMb25nRWRnZSIsIm5vbmUiXSxwZGZWZXJzaW9uOjEuN30sUGlja1RyYXlCeVBERlNpemU6e2RlZmF1bHRWYWx1ZTohMSx2YWx1ZTohMSx0eXBlOiJib29sZWFuIixleHBsaWNpdFNldDohMSx2YWx1ZVNldDpbITAsITFdLHBkZlZlcnNpb246MS43fSxQcmludFBhZ2VSYW5nZTp7ZGVmYXVsdFZhbHVlOiIiLHZhbHVlOiIiLHR5cGU6ImFycmF5IixleHBsaWNpdFNldDohMSx2YWx1ZVNldDpudWxsLHBkZlZlcnNpb246MS43fSxOdW1Db3BpZXM6e2RlZmF1bHRWYWx1ZToxLHZhbHVlOjEsdHlwZToiaW50ZWdlciIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6bnVsbCxwZGZWZXJzaW9uOjEuN319LGE9T2JqZWN0LmtleXMobyksbD1bXSxjPTAsdT0wLGg9MDtmdW5jdGlvbiBkKGUsdCl7dmFyIEEscj0hMTtmb3IoQT0wO0E8ZS5sZW5ndGg7QSs9MSllW0FdPT09dCYmKHI9ITApO3JldHVybiByfWlmKHZvaWQgMD09PXRoaXMuaW50ZXJuYWwudmlld2VycHJlZmVyZW5jZXMmJih0aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzPXt9LHRoaXMuaW50ZXJuYWwudmlld2VycHJlZmVyZW5jZXMuY29uZmlndXJhdGlvbj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKSx0aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmlzU3Vic2NyaWJlZD0hMSksQT10aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmNvbmZpZ3VyYXRpb24sInJlc2V0Ij09PWV8fCEwPT09dCl7dmFyIGY9YS5sZW5ndGg7Zm9yKGg9MDtoPGY7aCs9MSlBW2FbaF1dLnZhbHVlPUFbYVtoXV0uZGVmYXVsdFZhbHVlLEFbYVtoXV0uZXhwbGljaXRTZXQ9ITF9aWYoIm9iamVjdCI9PT0oMCxyLmRlZmF1bHQpKGUpKWZvcihzIGluIGUpaWYoaT1lW3NdLGQoYSxzKSYmdm9pZCAwIT09aSl7aWYoImJvb2xlYW4iPT09QVtzXS50eXBlJiYiYm9vbGVhbiI9PXR5cGVvZiBpKUFbc10udmFsdWU9aTtlbHNlIGlmKCJuYW1lIj09PUFbc10udHlwZSYmZChBW3NdLnZhbHVlU2V0LGkpKUFbc10udmFsdWU9aTtlbHNlIGlmKCJpbnRlZ2VyIj09PUFbc10udHlwZSYmTnVtYmVyLmlzSW50ZWdlcihpKSlBW3NdLnZhbHVlPWk7ZWxzZSBpZigiYXJyYXkiPT09QVtzXS50eXBlKXtmb3IoYz0wO2M8aS5sZW5ndGg7Yys9MSlpZihuPSEwLDE9PT1pW2NdLmxlbmd0aCYmIm51bWJlciI9PXR5cGVvZiBpW2NdWzBdKWwucHVzaChTdHJpbmcoaVtjXS0xKSk7ZWxzZSBpZihpW2NdLmxlbmd0aD4xKXtmb3IodT0wO3U8aVtjXS5sZW5ndGg7dSs9MSkibnVtYmVyIiE9dHlwZW9mIGlbY11bdV0mJihuPSExKTshMD09PW4mJmwucHVzaChbaVtjXVswXS0xLGlbY11bMV0tMV0uam9pbigiICIpKX1BW3NdLnZhbHVlPSJbIitsLmpvaW4oIiAiKSsiXSJ9ZWxzZSBBW3NdLnZhbHVlPUFbc10uZGVmYXVsdFZhbHVlO0Fbc10uZXhwbGljaXRTZXQ9ITB9cmV0dXJuITE9PT10aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmlzU3Vic2NyaWJlZCYmKHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgicHV0Q2F0YWxvZyIsZnVuY3Rpb24oKXt2YXIgZSx0PVtdO2ZvcihlIGluIEEpITA9PT1BW2VdLmV4cGxpY2l0U2V0JiYoIm5hbWUiPT09QVtlXS50eXBlP3QucHVzaCgiLyIrZSsiIC8iK0FbZV0udmFsdWUpOnQucHVzaCgiLyIrZSsiICIrQVtlXS52YWx1ZSkpOzAhPT10Lmxlbmd0aCYmdGhpcy5pbnRlcm5hbC53cml0ZSgiL1ZpZXdlclByZWZlcmVuY2VzXG48PFxuIit0LmpvaW4oIlxuIikrIlxuPj4iKX0pLHRoaXMuaW50ZXJuYWwudmlld2VycHJlZmVyZW5jZXMuaXNTdWJzY3JpYmVkPSEwKSx0aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmNvbmZpZ3VyYXRpb249QSx0aGlzfSxmdW5jdGlvbihlKXt2YXIgdD1mdW5jdGlvbigpe3ZhciBlPSc8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPjxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOmpzcGRmPSInK3RoaXMuaW50ZXJuYWwuX19tZXRhZGF0YV9fLm5hbWVzcGFjZXVyaSsnIj48anNwZGY6bWV0YWRhdGE+Jyx0PXVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCgnPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+JykpLEE9dW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGUpKSxyPXVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmludGVybmFsLl9fbWV0YWRhdGFfXy5tZXRhZGF0YSkpLG49dW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KCI8L2pzcGRmOm1ldGFkYXRhPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj4iKSkscz11bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoIjwveDp4bXBtZXRhPiIpKSxpPUEubGVuZ3RoK3IubGVuZ3RoK24ubGVuZ3RoK3QubGVuZ3RoK3MubGVuZ3RoO3RoaXMuaW50ZXJuYWwuX19tZXRhZGF0YV9fLm1ldGFkYXRhX29iamVjdF9udW1iZXI9dGhpcy5pbnRlcm5hbC5uZXdPYmplY3QoKSx0aGlzLmludGVybmFsLndyaXRlKCI8PCAvVHlwZSAvTWV0YWRhdGEgL1N1YnR5cGUgL1hNTCAvTGVuZ3RoICIraSsiID4+IiksdGhpcy5pbnRlcm5hbC53cml0ZSgic3RyZWFtIiksdGhpcy5pbnRlcm5hbC53cml0ZSh0K0ErcituK3MpLHRoaXMuaW50ZXJuYWwud3JpdGUoImVuZHN0cmVhbSIpLHRoaXMuaW50ZXJuYWwud3JpdGUoImVuZG9iaiIpfSxBPWZ1bmN0aW9uKCl7dGhpcy5pbnRlcm5hbC5fX21ldGFkYXRhX18ubWV0YWRhdGFfb2JqZWN0X251bWJlciYmdGhpcy5pbnRlcm5hbC53cml0ZSgiL01ldGFkYXRhICIrdGhpcy5pbnRlcm5hbC5fX21ldGFkYXRhX18ubWV0YWRhdGFfb2JqZWN0X251bWJlcisiIDAgUiIpfTtlLmFkZE1ldGFkYXRhPWZ1bmN0aW9uKGUscil7cmV0dXJuIHZvaWQgMD09PXRoaXMuaW50ZXJuYWwuX19tZXRhZGF0YV9fJiYodGhpcy5pbnRlcm5hbC5fX21ldGFkYXRhX189e21ldGFkYXRhOmUsbmFtZXNwYWNldXJpOnJ8fCJodHRwOi8vanNwZGYuZGVmYXVsdC5uYW1lc3BhY2V1cmkvIn0sdGhpcy5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKCJwdXRDYXRhbG9nIixBKSx0aGlzLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInBvc3RQdXRSZXNvdXJjZXMiLHQpKSx0aGlzfX0oTS5BUEkpLGZ1bmN0aW9uKGUpe3ZhciB0PWUuQVBJLEE9dC5wZGZFc2NhcGUxNj1mdW5jdGlvbihlLHQpe2Zvcih2YXIgQSxyPXQubWV0YWRhdGEuVW5pY29kZS53aWR0aHMsbj1bIiIsIjAiLCIwMCIsIjAwMCIsIjAwMDAiXSxzPVsiIl0saT0wLG89ZS5sZW5ndGg7aTxvOysraSl7aWYoQT10Lm1ldGFkYXRhLmNoYXJhY3RlclRvR2x5cGgoZS5jaGFyQ29kZUF0KGkpKSx0Lm1ldGFkYXRhLmdseUlkc1VzZWQucHVzaChBKSx0Lm1ldGFkYXRhLnRvVW5pY29kZVtBXT1lLmNoYXJDb2RlQXQoaSksLTE9PXIuaW5kZXhPZihBKSYmKHIucHVzaChBKSxyLnB1c2goW3BhcnNlSW50KHQubWV0YWRhdGEud2lkdGhPZkdseXBoKEEpLDEwKV0pKSwiMCI9PUEpcmV0dXJuIHMuam9pbigiIik7QT1BLnRvU3RyaW5nKDE2KSxzLnB1c2gobls0LUEubGVuZ3RoXSxBKX1yZXR1cm4gcy5qb2luKCIiKX0scj1mdW5jdGlvbihlKXt2YXIgdCxBLHIsbixzLGksbztmb3Iocz0iL0NJREluaXQgL1Byb2NTZXQgZmluZHJlc291cmNlIGJlZ2luXG4xMiBkaWN0IGJlZ2luXG5iZWdpbmNtYXBcbi9DSURTeXN0ZW1JbmZvIDw8XG4gIC9SZWdpc3RyeSAoQWRvYmUpXG4gIC9PcmRlcmluZyAoVUNTKVxuICAvU3VwcGxlbWVudCAwXG4+PiBkZWZcbi9DTWFwTmFtZSAvQWRvYmUtSWRlbnRpdHktVUNTIGRlZlxuL0NNYXBUeXBlIDIgZGVmXG4xIGJlZ2luY29kZXNwYWNlcmFuZ2VcbjwwMDAwPjxmZmZmPlxuZW5kY29kZXNwYWNlcmFuZ2UiLHI9W10saT0wLG89KEE9T2JqZWN0LmtleXMoZSkuc29ydChmdW5jdGlvbihlLHQpe3JldHVybiBlLXR9KSkubGVuZ3RoO2k8bztpKyspdD1BW2ldLHIubGVuZ3RoPj0xMDAmJihzKz0iXG4iK3IubGVuZ3RoKyIgYmVnaW5iZmNoYXJcbiIrci5qb2luKCJcbiIpKyJcbmVuZGJmY2hhciIscj1bXSksdm9pZCAwIT09ZVt0XSYmbnVsbCE9PWVbdF0mJiJmdW5jdGlvbiI9PXR5cGVvZiBlW3RdLnRvU3RyaW5nJiYobj0oIjAwMDAiK2VbdF0udG9TdHJpbmcoMTYpKS5zbGljZSgtNCksdD0oIjAwMDAiKygrdCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCksci5wdXNoKCI8Iit0KyI+PCIrbisiPiIpKTtyZXR1cm4gci5sZW5ndGgmJihzKz0iXG4iK3IubGVuZ3RoKyIgYmVnaW5iZmNoYXJcbiIrci5qb2luKCJcbiIpKyJcbmVuZGJmY2hhclxuIikscysiZW5kY21hcFxuQ01hcE5hbWUgY3VycmVudGRpY3QgL0NNYXAgZGVmaW5lcmVzb3VyY2UgcG9wXG5lbmRcbmVuZCJ9O3QuZXZlbnRzLnB1c2goWyJwdXRGb250IixmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7dmFyIEE9dC5mb250LG49dC5vdXQscz10Lm5ld09iamVjdCxpPXQucHV0U3RyZWFtO2lmKEEubWV0YWRhdGEgaW5zdGFuY2VvZiBlLkFQSS5UVEZGb250JiYiSWRlbnRpdHktSCI9PT1BLmVuY29kaW5nKXtmb3IodmFyIG89QS5tZXRhZGF0YS5Vbmljb2RlLndpZHRocyxhPUEubWV0YWRhdGEuc3Vic2V0LmVuY29kZShBLm1ldGFkYXRhLmdseUlkc1VzZWQsMSksbD0iIixjPTA7YzxhLmxlbmd0aDtjKyspbCs9U3RyaW5nLmZyb21DaGFyQ29kZShhW2NdKTt2YXIgdT1zKCk7aSh7ZGF0YTpsLGFkZExlbmd0aDE6ITAsb2JqZWN0SWQ6dX0pLG4oImVuZG9iaiIpO3ZhciBoPXMoKTtpKHtkYXRhOnIoQS5tZXRhZGF0YS50b1VuaWNvZGUpLGFkZExlbmd0aDE6ITAsb2JqZWN0SWQ6aH0pLG4oImVuZG9iaiIpO3ZhciBkPXMoKTtuKCI8PCIpLG4oIi9UeXBlIC9Gb250RGVzY3JpcHRvciIpLG4oIi9Gb250TmFtZSAvIitOKEEuZm9udE5hbWUpKSxuKCIvRm9udEZpbGUyICIrdSsiIDAgUiIpLG4oIi9Gb250QkJveCAiK2UuQVBJLlBERk9iamVjdC5jb252ZXJ0KEEubWV0YWRhdGEuYmJveCkpLG4oIi9GbGFncyAiK0EubWV0YWRhdGEuZmxhZ3MpLG4oIi9TdGVtViAiK0EubWV0YWRhdGEuc3RlbVYpLG4oIi9JdGFsaWNBbmdsZSAiK0EubWV0YWRhdGEuaXRhbGljQW5nbGUpLG4oIi9Bc2NlbnQgIitBLm1ldGFkYXRhLmFzY2VuZGVyKSxuKCIvRGVzY2VudCAiK0EubWV0YWRhdGEuZGVjZW5kZXIpLG4oIi9DYXBIZWlnaHQgIitBLm1ldGFkYXRhLmNhcEhlaWdodCksbigiPj4iKSxuKCJlbmRvYmoiKTt2YXIgZj1zKCk7bigiPDwiKSxuKCIvVHlwZSAvRm9udCIpLG4oIi9CYXNlRm9udCAvIitOKEEuZm9udE5hbWUpKSxuKCIvRm9udERlc2NyaXB0b3IgIitkKyIgMCBSIiksbigiL1cgIitlLkFQSS5QREZPYmplY3QuY29udmVydChvKSksbigiL0NJRFRvR0lETWFwIC9JZGVudGl0eSIpLG4oIi9EVyAxMDAwIiksbigiL1N1YnR5cGUgL0NJREZvbnRUeXBlMiIpLG4oIi9DSURTeXN0ZW1JbmZvIiksbigiPDwiKSxuKCIvU3VwcGxlbWVudCAwIiksbigiL1JlZ2lzdHJ5IChBZG9iZSkiKSxuKCIvT3JkZXJpbmcgKCIrQS5lbmNvZGluZysiKSIpLG4oIj4+IiksbigiPj4iKSxuKCJlbmRvYmoiKSxBLm9iamVjdE51bWJlcj1zKCksbigiPDwiKSxuKCIvVHlwZSAvRm9udCIpLG4oIi9TdWJ0eXBlIC9UeXBlMCIpLG4oIi9Ub1VuaWNvZGUgIitoKyIgMCBSIiksbigiL0Jhc2VGb250IC8iK04oQS5mb250TmFtZSkpLG4oIi9FbmNvZGluZyAvIitBLmVuY29kaW5nKSxuKCIvRGVzY2VuZGFudEZvbnRzIFsiK2YrIiAwIFJdIiksbigiPj4iKSxuKCJlbmRvYmoiKSxBLmlzQWxyZWFkeVB1dHRlZD0hMH19KHQpfV0pLHQuZXZlbnRzLnB1c2goWyJwdXRGb250IixmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7dmFyIEE9dC5mb250LG49dC5vdXQscz10Lm5ld09iamVjdCxpPXQucHV0U3RyZWFtO2lmKEEubWV0YWRhdGEgaW5zdGFuY2VvZiBlLkFQSS5UVEZGb250JiYiV2luQW5zaUVuY29kaW5nIj09PUEuZW5jb2Rpbmcpe2Zvcih2YXIgbz1BLm1ldGFkYXRhLnJhd0RhdGEsYT0iIixsPTA7bDxvLmxlbmd0aDtsKyspYSs9U3RyaW5nLmZyb21DaGFyQ29kZShvW2xdKTt2YXIgYz1zKCk7aSh7ZGF0YTphLGFkZExlbmd0aDE6ITAsb2JqZWN0SWQ6Y30pLG4oImVuZG9iaiIpO3ZhciB1PXMoKTtpKHtkYXRhOnIoQS5tZXRhZGF0YS50b1VuaWNvZGUpLGFkZExlbmd0aDE6ITAsb2JqZWN0SWQ6dX0pLG4oImVuZG9iaiIpO3ZhciBoPXMoKTtuKCI8PCIpLG4oIi9EZXNjZW50ICIrQS5tZXRhZGF0YS5kZWNlbmRlciksbigiL0NhcEhlaWdodCAiK0EubWV0YWRhdGEuY2FwSGVpZ2h0KSxuKCIvU3RlbVYgIitBLm1ldGFkYXRhLnN0ZW1WKSxuKCIvVHlwZSAvRm9udERlc2NyaXB0b3IiKSxuKCIvRm9udEZpbGUyICIrYysiIDAgUiIpLG4oIi9GbGFncyA5NiIpLG4oIi9Gb250QkJveCAiK2UuQVBJLlBERk9iamVjdC5jb252ZXJ0KEEubWV0YWRhdGEuYmJveCkpLG4oIi9Gb250TmFtZSAvIitOKEEuZm9udE5hbWUpKSxuKCIvSXRhbGljQW5nbGUgIitBLm1ldGFkYXRhLml0YWxpY0FuZ2xlKSxuKCIvQXNjZW50ICIrQS5tZXRhZGF0YS5hc2NlbmRlciksbigiPj4iKSxuKCJlbmRvYmoiKSxBLm9iamVjdE51bWJlcj1zKCk7Zm9yKHZhciBkPTA7ZDxBLm1ldGFkYXRhLmhtdHgud2lkdGhzLmxlbmd0aDtkKyspQS5tZXRhZGF0YS5obXR4LndpZHRoc1tkXT1wYXJzZUludChBLm1ldGFkYXRhLmhtdHgud2lkdGhzW2RdKigxZTMvQS5tZXRhZGF0YS5oZWFkLnVuaXRzUGVyRW0pKTtuKCI8PC9TdWJ0eXBlL1RydWVUeXBlL1R5cGUvRm9udC9Ub1VuaWNvZGUgIit1KyIgMCBSL0Jhc2VGb250LyIrTihBLmZvbnROYW1lKSsiL0ZvbnREZXNjcmlwdG9yICIraCsiIDAgUi9FbmNvZGluZy8iK0EuZW5jb2RpbmcrIiAvRmlyc3RDaGFyIDI5IC9MYXN0Q2hhciAyNTUgL1dpZHRocyAiK2UuQVBJLlBERk9iamVjdC5jb252ZXJ0KEEubWV0YWRhdGEuaG10eC53aWR0aHMpKyI+PiIpLG4oImVuZG9iaiIpLEEuaXNBbHJlYWR5UHV0dGVkPSEwfX0odCl9XSk7dmFyIG49ZnVuY3Rpb24oZSl7dmFyIHQscj1lLnRleHR8fCIiLG49ZS54LHM9ZS55LGk9ZS5vcHRpb25zfHx7fSxvPWUubXV0ZXh8fHt9LGE9by5wZGZFc2NhcGUsbD1vLmFjdGl2ZUZvbnRLZXksYz1vLmZvbnRzLHU9bCxoPSIiLGQ9MCxmPSIiLHA9Y1t1XS5lbmNvZGluZztpZigiSWRlbnRpdHktSCIhPT1jW3VdLmVuY29kaW5nKXJldHVybnt0ZXh0OnIseDpuLHk6cyxvcHRpb25zOmksbXV0ZXg6b307Zm9yKGY9cix1PWwsQXJyYXkuaXNBcnJheShyKSYmKGY9clswXSksZD0wO2Q8Zi5sZW5ndGg7ZCs9MSljW3VdLm1ldGFkYXRhLmhhc093blByb3BlcnR5KCJjbWFwIikmJih0PWNbdV0ubWV0YWRhdGEuY21hcC51bmljb2RlLmNvZGVNYXBbZltkXS5jaGFyQ29kZUF0KDApXSksdHx8ZltkXS5jaGFyQ29kZUF0KDApPDI1NiYmY1t1XS5tZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eSgiVW5pY29kZSIpP2grPWZbZF06aCs9IiI7dmFyIGc9IiI7cmV0dXJuIHBhcnNlSW50KHUuc2xpY2UoMSkpPDE0fHwiV2luQW5zaUVuY29kaW5nIj09PXA/Zz1hKGgsdSkuc3BsaXQoIiIpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KX0pLmpvaW4oIiIpOiJJZGVudGl0eS1IIj09PXAmJihnPUEoaCxjW3VdKSksby5pc0hleD0hMCx7dGV4dDpnLHg6bix5OnMsb3B0aW9uczppLG11dGV4Om99fTt0LmV2ZW50cy5wdXNoKFsicG9zdFByb2Nlc3NUZXh0IixmdW5jdGlvbihlKXt2YXIgdD1lLnRleHR8fCIiLEE9W10scj17dGV4dDp0LHg6ZS54LHk6ZS55LG9wdGlvbnM6ZS5vcHRpb25zLG11dGV4OmUubXV0ZXh9O2lmKEFycmF5LmlzQXJyYXkodCkpe3ZhciBzPTA7Zm9yKHM9MDtzPHQubGVuZ3RoO3MrPTEpQXJyYXkuaXNBcnJheSh0W3NdKSYmMz09PXRbc10ubGVuZ3RoP0EucHVzaChbbihPYmplY3QuYXNzaWduKHt9LHIse3RleHQ6dFtzXVswXX0pKS50ZXh0LHRbc11bMV0sdFtzXVsyXV0pOkEucHVzaChuKE9iamVjdC5hc3NpZ24oe30scix7dGV4dDp0W3NdfSkpLnRleHQpO2UudGV4dD1BfWVsc2UgZS50ZXh0PW4oT2JqZWN0LmFzc2lnbih7fSxyLHt0ZXh0OnR9KSkudGV4dH1dKX0oTSksZnVuY3Rpb24oZSl7dmFyIHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5pbnRlcm5hbC52RlMmJih0aGlzLmludGVybmFsLnZGUz17fSksITB9O2UuZXhpc3RzRmlsZUluVkZTPWZ1bmN0aW9uKGUpe3JldHVybiB0LmNhbGwodGhpcyksdm9pZCAwIT09dGhpcy5pbnRlcm5hbC52RlNbZV19LGUuYWRkRmlsZVRvVkZTPWZ1bmN0aW9uKGUsQSl7cmV0dXJuIHQuY2FsbCh0aGlzKSx0aGlzLmludGVybmFsLnZGU1tlXT1BLHRoaXN9LGUuZ2V0RmlsZUZyb21WRlM9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuY2FsbCh0aGlzKSx2b2lkIDAhPT10aGlzLmludGVybmFsLnZGU1tlXT90aGlzLmludGVybmFsLnZGU1tlXTpudWxsfX0oTS5BUEkpLGZ1bmN0aW9uKGUpe2UuX19iaWRpRW5naW5lX189ZS5wcm90b3R5cGUuX19iaWRpRW5naW5lX189ZnVuY3Rpb24oZSl7dmFyIEEscixuLHMsaSxvLGEsbD10LGM9W1swLDMsMCwxLDAsMCwwXSxbMCwzLDAsMSwyLDIsMF0sWzAsMywwLDE3LDIsMCwxXSxbMCwzLDUsNSw0LDEsMF0sWzAsMywyMSwyMSw0LDAsMV0sWzAsMyw1LDUsNCwyLDBdXSx1PVtbMiwwLDEsMSwwLDEsMF0sWzIsMCwxLDEsMCwyLDBdLFsyLDAsMiwxLDMsMiwwXSxbMiwwLDIsMzMsMywxLDFdXSxoPXtMOjAsUjoxLEVOOjIsQU46MyxOOjQsQjo1LFM6Nn0sZD17MDowLDU6MSw2OjIsNzozLDMyOjQsMjUxOjUsMjU0OjYsMjU1Ojd9LGY9WyIoIiwiKSIsIigiLCI8IiwiPiIsIjwiLCJbIiwiXSIsIlsiLCJ7IiwifSIsInsiLCLCqyIsIsK7IiwiwqsiLCLigLkiLCLigLoiLCLigLkiLCLigYUiLCLigYYiLCLigYUiLCLigb0iLCLigb4iLCLigb0iLCLigo0iLCLigo4iLCLigo0iLCLiiaQiLCLiiaUiLCLiiaQiLCLijKkiLCLijKoiLCLijKkiLCLvuZkiLCLvuZoiLCLvuZkiLCLvuZsiLCLvuZwiLCLvuZsiLCLvuZ0iLCLvuZ4iLCLvuZ0iLCLvuaQiLCLvuaUiLCLvuaQiXSxwPW5ldyBSZWdFeHAoL14oWzEtNHw5XXwxWzAtOV18MlswLTldfDNbMDE2OF18NFswNDU4OV18NVswMTJdfDdbNzhdfDE1OXwxNlswLTldfDE3WzAtMl18MjFbNTY5XXwyMlswMzQ4OV18MjUwKSQvKSxnPSExLG09MDt0aGlzLl9fYmlkaUVuZ2luZV9fPXt9O3ZhciB3PWZ1bmN0aW9uKGUpe3ZhciB0PWUuY2hhckNvZGVBdCgpLEE9dD4+OCxyPWRbQV07cmV0dXJuIHZvaWQgMCE9PXI/bFsyNTYqcisoMjU1JnQpXToyNTI9PT1BfHwyNTM9PT1BPyJBTCI6cC50ZXN0KEEpPyJMIjo4PT09QT8iUiI6Ik4ifSxCPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxBPTA7QTxlLmxlbmd0aDtBKyspe2lmKCJMIj09PSh0PXcoZS5jaGFyQXQoQSkpKSlyZXR1cm4hMTtpZigiUiI9PT10KXJldHVybiEwfXJldHVybiExfSx5PWZ1bmN0aW9uKGUsdCxpLG8pe3ZhciBhLGwsYyx1LGg9dFtvXTtzd2l0Y2goaCl7Y2FzZSJMIjpjYXNlIlIiOmNhc2UiTFJFIjpjYXNlIlJMRSI6Y2FzZSJMUk8iOmNhc2UiUkxPIjpjYXNlIlBERiI6Zz0hMTticmVhaztjYXNlIk4iOmNhc2UiQU4iOmJyZWFrO2Nhc2UiRU4iOmcmJihoPSJBTiIpO2JyZWFrO2Nhc2UiQUwiOmc9ITAsaD0iUiI7YnJlYWs7Y2FzZSJXUyI6Y2FzZSJCTiI6aD0iTiI7YnJlYWs7Y2FzZSJDUyI6bzwxfHxvKzE+PXQubGVuZ3RofHwiRU4iIT09KGE9aVtvLTFdKSYmIkFOIiE9PWF8fCJFTiIhPT0obD10W28rMV0pJiYiQU4iIT09bD9oPSJOIjpnJiYobD0iQU4iKSxoPWw9PT1hP2w6Ik4iO2JyZWFrO2Nhc2UiRVMiOmg9IkVOIj09PShhPW8+MD9pW28tMV06IkIiKSYmbysxPHQubGVuZ3RoJiYiRU4iPT09dFtvKzFdPyJFTiI6Ik4iO2JyZWFrO2Nhc2UiRVQiOmlmKG8+MCYmIkVOIj09PWlbby0xXSl7aD0iRU4iO2JyZWFrfWlmKGcpe2g9Ik4iO2JyZWFrfWZvcihjPW8rMSx1PXQubGVuZ3RoO2M8dSYmIkVUIj09PXRbY107KWMrKztoPWM8dSYmIkVOIj09PXRbY10/IkVOIjoiTiI7YnJlYWs7Y2FzZSJOU00iOmlmKG4mJiFzKXtmb3IodT10Lmxlbmd0aCxjPW8rMTtjPHUmJiJOU00iPT09dFtjXTspYysrO2lmKGM8dSl7dmFyIGQ9ZVtvXSxmPWQ+PTE0MjUmJmQ8PTIzMDN8fDY0Mjg2PT09ZDtpZihhPXRbY10sZiYmKCJSIj09PWF8fCJBTCI9PT1hKSl7aD0iUiI7YnJlYWt9fX1oPW88MXx8IkIiPT09KGE9dFtvLTFdKT8iTiI6aVtvLTFdO2JyZWFrO2Nhc2UiQiI6Zz0hMSxBPSEwLGg9bTticmVhaztjYXNlIlMiOnI9ITAsaD0iTiJ9cmV0dXJuIGh9LHY9ZnVuY3Rpb24oZSx0LEEpe3ZhciByPWUuc3BsaXQoIiIpO3JldHVybiBBJiZiKHIsQSx7aGlMZXZlbDptfSksci5yZXZlcnNlKCksdCYmdC5yZXZlcnNlKCksci5qb2luKCIiKX0sYj1mdW5jdGlvbihlLHQsbil7dmFyIHMsaSxvLGEsbCxkPS0xLGY9ZS5sZW5ndGgscD0wLEI9W10sdj1tP3U6YyxiPVtdO2ZvcihnPSExLEE9ITEscj0hMSxpPTA7aTxmO2krKyliW2ldPXcoZVtpXSk7Zm9yKG89MDtvPGY7bysrKXtpZihsPXAsQltvXT15KGUsYixCLG8pLHM9MjQwJihwPXZbbF1baFtCW29dXV0pLHAmPTE1LHRbb109YT12W3BdWzVdLHM+MClpZigxNj09PXMpe2ZvcihpPWQ7aTxvO2krKyl0W2ldPTE7ZD0tMX1lbHNlIGQ9LTE7aWYodltwXVs2XSktMT09PWQmJihkPW8pO2Vsc2UgaWYoZD4tMSl7Zm9yKGk9ZDtpPG87aSsrKXRbaV09YTtkPS0xfSJCIj09PWJbb10mJih0W29dPTApLG4uaGlMZXZlbHw9YX1yJiZmdW5jdGlvbihlLHQsQSl7Zm9yKHZhciByPTA7cjxBO3IrKylpZigiUyI9PT1lW3JdKXt0W3JdPW07Zm9yKHZhciBuPXItMTtuPj0wJiYiV1MiPT09ZVtuXTtuLS0pdFtuXT1tfX0oYix0LGYpfSxDPWZ1bmN0aW9uKGUsdCxyLG4scyl7aWYoIShzLmhpTGV2ZWw8ZSkpe2lmKDE9PT1lJiYxPT09bSYmIUEpcmV0dXJuIHQucmV2ZXJzZSgpLHZvaWQociYmci5yZXZlcnNlKCkpO2Zvcih2YXIgaSxvLGEsbCxjPXQubGVuZ3RoLHU9MDt1PGM7KXtpZihuW3VdPj1lKXtmb3IoYT11KzE7YTxjJiZuW2FdPj1lOylhKys7Zm9yKGw9dSxvPWEtMTtsPG87bCsrLG8tLSlpPXRbbF0sdFtsXT10W29dLHRbb109aSxyJiYoaT1yW2xdLHJbbF09cltvXSxyW29dPWkpO3U9YX11Kyt9fX0sXz1mdW5jdGlvbihlLHQsQSl7dmFyIHI9ZS5zcGxpdCgiIiksbj17aGlMZXZlbDptfTtyZXR1cm4gQXx8KEE9W10pLGIocixBLG4pLGZ1bmN0aW9uKGUsdCxBKXtpZigwIT09QS5oaUxldmVsJiZhKWZvcih2YXIgcixuPTA7bjxlLmxlbmd0aDtuKyspMT09PXRbbl0mJihyPWYuaW5kZXhPZihlW25dKSk+PTAmJihlW25dPWZbcisxXSl9KHIsQSxuKSxDKDIscix0LEEsbiksQygxLHIsdCxBLG4pLHIuam9pbigiIil9O3JldHVybiB0aGlzLl9fYmlkaUVuZ2luZV9fLmRvQmlkaVJlb3JkZXI9ZnVuY3Rpb24oZSx0LEEpe2lmKGZ1bmN0aW9uKGUsdCl7aWYodClmb3IodmFyIEE9MDtBPGUubGVuZ3RoO0ErKyl0W0FdPUE7dm9pZCAwPT09cyYmKHM9QihlKSksdm9pZCAwPT09byYmKG89QihlKSl9KGUsdCksbnx8IWl8fG8paWYobiYmaSYmc15vKW09cz8xOjAsZT12KGUsdCxBKTtlbHNlIGlmKCFuJiZpJiZvKW09cz8xOjAsZT1fKGUsdCxBKSxlPXYoZSx0KTtlbHNlIGlmKCFufHxzfHxpfHxvKXtpZihuJiYhaSYmc15vKWU9dihlLHQpLHM/KG09MCxlPV8oZSx0LEEpKToobT0xLGU9XyhlLHQsQSksZT12KGUsdCkpO2Vsc2UgaWYobiYmcyYmIWkmJm8pbT0xLGU9XyhlLHQsQSksZT12KGUsdCk7ZWxzZSBpZighbiYmIWkmJnNebyl7dmFyIHI9YTtzPyhtPTEsZT1fKGUsdCxBKSxtPTAsYT0hMSxlPV8oZSx0LEEpLGE9cik6KG09MCxlPV8oZSx0LEEpLGU9dihlLHQpLG09MSxhPSExLGU9XyhlLHQsQSksYT1yLGU9dihlLHQpKX19ZWxzZSBtPTAsZT1fKGUsdCxBKTtlbHNlIG09cz8xOjAsZT1fKGUsdCxBKTtyZXR1cm4gZX0sdGhpcy5fX2JpZGlFbmdpbmVfXy5zZXRPcHRpb25zPWZ1bmN0aW9uKGUpe2UmJihuPWUuaXNJbnB1dFZpc3VhbCxpPWUuaXNPdXRwdXRWaXN1YWwscz1lLmlzSW5wdXRSdGwsbz1lLmlzT3V0cHV0UnRsLGE9ZS5pc1N5bW1ldHJpY1N3YXBwaW5nKX0sdGhpcy5fX2JpZGlFbmdpbmVfXy5zZXRPcHRpb25zKGUpLHRoaXMuX19iaWRpRW5naW5lX199O3ZhciB0PVsiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiUyIsIkIiLCJTIiwiV1MiLCJCIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkIiLCJCIiwiQiIsIlMiLCJXUyIsIk4iLCJOIiwiRVQiLCJFVCIsIkVUIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJFUyIsIkNTIiwiRVMiLCJDUyIsIkNTIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJDUyIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTiIsIk4iLCJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJDUyIsIk4iLCJFVCIsIkVUIiwiRVQiLCJFVCIsIk4iLCJOIiwiTiIsIk4iLCJMIiwiTiIsIk4iLCJCTiIsIk4iLCJOIiwiRVQiLCJFVCIsIkVOIiwiRU4iLCJOIiwiTCIsIk4iLCJOIiwiTiIsIkVOIiwiTCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiRVQiLCJOIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiUiIsIk5TTSIsIlIiLCJOU00iLCJOU00iLCJSIiwiTlNNIiwiTlNNIiwiUiIsIk5TTSIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJSIiwiUiIsIlIiLCJSIiwiUiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiTiIsIk4iLCJBTCIsIkVUIiwiRVQiLCJBTCIsIkNTIiwiQUwiLCJOIiwiTiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIkFMIiwiQUwiLCJOIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJFVCIsIkFOIiwiQU4iLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQU4iLCJOIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQUwiLCJBTCIsIk5TTSIsIk5TTSIsIk4iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJBTCIsIkFMIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTiIsIkFMIiwiQUwiLCJOU00iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOIiwiTiIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJBTCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIlIiLCJSIiwiTiIsIk4iLCJOIiwiTiIsIlIiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIldTIiwiV1MiLCJXUyIsIldTIiwiV1MiLCJXUyIsIldTIiwiV1MiLCJXUyIsIldTIiwiV1MiLCJCTiIsIkJOIiwiQk4iLCJMIiwiUiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIldTIiwiQiIsIkxSRSIsIlJMRSIsIlBERiIsIkxSTyIsIlJMTyIsIkNTIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIkNTIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJXUyIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJOIiwiTFJJIiwiUkxJIiwiRlNJIiwiUERJIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiRU4iLCJMIiwiTiIsIk4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFUyIsIkVTIiwiTiIsIk4iLCJOIiwiTCIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRVMiLCJFUyIsIk4iLCJOIiwiTiIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJOIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiUiIsIk5TTSIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJFUyIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJOIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJOIiwiUiIsIk4iLCJSIiwiUiIsIk4iLCJSIiwiUiIsIk4iLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJDUyIsIk4iLCJDUyIsIk4iLCJOIiwiQ1MiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJFVCIsIk4iLCJOIiwiRVMiLCJFUyIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiRVQiLCJFVCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIk4iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJOIiwiTiIsIkJOIiwiTiIsIk4iLCJOIiwiRVQiLCJFVCIsIkVUIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJFUyIsIkNTIiwiRVMiLCJDUyIsIkNTIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJDUyIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJOIiwiRVQiLCJFVCIsIk4iLCJOIiwiTiIsIkVUIiwiRVQiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIl0sQT1uZXcgZS5fX2JpZGlFbmdpbmVfXyh7aXNJbnB1dFZpc3VhbDohMH0pO2UuQVBJLmV2ZW50cy5wdXNoKFsicG9zdFByb2Nlc3NUZXh0IixmdW5jdGlvbihlKXt2YXIgdD1lLnRleHQ7ZS54LGUueTt2YXIgcj1lLm9wdGlvbnN8fHt9O2UubXV0ZXgsci5sYW5nO3ZhciBuPVtdO2lmKHIuaXNJbnB1dFZpc3VhbD0iYm9vbGVhbiIhPXR5cGVvZiByLmlzSW5wdXRWaXN1YWx8fHIuaXNJbnB1dFZpc3VhbCxBLnNldE9wdGlvbnMociksIltvYmplY3QgQXJyYXldIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSl7dmFyIHM9MDtmb3Iobj1bXSxzPTA7czx0Lmxlbmd0aDtzKz0xKSJbb2JqZWN0IEFycmF5XSI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodFtzXSk/bi5wdXNoKFtBLmRvQmlkaVJlb3JkZXIodFtzXVswXSksdFtzXVsxXSx0W3NdWzJdXSk6bi5wdXNoKFtBLmRvQmlkaVJlb3JkZXIodFtzXSldKTtlLnRleHQ9bn1lbHNlIGUudGV4dD1BLmRvQmlkaVJlb3JkZXIodCk7QS5zZXRPcHRpb25zKHtpc0lucHV0VmlzdWFsOiEwfSl9XSl9KE0pLE0uQVBJLlRURkZvbnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3ZhciB0O2lmKHRoaXMucmF3RGF0YT1lLHQ9dGhpcy5jb250ZW50cz1uZXcgZ3QoZSksdGhpcy5jb250ZW50cy5wb3M9NCwidHRjZiI9PT10LnJlYWRTdHJpbmcoNCkpdGhyb3cgbmV3IEVycm9yKCJUVENGIG5vdCBzdXBwb3J0ZWQuIik7dC5wb3M9MCx0aGlzLnBhcnNlKCksdGhpcy5zdWJzZXQ9bmV3IGt0KHRoaXMpLHRoaXMucmVnaXN0ZXJUVEYoKX1yZXR1cm4gZS5vcGVuPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXJlY3Rvcnk9bmV3IG10KHRoaXMuY29udGVudHMpLHRoaXMuaGVhZD1uZXcgeXQodGhpcyksdGhpcy5uYW1lPW5ldyBGdCh0aGlzKSx0aGlzLmNtYXA9bmV3IGJ0KHRoaXMpLHRoaXMudG9Vbmljb2RlPXt9LHRoaXMuaGhlYT1uZXcgQ3QodGhpcyksdGhpcy5tYXhwPW5ldyBRdCh0aGlzKSx0aGlzLmhtdHg9bmV3IFV0KHRoaXMpLHRoaXMucG9zdD1uZXcganQodGhpcyksdGhpcy5vczI9bmV3IF90KHRoaXMpLHRoaXMubG9jYT1uZXcgTnQodGhpcyksdGhpcy5nbHlmPW5ldyBTdCh0aGlzKSx0aGlzLmFzY2VuZGVyPXRoaXMub3MyLmV4aXN0cyYmdGhpcy5vczIuYXNjZW5kZXJ8fHRoaXMuaGhlYS5hc2NlbmRlcix0aGlzLmRlY2VuZGVyPXRoaXMub3MyLmV4aXN0cyYmdGhpcy5vczIuZGVjZW5kZXJ8fHRoaXMuaGhlYS5kZWNlbmRlcix0aGlzLmxpbmVHYXA9dGhpcy5vczIuZXhpc3RzJiZ0aGlzLm9zMi5saW5lR2FwfHx0aGlzLmhoZWEubGluZUdhcCx0aGlzLmJib3g9W3RoaXMuaGVhZC54TWluLHRoaXMuaGVhZC55TWluLHRoaXMuaGVhZC54TWF4LHRoaXMuaGVhZC55TWF4XX0sZS5wcm90b3R5cGUucmVnaXN0ZXJUVEY9ZnVuY3Rpb24oKXt2YXIgZSx0LEEscixuO2lmKHRoaXMuc2NhbGVGYWN0b3I9MWUzL3RoaXMuaGVhZC51bml0c1BlckVtLHRoaXMuYmJveD1mdW5jdGlvbigpe3ZhciB0LEEscixuO2ZvcihuPVtdLHQ9MCxBPShyPXRoaXMuYmJveCkubGVuZ3RoO3Q8QTt0KyspZT1yW3RdLG4ucHVzaChNYXRoLnJvdW5kKGUqdGhpcy5zY2FsZUZhY3RvcikpO3JldHVybiBufS5jYWxsKHRoaXMpLHRoaXMuc3RlbVY9MCx0aGlzLnBvc3QuZXhpc3RzPyhBPTI1NSYocj10aGlzLnBvc3QuaXRhbGljX2FuZ2xlKSwzMjc2OCYodD1yPj4xNikmJih0PS0oMSsoNjU1MzVedCkpKSx0aGlzLml0YWxpY0FuZ2xlPSsodCsiLiIrQSkpOnRoaXMuaXRhbGljQW5nbGU9MCx0aGlzLmFzY2VuZGVyPU1hdGgucm91bmQodGhpcy5hc2NlbmRlcip0aGlzLnNjYWxlRmFjdG9yKSx0aGlzLmRlY2VuZGVyPU1hdGgucm91bmQodGhpcy5kZWNlbmRlcip0aGlzLnNjYWxlRmFjdG9yKSx0aGlzLmxpbmVHYXA9TWF0aC5yb3VuZCh0aGlzLmxpbmVHYXAqdGhpcy5zY2FsZUZhY3RvciksdGhpcy5jYXBIZWlnaHQ9dGhpcy5vczIuZXhpc3RzJiZ0aGlzLm9zMi5jYXBIZWlnaHR8fHRoaXMuYXNjZW5kZXIsdGhpcy54SGVpZ2h0PXRoaXMub3MyLmV4aXN0cyYmdGhpcy5vczIueEhlaWdodHx8MCx0aGlzLmZhbWlseUNsYXNzPSh0aGlzLm9zMi5leGlzdHMmJnRoaXMub3MyLmZhbWlseUNsYXNzfHwwKT4+OCx0aGlzLmlzU2VyaWY9MT09PShuPXRoaXMuZmFtaWx5Q2xhc3MpfHwyPT09bnx8Mz09PW58fDQ9PT1ufHw1PT09bnx8Nz09PW4sdGhpcy5pc1NjcmlwdD0xMD09PXRoaXMuZmFtaWx5Q2xhc3MsdGhpcy5mbGFncz0wLHRoaXMucG9zdC5pc0ZpeGVkUGl0Y2gmJih0aGlzLmZsYWdzfD0xKSx0aGlzLmlzU2VyaWYmJih0aGlzLmZsYWdzfD0yKSx0aGlzLmlzU2NyaXB0JiYodGhpcy5mbGFnc3w9OCksMCE9PXRoaXMuaXRhbGljQW5nbGUmJih0aGlzLmZsYWdzfD02NCksdGhpcy5mbGFnc3w9MzIsIXRoaXMuY21hcC51bmljb2RlKXRocm93IG5ldyBFcnJvcigiTm8gdW5pY29kZSBjbWFwIGZvciBmb250Iil9LGUucHJvdG90eXBlLmNoYXJhY3RlclRvR2x5cGg9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuKG51bGwhPSh0PXRoaXMuY21hcC51bmljb2RlKT90LmNvZGVNYXBbZV06dm9pZCAwKXx8MH0sZS5wcm90b3R5cGUud2lkdGhPZkdseXBoPWZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiB0PTFlMy90aGlzLmhlYWQudW5pdHNQZXJFbSx0aGlzLmhtdHguZm9yR2x5cGgoZSkuYWR2YW5jZSp0fSxlLnByb3RvdHlwZS53aWR0aE9mU3RyaW5nPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcixuLHMsaTtmb3Iocz0wLG49MCxpPShlPSIiK2UpLmxlbmd0aDswPD1pP248aTpuPmk7bj0wPD1pPysrbjotLW4pcj1lLmNoYXJDb2RlQXQobikscys9dGhpcy53aWR0aE9mR2x5cGgodGhpcy5jaGFyYWN0ZXJUb0dseXBoKHIpKStBKigxZTMvdCl8fDA7cmV0dXJuIHMqKHQvMWUzKX0sZS5wcm90b3R5cGUubGluZUhlaWdodD1mdW5jdGlvbihlLHQpe3ZhciBBO3JldHVybiBudWxsPT10JiYodD0hMSksQT10P3RoaXMubGluZUdhcDowLCh0aGlzLmFzY2VuZGVyK0EtdGhpcy5kZWNlbmRlcikvMWUzKmV9LGV9KCk7dmFyIHB0LGd0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLmRhdGE9bnVsbCE9ZT9lOltdLHRoaXMucG9zPTAsdGhpcy5sZW5ndGg9dGhpcy5kYXRhLmxlbmd0aH1yZXR1cm4gZS5wcm90b3R5cGUucmVhZEJ5dGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhW3RoaXMucG9zKytdfSxlLnByb3RvdHlwZS53cml0ZUJ5dGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGF0YVt0aGlzLnBvcysrXT1lfSxlLnByb3RvdHlwZS5yZWFkVUludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDE2Nzc3MjE2KnRoaXMucmVhZEJ5dGUoKSsodGhpcy5yZWFkQnl0ZSgpPDwxNikrKHRoaXMucmVhZEJ5dGUoKTw8OCkrdGhpcy5yZWFkQnl0ZSgpfSxlLnByb3RvdHlwZS53cml0ZVVJbnQzMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy53cml0ZUJ5dGUoZT4+PjI0JjI1NSksdGhpcy53cml0ZUJ5dGUoZT4+MTYmMjU1KSx0aGlzLndyaXRlQnl0ZShlPj44JjI1NSksdGhpcy53cml0ZUJ5dGUoMjU1JmUpfSxlLnByb3RvdHlwZS5yZWFkSW50MzI9ZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4oZT10aGlzLnJlYWRVSW50MzIoKSk+PTIxNDc0ODM2NDg/ZS00Mjk0OTY3Mjk2OmV9LGUucHJvdG90eXBlLndyaXRlSW50MzI9ZnVuY3Rpb24oZSl7cmV0dXJuIGU8MCYmKGUrPTQyOTQ5NjcyOTYpLHRoaXMud3JpdGVVSW50MzIoZSl9LGUucHJvdG90eXBlLnJlYWRVSW50MTY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWFkQnl0ZSgpPDw4fHRoaXMucmVhZEJ5dGUoKX0sZS5wcm90b3R5cGUud3JpdGVVSW50MTY9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMud3JpdGVCeXRlKGU+PjgmMjU1KSx0aGlzLndyaXRlQnl0ZSgyNTUmZSl9LGUucHJvdG90eXBlLnJlYWRJbnQxNj1mdW5jdGlvbigpe3ZhciBlO3JldHVybihlPXRoaXMucmVhZFVJbnQxNigpKT49MzI3Njg/ZS02NTUzNjplfSxlLnByb3RvdHlwZS53cml0ZUludDE2PWZ1bmN0aW9uKGUpe3JldHVybiBlPDAmJihlKz02NTUzNiksdGhpcy53cml0ZVVJbnQxNihlKX0sZS5wcm90b3R5cGUucmVhZFN0cmluZz1mdW5jdGlvbihlKXt2YXIgdCxBO2ZvcihBPVtdLHQ9MDswPD1lP3Q8ZTp0PmU7dD0wPD1lPysrdDotLXQpQVt0XT1TdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEJ5dGUoKSk7cmV0dXJuIEEuam9pbigiIil9LGUucHJvdG90eXBlLndyaXRlU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0LEEscjtmb3Iocj1bXSx0PTAsQT1lLmxlbmd0aDswPD1BP3Q8QTp0PkE7dD0wPD1BPysrdDotLXQpci5wdXNoKHRoaXMud3JpdGVCeXRlKGUuY2hhckNvZGVBdCh0KSkpO3JldHVybiByfSxlLnByb3RvdHlwZS5yZWFkU2hvcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWFkSW50MTYoKX0sZS5wcm90b3R5cGUud3JpdGVTaG9ydD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy53cml0ZUludDE2KGUpfSxlLnByb3RvdHlwZS5yZWFkTG9uZ0xvbmc9ZnVuY3Rpb24oKXt2YXIgZSx0LEEscixuLHMsaSxvO3JldHVybiBlPXRoaXMucmVhZEJ5dGUoKSx0PXRoaXMucmVhZEJ5dGUoKSxBPXRoaXMucmVhZEJ5dGUoKSxyPXRoaXMucmVhZEJ5dGUoKSxuPXRoaXMucmVhZEJ5dGUoKSxzPXRoaXMucmVhZEJ5dGUoKSxpPXRoaXMucmVhZEJ5dGUoKSxvPXRoaXMucmVhZEJ5dGUoKSwxMjgmZT8tMSooNzIwNTc1OTQwMzc5Mjc5NDAqKDI1NV5lKSsyODE0NzQ5NzY3MTA2NTYqKDI1NV50KSsxMDk5NTExNjI3Nzc2KigyNTVeQSkrNDI5NDk2NzI5NiooMjU1XnIpKzE2Nzc3MjE2KigyNTVebikrNjU1MzYqKDI1NV5zKSsyNTYqKDI1NV5pKSsoMjU1Xm8pKzEpOjcyMDU3NTk0MDM3OTI3OTQwKmUrMjgxNDc0OTc2NzEwNjU2KnQrMTA5OTUxMTYyNzc3NipBKzQyOTQ5NjcyOTYqcisxNjc3NzIxNipuKzY1NTM2KnMrMjU2Kmkrb30sZS5wcm90b3R5cGUud3JpdGVMb25nTG9uZz1mdW5jdGlvbihlKXt2YXIgdCxBO3JldHVybiB0PU1hdGguZmxvb3IoZS80Mjk0OTY3Mjk2KSxBPTQyOTQ5NjcyOTUmZSx0aGlzLndyaXRlQnl0ZSh0Pj4yNCYyNTUpLHRoaXMud3JpdGVCeXRlKHQ+PjE2JjI1NSksdGhpcy53cml0ZUJ5dGUodD4+OCYyNTUpLHRoaXMud3JpdGVCeXRlKDI1NSZ0KSx0aGlzLndyaXRlQnl0ZShBPj4yNCYyNTUpLHRoaXMud3JpdGVCeXRlKEE+PjE2JjI1NSksdGhpcy53cml0ZUJ5dGUoQT4+OCYyNTUpLHRoaXMud3JpdGVCeXRlKDI1NSZBKX0sZS5wcm90b3R5cGUucmVhZEludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlYWRJbnQzMigpfSxlLnByb3RvdHlwZS53cml0ZUludD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy53cml0ZUludDMyKGUpfSxlLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKGUpe3ZhciB0LEE7Zm9yKHQ9W10sQT0wOzA8PWU/QTxlOkE+ZTtBPTA8PWU/KytBOi0tQSl0LnB1c2godGhpcy5yZWFkQnl0ZSgpKTtyZXR1cm4gdH0sZS5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oZSl7dmFyIHQsQSxyLG47Zm9yKG49W10sQT0wLHI9ZS5sZW5ndGg7QTxyO0ErKyl0PWVbQV0sbi5wdXNoKHRoaXMud3JpdGVCeXRlKHQpKTtyZXR1cm4gbn0sZX0oKSxtdD1mdW5jdGlvbigpe3ZhciBlO2Z1bmN0aW9uIHQoZSl7dmFyIHQsQSxyO2Zvcih0aGlzLnNjYWxhclR5cGU9ZS5yZWFkSW50KCksdGhpcy50YWJsZUNvdW50PWUucmVhZFNob3J0KCksdGhpcy5zZWFyY2hSYW5nZT1lLnJlYWRTaG9ydCgpLHRoaXMuZW50cnlTZWxlY3Rvcj1lLnJlYWRTaG9ydCgpLHRoaXMucmFuZ2VTaGlmdD1lLnJlYWRTaG9ydCgpLHRoaXMudGFibGVzPXt9LEE9MCxyPXRoaXMudGFibGVDb3VudDswPD1yP0E8cjpBPnI7QT0wPD1yPysrQTotLUEpdD17dGFnOmUucmVhZFN0cmluZyg0KSxjaGVja3N1bTplLnJlYWRJbnQoKSxvZmZzZXQ6ZS5yZWFkSW50KCksbGVuZ3RoOmUucmVhZEludCgpfSx0aGlzLnRhYmxlc1t0LnRhZ109dH1yZXR1cm4gdC5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQpe3ZhciBBLHIsbixzLGksbyxhLGwsYyx1LGgsZCxmO2ZvcihmIGluIGg9T2JqZWN0LmtleXModCkubGVuZ3RoLG89TWF0aC5sb2coMiksYz0xNipNYXRoLmZsb29yKE1hdGgubG9nKGgpL28pLHM9TWF0aC5mbG9vcihjL28pLGw9MTYqaC1jLChyPW5ldyBndCkud3JpdGVJbnQodGhpcy5zY2FsYXJUeXBlKSxyLndyaXRlU2hvcnQoaCksci53cml0ZVNob3J0KGMpLHIud3JpdGVTaG9ydChzKSxyLndyaXRlU2hvcnQobCksbj0xNipoLGE9ci5wb3MrbixpPW51bGwsZD1bXSx0KWZvcih1PXRbZl0sci53cml0ZVN0cmluZyhmKSxyLndyaXRlSW50KGUodSkpLHIud3JpdGVJbnQoYSksci53cml0ZUludCh1Lmxlbmd0aCksZD1kLmNvbmNhdCh1KSwiaGVhZCI9PT1mJiYoaT1hKSxhKz11Lmxlbmd0aDthJTQ7KWQucHVzaCgwKSxhKys7cmV0dXJuIHIud3JpdGUoZCksQT0yOTgxMTQ2NTU0LWUoci5kYXRhKSxyLnBvcz1pKzgsci53cml0ZVVJbnQzMihBKSxyLmRhdGF9LGU9ZnVuY3Rpb24oZSl7dmFyIHQsQSxyLG47Zm9yKGU9RXQuY2FsbChlKTtlLmxlbmd0aCU0OyllLnB1c2goMCk7Zm9yKHI9bmV3IGd0KGUpLEE9MCx0PTAsbj1lLmxlbmd0aDt0PG47dD10Kz00KUErPXIucmVhZFVJbnQzMigpO3JldHVybiA0Mjk0OTY3Mjk1JkF9LHR9KCksd3Q9e30uaGFzT3duUHJvcGVydHksQnQ9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIEEgaW4gdCl3dC5jYWxsKHQsQSkmJihlW0FdPXRbQV0pO2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9cmV0dXJuIHIucHJvdG90eXBlPXQucHJvdG90eXBlLGUucHJvdG90eXBlPW5ldyByLGUuX19zdXBlcl9fPXQucHJvdG90eXBlLGV9O3B0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt2YXIgdDt0aGlzLmZpbGU9ZSx0PXRoaXMuZmlsZS5kaXJlY3RvcnkudGFibGVzW3RoaXMudGFnXSx0aGlzLmV4aXN0cz0hIXQsdCYmKHRoaXMub2Zmc2V0PXQub2Zmc2V0LHRoaXMubGVuZ3RoPXQubGVuZ3RoLHRoaXMucGFyc2UodGhpcy5maWxlLmNvbnRlbnRzKSl9cmV0dXJuIGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKCl7fSxlLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oKXt9LGUucHJvdG90eXBlLnJhdz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmV4aXN0cz8odGhpcy5maWxlLmNvbnRlbnRzLnBvcz10aGlzLm9mZnNldCx0aGlzLmZpbGUuY29udGVudHMucmVhZCh0aGlzLmxlbmd0aCkpOm51bGx9LGV9KCk7dmFyIHl0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3JldHVybiBlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIEJ0KGUscHQpLGUucHJvdG90eXBlLnRhZz0iaGVhZCIsZS5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucG9zPXRoaXMub2Zmc2V0LHRoaXMudmVyc2lvbj1lLnJlYWRJbnQoKSx0aGlzLnJldmlzaW9uPWUucmVhZEludCgpLHRoaXMuY2hlY2tTdW1BZGp1c3RtZW50PWUucmVhZEludCgpLHRoaXMubWFnaWNOdW1iZXI9ZS5yZWFkSW50KCksdGhpcy5mbGFncz1lLnJlYWRTaG9ydCgpLHRoaXMudW5pdHNQZXJFbT1lLnJlYWRTaG9ydCgpLHRoaXMuY3JlYXRlZD1lLnJlYWRMb25nTG9uZygpLHRoaXMubW9kaWZpZWQ9ZS5yZWFkTG9uZ0xvbmcoKSx0aGlzLnhNaW49ZS5yZWFkU2hvcnQoKSx0aGlzLnlNaW49ZS5yZWFkU2hvcnQoKSx0aGlzLnhNYXg9ZS5yZWFkU2hvcnQoKSx0aGlzLnlNYXg9ZS5yZWFkU2hvcnQoKSx0aGlzLm1hY1N0eWxlPWUucmVhZFNob3J0KCksdGhpcy5sb3dlc3RSZWNQUEVNPWUucmVhZFNob3J0KCksdGhpcy5mb250RGlyZWN0aW9uSGludD1lLnJlYWRTaG9ydCgpLHRoaXMuaW5kZXhUb0xvY0Zvcm1hdD1lLnJlYWRTaG9ydCgpLHRoaXMuZ2x5cGhEYXRhRm9ybWF0PWUucmVhZFNob3J0KCl9LGUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4odD1uZXcgZ3QpLndyaXRlSW50KHRoaXMudmVyc2lvbiksdC53cml0ZUludCh0aGlzLnJldmlzaW9uKSx0LndyaXRlSW50KHRoaXMuY2hlY2tTdW1BZGp1c3RtZW50KSx0LndyaXRlSW50KHRoaXMubWFnaWNOdW1iZXIpLHQud3JpdGVTaG9ydCh0aGlzLmZsYWdzKSx0LndyaXRlU2hvcnQodGhpcy51bml0c1BlckVtKSx0LndyaXRlTG9uZ0xvbmcodGhpcy5jcmVhdGVkKSx0LndyaXRlTG9uZ0xvbmcodGhpcy5tb2RpZmllZCksdC53cml0ZVNob3J0KHRoaXMueE1pbiksdC53cml0ZVNob3J0KHRoaXMueU1pbiksdC53cml0ZVNob3J0KHRoaXMueE1heCksdC53cml0ZVNob3J0KHRoaXMueU1heCksdC53cml0ZVNob3J0KHRoaXMubWFjU3R5bGUpLHQud3JpdGVTaG9ydCh0aGlzLmxvd2VzdFJlY1BQRU0pLHQud3JpdGVTaG9ydCh0aGlzLmZvbnREaXJlY3Rpb25IaW50KSx0LndyaXRlU2hvcnQoZSksdC53cml0ZVNob3J0KHRoaXMuZ2x5cGhEYXRhRm9ybWF0KSx0LmRhdGF9LGV9KCksdnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dmFyIEEscixuLHMsaSxvLGEsbCxjLHUsaCxkLGYscCxnLG0sdztzd2l0Y2godGhpcy5wbGF0Zm9ybUlEPWUucmVhZFVJbnQxNigpLHRoaXMuZW5jb2RpbmdJRD1lLnJlYWRTaG9ydCgpLHRoaXMub2Zmc2V0PXQrZS5yZWFkSW50KCksYz1lLnBvcyxlLnBvcz10aGlzLm9mZnNldCx0aGlzLmZvcm1hdD1lLnJlYWRVSW50MTYoKSx0aGlzLmxlbmd0aD1lLnJlYWRVSW50MTYoKSx0aGlzLmxhbmd1YWdlPWUucmVhZFVJbnQxNigpLHRoaXMuaXNVbmljb2RlPTM9PT10aGlzLnBsYXRmb3JtSUQmJjE9PT10aGlzLmVuY29kaW5nSUQmJjQ9PT10aGlzLmZvcm1hdHx8MD09PXRoaXMucGxhdGZvcm1JRCYmND09PXRoaXMuZm9ybWF0LHRoaXMuY29kZU1hcD17fSx0aGlzLmZvcm1hdCl7Y2FzZSAwOmZvcihvPTA7bzwyNTY7KytvKXRoaXMuY29kZU1hcFtvXT1lLnJlYWRCeXRlKCk7YnJlYWs7Y2FzZSA0OmZvcihoPWUucmVhZFVJbnQxNigpLHU9aC8yLGUucG9zKz02LG49ZnVuY3Rpb24oKXt2YXIgdCxBO2ZvcihBPVtdLG89dD0wOzA8PXU/dDx1OnQ+dTtvPTA8PXU/Kyt0Oi0tdClBLnB1c2goZS5yZWFkVUludDE2KCkpO3JldHVybiBBfSgpLGUucG9zKz0yLGY9ZnVuY3Rpb24oKXt2YXIgdCxBO2ZvcihBPVtdLG89dD0wOzA8PXU/dDx1OnQ+dTtvPTA8PXU/Kyt0Oi0tdClBLnB1c2goZS5yZWFkVUludDE2KCkpO3JldHVybiBBfSgpLGE9ZnVuY3Rpb24oKXt2YXIgdCxBO2ZvcihBPVtdLG89dD0wOzA8PXU/dDx1OnQ+dTtvPTA8PXU/Kyt0Oi0tdClBLnB1c2goZS5yZWFkVUludDE2KCkpO3JldHVybiBBfSgpLGw9ZnVuY3Rpb24oKXt2YXIgdCxBO2ZvcihBPVtdLG89dD0wOzA8PXU/dDx1OnQ+dTtvPTA8PXU/Kyt0Oi0tdClBLnB1c2goZS5yZWFkVUludDE2KCkpO3JldHVybiBBfSgpLHI9KHRoaXMubGVuZ3RoLWUucG9zK3RoaXMub2Zmc2V0KS8yLGk9ZnVuY3Rpb24oKXt2YXIgdCxBO2ZvcihBPVtdLG89dD0wOzA8PXI/dDxyOnQ+cjtvPTA8PXI/Kyt0Oi0tdClBLnB1c2goZS5yZWFkVUludDE2KCkpO3JldHVybiBBfSgpLG89Zz0wLHc9bi5sZW5ndGg7Zzx3O289KytnKWZvcihwPW5bb10sQT1tPWQ9ZltvXTtkPD1wP208PXA6bT49cDtBPWQ8PXA/KyttOi0tbSkwPT09bFtvXT9zPUErYVtvXTowIT09KHM9aVtsW29dLzIrKEEtZCktKHUtbyldfHwwKSYmKHMrPWFbb10pLHRoaXMuY29kZU1hcFtBXT02NTUzNSZzfWUucG9zPWN9cmV0dXJuIGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7dmFyIEEscixuLHMsaSxvLGEsbCxjLHUsaCxkLGYscCxnLG0sdyxCLHksdixiLEMsXyxqLHgsRixRLFUsRSxTLEwsSSxOLGssSCxQLFQsTyxNLEQsUixLLFYsRyx6LHE7c3dpdGNoKFU9bmV3IGd0LHM9T2JqZWN0LmtleXMoZSkuc29ydChmdW5jdGlvbihlLHQpe3JldHVybiBlLXR9KSx0KXtjYXNlIm1hY3JvbWFuIjpmb3IoZj0wLHA9ZnVuY3Rpb24oKXt2YXIgZT1bXTtmb3IoZD0wO2Q8MjU2OysrZCllLnB1c2goMCk7cmV0dXJuIGV9KCksbT17MDowfSxuPXt9LEU9MCxOPXMubGVuZ3RoO0U8TjtFKyspbnVsbD09bVtWPWVbcj1zW0VdXV0mJihtW1ZdPSsrZiksbltyXT17b2xkOmVbcl0sbmV3Om1bZVtyXV19LHBbcl09bVtlW3JdXTtyZXR1cm4gVS53cml0ZVVJbnQxNigxKSxVLndyaXRlVUludDE2KDApLFUud3JpdGVVSW50MzIoMTIpLFUud3JpdGVVSW50MTYoMCksVS53cml0ZVVJbnQxNigyNjIpLFUud3JpdGVVSW50MTYoMCksVS53cml0ZShwKSx7Y2hhck1hcDpuLHN1YnRhYmxlOlUuZGF0YSxtYXhHbHlwaElEOmYrMX07Y2FzZSJ1bmljb2RlIjpmb3IoRj1bXSxjPVtdLHc9MCxtPXt9LEE9e30sZz1hPW51bGwsUz0wLGs9cy5sZW5ndGg7UzxrO1MrKyludWxsPT1tW3k9ZVtyPXNbU11dXSYmKG1beV09Kyt3KSxBW3JdPXtvbGQ6eSxuZXc6bVt5XX0saT1tW3ldLXIsbnVsbCE9ZyYmaT09PWF8fChnJiZjLnB1c2goZyksRi5wdXNoKHIpLGE9aSksZz1yO2ZvcihnJiZjLnB1c2goZyksYy5wdXNoKDY1NTM1KSxGLnB1c2goNjU1MzUpLGo9MiooXz1GLmxlbmd0aCksQz0yKk1hdGgucG93KE1hdGgubG9nKF8pL01hdGguTE4yLDIpLHU9TWF0aC5sb2coQy8yKS9NYXRoLkxOMixiPTIqXy1DLG89W10sdj1bXSxoPVtdLGQ9TD0wLEg9Ri5sZW5ndGg7TDxIO2Q9KytMKXtpZih4PUZbZF0sbD1jW2RdLDY1NTM1PT09eCl7by5wdXNoKDApLHYucHVzaCgwKTticmVha31pZih4LShRPUFbeF0ubmV3KT49MzI3NjgpZm9yKG8ucHVzaCgwKSx2LnB1c2goMiooaC5sZW5ndGgrXy1kKSkscj1JPXg7eDw9bD9JPD1sOkk+PWw7cj14PD1sPysrSTotLUkpaC5wdXNoKEFbcl0ubmV3KTtlbHNlIG8ucHVzaChRLXgpLHYucHVzaCgwKX1mb3IoVS53cml0ZVVJbnQxNigzKSxVLndyaXRlVUludDE2KDEpLFUud3JpdGVVSW50MzIoMTIpLFUud3JpdGVVSW50MTYoNCksVS53cml0ZVVJbnQxNigxNis4Kl8rMipoLmxlbmd0aCksVS53cml0ZVVJbnQxNigwKSxVLndyaXRlVUludDE2KGopLFUud3JpdGVVSW50MTYoQyksVS53cml0ZVVJbnQxNih1KSxVLndyaXRlVUludDE2KGIpLFI9MCxQPWMubGVuZ3RoO1I8UDtSKyspcj1jW1JdLFUud3JpdGVVSW50MTYocik7Zm9yKFUud3JpdGVVSW50MTYoMCksSz0wLFQ9Ri5sZW5ndGg7SzxUO0srKylyPUZbS10sVS53cml0ZVVJbnQxNihyKTtmb3IoRz0wLE89by5sZW5ndGg7RzxPO0crKylpPW9bR10sVS53cml0ZVVJbnQxNihpKTtmb3Ioej0wLE09di5sZW5ndGg7ejxNO3orKylCPXZbel0sVS53cml0ZVVJbnQxNihCKTtmb3IocT0wLEQ9aC5sZW5ndGg7cTxEO3ErKylmPWhbcV0sVS53cml0ZVVJbnQxNihmKTtyZXR1cm57Y2hhck1hcDpBLHN1YnRhYmxlOlUuZGF0YSxtYXhHbHlwaElEOncrMX19fSxlfSgpLGJ0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3JldHVybiBlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIEJ0KGUscHQpLGUucHJvdG90eXBlLnRhZz0iY21hcCIsZS5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oZSl7dmFyIHQsQSxyO2ZvcihlLnBvcz10aGlzLm9mZnNldCx0aGlzLnZlcnNpb249ZS5yZWFkVUludDE2KCkscj1lLnJlYWRVSW50MTYoKSx0aGlzLnRhYmxlcz1bXSx0aGlzLnVuaWNvZGU9bnVsbCxBPTA7MDw9cj9BPHI6QT5yO0E9MDw9cj8rK0E6LS1BKXQ9bmV3IHZ0KGUsdGhpcy5vZmZzZXQpLHRoaXMudGFibGVzLnB1c2godCksdC5pc1VuaWNvZGUmJm51bGw9PXRoaXMudW5pY29kZSYmKHRoaXMudW5pY29kZT10KTtyZXR1cm4hMH0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXt2YXIgQSxyO3JldHVybiBudWxsPT10JiYodD0ibWFjcm9tYW4iKSxBPXZ0LmVuY29kZShlLHQpLChyPW5ldyBndCkud3JpdGVVSW50MTYoMCksci53cml0ZVVJbnQxNigxKSxBLnRhYmxlPXIuZGF0YS5jb25jYXQoQS5zdWJ0YWJsZSksQX0sZX0oKSxDdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBCdChlLHB0KSxlLnByb3RvdHlwZS50YWc9ImhoZWEiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKGUpe3JldHVybiBlLnBvcz10aGlzLm9mZnNldCx0aGlzLnZlcnNpb249ZS5yZWFkSW50KCksdGhpcy5hc2NlbmRlcj1lLnJlYWRTaG9ydCgpLHRoaXMuZGVjZW5kZXI9ZS5yZWFkU2hvcnQoKSx0aGlzLmxpbmVHYXA9ZS5yZWFkU2hvcnQoKSx0aGlzLmFkdmFuY2VXaWR0aE1heD1lLnJlYWRTaG9ydCgpLHRoaXMubWluTGVmdFNpZGVCZWFyaW5nPWUucmVhZFNob3J0KCksdGhpcy5taW5SaWdodFNpZGVCZWFyaW5nPWUucmVhZFNob3J0KCksdGhpcy54TWF4RXh0ZW50PWUucmVhZFNob3J0KCksdGhpcy5jYXJldFNsb3BlUmlzZT1lLnJlYWRTaG9ydCgpLHRoaXMuY2FyZXRTbG9wZVJ1bj1lLnJlYWRTaG9ydCgpLHRoaXMuY2FyZXRPZmZzZXQ9ZS5yZWFkU2hvcnQoKSxlLnBvcys9OCx0aGlzLm1ldHJpY0RhdGFGb3JtYXQ9ZS5yZWFkU2hvcnQoKSx0aGlzLm51bWJlck9mTWV0cmljcz1lLnJlYWRVSW50MTYoKX0sZX0oKSxfdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBCdChlLHB0KSxlLnByb3RvdHlwZS50YWc9Ik9TLzIiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKGUpe2lmKGUucG9zPXRoaXMub2Zmc2V0LHRoaXMudmVyc2lvbj1lLnJlYWRVSW50MTYoKSx0aGlzLmF2ZXJhZ2VDaGFyV2lkdGg9ZS5yZWFkU2hvcnQoKSx0aGlzLndlaWdodENsYXNzPWUucmVhZFVJbnQxNigpLHRoaXMud2lkdGhDbGFzcz1lLnJlYWRVSW50MTYoKSx0aGlzLnR5cGU9ZS5yZWFkU2hvcnQoKSx0aGlzLnlTdWJzY3JpcHRYU2l6ZT1lLnJlYWRTaG9ydCgpLHRoaXMueVN1YnNjcmlwdFlTaXplPWUucmVhZFNob3J0KCksdGhpcy55U3Vic2NyaXB0WE9mZnNldD1lLnJlYWRTaG9ydCgpLHRoaXMueVN1YnNjcmlwdFlPZmZzZXQ9ZS5yZWFkU2hvcnQoKSx0aGlzLnlTdXBlcnNjcmlwdFhTaXplPWUucmVhZFNob3J0KCksdGhpcy55U3VwZXJzY3JpcHRZU2l6ZT1lLnJlYWRTaG9ydCgpLHRoaXMueVN1cGVyc2NyaXB0WE9mZnNldD1lLnJlYWRTaG9ydCgpLHRoaXMueVN1cGVyc2NyaXB0WU9mZnNldD1lLnJlYWRTaG9ydCgpLHRoaXMueVN0cmlrZW91dFNpemU9ZS5yZWFkU2hvcnQoKSx0aGlzLnlTdHJpa2VvdXRQb3NpdGlvbj1lLnJlYWRTaG9ydCgpLHRoaXMuZmFtaWx5Q2xhc3M9ZS5yZWFkU2hvcnQoKSx0aGlzLnBhbm9zZT1mdW5jdGlvbigpe3ZhciB0LEE7Zm9yKEE9W10sdD0wO3Q8MTA7Kyt0KUEucHVzaChlLnJlYWRCeXRlKCkpO3JldHVybiBBfSgpLHRoaXMuY2hhclJhbmdlPWZ1bmN0aW9uKCl7dmFyIHQsQTtmb3IoQT1bXSx0PTA7dDw0OysrdClBLnB1c2goZS5yZWFkSW50KCkpO3JldHVybiBBfSgpLHRoaXMudmVuZG9ySUQ9ZS5yZWFkU3RyaW5nKDQpLHRoaXMuc2VsZWN0aW9uPWUucmVhZFNob3J0KCksdGhpcy5maXJzdENoYXJJbmRleD1lLnJlYWRTaG9ydCgpLHRoaXMubGFzdENoYXJJbmRleD1lLnJlYWRTaG9ydCgpLHRoaXMudmVyc2lvbj4wJiYodGhpcy5hc2NlbnQ9ZS5yZWFkU2hvcnQoKSx0aGlzLmRlc2NlbnQ9ZS5yZWFkU2hvcnQoKSx0aGlzLmxpbmVHYXA9ZS5yZWFkU2hvcnQoKSx0aGlzLndpbkFzY2VudD1lLnJlYWRTaG9ydCgpLHRoaXMud2luRGVzY2VudD1lLnJlYWRTaG9ydCgpLHRoaXMuY29kZVBhZ2VSYW5nZT1mdW5jdGlvbigpe3ZhciB0LEE7Zm9yKEE9W10sdD0wO3Q8Mjt0PSsrdClBLnB1c2goZS5yZWFkSW50KCkpO3JldHVybiBBfSgpLHRoaXMudmVyc2lvbj4xKSlyZXR1cm4gdGhpcy54SGVpZ2h0PWUucmVhZFNob3J0KCksdGhpcy5jYXBIZWlnaHQ9ZS5yZWFkU2hvcnQoKSx0aGlzLmRlZmF1bHRDaGFyPWUucmVhZFNob3J0KCksdGhpcy5icmVha0NoYXI9ZS5yZWFkU2hvcnQoKSx0aGlzLm1heENvbnRleHQ9ZS5yZWFkU2hvcnQoKX0sZX0oKSxqdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBCdChlLHB0KSxlLnByb3RvdHlwZS50YWc9InBvc3QiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKGUpe3ZhciB0LEEscjtzd2l0Y2goZS5wb3M9dGhpcy5vZmZzZXQsdGhpcy5mb3JtYXQ9ZS5yZWFkSW50KCksdGhpcy5pdGFsaWNBbmdsZT1lLnJlYWRJbnQoKSx0aGlzLnVuZGVybGluZVBvc2l0aW9uPWUucmVhZFNob3J0KCksdGhpcy51bmRlcmxpbmVUaGlja25lc3M9ZS5yZWFkU2hvcnQoKSx0aGlzLmlzRml4ZWRQaXRjaD1lLnJlYWRJbnQoKSx0aGlzLm1pbk1lbVR5cGU0Mj1lLnJlYWRJbnQoKSx0aGlzLm1heE1lbVR5cGU0Mj1lLnJlYWRJbnQoKSx0aGlzLm1pbk1lbVR5cGUxPWUucmVhZEludCgpLHRoaXMubWF4TWVtVHlwZTE9ZS5yZWFkSW50KCksdGhpcy5mb3JtYXQpe2Nhc2UgNjU1MzY6Y2FzZSAxOTY2MDg6YnJlYWs7Y2FzZSAxMzEwNzI6dmFyIG47Zm9yKEE9ZS5yZWFkVUludDE2KCksdGhpcy5nbHlwaE5hbWVJbmRleD1bXSxuPTA7MDw9QT9uPEE6bj5BO249MDw9QT8rK246LS1uKXRoaXMuZ2x5cGhOYW1lSW5kZXgucHVzaChlLnJlYWRVSW50MTYoKSk7Zm9yKHRoaXMubmFtZXM9W10scj1bXTtlLnBvczx0aGlzLm9mZnNldCt0aGlzLmxlbmd0aDspdD1lLnJlYWRCeXRlKCksci5wdXNoKHRoaXMubmFtZXMucHVzaChlLnJlYWRTdHJpbmcodCkpKTtyZXR1cm4gcjtjYXNlIDE1MTU1MjpyZXR1cm4gQT1lLnJlYWRVSW50MTYoKSx0aGlzLm9mZnNldHM9ZS5yZWFkKEEpO2Nhc2UgMjYyMTQ0OnJldHVybiB0aGlzLm1hcD1mdW5jdGlvbigpe3ZhciB0LEEscjtmb3Iocj1bXSxuPXQ9MCxBPXRoaXMuZmlsZS5tYXhwLm51bUdseXBoczswPD1BP3Q8QTp0PkE7bj0wPD1BPysrdDotLXQpci5wdXNoKGUucmVhZFVJbnQzMigpKTtyZXR1cm4gcn0uY2FsbCh0aGlzKX19LGV9KCkseHQ9ZnVuY3Rpb24oZSx0KXt0aGlzLnJhdz1lLHRoaXMubGVuZ3RoPWUubGVuZ3RoLHRoaXMucGxhdGZvcm1JRD10LnBsYXRmb3JtSUQsdGhpcy5lbmNvZGluZ0lEPXQuZW5jb2RpbmdJRCx0aGlzLmxhbmd1YWdlSUQ9dC5sYW5ndWFnZUlEfSxGdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBCdChlLHB0KSxlLnByb3RvdHlwZS50YWc9Im5hbWUiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKGUpe3ZhciB0LEEscixuLHMsaSxvLGEsbCxjLHU7Zm9yKGUucG9zPXRoaXMub2Zmc2V0LGUucmVhZFNob3J0KCksdD1lLnJlYWRTaG9ydCgpLGk9ZS5yZWFkU2hvcnQoKSxBPVtdLG49MDswPD10P248dDpuPnQ7bj0wPD10PysrbjotLW4pQS5wdXNoKHtwbGF0Zm9ybUlEOmUucmVhZFNob3J0KCksZW5jb2RpbmdJRDplLnJlYWRTaG9ydCgpLGxhbmd1YWdlSUQ6ZS5yZWFkU2hvcnQoKSxuYW1lSUQ6ZS5yZWFkU2hvcnQoKSxsZW5ndGg6ZS5yZWFkU2hvcnQoKSxvZmZzZXQ6dGhpcy5vZmZzZXQraStlLnJlYWRTaG9ydCgpfSk7Zm9yKG89e30sbj1sPTAsYz1BLmxlbmd0aDtsPGM7bj0rK2wpcj1BW25dLGUucG9zPXIub2Zmc2V0LGE9ZS5yZWFkU3RyaW5nKHIubGVuZ3RoKSxzPW5ldyB4dChhLHIpLG51bGw9PW9bdT1yLm5hbWVJRF0mJihvW3VdPVtdKSxvW3IubmFtZUlEXS5wdXNoKHMpO3RoaXMuc3RyaW5ncz1vLHRoaXMuY29weXJpZ2h0PW9bMF0sdGhpcy5mb250RmFtaWx5PW9bMV0sdGhpcy5mb250U3ViZmFtaWx5PW9bMl0sdGhpcy51bmlxdWVTdWJmYW1pbHk9b1szXSx0aGlzLmZvbnROYW1lPW9bNF0sdGhpcy52ZXJzaW9uPW9bNV07dHJ5e3RoaXMucG9zdHNjcmlwdE5hbWU9b1s2XVswXS5yYXcucmVwbGFjZSgvW1x4MDAtXHgxOVx4ODAtXHhmZl0vZywiIil9Y2F0Y2goZSl7dGhpcy5wb3N0c2NyaXB0TmFtZT1vWzRdWzBdLnJhdy5yZXBsYWNlKC9bXHgwMC1ceDE5XHg4MC1ceGZmXS9nLCIiKX1yZXR1cm4gdGhpcy50cmFkZW1hcms9b1s3XSx0aGlzLm1hbnVmYWN0dXJlcj1vWzhdLHRoaXMuZGVzaWduZXI9b1s5XSx0aGlzLmRlc2NyaXB0aW9uPW9bMTBdLHRoaXMudmVuZG9yVXJsPW9bMTFdLHRoaXMuZGVzaWduZXJVcmw9b1sxMl0sdGhpcy5saWNlbnNlPW9bMTNdLHRoaXMubGljZW5zZVVybD1vWzE0XSx0aGlzLnByZWZlcnJlZEZhbWlseT1vWzE1XSx0aGlzLnByZWZlcnJlZFN1YmZhbWlseT1vWzE3XSx0aGlzLmNvbXBhdGlibGVGdWxsPW9bMThdLHRoaXMuc2FtcGxlVGV4dD1vWzE5XX0sZX0oKSxRdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBCdChlLHB0KSxlLnByb3RvdHlwZS50YWc9Im1heHAiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKGUpe3JldHVybiBlLnBvcz10aGlzLm9mZnNldCx0aGlzLnZlcnNpb249ZS5yZWFkSW50KCksdGhpcy5udW1HbHlwaHM9ZS5yZWFkVUludDE2KCksdGhpcy5tYXhQb2ludHM9ZS5yZWFkVUludDE2KCksdGhpcy5tYXhDb250b3Vycz1lLnJlYWRVSW50MTYoKSx0aGlzLm1heENvbXBvc2l0ZVBvaW50cz1lLnJlYWRVSW50MTYoKSx0aGlzLm1heENvbXBvbmVudENvbnRvdXJzPWUucmVhZFVJbnQxNigpLHRoaXMubWF4Wm9uZXM9ZS5yZWFkVUludDE2KCksdGhpcy5tYXhUd2lsaWdodFBvaW50cz1lLnJlYWRVSW50MTYoKSx0aGlzLm1heFN0b3JhZ2U9ZS5yZWFkVUludDE2KCksdGhpcy5tYXhGdW5jdGlvbkRlZnM9ZS5yZWFkVUludDE2KCksdGhpcy5tYXhJbnN0cnVjdGlvbkRlZnM9ZS5yZWFkVUludDE2KCksdGhpcy5tYXhTdGFja0VsZW1lbnRzPWUucmVhZFVJbnQxNigpLHRoaXMubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zPWUucmVhZFVJbnQxNigpLHRoaXMubWF4Q29tcG9uZW50RWxlbWVudHM9ZS5yZWFkVUludDE2KCksdGhpcy5tYXhDb21wb25lbnREZXB0aD1lLnJlYWRVSW50MTYoKX0sZX0oKSxVdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBCdChlLHB0KSxlLnByb3RvdHlwZS50YWc9ImhtdHgiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKGUpe3ZhciB0LEEscixuLHMsaSxvO2ZvcihlLnBvcz10aGlzLm9mZnNldCx0aGlzLm1ldHJpY3M9W10sdD0wLGk9dGhpcy5maWxlLmhoZWEubnVtYmVyT2ZNZXRyaWNzOzA8PWk/dDxpOnQ+aTt0PTA8PWk/Kyt0Oi0tdCl0aGlzLm1ldHJpY3MucHVzaCh7YWR2YW5jZTplLnJlYWRVSW50MTYoKSxsc2I6ZS5yZWFkSW50MTYoKX0pO2ZvcihyPXRoaXMuZmlsZS5tYXhwLm51bUdseXBocy10aGlzLmZpbGUuaGhlYS5udW1iZXJPZk1ldHJpY3MsdGhpcy5sZWZ0U2lkZUJlYXJpbmdzPWZ1bmN0aW9uKCl7dmFyIEEsbjtmb3Iobj1bXSx0PUE9MDswPD1yP0E8cjpBPnI7dD0wPD1yPysrQTotLUEpbi5wdXNoKGUucmVhZEludDE2KCkpO3JldHVybiBufSgpLHRoaXMud2lkdGhzPWZ1bmN0aW9uKCl7dmFyIGUsdCxBLHI7Zm9yKHI9W10sZT0wLHQ9KEE9dGhpcy5tZXRyaWNzKS5sZW5ndGg7ZTx0O2UrKyluPUFbZV0sci5wdXNoKG4uYWR2YW5jZSk7cmV0dXJuIHJ9LmNhbGwodGhpcyksQT10aGlzLndpZHRoc1t0aGlzLndpZHRocy5sZW5ndGgtMV0sbz1bXSx0PXM9MDswPD1yP3M8cjpzPnI7dD0wPD1yPysrczotLXMpby5wdXNoKHRoaXMud2lkdGhzLnB1c2goQSkpO3JldHVybiBvfSxlLnByb3RvdHlwZS5mb3JHbHlwaD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbiB0aGlzLm1ldHJpY3M/dGhpcy5tZXRyaWNzW2VdOnthZHZhbmNlOnRoaXMubWV0cmljc1t0aGlzLm1ldHJpY3MubGVuZ3RoLTFdLmFkdmFuY2UsbHNiOnRoaXMubGVmdFNpZGVCZWFyaW5nc1tlLXRoaXMubWV0cmljcy5sZW5ndGhdfX0sZX0oKSxFdD1bXS5zbGljZSxTdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBCdChlLHB0KSxlLnByb3RvdHlwZS50YWc9ImdseWYiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FjaGU9e319LGUucHJvdG90eXBlLmdseXBoRm9yPWZ1bmN0aW9uKGUpe3ZhciB0LEEscixuLHMsaSxvLGEsbCxjO3JldHVybiBlIGluIHRoaXMuY2FjaGU/dGhpcy5jYWNoZVtlXToobj10aGlzLmZpbGUubG9jYSx0PXRoaXMuZmlsZS5jb250ZW50cyxBPW4uaW5kZXhPZihlKSwwPT09KHI9bi5sZW5ndGhPZihlKSk/dGhpcy5jYWNoZVtlXT1udWxsOih0LnBvcz10aGlzLm9mZnNldCtBLHM9KGk9bmV3IGd0KHQucmVhZChyKSkpLnJlYWRTaG9ydCgpLGE9aS5yZWFkU2hvcnQoKSxjPWkucmVhZFNob3J0KCksbz1pLnJlYWRTaG9ydCgpLGw9aS5yZWFkU2hvcnQoKSx0aGlzLmNhY2hlW2VdPS0xPT09cz9uZXcgSXQoaSxhLGMsbyxsKTpuZXcgTHQoaSxzLGEsYyxvLGwpLHRoaXMuY2FjaGVbZV0pKX0sZS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCxBKXt2YXIgcixuLHMsaSxvO2ZvcihzPVtdLG49W10saT0wLG89dC5sZW5ndGg7aTxvO2krKylyPWVbdFtpXV0sbi5wdXNoKHMubGVuZ3RoKSxyJiYocz1zLmNvbmNhdChyLmVuY29kZShBKSkpO3JldHVybiBuLnB1c2gocy5sZW5ndGgpLHt0YWJsZTpzLG9mZnNldHM6bn19LGV9KCksTHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxBLHIsbixzKXt0aGlzLnJhdz1lLHRoaXMubnVtYmVyT2ZDb250b3Vycz10LHRoaXMueE1pbj1BLHRoaXMueU1pbj1yLHRoaXMueE1heD1uLHRoaXMueU1heD1zLHRoaXMuY29tcG91bmQ9ITF9cmV0dXJuIGUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJhdy5kYXRhfSxlfSgpLEl0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQsQSxyLG4pe3ZhciBzLGk7Zm9yKHRoaXMucmF3PWUsdGhpcy54TWluPXQsdGhpcy55TWluPUEsdGhpcy54TWF4PXIsdGhpcy55TWF4PW4sdGhpcy5jb21wb3VuZD0hMCx0aGlzLmdseXBoSURzPVtdLHRoaXMuZ2x5cGhPZmZzZXRzPVtdLHM9dGhpcy5yYXc7aT1zLnJlYWRTaG9ydCgpLHRoaXMuZ2x5cGhPZmZzZXRzLnB1c2gocy5wb3MpLHRoaXMuZ2x5cGhJRHMucHVzaChzLnJlYWRVSW50MTYoKSksMzImaTspcy5wb3MrPTEmaT80OjIsMTI4Jmk/cy5wb3MrPTg6NjQmaT9zLnBvcys9NDo4JmkmJihzLnBvcys9Mil9cmV0dXJuIGUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbigpe3ZhciBlLHQsQTtmb3IodD1uZXcgZ3QoRXQuY2FsbCh0aGlzLnJhdy5kYXRhKSksZT0wLEE9dGhpcy5nbHlwaElEcy5sZW5ndGg7ZTxBOysrZSl0LnBvcz10aGlzLmdseXBoT2Zmc2V0c1tlXTtyZXR1cm4gdC5kYXRhfSxlfSgpLE50PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3JldHVybiBlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIEJ0KGUscHQpLGUucHJvdG90eXBlLnRhZz0ibG9jYSIsZS5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oZSl7dmFyIHQsQTtyZXR1cm4gZS5wb3M9dGhpcy5vZmZzZXQsdD10aGlzLmZpbGUuaGVhZC5pbmRleFRvTG9jRm9ybWF0LHRoaXMub2Zmc2V0cz0wPT09dD9mdW5jdGlvbigpe3ZhciB0LHI7Zm9yKHI9W10sQT0wLHQ9dGhpcy5sZW5ndGg7QTx0O0ErPTIpci5wdXNoKDIqZS5yZWFkVUludDE2KCkpO3JldHVybiByfS5jYWxsKHRoaXMpOmZ1bmN0aW9uKCl7dmFyIHQscjtmb3Iocj1bXSxBPTAsdD10aGlzLmxlbmd0aDtBPHQ7QSs9NClyLnB1c2goZS5yZWFkVUludDMyKCkpO3JldHVybiByfS5jYWxsKHRoaXMpfSxlLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9mZnNldHNbZV19LGUucHJvdG90eXBlLmxlbmd0aE9mPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9mZnNldHNbZSsxXS10aGlzLm9mZnNldHNbZV19LGUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgQT1uZXcgVWludDMyQXJyYXkodGhpcy5vZmZzZXRzLmxlbmd0aCkscj0wLG49MCxzPTA7czxBLmxlbmd0aDsrK3MpaWYoQVtzXT1yLG48dC5sZW5ndGgmJnRbbl09PXMpeysrbixBW3NdPXI7dmFyIGk9dGhpcy5vZmZzZXRzW3NdLG89dGhpcy5vZmZzZXRzW3MrMV0taTtvPjAmJihyKz1vKX1mb3IodmFyIGE9bmV3IEFycmF5KDQqQS5sZW5ndGgpLGw9MDtsPEEubGVuZ3RoOysrbClhWzQqbCszXT0yNTUmQVtsXSxhWzQqbCsyXT0oNjUyODAmQVtsXSk+PjgsYVs0KmwrMV09KDE2NzExNjgwJkFbbF0pPj4xNixhWzQqbF09KDQyNzgxOTAwODAmQVtsXSk+PjI0O3JldHVybiBhfSxlfSgpLGt0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLmZvbnQ9ZSx0aGlzLnN1YnNldD17fSx0aGlzLnVuaWNvZGVzPXt9LHRoaXMubmV4dD0zM31yZXR1cm4gZS5wcm90b3R5cGUuZ2VuZXJhdGVDbWFwPWZ1bmN0aW9uKCl7dmFyIGUsdCxBLHIsbjtmb3IodCBpbiByPXRoaXMuZm9udC5jbWFwLnRhYmxlc1swXS5jb2RlTWFwLGU9e30sbj10aGlzLnN1YnNldClBPW5bdF0sZVt0XT1yW0FdO3JldHVybiBlfSxlLnByb3RvdHlwZS5nbHlwaHNGb3I9ZnVuY3Rpb24oZSl7dmFyIHQsQSxyLG4scyxpLG87Zm9yKHI9e30scz0wLGk9ZS5sZW5ndGg7czxpO3MrKylyW249ZVtzXV09dGhpcy5mb250LmdseWYuZ2x5cGhGb3Iobik7Zm9yKG4gaW4gdD1bXSxyKShudWxsIT0oQT1yW25dKT9BLmNvbXBvdW5kOnZvaWQgMCkmJnQucHVzaC5hcHBseSh0LEEuZ2x5cGhJRHMpO2lmKHQubGVuZ3RoPjApZm9yKG4gaW4gbz10aGlzLmdseXBoc0Zvcih0KSlBPW9bbl0scltuXT1BO3JldHVybiByfSxlLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXt2YXIgQSxyLG4scyxpLG8sYSxsLGMsdSxoLGQsZixwLGc7Zm9yKHIgaW4gQT1idC5lbmNvZGUodGhpcy5nZW5lcmF0ZUNtYXAoKSwidW5pY29kZSIpLHM9dGhpcy5nbHlwaHNGb3IoZSksaD17MDowfSxnPUEuY2hhck1hcCloWyhvPWdbcl0pLm9sZF09by5uZXc7Zm9yKGQgaW4gdT1BLm1heEdseXBoSUQscylkIGluIGh8fChoW2RdPXUrKyk7cmV0dXJuIGw9ZnVuY3Rpb24oZSl7dmFyIHQsQTtmb3IodCBpbiBBPXt9LGUpQVtlW3RdXT10O3JldHVybiBBfShoKSxjPU9iamVjdC5rZXlzKGwpLnNvcnQoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS10fSksZj1mdW5jdGlvbigpe3ZhciBlLHQsQTtmb3IoQT1bXSxlPTAsdD1jLmxlbmd0aDtlPHQ7ZSsrKWk9Y1tlXSxBLnB1c2gobFtpXSk7cmV0dXJuIEF9KCksbj10aGlzLmZvbnQuZ2x5Zi5lbmNvZGUocyxmLGgpLGE9dGhpcy5mb250LmxvY2EuZW5jb2RlKG4ub2Zmc2V0cyxmKSxwPXtjbWFwOnRoaXMuZm9udC5jbWFwLnJhdygpLGdseWY6bi50YWJsZSxsb2NhOmEsaG10eDp0aGlzLmZvbnQuaG10eC5yYXcoKSxoaGVhOnRoaXMuZm9udC5oaGVhLnJhdygpLG1heHA6dGhpcy5mb250Lm1heHAucmF3KCkscG9zdDp0aGlzLmZvbnQucG9zdC5yYXcoKSxuYW1lOnRoaXMuZm9udC5uYW1lLnJhdygpLGhlYWQ6dGhpcy5mb250LmhlYWQuZW5jb2RlKHQpfSx0aGlzLmZvbnQub3MyLmV4aXN0cyYmKHBbIk9TLzIiXT10aGlzLmZvbnQub3MyLnJhdygpKSx0aGlzLmZvbnQuZGlyZWN0b3J5LmVuY29kZShwKX0sZX0oKTtNLkFQSS5QREZPYmplY3Q9ZnVuY3Rpb24oKXt2YXIgZTtmdW5jdGlvbiB0KCl7fXJldHVybiBlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKEFycmF5KHQrMSkuam9pbigiMCIpK2UpLnNsaWNlKC10KX0sdC5jb252ZXJ0PWZ1bmN0aW9uKEEpe3ZhciByLG4scyxpO2lmKEFycmF5LmlzQXJyYXkoQSkpcmV0dXJuIlsiK2Z1bmN0aW9uKCl7dmFyIGUsbixzO2ZvcihzPVtdLGU9MCxuPUEubGVuZ3RoO2U8bjtlKyspcj1BW2VdLHMucHVzaCh0LmNvbnZlcnQocikpO3JldHVybiBzfSgpLmpvaW4oIiAiKSsiXSI7aWYoInN0cmluZyI9PXR5cGVvZiBBKXJldHVybiIvIitBO2lmKG51bGwhPUE/QS5pc1N0cmluZzp2b2lkIDApcmV0dXJuIigiK0ErIikiO2lmKEEgaW5zdGFuY2VvZiBEYXRlKXJldHVybiIoRDoiK2UoQS5nZXRVVENGdWxsWWVhcigpLDQpK2UoQS5nZXRVVENNb250aCgpLDIpK2UoQS5nZXRVVENEYXRlKCksMikrZShBLmdldFVUQ0hvdXJzKCksMikrZShBLmdldFVUQ01pbnV0ZXMoKSwyKStlKEEuZ2V0VVRDU2Vjb25kcygpLDIpKyJaKSI7aWYoIltvYmplY3QgT2JqZWN0XSI9PT17fS50b1N0cmluZy5jYWxsKEEpKXtmb3IobiBpbiBzPVsiPDwiXSxBKWk9QVtuXSxzLnB1c2goIi8iK24rIiAiK3QuY29udmVydChpKSk7cmV0dXJuIHMucHVzaCgiPj4iKSxzLmpvaW4oIlxuIil9cmV0dXJuIiIrQX0sdH0oKX0sIi4vbm9kZV9tb2R1bGVzL3Bha28vZGlzdC9wYWtvLmVzbS5tanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtsZXQgdD1lLmxlbmd0aDtmb3IoOy0tdD49MDspZVt0XT0wfUEucih0KSxBLmQodCx7RGVmbGF0ZTpmdW5jdGlvbigpe3JldHVybiBiQX0sSW5mbGF0ZTpmdW5jdGlvbigpe3JldHVybiB4QX0sY29uc3RhbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIEVBfSxkZWZhdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIFNBfSxkZWZsYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIENBfSxkZWZsYXRlUmF3OmZ1bmN0aW9uKCl7cmV0dXJuIF9BfSxnemlwOmZ1bmN0aW9uKCl7cmV0dXJuIGpBfSxpbmZsYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIEZBfSxpbmZsYXRlUmF3OmZ1bmN0aW9uKCl7cmV0dXJuIFFBfSx1bmd6aXA6ZnVuY3Rpb24oKXtyZXR1cm4gVUF9fSk7Y29uc3Qgbj1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXSkscz1uZXcgVWludDhBcnJheShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10pLGk9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddKSxvPW5ldyBVaW50OEFycmF5KFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksYT1uZXcgQXJyYXkoNTc2KTtyKGEpO2NvbnN0IGw9bmV3IEFycmF5KDYwKTtyKGwpO2NvbnN0IGM9bmV3IEFycmF5KDUxMik7cihjKTtjb25zdCB1PW5ldyBBcnJheSgyNTYpO3IodSk7Y29uc3QgaD1uZXcgQXJyYXkoMjkpO3IoaCk7Y29uc3QgZD1uZXcgQXJyYXkoMzApO2Z1bmN0aW9uIGYoZSx0LEEscixuKXt0aGlzLnN0YXRpY190cmVlPWUsdGhpcy5leHRyYV9iaXRzPXQsdGhpcy5leHRyYV9iYXNlPUEsdGhpcy5lbGVtcz1yLHRoaXMubWF4X2xlbmd0aD1uLHRoaXMuaGFzX3N0cmVlPWUmJmUubGVuZ3RofWxldCBwLGcsbTtmdW5jdGlvbiB3KGUsdCl7dGhpcy5keW5fdHJlZT1lLHRoaXMubWF4X2NvZGU9MCx0aGlzLnN0YXRfZGVzYz10fXIoZCk7Y29uc3QgQj1lPT5lPDI1Nj9jW2VdOmNbMjU2KyhlPj4+NyldLHk9KGUsdCk9PntlLnBlbmRpbmdfYnVmW2UucGVuZGluZysrXT0yNTUmdCxlLnBlbmRpbmdfYnVmW2UucGVuZGluZysrXT10Pj4+OCYyNTV9LHY9KGUsdCxBKT0+e2UuYmlfdmFsaWQ+MTYtQT8oZS5iaV9idWZ8PXQ8PGUuYmlfdmFsaWQmNjU1MzUseShlLGUuYmlfYnVmKSxlLmJpX2J1Zj10Pj4xNi1lLmJpX3ZhbGlkLGUuYmlfdmFsaWQrPUEtMTYpOihlLmJpX2J1Znw9dDw8ZS5iaV92YWxpZCY2NTUzNSxlLmJpX3ZhbGlkKz1BKX0sYj0oZSx0LEEpPT57dihlLEFbMip0XSxBWzIqdCsxXSl9LEM9KGUsdCk9PntsZXQgQT0wO2Rve0F8PTEmZSxlPj4+PTEsQTw8PTF9d2hpbGUoLS10PjApO3JldHVybiBBPj4+MX0sXz0oZSx0LEEpPT57Y29uc3Qgcj1uZXcgQXJyYXkoMTYpO2xldCBuLHMsaT0wO2ZvcihuPTE7bjw9MTU7bisrKWk9aStBW24tMV08PDEscltuXT1pO2ZvcihzPTA7czw9dDtzKyspe2xldCB0PWVbMipzKzFdOzAhPT10JiYoZVsyKnNdPUMoclt0XSsrLHQpKX19LGo9ZT0+e2xldCB0O2Zvcih0PTA7dDwyODY7dCsrKWUuZHluX2x0cmVlWzIqdF09MDtmb3IodD0wO3Q8MzA7dCsrKWUuZHluX2R0cmVlWzIqdF09MDtmb3IodD0wO3Q8MTk7dCsrKWUuYmxfdHJlZVsyKnRdPTA7ZS5keW5fbHRyZWVbNTEyXT0xLGUub3B0X2xlbj1lLnN0YXRpY19sZW49MCxlLnN5bV9uZXh0PWUubWF0Y2hlcz0wfSx4PWU9PntlLmJpX3ZhbGlkPjg/eShlLGUuYmlfYnVmKTplLmJpX3ZhbGlkPjAmJihlLnBlbmRpbmdfYnVmW2UucGVuZGluZysrXT1lLmJpX2J1ZiksZS5iaV9idWY9MCxlLmJpX3ZhbGlkPTB9LEY9KGUsdCxBLHIpPT57Y29uc3Qgbj0yKnQscz0yKkE7cmV0dXJuIGVbbl08ZVtzXXx8ZVtuXT09PWVbc10mJnJbdF08PXJbQV19LFE9KGUsdCxBKT0+e2NvbnN0IHI9ZS5oZWFwW0FdO2xldCBuPUE8PDE7Zm9yKDtuPD1lLmhlYXBfbGVuJiYobjxlLmhlYXBfbGVuJiZGKHQsZS5oZWFwW24rMV0sZS5oZWFwW25dLGUuZGVwdGgpJiZuKyssIUYodCxyLGUuaGVhcFtuXSxlLmRlcHRoKSk7KWUuaGVhcFtBXT1lLmhlYXBbbl0sQT1uLG48PD0xO2UuaGVhcFtBXT1yfSxVPShlLHQsQSk9PntsZXQgcixpLG8sYSxsPTA7aWYoMCE9PWUuc3ltX25leHQpZG97cj0yNTUmZS5wZW5kaW5nX2J1ZltlLnN5bV9idWYrbCsrXSxyKz0oMjU1JmUucGVuZGluZ19idWZbZS5zeW1fYnVmK2wrK10pPDw4LGk9ZS5wZW5kaW5nX2J1ZltlLnN5bV9idWYrbCsrXSwwPT09cj9iKGUsaSx0KToobz11W2ldLGIoZSxvKzI1NisxLHQpLGE9bltvXSwwIT09YSYmKGktPWhbb10sdihlLGksYSkpLHItLSxvPUIociksYihlLG8sQSksYT1zW29dLDAhPT1hJiYoci09ZFtvXSx2KGUscixhKSkpfXdoaWxlKGw8ZS5zeW1fbmV4dCk7YihlLDI1Nix0KX0sRT0oZSx0KT0+e2NvbnN0IEE9dC5keW5fdHJlZSxyPXQuc3RhdF9kZXNjLnN0YXRpY190cmVlLG49dC5zdGF0X2Rlc2MuaGFzX3N0cmVlLHM9dC5zdGF0X2Rlc2MuZWxlbXM7bGV0IGksbyxhLGw9LTE7Zm9yKGUuaGVhcF9sZW49MCxlLmhlYXBfbWF4PTU3MyxpPTA7aTxzO2krKykwIT09QVsyKmldPyhlLmhlYXBbKytlLmhlYXBfbGVuXT1sPWksZS5kZXB0aFtpXT0wKTpBWzIqaSsxXT0wO2Zvcig7ZS5oZWFwX2xlbjwyOylhPWUuaGVhcFsrK2UuaGVhcF9sZW5dPWw8Mj8rK2w6MCxBWzIqYV09MSxlLmRlcHRoW2FdPTAsZS5vcHRfbGVuLS0sbiYmKGUuc3RhdGljX2xlbi09clsyKmErMV0pO2Zvcih0Lm1heF9jb2RlPWwsaT1lLmhlYXBfbGVuPj4xO2k+PTE7aS0tKVEoZSxBLGkpO2E9cztkb3tpPWUuaGVhcFsxXSxlLmhlYXBbMV09ZS5oZWFwW2UuaGVhcF9sZW4tLV0sUShlLEEsMSksbz1lLmhlYXBbMV0sZS5oZWFwWy0tZS5oZWFwX21heF09aSxlLmhlYXBbLS1lLmhlYXBfbWF4XT1vLEFbMiphXT1BWzIqaV0rQVsyKm9dLGUuZGVwdGhbYV09KGUuZGVwdGhbaV0+PWUuZGVwdGhbb10/ZS5kZXB0aFtpXTplLmRlcHRoW29dKSsxLEFbMippKzFdPUFbMipvKzFdPWEsZS5oZWFwWzFdPWErKyxRKGUsQSwxKX13aGlsZShlLmhlYXBfbGVuPj0yKTtlLmhlYXBbLS1lLmhlYXBfbWF4XT1lLmhlYXBbMV0sKChlLHQpPT57Y29uc3QgQT10LmR5bl90cmVlLHI9dC5tYXhfY29kZSxuPXQuc3RhdF9kZXNjLnN0YXRpY190cmVlLHM9dC5zdGF0X2Rlc2MuaGFzX3N0cmVlLGk9dC5zdGF0X2Rlc2MuZXh0cmFfYml0cyxvPXQuc3RhdF9kZXNjLmV4dHJhX2Jhc2UsYT10LnN0YXRfZGVzYy5tYXhfbGVuZ3RoO2xldCBsLGMsdSxoLGQsZixwPTA7Zm9yKGg9MDtoPD0xNTtoKyspZS5ibF9jb3VudFtoXT0wO2ZvcihBWzIqZS5oZWFwW2UuaGVhcF9tYXhdKzFdPTAsbD1lLmhlYXBfbWF4KzE7bDw1NzM7bCsrKWM9ZS5oZWFwW2xdLGg9QVsyKkFbMipjKzFdKzFdKzEsaD5hJiYoaD1hLHArKyksQVsyKmMrMV09aCxjPnJ8fChlLmJsX2NvdW50W2hdKyssZD0wLGM+PW8mJihkPWlbYy1vXSksZj1BWzIqY10sZS5vcHRfbGVuKz1mKihoK2QpLHMmJihlLnN0YXRpY19sZW4rPWYqKG5bMipjKzFdK2QpKSk7aWYoMCE9PXApe2Rve2ZvcihoPWEtMTswPT09ZS5ibF9jb3VudFtoXTspaC0tO2UuYmxfY291bnRbaF0tLSxlLmJsX2NvdW50W2grMV0rPTIsZS5ibF9jb3VudFthXS0tLHAtPTJ9d2hpbGUocD4wKTtmb3IoaD1hOzAhPT1oO2gtLSlmb3IoYz1lLmJsX2NvdW50W2hdOzAhPT1jOyl1PWUuaGVhcFstLWxdLHU+cnx8KEFbMip1KzFdIT09aCYmKGUub3B0X2xlbis9KGgtQVsyKnUrMV0pKkFbMip1XSxBWzIqdSsxXT1oKSxjLS0pfX0pKGUsdCksXyhBLGwsZS5ibF9jb3VudCl9LFM9KGUsdCxBKT0+e2xldCByLG4scz0tMSxpPXRbMV0sbz0wLGE9NyxsPTQ7Zm9yKDA9PT1pJiYoYT0xMzgsbD0zKSx0WzIqKEErMSkrMV09NjU1MzUscj0wO3I8PUE7cisrKW49aSxpPXRbMioocisxKSsxXSwrK288YSYmbj09PWl8fChvPGw/ZS5ibF90cmVlWzIqbl0rPW86MCE9PW4/KG4hPT1zJiZlLmJsX3RyZWVbMipuXSsrLGUuYmxfdHJlZVszMl0rKyk6bzw9MTA/ZS5ibF90cmVlWzM0XSsrOmUuYmxfdHJlZVszNl0rKyxvPTAscz1uLDA9PT1pPyhhPTEzOCxsPTMpOm49PT1pPyhhPTYsbD0zKTooYT03LGw9NCkpfSxMPShlLHQsQSk9PntsZXQgcixuLHM9LTEsaT10WzFdLG89MCxhPTcsbD00O2ZvcigwPT09aSYmKGE9MTM4LGw9Mykscj0wO3I8PUE7cisrKWlmKG49aSxpPXRbMioocisxKSsxXSwhKCsrbzxhJiZuPT09aSkpe2lmKG88bClkb3tiKGUsbixlLmJsX3RyZWUpfXdoaWxlKDAhPT0tLW8pO2Vsc2UgMCE9PW4/KG4hPT1zJiYoYihlLG4sZS5ibF90cmVlKSxvLS0pLGIoZSwxNixlLmJsX3RyZWUpLHYoZSxvLTMsMikpOm88PTEwPyhiKGUsMTcsZS5ibF90cmVlKSx2KGUsby0zLDMpKTooYihlLDE4LGUuYmxfdHJlZSksdihlLG8tMTEsNykpO289MCxzPW4sMD09PWk/KGE9MTM4LGw9Myk6bj09PWk/KGE9NixsPTMpOihhPTcsbD00KX19O2xldCBJPSExO2NvbnN0IE49KGUsdCxBLHIpPT57dihlLDArKHI/MTowKSwzKSx4KGUpLHkoZSxBKSx5KGUsfkEpLEEmJmUucGVuZGluZ19idWYuc2V0KGUud2luZG93LnN1YmFycmF5KHQsdCtBKSxlLnBlbmRpbmcpLGUucGVuZGluZys9QX07dmFyIGs9e190cl9pbml0OmU9PntJfHwoKCgpPT57bGV0IGUsdCxBLHIsbztjb25zdCB3PW5ldyBBcnJheSgxNik7Zm9yKEE9MCxyPTA7cjwyODtyKyspZm9yKGhbcl09QSxlPTA7ZTwxPDxuW3JdO2UrKyl1W0ErK109cjtmb3IodVtBLTFdPXIsbz0wLHI9MDtyPDE2O3IrKylmb3IoZFtyXT1vLGU9MDtlPDE8PHNbcl07ZSsrKWNbbysrXT1yO2ZvcihvPj49NztyPDMwO3IrKylmb3IoZFtyXT1vPDw3LGU9MDtlPDE8PHNbcl0tNztlKyspY1syNTYrbysrXT1yO2Zvcih0PTA7dDw9MTU7dCsrKXdbdF09MDtmb3IoZT0wO2U8PTE0MzspYVsyKmUrMV09OCxlKyssd1s4XSsrO2Zvcig7ZTw9MjU1OylhWzIqZSsxXT05LGUrKyx3WzldKys7Zm9yKDtlPD0yNzk7KWFbMiplKzFdPTcsZSsrLHdbN10rKztmb3IoO2U8PTI4NzspYVsyKmUrMV09OCxlKyssd1s4XSsrO2ZvcihfKGEsMjg3LHcpLGU9MDtlPDMwO2UrKylsWzIqZSsxXT01LGxbMiplXT1DKGUsNSk7cD1uZXcgZihhLG4sMjU3LDI4NiwxNSksZz1uZXcgZihsLHMsMCwzMCwxNSksbT1uZXcgZihuZXcgQXJyYXkoMCksaSwwLDE5LDcpfSkoKSxJPSEwKSxlLmxfZGVzYz1uZXcgdyhlLmR5bl9sdHJlZSxwKSxlLmRfZGVzYz1uZXcgdyhlLmR5bl9kdHJlZSxnKSxlLmJsX2Rlc2M9bmV3IHcoZS5ibF90cmVlLG0pLGUuYmlfYnVmPTAsZS5iaV92YWxpZD0wLGooZSl9LF90cl9zdG9yZWRfYmxvY2s6TixfdHJfZmx1c2hfYmxvY2s6KGUsdCxBLHIpPT57bGV0IG4scyxpPTA7ZS5sZXZlbD4wPygyPT09ZS5zdHJtLmRhdGFfdHlwZSYmKGUuc3RybS5kYXRhX3R5cGU9KGU9PntsZXQgdCxBPTQwOTM2MjQ0NDc7Zm9yKHQ9MDt0PD0zMTt0KyssQT4+Pj0xKWlmKDEmQSYmMCE9PWUuZHluX2x0cmVlWzIqdF0pcmV0dXJuIDA7aWYoMCE9PWUuZHluX2x0cmVlWzE4XXx8MCE9PWUuZHluX2x0cmVlWzIwXXx8MCE9PWUuZHluX2x0cmVlWzI2XSlyZXR1cm4gMTtmb3IodD0zMjt0PDI1Njt0KyspaWYoMCE9PWUuZHluX2x0cmVlWzIqdF0pcmV0dXJuIDE7cmV0dXJuIDB9KShlKSksRShlLGUubF9kZXNjKSxFKGUsZS5kX2Rlc2MpLGk9KGU9PntsZXQgdDtmb3IoUyhlLGUuZHluX2x0cmVlLGUubF9kZXNjLm1heF9jb2RlKSxTKGUsZS5keW5fZHRyZWUsZS5kX2Rlc2MubWF4X2NvZGUpLEUoZSxlLmJsX2Rlc2MpLHQ9MTg7dD49MyYmMD09PWUuYmxfdHJlZVsyKm9bdF0rMV07dC0tKTtyZXR1cm4gZS5vcHRfbGVuKz0zKih0KzEpKzUrNSs0LHR9KShlKSxuPWUub3B0X2xlbiszKzc+Pj4zLHM9ZS5zdGF0aWNfbGVuKzMrNz4+PjMsczw9biYmKG49cykpOm49cz1BKzUsQSs0PD1uJiYtMSE9PXQ/TihlLHQsQSxyKTo0PT09ZS5zdHJhdGVneXx8cz09PW4/KHYoZSwyKyhyPzE6MCksMyksVShlLGEsbCkpOih2KGUsNCsocj8xOjApLDMpLCgoZSx0LEEscik9PntsZXQgbjtmb3IodihlLHQtMjU3LDUpLHYoZSxBLTEsNSksdihlLHItNCw0KSxuPTA7bjxyO24rKyl2KGUsZS5ibF90cmVlWzIqb1tuXSsxXSwzKTtMKGUsZS5keW5fbHRyZWUsdC0xKSxMKGUsZS5keW5fZHRyZWUsQS0xKX0pKGUsZS5sX2Rlc2MubWF4X2NvZGUrMSxlLmRfZGVzYy5tYXhfY29kZSsxLGkrMSksVShlLGUuZHluX2x0cmVlLGUuZHluX2R0cmVlKSksaihlKSxyJiZ4KGUpfSxfdHJfdGFsbHk6KGUsdCxBKT0+KGUucGVuZGluZ19idWZbZS5zeW1fYnVmK2Uuc3ltX25leHQrK109dCxlLnBlbmRpbmdfYnVmW2Uuc3ltX2J1ZitlLnN5bV9uZXh0KytdPXQ+PjgsZS5wZW5kaW5nX2J1ZltlLnN5bV9idWYrZS5zeW1fbmV4dCsrXT1BLDA9PT10P2UuZHluX2x0cmVlWzIqQV0rKzooZS5tYXRjaGVzKyssdC0tLGUuZHluX2x0cmVlWzIqKHVbQV0rMjU2KzEpXSsrLGUuZHluX2R0cmVlWzIqQih0KV0rKyksZS5zeW1fbmV4dD09PWUuc3ltX2VuZCksX3RyX2FsaWduOmU9Pnt2KGUsMiwzKSxiKGUsMjU2LGEpLChlPT57MTY9PT1lLmJpX3ZhbGlkPyh5KGUsZS5iaV9idWYpLGUuYmlfYnVmPTAsZS5iaV92YWxpZD0wKTplLmJpX3ZhbGlkPj04JiYoZS5wZW5kaW5nX2J1ZltlLnBlbmRpbmcrK109MjU1JmUuYmlfYnVmLGUuYmlfYnVmPj49OCxlLmJpX3ZhbGlkLT04KX0pKGUpfX0sSD0oZSx0LEEscik9PntsZXQgbj02NTUzNSZlLHM9ZT4+PjE2JjY1NTM1LGk9MDtmb3IoOzAhPT1BOyl7aT1BPjJlMz8yZTM6QSxBLT1pO2Rve249bit0W3IrK118MCxzPXMrbnwwfXdoaWxlKC0taSk7biU9NjU1MjEscyU9NjU1MjF9cmV0dXJuIG58czw8MTZ9O2NvbnN0IFA9bmV3IFVpbnQzMkFycmF5KCgoKT0+e2xldCBlLHQ9W107Zm9yKHZhciBBPTA7QTwyNTY7QSsrKXtlPUE7Zm9yKHZhciByPTA7cjw4O3IrKyllPTEmZT8zOTg4MjkyMzg0XmU+Pj4xOmU+Pj4xO3RbQV09ZX1yZXR1cm4gdH0pKCkpO3ZhciBUPShlLHQsQSxyKT0+e2NvbnN0IG49UCxzPXIrQTtlXj0tMTtmb3IobGV0IEE9cjtBPHM7QSsrKWU9ZT4+PjheblsyNTUmKGVedFtBXSldO3JldHVybi0xXmV9LE89ezI6Im5lZWQgZGljdGlvbmFyeSIsMToic3RyZWFtIGVuZCIsMDoiIiwiLTEiOiJmaWxlIGVycm9yIiwiLTIiOiJzdHJlYW0gZXJyb3IiLCItMyI6ImRhdGEgZXJyb3IiLCItNCI6Imluc3VmZmljaWVudCBtZW1vcnkiLCItNSI6ImJ1ZmZlciBlcnJvciIsIi02IjoiaW5jb21wYXRpYmxlIHZlcnNpb24ifSxNPXtaX05PX0ZMVVNIOjAsWl9QQVJUSUFMX0ZMVVNIOjEsWl9TWU5DX0ZMVVNIOjIsWl9GVUxMX0ZMVVNIOjMsWl9GSU5JU0g6NCxaX0JMT0NLOjUsWl9UUkVFUzo2LFpfT0s6MCxaX1NUUkVBTV9FTkQ6MSxaX05FRURfRElDVDoyLFpfRVJSTk86LTEsWl9TVFJFQU1fRVJST1I6LTIsWl9EQVRBX0VSUk9SOi0zLFpfTUVNX0VSUk9SOi00LFpfQlVGX0VSUk9SOi01LFpfTk9fQ09NUFJFU1NJT046MCxaX0JFU1RfU1BFRUQ6MSxaX0JFU1RfQ09NUFJFU1NJT046OSxaX0RFRkFVTFRfQ09NUFJFU1NJT046LTEsWl9GSUxURVJFRDoxLFpfSFVGRk1BTl9PTkxZOjIsWl9STEU6MyxaX0ZJWEVEOjQsWl9ERUZBVUxUX1NUUkFURUdZOjAsWl9CSU5BUlk6MCxaX1RFWFQ6MSxaX1VOS05PV046MixaX0RFRkxBVEVEOjh9O2NvbnN0e190cl9pbml0OkQsX3RyX3N0b3JlZF9ibG9jazpSLF90cl9mbHVzaF9ibG9jazpLLF90cl90YWxseTpWLF90cl9hbGlnbjpHfT1rLHtaX05PX0ZMVVNIOnosWl9QQVJUSUFMX0ZMVVNIOnEsWl9GVUxMX0ZMVVNIOlcsWl9GSU5JU0g6WCxaX0JMT0NLOlksWl9PSzpKLFpfU1RSRUFNX0VORDpaLFpfU1RSRUFNX0VSUk9SOiQsWl9EQVRBX0VSUk9SOmVlLFpfQlVGX0VSUk9SOnRlLFpfREVGQVVMVF9DT01QUkVTU0lPTjpBZSxaX0ZJTFRFUkVEOnJlLFpfSFVGRk1BTl9PTkxZOm5lLFpfUkxFOnNlLFpfRklYRUQ6aWUsWl9ERUZBVUxUX1NUUkFURUdZOm9lLFpfVU5LTk9XTjphZSxaX0RFRkxBVEVEOmxlfT1NLGNlPTI1OCx1ZT0yNjIsaGU9NDIsZGU9MTEzLGZlPTY2NixwZT0oZSx0KT0+KGUubXNnPU9bdF0sdCksZ2U9ZT0+MiplLShlPjQ/OTowKSxtZT1lPT57bGV0IHQ9ZS5sZW5ndGg7Zm9yKDstLXQ+PTA7KWVbdF09MH0sd2U9ZT0+e2xldCB0LEEscixuPWUud19zaXplO3Q9ZS5oYXNoX3NpemUscj10O2Rve0E9ZS5oZWFkWy0tcl0sZS5oZWFkW3JdPUE+PW4/QS1uOjB9d2hpbGUoLS10KTt0PW4scj10O2Rve0E9ZS5wcmV2Wy0tcl0sZS5wcmV2W3JdPUE+PW4/QS1uOjB9d2hpbGUoLS10KX07bGV0IEJlPShlLHQsQSk9Pih0PDxlLmhhc2hfc2hpZnReQSkmZS5oYXNoX21hc2s7Y29uc3QgeWU9ZT0+e2NvbnN0IHQ9ZS5zdGF0ZTtsZXQgQT10LnBlbmRpbmc7QT5lLmF2YWlsX291dCYmKEE9ZS5hdmFpbF9vdXQpLDAhPT1BJiYoZS5vdXRwdXQuc2V0KHQucGVuZGluZ19idWYuc3ViYXJyYXkodC5wZW5kaW5nX291dCx0LnBlbmRpbmdfb3V0K0EpLGUubmV4dF9vdXQpLGUubmV4dF9vdXQrPUEsdC5wZW5kaW5nX291dCs9QSxlLnRvdGFsX291dCs9QSxlLmF2YWlsX291dC09QSx0LnBlbmRpbmctPUEsMD09PXQucGVuZGluZyYmKHQucGVuZGluZ19vdXQ9MCkpfSx2ZT0oZSx0KT0+e0soZSxlLmJsb2NrX3N0YXJ0Pj0wP2UuYmxvY2tfc3RhcnQ6LTEsZS5zdHJzdGFydC1lLmJsb2NrX3N0YXJ0LHQpLGUuYmxvY2tfc3RhcnQ9ZS5zdHJzdGFydCx5ZShlLnN0cm0pfSxiZT0oZSx0KT0+e2UucGVuZGluZ19idWZbZS5wZW5kaW5nKytdPXR9LENlPShlLHQpPT57ZS5wZW5kaW5nX2J1ZltlLnBlbmRpbmcrK109dD4+PjgmMjU1LGUucGVuZGluZ19idWZbZS5wZW5kaW5nKytdPTI1NSZ0fSxfZT0oZSx0LEEscik9PntsZXQgbj1lLmF2YWlsX2luO3JldHVybiBuPnImJihuPXIpLDA9PT1uPzA6KGUuYXZhaWxfaW4tPW4sdC5zZXQoZS5pbnB1dC5zdWJhcnJheShlLm5leHRfaW4sZS5uZXh0X2luK24pLEEpLDE9PT1lLnN0YXRlLndyYXA/ZS5hZGxlcj1IKGUuYWRsZXIsdCxuLEEpOjI9PT1lLnN0YXRlLndyYXAmJihlLmFkbGVyPVQoZS5hZGxlcix0LG4sQSkpLGUubmV4dF9pbis9bixlLnRvdGFsX2luKz1uLG4pfSxqZT0oZSx0KT0+e2xldCBBLHIsbj1lLm1heF9jaGFpbl9sZW5ndGgscz1lLnN0cnN0YXJ0LGk9ZS5wcmV2X2xlbmd0aCxvPWUubmljZV9tYXRjaDtjb25zdCBhPWUuc3Ryc3RhcnQ+ZS53X3NpemUtdWU/ZS5zdHJzdGFydC0oZS53X3NpemUtdWUpOjAsbD1lLndpbmRvdyxjPWUud19tYXNrLHU9ZS5wcmV2LGg9ZS5zdHJzdGFydCtjZTtsZXQgZD1sW3MraS0xXSxmPWxbcytpXTtlLnByZXZfbGVuZ3RoPj1lLmdvb2RfbWF0Y2gmJihuPj49Miksbz5lLmxvb2thaGVhZCYmKG89ZS5sb29rYWhlYWQpO2Rve2lmKEE9dCxsW0EraV09PT1mJiZsW0EraS0xXT09PWQmJmxbQV09PT1sW3NdJiZsWysrQV09PT1sW3MrMV0pe3MrPTIsQSsrO2Rve313aGlsZShsWysrc109PT1sWysrQV0mJmxbKytzXT09PWxbKytBXSYmbFsrK3NdPT09bFsrK0FdJiZsWysrc109PT1sWysrQV0mJmxbKytzXT09PWxbKytBXSYmbFsrK3NdPT09bFsrK0FdJiZsWysrc109PT1sWysrQV0mJmxbKytzXT09PWxbKytBXSYmczxoKTtpZihyPWNlLShoLXMpLHM9aC1jZSxyPmkpe2lmKGUubWF0Y2hfc3RhcnQ9dCxpPXIscj49bylicmVhaztkPWxbcytpLTFdLGY9bFtzK2ldfX19d2hpbGUoKHQ9dVt0JmNdKT5hJiYwIT09LS1uKTtyZXR1cm4gaTw9ZS5sb29rYWhlYWQ/aTplLmxvb2thaGVhZH0seGU9ZT0+e2NvbnN0IHQ9ZS53X3NpemU7bGV0IEEscixuO2Rve2lmKHI9ZS53aW5kb3dfc2l6ZS1lLmxvb2thaGVhZC1lLnN0cnN0YXJ0LGUuc3Ryc3RhcnQ+PXQrKHQtdWUpJiYoZS53aW5kb3cuc2V0KGUud2luZG93LnN1YmFycmF5KHQsdCt0LXIpLDApLGUubWF0Y2hfc3RhcnQtPXQsZS5zdHJzdGFydC09dCxlLmJsb2NrX3N0YXJ0LT10LGUuaW5zZXJ0PmUuc3Ryc3RhcnQmJihlLmluc2VydD1lLnN0cnN0YXJ0KSx3ZShlKSxyKz10KSwwPT09ZS5zdHJtLmF2YWlsX2luKWJyZWFrO2lmKEE9X2UoZS5zdHJtLGUud2luZG93LGUuc3Ryc3RhcnQrZS5sb29rYWhlYWQsciksZS5sb29rYWhlYWQrPUEsZS5sb29rYWhlYWQrZS5pbnNlcnQ+PTMpZm9yKG49ZS5zdHJzdGFydC1lLmluc2VydCxlLmluc19oPWUud2luZG93W25dLGUuaW5zX2g9QmUoZSxlLmluc19oLGUud2luZG93W24rMV0pO2UuaW5zZXJ0JiYoZS5pbnNfaD1CZShlLGUuaW5zX2gsZS53aW5kb3dbbiszLTFdKSxlLnByZXZbbiZlLndfbWFza109ZS5oZWFkW2UuaW5zX2hdLGUuaGVhZFtlLmluc19oXT1uLG4rKyxlLmluc2VydC0tLCEoZS5sb29rYWhlYWQrZS5pbnNlcnQ8MykpOyk7fXdoaWxlKGUubG9va2FoZWFkPHVlJiYwIT09ZS5zdHJtLmF2YWlsX2luKX0sRmU9KGUsdCk9PntsZXQgQSxyLG4scz1lLnBlbmRpbmdfYnVmX3NpemUtNT5lLndfc2l6ZT9lLndfc2l6ZTplLnBlbmRpbmdfYnVmX3NpemUtNSxpPTAsbz1lLnN0cm0uYXZhaWxfaW47ZG97aWYoQT02NTUzNSxuPWUuYmlfdmFsaWQrNDI+PjMsZS5zdHJtLmF2YWlsX291dDxuKWJyZWFrO2lmKG49ZS5zdHJtLmF2YWlsX291dC1uLHI9ZS5zdHJzdGFydC1lLmJsb2NrX3N0YXJ0LEE+citlLnN0cm0uYXZhaWxfaW4mJihBPXIrZS5zdHJtLmF2YWlsX2luKSxBPm4mJihBPW4pLEE8cyYmKDA9PT1BJiZ0IT09WHx8dD09PXp8fEEhPT1yK2Uuc3RybS5hdmFpbF9pbikpYnJlYWs7aT10PT09WCYmQT09PXIrZS5zdHJtLmF2YWlsX2luPzE6MCxSKGUsMCwwLGkpLGUucGVuZGluZ19idWZbZS5wZW5kaW5nLTRdPUEsZS5wZW5kaW5nX2J1ZltlLnBlbmRpbmctM109QT4+OCxlLnBlbmRpbmdfYnVmW2UucGVuZGluZy0yXT1+QSxlLnBlbmRpbmdfYnVmW2UucGVuZGluZy0xXT1+QT4+OCx5ZShlLnN0cm0pLHImJihyPkEmJihyPUEpLGUuc3RybS5vdXRwdXQuc2V0KGUud2luZG93LnN1YmFycmF5KGUuYmxvY2tfc3RhcnQsZS5ibG9ja19zdGFydCtyKSxlLnN0cm0ubmV4dF9vdXQpLGUuc3RybS5uZXh0X291dCs9cixlLnN0cm0uYXZhaWxfb3V0LT1yLGUuc3RybS50b3RhbF9vdXQrPXIsZS5ibG9ja19zdGFydCs9cixBLT1yKSxBJiYoX2UoZS5zdHJtLGUuc3RybS5vdXRwdXQsZS5zdHJtLm5leHRfb3V0LEEpLGUuc3RybS5uZXh0X291dCs9QSxlLnN0cm0uYXZhaWxfb3V0LT1BLGUuc3RybS50b3RhbF9vdXQrPUEpfXdoaWxlKDA9PT1pKTtyZXR1cm4gby09ZS5zdHJtLmF2YWlsX2luLG8mJihvPj1lLndfc2l6ZT8oZS5tYXRjaGVzPTIsZS53aW5kb3cuc2V0KGUuc3RybS5pbnB1dC5zdWJhcnJheShlLnN0cm0ubmV4dF9pbi1lLndfc2l6ZSxlLnN0cm0ubmV4dF9pbiksMCksZS5zdHJzdGFydD1lLndfc2l6ZSxlLmluc2VydD1lLnN0cnN0YXJ0KTooZS53aW5kb3dfc2l6ZS1lLnN0cnN0YXJ0PD1vJiYoZS5zdHJzdGFydC09ZS53X3NpemUsZS53aW5kb3cuc2V0KGUud2luZG93LnN1YmFycmF5KGUud19zaXplLGUud19zaXplK2Uuc3Ryc3RhcnQpLDApLGUubWF0Y2hlczwyJiZlLm1hdGNoZXMrKyxlLmluc2VydD5lLnN0cnN0YXJ0JiYoZS5pbnNlcnQ9ZS5zdHJzdGFydCkpLGUud2luZG93LnNldChlLnN0cm0uaW5wdXQuc3ViYXJyYXkoZS5zdHJtLm5leHRfaW4tbyxlLnN0cm0ubmV4dF9pbiksZS5zdHJzdGFydCksZS5zdHJzdGFydCs9byxlLmluc2VydCs9bz5lLndfc2l6ZS1lLmluc2VydD9lLndfc2l6ZS1lLmluc2VydDpvKSxlLmJsb2NrX3N0YXJ0PWUuc3Ryc3RhcnQpLGUuaGlnaF93YXRlcjxlLnN0cnN0YXJ0JiYoZS5oaWdoX3dhdGVyPWUuc3Ryc3RhcnQpLGk/NDp0IT09eiYmdCE9PVgmJjA9PT1lLnN0cm0uYXZhaWxfaW4mJmUuc3Ryc3RhcnQ9PT1lLmJsb2NrX3N0YXJ0PzI6KG49ZS53aW5kb3dfc2l6ZS1lLnN0cnN0YXJ0LGUuc3RybS5hdmFpbF9pbj5uJiZlLmJsb2NrX3N0YXJ0Pj1lLndfc2l6ZSYmKGUuYmxvY2tfc3RhcnQtPWUud19zaXplLGUuc3Ryc3RhcnQtPWUud19zaXplLGUud2luZG93LnNldChlLndpbmRvdy5zdWJhcnJheShlLndfc2l6ZSxlLndfc2l6ZStlLnN0cnN0YXJ0KSwwKSxlLm1hdGNoZXM8MiYmZS5tYXRjaGVzKyssbis9ZS53X3NpemUsZS5pbnNlcnQ+ZS5zdHJzdGFydCYmKGUuaW5zZXJ0PWUuc3Ryc3RhcnQpKSxuPmUuc3RybS5hdmFpbF9pbiYmKG49ZS5zdHJtLmF2YWlsX2luKSxuJiYoX2UoZS5zdHJtLGUud2luZG93LGUuc3Ryc3RhcnQsbiksZS5zdHJzdGFydCs9bixlLmluc2VydCs9bj5lLndfc2l6ZS1lLmluc2VydD9lLndfc2l6ZS1lLmluc2VydDpuKSxlLmhpZ2hfd2F0ZXI8ZS5zdHJzdGFydCYmKGUuaGlnaF93YXRlcj1lLnN0cnN0YXJ0KSxuPWUuYmlfdmFsaWQrNDI+PjMsbj1lLnBlbmRpbmdfYnVmX3NpemUtbj42NTUzNT82NTUzNTplLnBlbmRpbmdfYnVmX3NpemUtbixzPW4+ZS53X3NpemU/ZS53X3NpemU6bixyPWUuc3Ryc3RhcnQtZS5ibG9ja19zdGFydCwocj49c3x8KHJ8fHQ9PT1YKSYmdCE9PXomJjA9PT1lLnN0cm0uYXZhaWxfaW4mJnI8PW4pJiYoQT1yPm4/bjpyLGk9dD09PVgmJjA9PT1lLnN0cm0uYXZhaWxfaW4mJkE9PT1yPzE6MCxSKGUsZS5ibG9ja19zdGFydCxBLGkpLGUuYmxvY2tfc3RhcnQrPUEseWUoZS5zdHJtKSksaT8zOjEpfSxRZT0oZSx0KT0+e2xldCBBLHI7Zm9yKDs7KXtpZihlLmxvb2thaGVhZDx1ZSl7aWYoeGUoZSksZS5sb29rYWhlYWQ8dWUmJnQ9PT16KXJldHVybiAxO2lmKDA9PT1lLmxvb2thaGVhZClicmVha31pZihBPTAsZS5sb29rYWhlYWQ+PTMmJihlLmluc19oPUJlKGUsZS5pbnNfaCxlLndpbmRvd1tlLnN0cnN0YXJ0KzMtMV0pLEE9ZS5wcmV2W2Uuc3Ryc3RhcnQmZS53X21hc2tdPWUuaGVhZFtlLmluc19oXSxlLmhlYWRbZS5pbnNfaF09ZS5zdHJzdGFydCksMCE9PUEmJmUuc3Ryc3RhcnQtQTw9ZS53X3NpemUtdWUmJihlLm1hdGNoX2xlbmd0aD1qZShlLEEpKSxlLm1hdGNoX2xlbmd0aD49MylpZihyPVYoZSxlLnN0cnN0YXJ0LWUubWF0Y2hfc3RhcnQsZS5tYXRjaF9sZW5ndGgtMyksZS5sb29rYWhlYWQtPWUubWF0Y2hfbGVuZ3RoLGUubWF0Y2hfbGVuZ3RoPD1lLm1heF9sYXp5X21hdGNoJiZlLmxvb2thaGVhZD49Myl7ZS5tYXRjaF9sZW5ndGgtLTtkb3tlLnN0cnN0YXJ0KyssZS5pbnNfaD1CZShlLGUuaW5zX2gsZS53aW5kb3dbZS5zdHJzdGFydCszLTFdKSxBPWUucHJldltlLnN0cnN0YXJ0JmUud19tYXNrXT1lLmhlYWRbZS5pbnNfaF0sZS5oZWFkW2UuaW5zX2hdPWUuc3Ryc3RhcnR9d2hpbGUoMCE9PS0tZS5tYXRjaF9sZW5ndGgpO2Uuc3Ryc3RhcnQrK31lbHNlIGUuc3Ryc3RhcnQrPWUubWF0Y2hfbGVuZ3RoLGUubWF0Y2hfbGVuZ3RoPTAsZS5pbnNfaD1lLndpbmRvd1tlLnN0cnN0YXJ0XSxlLmluc19oPUJlKGUsZS5pbnNfaCxlLndpbmRvd1tlLnN0cnN0YXJ0KzFdKTtlbHNlIHI9VihlLDAsZS53aW5kb3dbZS5zdHJzdGFydF0pLGUubG9va2FoZWFkLS0sZS5zdHJzdGFydCsrO2lmKHImJih2ZShlLCExKSwwPT09ZS5zdHJtLmF2YWlsX291dCkpcmV0dXJuIDF9cmV0dXJuIGUuaW5zZXJ0PWUuc3Ryc3RhcnQ8Mj9lLnN0cnN0YXJ0OjIsdD09PVg/KHZlKGUsITApLDA9PT1lLnN0cm0uYXZhaWxfb3V0PzM6NCk6ZS5zeW1fbmV4dCYmKHZlKGUsITEpLDA9PT1lLnN0cm0uYXZhaWxfb3V0KT8xOjJ9LFVlPShlLHQpPT57bGV0IEEscixuO2Zvcig7Oyl7aWYoZS5sb29rYWhlYWQ8dWUpe2lmKHhlKGUpLGUubG9va2FoZWFkPHVlJiZ0PT09eilyZXR1cm4gMTtpZigwPT09ZS5sb29rYWhlYWQpYnJlYWt9aWYoQT0wLGUubG9va2FoZWFkPj0zJiYoZS5pbnNfaD1CZShlLGUuaW5zX2gsZS53aW5kb3dbZS5zdHJzdGFydCszLTFdKSxBPWUucHJldltlLnN0cnN0YXJ0JmUud19tYXNrXT1lLmhlYWRbZS5pbnNfaF0sZS5oZWFkW2UuaW5zX2hdPWUuc3Ryc3RhcnQpLGUucHJldl9sZW5ndGg9ZS5tYXRjaF9sZW5ndGgsZS5wcmV2X21hdGNoPWUubWF0Y2hfc3RhcnQsZS5tYXRjaF9sZW5ndGg9MiwwIT09QSYmZS5wcmV2X2xlbmd0aDxlLm1heF9sYXp5X21hdGNoJiZlLnN0cnN0YXJ0LUE8PWUud19zaXplLXVlJiYoZS5tYXRjaF9sZW5ndGg9amUoZSxBKSxlLm1hdGNoX2xlbmd0aDw9NSYmKGUuc3RyYXRlZ3k9PT1yZXx8Mz09PWUubWF0Y2hfbGVuZ3RoJiZlLnN0cnN0YXJ0LWUubWF0Y2hfc3RhcnQ+NDA5NikmJihlLm1hdGNoX2xlbmd0aD0yKSksZS5wcmV2X2xlbmd0aD49MyYmZS5tYXRjaF9sZW5ndGg8PWUucHJldl9sZW5ndGgpe249ZS5zdHJzdGFydCtlLmxvb2thaGVhZC0zLHI9VihlLGUuc3Ryc3RhcnQtMS1lLnByZXZfbWF0Y2gsZS5wcmV2X2xlbmd0aC0zKSxlLmxvb2thaGVhZC09ZS5wcmV2X2xlbmd0aC0xLGUucHJldl9sZW5ndGgtPTI7ZG97KytlLnN0cnN0YXJ0PD1uJiYoZS5pbnNfaD1CZShlLGUuaW5zX2gsZS53aW5kb3dbZS5zdHJzdGFydCszLTFdKSxBPWUucHJldltlLnN0cnN0YXJ0JmUud19tYXNrXT1lLmhlYWRbZS5pbnNfaF0sZS5oZWFkW2UuaW5zX2hdPWUuc3Ryc3RhcnQpfXdoaWxlKDAhPT0tLWUucHJldl9sZW5ndGgpO2lmKGUubWF0Y2hfYXZhaWxhYmxlPTAsZS5tYXRjaF9sZW5ndGg9MixlLnN0cnN0YXJ0KyssciYmKHZlKGUsITEpLDA9PT1lLnN0cm0uYXZhaWxfb3V0KSlyZXR1cm4gMX1lbHNlIGlmKGUubWF0Y2hfYXZhaWxhYmxlKXtpZihyPVYoZSwwLGUud2luZG93W2Uuc3Ryc3RhcnQtMV0pLHImJnZlKGUsITEpLGUuc3Ryc3RhcnQrKyxlLmxvb2thaGVhZC0tLDA9PT1lLnN0cm0uYXZhaWxfb3V0KXJldHVybiAxfWVsc2UgZS5tYXRjaF9hdmFpbGFibGU9MSxlLnN0cnN0YXJ0KyssZS5sb29rYWhlYWQtLX1yZXR1cm4gZS5tYXRjaF9hdmFpbGFibGUmJihyPVYoZSwwLGUud2luZG93W2Uuc3Ryc3RhcnQtMV0pLGUubWF0Y2hfYXZhaWxhYmxlPTApLGUuaW5zZXJ0PWUuc3Ryc3RhcnQ8Mj9lLnN0cnN0YXJ0OjIsdD09PVg/KHZlKGUsITApLDA9PT1lLnN0cm0uYXZhaWxfb3V0PzM6NCk6ZS5zeW1fbmV4dCYmKHZlKGUsITEpLDA9PT1lLnN0cm0uYXZhaWxfb3V0KT8xOjJ9O2Z1bmN0aW9uIEVlKGUsdCxBLHIsbil7dGhpcy5nb29kX2xlbmd0aD1lLHRoaXMubWF4X2xhenk9dCx0aGlzLm5pY2VfbGVuZ3RoPUEsdGhpcy5tYXhfY2hhaW49cix0aGlzLmZ1bmM9bn1jb25zdCBTZT1bbmV3IEVlKDAsMCwwLDAsRmUpLG5ldyBFZSg0LDQsOCw0LFFlKSxuZXcgRWUoNCw1LDE2LDgsUWUpLG5ldyBFZSg0LDYsMzIsMzIsUWUpLG5ldyBFZSg0LDQsMTYsMTYsVWUpLG5ldyBFZSg4LDE2LDMyLDMyLFVlKSxuZXcgRWUoOCwxNiwxMjgsMTI4LFVlKSxuZXcgRWUoOCwzMiwxMjgsMjU2LFVlKSxuZXcgRWUoMzIsMTI4LDI1OCwxMDI0LFVlKSxuZXcgRWUoMzIsMjU4LDI1OCw0MDk2LFVlKV07ZnVuY3Rpb24gTGUoKXt0aGlzLnN0cm09bnVsbCx0aGlzLnN0YXR1cz0wLHRoaXMucGVuZGluZ19idWY9bnVsbCx0aGlzLnBlbmRpbmdfYnVmX3NpemU9MCx0aGlzLnBlbmRpbmdfb3V0PTAsdGhpcy5wZW5kaW5nPTAsdGhpcy53cmFwPTAsdGhpcy5nemhlYWQ9bnVsbCx0aGlzLmd6aW5kZXg9MCx0aGlzLm1ldGhvZD1sZSx0aGlzLmxhc3RfZmx1c2g9LTEsdGhpcy53X3NpemU9MCx0aGlzLndfYml0cz0wLHRoaXMud19tYXNrPTAsdGhpcy53aW5kb3c9bnVsbCx0aGlzLndpbmRvd19zaXplPTAsdGhpcy5wcmV2PW51bGwsdGhpcy5oZWFkPW51bGwsdGhpcy5pbnNfaD0wLHRoaXMuaGFzaF9zaXplPTAsdGhpcy5oYXNoX2JpdHM9MCx0aGlzLmhhc2hfbWFzaz0wLHRoaXMuaGFzaF9zaGlmdD0wLHRoaXMuYmxvY2tfc3RhcnQ9MCx0aGlzLm1hdGNoX2xlbmd0aD0wLHRoaXMucHJldl9tYXRjaD0wLHRoaXMubWF0Y2hfYXZhaWxhYmxlPTAsdGhpcy5zdHJzdGFydD0wLHRoaXMubWF0Y2hfc3RhcnQ9MCx0aGlzLmxvb2thaGVhZD0wLHRoaXMucHJldl9sZW5ndGg9MCx0aGlzLm1heF9jaGFpbl9sZW5ndGg9MCx0aGlzLm1heF9sYXp5X21hdGNoPTAsdGhpcy5sZXZlbD0wLHRoaXMuc3RyYXRlZ3k9MCx0aGlzLmdvb2RfbWF0Y2g9MCx0aGlzLm5pY2VfbWF0Y2g9MCx0aGlzLmR5bl9sdHJlZT1uZXcgVWludDE2QXJyYXkoMTE0NiksdGhpcy5keW5fZHRyZWU9bmV3IFVpbnQxNkFycmF5KDEyMiksdGhpcy5ibF90cmVlPW5ldyBVaW50MTZBcnJheSg3OCksbWUodGhpcy5keW5fbHRyZWUpLG1lKHRoaXMuZHluX2R0cmVlKSxtZSh0aGlzLmJsX3RyZWUpLHRoaXMubF9kZXNjPW51bGwsdGhpcy5kX2Rlc2M9bnVsbCx0aGlzLmJsX2Rlc2M9bnVsbCx0aGlzLmJsX2NvdW50PW5ldyBVaW50MTZBcnJheSgxNiksdGhpcy5oZWFwPW5ldyBVaW50MTZBcnJheSg1NzMpLG1lKHRoaXMuaGVhcCksdGhpcy5oZWFwX2xlbj0wLHRoaXMuaGVhcF9tYXg9MCx0aGlzLmRlcHRoPW5ldyBVaW50MTZBcnJheSg1NzMpLG1lKHRoaXMuZGVwdGgpLHRoaXMuc3ltX2J1Zj0wLHRoaXMubGl0X2J1ZnNpemU9MCx0aGlzLnN5bV9uZXh0PTAsdGhpcy5zeW1fZW5kPTAsdGhpcy5vcHRfbGVuPTAsdGhpcy5zdGF0aWNfbGVuPTAsdGhpcy5tYXRjaGVzPTAsdGhpcy5pbnNlcnQ9MCx0aGlzLmJpX2J1Zj0wLHRoaXMuYmlfdmFsaWQ9MH1jb25zdCBJZT1lPT57aWYoIWUpcmV0dXJuIDE7Y29uc3QgdD1lLnN0YXRlO3JldHVybiF0fHx0LnN0cm0hPT1lfHx0LnN0YXR1cyE9PWhlJiY1NyE9PXQuc3RhdHVzJiY2OSE9PXQuc3RhdHVzJiY3MyE9PXQuc3RhdHVzJiY5MSE9PXQuc3RhdHVzJiYxMDMhPT10LnN0YXR1cyYmdC5zdGF0dXMhPT1kZSYmdC5zdGF0dXMhPT1mZT8xOjB9LE5lPWU9PntpZihJZShlKSlyZXR1cm4gcGUoZSwkKTtlLnRvdGFsX2luPWUudG90YWxfb3V0PTAsZS5kYXRhX3R5cGU9YWU7Y29uc3QgdD1lLnN0YXRlO3JldHVybiB0LnBlbmRpbmc9MCx0LnBlbmRpbmdfb3V0PTAsdC53cmFwPDAmJih0LndyYXA9LXQud3JhcCksdC5zdGF0dXM9Mj09PXQud3JhcD81Nzp0LndyYXA/aGU6ZGUsZS5hZGxlcj0yPT09dC53cmFwPzA6MSx0Lmxhc3RfZmx1c2g9LTIsRCh0KSxKfSxrZT1lPT57Y29uc3QgdD1OZShlKTt2YXIgQTtyZXR1cm4gdD09PUomJigoQT1lLnN0YXRlKS53aW5kb3dfc2l6ZT0yKkEud19zaXplLG1lKEEuaGVhZCksQS5tYXhfbGF6eV9tYXRjaD1TZVtBLmxldmVsXS5tYXhfbGF6eSxBLmdvb2RfbWF0Y2g9U2VbQS5sZXZlbF0uZ29vZF9sZW5ndGgsQS5uaWNlX21hdGNoPVNlW0EubGV2ZWxdLm5pY2VfbGVuZ3RoLEEubWF4X2NoYWluX2xlbmd0aD1TZVtBLmxldmVsXS5tYXhfY2hhaW4sQS5zdHJzdGFydD0wLEEuYmxvY2tfc3RhcnQ9MCxBLmxvb2thaGVhZD0wLEEuaW5zZXJ0PTAsQS5tYXRjaF9sZW5ndGg9QS5wcmV2X2xlbmd0aD0yLEEubWF0Y2hfYXZhaWxhYmxlPTAsQS5pbnNfaD0wKSx0fSxIZT0oZSx0LEEscixuLHMpPT57aWYoIWUpcmV0dXJuICQ7bGV0IGk9MTtpZih0PT09QWUmJih0PTYpLHI8MD8oaT0wLHI9LXIpOnI+MTUmJihpPTIsci09MTYpLG48MXx8bj45fHxBIT09bGV8fHI8OHx8cj4xNXx8dDwwfHx0Pjl8fHM8MHx8cz5pZXx8OD09PXImJjEhPT1pKXJldHVybiBwZShlLCQpOzg9PT1yJiYocj05KTtjb25zdCBvPW5ldyBMZTtyZXR1cm4gZS5zdGF0ZT1vLG8uc3RybT1lLG8uc3RhdHVzPWhlLG8ud3JhcD1pLG8uZ3poZWFkPW51bGwsby53X2JpdHM9cixvLndfc2l6ZT0xPDxvLndfYml0cyxvLndfbWFzaz1vLndfc2l6ZS0xLG8uaGFzaF9iaXRzPW4rNyxvLmhhc2hfc2l6ZT0xPDxvLmhhc2hfYml0cyxvLmhhc2hfbWFzaz1vLmhhc2hfc2l6ZS0xLG8uaGFzaF9zaGlmdD1+figoby5oYXNoX2JpdHMrMy0xKS8zKSxvLndpbmRvdz1uZXcgVWludDhBcnJheSgyKm8ud19zaXplKSxvLmhlYWQ9bmV3IFVpbnQxNkFycmF5KG8uaGFzaF9zaXplKSxvLnByZXY9bmV3IFVpbnQxNkFycmF5KG8ud19zaXplKSxvLmxpdF9idWZzaXplPTE8PG4rNixvLnBlbmRpbmdfYnVmX3NpemU9NCpvLmxpdF9idWZzaXplLG8ucGVuZGluZ19idWY9bmV3IFVpbnQ4QXJyYXkoby5wZW5kaW5nX2J1Zl9zaXplKSxvLnN5bV9idWY9by5saXRfYnVmc2l6ZSxvLnN5bV9lbmQ9Myooby5saXRfYnVmc2l6ZS0xKSxvLmxldmVsPXQsby5zdHJhdGVneT1zLG8ubWV0aG9kPUEsa2UoZSl9O3ZhciBQZT1IZSxUZT0oZSx0KT0+SWUoZSl8fDIhPT1lLnN0YXRlLndyYXA/JDooZS5zdGF0ZS5nemhlYWQ9dCxKKSxPZT0oZSx0KT0+e2lmKEllKGUpfHx0Pll8fHQ8MClyZXR1cm4gZT9wZShlLCQpOiQ7Y29uc3QgQT1lLnN0YXRlO2lmKCFlLm91dHB1dHx8MCE9PWUuYXZhaWxfaW4mJiFlLmlucHV0fHxBLnN0YXR1cz09PWZlJiZ0IT09WClyZXR1cm4gcGUoZSwwPT09ZS5hdmFpbF9vdXQ/dGU6JCk7Y29uc3Qgcj1BLmxhc3RfZmx1c2g7aWYoQS5sYXN0X2ZsdXNoPXQsMCE9PUEucGVuZGluZyl7aWYoeWUoZSksMD09PWUuYXZhaWxfb3V0KXJldHVybiBBLmxhc3RfZmx1c2g9LTEsSn1lbHNlIGlmKDA9PT1lLmF2YWlsX2luJiZnZSh0KTw9Z2UocikmJnQhPT1YKXJldHVybiBwZShlLHRlKTtpZihBLnN0YXR1cz09PWZlJiYwIT09ZS5hdmFpbF9pbilyZXR1cm4gcGUoZSx0ZSk7aWYoQS5zdGF0dXM9PT1oZSYmMD09PUEud3JhcCYmKEEuc3RhdHVzPWRlKSxBLnN0YXR1cz09PWhlKXtsZXQgdD1sZSsoQS53X2JpdHMtODw8NCk8PDgscj0tMTtpZihyPUEuc3RyYXRlZ3k+PW5lfHxBLmxldmVsPDI/MDpBLmxldmVsPDY/MTo2PT09QS5sZXZlbD8yOjMsdHw9cjw8NiwwIT09QS5zdHJzdGFydCYmKHR8PTMyKSx0Kz0zMS10JTMxLENlKEEsdCksMCE9PUEuc3Ryc3RhcnQmJihDZShBLGUuYWRsZXI+Pj4xNiksQ2UoQSw2NTUzNSZlLmFkbGVyKSksZS5hZGxlcj0xLEEuc3RhdHVzPWRlLHllKGUpLDAhPT1BLnBlbmRpbmcpcmV0dXJuIEEubGFzdF9mbHVzaD0tMSxKfWlmKDU3PT09QS5zdGF0dXMpaWYoZS5hZGxlcj0wLGJlKEEsMzEpLGJlKEEsMTM5KSxiZShBLDgpLEEuZ3poZWFkKWJlKEEsKEEuZ3poZWFkLnRleHQ/MTowKSsoQS5nemhlYWQuaGNyYz8yOjApKyhBLmd6aGVhZC5leHRyYT80OjApKyhBLmd6aGVhZC5uYW1lPzg6MCkrKEEuZ3poZWFkLmNvbW1lbnQ/MTY6MCkpLGJlKEEsMjU1JkEuZ3poZWFkLnRpbWUpLGJlKEEsQS5nemhlYWQudGltZT4+OCYyNTUpLGJlKEEsQS5nemhlYWQudGltZT4+MTYmMjU1KSxiZShBLEEuZ3poZWFkLnRpbWU+PjI0JjI1NSksYmUoQSw5PT09QS5sZXZlbD8yOkEuc3RyYXRlZ3k+PW5lfHxBLmxldmVsPDI/NDowKSxiZShBLDI1NSZBLmd6aGVhZC5vcyksQS5nemhlYWQuZXh0cmEmJkEuZ3poZWFkLmV4dHJhLmxlbmd0aCYmKGJlKEEsMjU1JkEuZ3poZWFkLmV4dHJhLmxlbmd0aCksYmUoQSxBLmd6aGVhZC5leHRyYS5sZW5ndGg+PjgmMjU1KSksQS5nemhlYWQuaGNyYyYmKGUuYWRsZXI9VChlLmFkbGVyLEEucGVuZGluZ19idWYsQS5wZW5kaW5nLDApKSxBLmd6aW5kZXg9MCxBLnN0YXR1cz02OTtlbHNlIGlmKGJlKEEsMCksYmUoQSwwKSxiZShBLDApLGJlKEEsMCksYmUoQSwwKSxiZShBLDk9PT1BLmxldmVsPzI6QS5zdHJhdGVneT49bmV8fEEubGV2ZWw8Mj80OjApLGJlKEEsMyksQS5zdGF0dXM9ZGUseWUoZSksMCE9PUEucGVuZGluZylyZXR1cm4gQS5sYXN0X2ZsdXNoPS0xLEo7aWYoNjk9PT1BLnN0YXR1cyl7aWYoQS5nemhlYWQuZXh0cmEpe2xldCB0PUEucGVuZGluZyxyPSg2NTUzNSZBLmd6aGVhZC5leHRyYS5sZW5ndGgpLUEuZ3ppbmRleDtmb3IoO0EucGVuZGluZytyPkEucGVuZGluZ19idWZfc2l6ZTspe2xldCBuPUEucGVuZGluZ19idWZfc2l6ZS1BLnBlbmRpbmc7aWYoQS5wZW5kaW5nX2J1Zi5zZXQoQS5nemhlYWQuZXh0cmEuc3ViYXJyYXkoQS5nemluZGV4LEEuZ3ppbmRleCtuKSxBLnBlbmRpbmcpLEEucGVuZGluZz1BLnBlbmRpbmdfYnVmX3NpemUsQS5nemhlYWQuaGNyYyYmQS5wZW5kaW5nPnQmJihlLmFkbGVyPVQoZS5hZGxlcixBLnBlbmRpbmdfYnVmLEEucGVuZGluZy10LHQpKSxBLmd6aW5kZXgrPW4seWUoZSksMCE9PUEucGVuZGluZylyZXR1cm4gQS5sYXN0X2ZsdXNoPS0xLEo7dD0wLHItPW59bGV0IG49bmV3IFVpbnQ4QXJyYXkoQS5nemhlYWQuZXh0cmEpO0EucGVuZGluZ19idWYuc2V0KG4uc3ViYXJyYXkoQS5nemluZGV4LEEuZ3ppbmRleCtyKSxBLnBlbmRpbmcpLEEucGVuZGluZys9cixBLmd6aGVhZC5oY3JjJiZBLnBlbmRpbmc+dCYmKGUuYWRsZXI9VChlLmFkbGVyLEEucGVuZGluZ19idWYsQS5wZW5kaW5nLXQsdCkpLEEuZ3ppbmRleD0wfUEuc3RhdHVzPTczfWlmKDczPT09QS5zdGF0dXMpe2lmKEEuZ3poZWFkLm5hbWUpe2xldCB0LHI9QS5wZW5kaW5nO2Rve2lmKEEucGVuZGluZz09PUEucGVuZGluZ19idWZfc2l6ZSl7aWYoQS5nemhlYWQuaGNyYyYmQS5wZW5kaW5nPnImJihlLmFkbGVyPVQoZS5hZGxlcixBLnBlbmRpbmdfYnVmLEEucGVuZGluZy1yLHIpKSx5ZShlKSwwIT09QS5wZW5kaW5nKXJldHVybiBBLmxhc3RfZmx1c2g9LTEsSjtyPTB9dD1BLmd6aW5kZXg8QS5nemhlYWQubmFtZS5sZW5ndGg/MjU1JkEuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChBLmd6aW5kZXgrKyk6MCxiZShBLHQpfXdoaWxlKDAhPT10KTtBLmd6aGVhZC5oY3JjJiZBLnBlbmRpbmc+ciYmKGUuYWRsZXI9VChlLmFkbGVyLEEucGVuZGluZ19idWYsQS5wZW5kaW5nLXIscikpLEEuZ3ppbmRleD0wfUEuc3RhdHVzPTkxfWlmKDkxPT09QS5zdGF0dXMpe2lmKEEuZ3poZWFkLmNvbW1lbnQpe2xldCB0LHI9QS5wZW5kaW5nO2Rve2lmKEEucGVuZGluZz09PUEucGVuZGluZ19idWZfc2l6ZSl7aWYoQS5nemhlYWQuaGNyYyYmQS5wZW5kaW5nPnImJihlLmFkbGVyPVQoZS5hZGxlcixBLnBlbmRpbmdfYnVmLEEucGVuZGluZy1yLHIpKSx5ZShlKSwwIT09QS5wZW5kaW5nKXJldHVybiBBLmxhc3RfZmx1c2g9LTEsSjtyPTB9dD1BLmd6aW5kZXg8QS5nemhlYWQuY29tbWVudC5sZW5ndGg/MjU1JkEuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChBLmd6aW5kZXgrKyk6MCxiZShBLHQpfXdoaWxlKDAhPT10KTtBLmd6aGVhZC5oY3JjJiZBLnBlbmRpbmc+ciYmKGUuYWRsZXI9VChlLmFkbGVyLEEucGVuZGluZ19idWYsQS5wZW5kaW5nLXIscikpfUEuc3RhdHVzPTEwM31pZigxMDM9PT1BLnN0YXR1cyl7aWYoQS5nemhlYWQuaGNyYyl7aWYoQS5wZW5kaW5nKzI+QS5wZW5kaW5nX2J1Zl9zaXplJiYoeWUoZSksMCE9PUEucGVuZGluZykpcmV0dXJuIEEubGFzdF9mbHVzaD0tMSxKO2JlKEEsMjU1JmUuYWRsZXIpLGJlKEEsZS5hZGxlcj4+OCYyNTUpLGUuYWRsZXI9MH1pZihBLnN0YXR1cz1kZSx5ZShlKSwwIT09QS5wZW5kaW5nKXJldHVybiBBLmxhc3RfZmx1c2g9LTEsSn1pZigwIT09ZS5hdmFpbF9pbnx8MCE9PUEubG9va2FoZWFkfHx0IT09eiYmQS5zdGF0dXMhPT1mZSl7bGV0IHI9MD09PUEubGV2ZWw/RmUoQSx0KTpBLnN0cmF0ZWd5PT09bmU/KChlLHQpPT57bGV0IEE7Zm9yKDs7KXtpZigwPT09ZS5sb29rYWhlYWQmJih4ZShlKSwwPT09ZS5sb29rYWhlYWQpKXtpZih0PT09eilyZXR1cm4gMTticmVha31pZihlLm1hdGNoX2xlbmd0aD0wLEE9VihlLDAsZS53aW5kb3dbZS5zdHJzdGFydF0pLGUubG9va2FoZWFkLS0sZS5zdHJzdGFydCsrLEEmJih2ZShlLCExKSwwPT09ZS5zdHJtLmF2YWlsX291dCkpcmV0dXJuIDF9cmV0dXJuIGUuaW5zZXJ0PTAsdD09PVg/KHZlKGUsITApLDA9PT1lLnN0cm0uYXZhaWxfb3V0PzM6NCk6ZS5zeW1fbmV4dCYmKHZlKGUsITEpLDA9PT1lLnN0cm0uYXZhaWxfb3V0KT8xOjJ9KShBLHQpOkEuc3RyYXRlZ3k9PT1zZT8oKGUsdCk9PntsZXQgQSxyLG4scztjb25zdCBpPWUud2luZG93O2Zvcig7Oyl7aWYoZS5sb29rYWhlYWQ8PWNlKXtpZih4ZShlKSxlLmxvb2thaGVhZDw9Y2UmJnQ9PT16KXJldHVybiAxO2lmKDA9PT1lLmxvb2thaGVhZClicmVha31pZihlLm1hdGNoX2xlbmd0aD0wLGUubG9va2FoZWFkPj0zJiZlLnN0cnN0YXJ0PjAmJihuPWUuc3Ryc3RhcnQtMSxyPWlbbl0scj09PWlbKytuXSYmcj09PWlbKytuXSYmcj09PWlbKytuXSkpe3M9ZS5zdHJzdGFydCtjZTtkb3t9d2hpbGUocj09PWlbKytuXSYmcj09PWlbKytuXSYmcj09PWlbKytuXSYmcj09PWlbKytuXSYmcj09PWlbKytuXSYmcj09PWlbKytuXSYmcj09PWlbKytuXSYmcj09PWlbKytuXSYmbjxzKTtlLm1hdGNoX2xlbmd0aD1jZS0ocy1uKSxlLm1hdGNoX2xlbmd0aD5lLmxvb2thaGVhZCYmKGUubWF0Y2hfbGVuZ3RoPWUubG9va2FoZWFkKX1pZihlLm1hdGNoX2xlbmd0aD49Mz8oQT1WKGUsMSxlLm1hdGNoX2xlbmd0aC0zKSxlLmxvb2thaGVhZC09ZS5tYXRjaF9sZW5ndGgsZS5zdHJzdGFydCs9ZS5tYXRjaF9sZW5ndGgsZS5tYXRjaF9sZW5ndGg9MCk6KEE9VihlLDAsZS53aW5kb3dbZS5zdHJzdGFydF0pLGUubG9va2FoZWFkLS0sZS5zdHJzdGFydCsrKSxBJiYodmUoZSwhMSksMD09PWUuc3RybS5hdmFpbF9vdXQpKXJldHVybiAxfXJldHVybiBlLmluc2VydD0wLHQ9PT1YPyh2ZShlLCEwKSwwPT09ZS5zdHJtLmF2YWlsX291dD8zOjQpOmUuc3ltX25leHQmJih2ZShlLCExKSwwPT09ZS5zdHJtLmF2YWlsX291dCk/MToyfSkoQSx0KTpTZVtBLmxldmVsXS5mdW5jKEEsdCk7aWYoMyE9PXImJjQhPT1yfHwoQS5zdGF0dXM9ZmUpLDE9PT1yfHwzPT09cilyZXR1cm4gMD09PWUuYXZhaWxfb3V0JiYoQS5sYXN0X2ZsdXNoPS0xKSxKO2lmKDI9PT1yJiYodD09PXE/RyhBKTp0IT09WSYmKFIoQSwwLDAsITEpLHQ9PT1XJiYobWUoQS5oZWFkKSwwPT09QS5sb29rYWhlYWQmJihBLnN0cnN0YXJ0PTAsQS5ibG9ja19zdGFydD0wLEEuaW5zZXJ0PTApKSkseWUoZSksMD09PWUuYXZhaWxfb3V0KSlyZXR1cm4gQS5sYXN0X2ZsdXNoPS0xLEp9cmV0dXJuIHQhPT1YP0o6QS53cmFwPD0wP1o6KDI9PT1BLndyYXA/KGJlKEEsMjU1JmUuYWRsZXIpLGJlKEEsZS5hZGxlcj4+OCYyNTUpLGJlKEEsZS5hZGxlcj4+MTYmMjU1KSxiZShBLGUuYWRsZXI+PjI0JjI1NSksYmUoQSwyNTUmZS50b3RhbF9pbiksYmUoQSxlLnRvdGFsX2luPj44JjI1NSksYmUoQSxlLnRvdGFsX2luPj4xNiYyNTUpLGJlKEEsZS50b3RhbF9pbj4+MjQmMjU1KSk6KENlKEEsZS5hZGxlcj4+PjE2KSxDZShBLDY1NTM1JmUuYWRsZXIpKSx5ZShlKSxBLndyYXA+MCYmKEEud3JhcD0tQS53cmFwKSwwIT09QS5wZW5kaW5nP0o6Wil9LE1lPWU9PntpZihJZShlKSlyZXR1cm4gJDtjb25zdCB0PWUuc3RhdGUuc3RhdHVzO3JldHVybiBlLnN0YXRlPW51bGwsdD09PWRlP3BlKGUsZWUpOkp9LERlPShlLHQpPT57bGV0IEE9dC5sZW5ndGg7aWYoSWUoZSkpcmV0dXJuICQ7Y29uc3Qgcj1lLnN0YXRlLG49ci53cmFwO2lmKDI9PT1ufHwxPT09biYmci5zdGF0dXMhPT1oZXx8ci5sb29rYWhlYWQpcmV0dXJuICQ7aWYoMT09PW4mJihlLmFkbGVyPUgoZS5hZGxlcix0LEEsMCkpLHIud3JhcD0wLEE+PXIud19zaXplKXswPT09biYmKG1lKHIuaGVhZCksci5zdHJzdGFydD0wLHIuYmxvY2tfc3RhcnQ9MCxyLmluc2VydD0wKTtsZXQgZT1uZXcgVWludDhBcnJheShyLndfc2l6ZSk7ZS5zZXQodC5zdWJhcnJheShBLXIud19zaXplLEEpLDApLHQ9ZSxBPXIud19zaXplfWNvbnN0IHM9ZS5hdmFpbF9pbixpPWUubmV4dF9pbixvPWUuaW5wdXQ7Zm9yKGUuYXZhaWxfaW49QSxlLm5leHRfaW49MCxlLmlucHV0PXQseGUocik7ci5sb29rYWhlYWQ+PTM7KXtsZXQgZT1yLnN0cnN0YXJ0LHQ9ci5sb29rYWhlYWQtMjtkb3tyLmluc19oPUJlKHIsci5pbnNfaCxyLndpbmRvd1tlKzMtMV0pLHIucHJldltlJnIud19tYXNrXT1yLmhlYWRbci5pbnNfaF0sci5oZWFkW3IuaW5zX2hdPWUsZSsrfXdoaWxlKC0tdCk7ci5zdHJzdGFydD1lLHIubG9va2FoZWFkPTIseGUocil9cmV0dXJuIHIuc3Ryc3RhcnQrPXIubG9va2FoZWFkLHIuYmxvY2tfc3RhcnQ9ci5zdHJzdGFydCxyLmluc2VydD1yLmxvb2thaGVhZCxyLmxvb2thaGVhZD0wLHIubWF0Y2hfbGVuZ3RoPXIucHJldl9sZW5ndGg9MixyLm1hdGNoX2F2YWlsYWJsZT0wLGUubmV4dF9pbj1pLGUuaW5wdXQ9byxlLmF2YWlsX2luPXMsci53cmFwPW4sSn07Y29uc3QgUmU9KGUsdCk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpO3ZhciBLZT1mdW5jdGlvbihlKXtjb25zdCB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtmb3IoO3QubGVuZ3RoOyl7Y29uc3QgQT10LnNoaWZ0KCk7aWYoQSl7aWYoIm9iamVjdCIhPXR5cGVvZiBBKXRocm93IG5ldyBUeXBlRXJyb3IoQSsibXVzdCBiZSBub24tb2JqZWN0Iik7Zm9yKGNvbnN0IHQgaW4gQSlSZShBLHQpJiYoZVt0XT1BW3RdKX19cmV0dXJuIGV9LFZlPWU9PntsZXQgdD0wO2ZvcihsZXQgQT0wLHI9ZS5sZW5ndGg7QTxyO0ErKyl0Kz1lW0FdLmxlbmd0aDtjb25zdCBBPW5ldyBVaW50OEFycmF5KHQpO2ZvcihsZXQgdD0wLHI9MCxuPWUubGVuZ3RoO3Q8bjt0Kyspe2xldCBuPWVbdF07QS5zZXQobixyKSxyKz1uLmxlbmd0aH1yZXR1cm4gQX07bGV0IEdlPSEwO3RyeXtTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkoMSkpfWNhdGNoKGUpe0dlPSExfWNvbnN0IHplPW5ldyBVaW50OEFycmF5KDI1Nik7Zm9yKGxldCBlPTA7ZTwyNTY7ZSsrKXplW2VdPWU+PTI1Mj82OmU+PTI0OD81OmU+PTI0MD80OmU+PTIyND8zOmU+PTE5Mj8yOjE7emVbMjU0XT16ZVsyNTRdPTE7dmFyIHFlPWU9PntpZigiZnVuY3Rpb24iPT10eXBlb2YgVGV4dEVuY29kZXImJlRleHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUpcmV0dXJuKG5ldyBUZXh0RW5jb2RlcikuZW5jb2RlKGUpO2xldCB0LEEscixuLHMsaT1lLmxlbmd0aCxvPTA7Zm9yKG49MDtuPGk7bisrKUE9ZS5jaGFyQ29kZUF0KG4pLDU1Mjk2PT0oNjQ1MTImQSkmJm4rMTxpJiYocj1lLmNoYXJDb2RlQXQobisxKSw1NjMyMD09KDY0NTEyJnIpJiYoQT02NTUzNisoQS01NTI5Njw8MTApKyhyLTU2MzIwKSxuKyspKSxvKz1BPDEyOD8xOkE8MjA0OD8yOkE8NjU1MzY/Mzo0O2Zvcih0PW5ldyBVaW50OEFycmF5KG8pLHM9MCxuPTA7czxvO24rKylBPWUuY2hhckNvZGVBdChuKSw1NTI5Nj09KDY0NTEyJkEpJiZuKzE8aSYmKHI9ZS5jaGFyQ29kZUF0KG4rMSksNTYzMjA9PSg2NDUxMiZyKSYmKEE9NjU1MzYrKEEtNTUyOTY8PDEwKSsoci01NjMyMCksbisrKSksQTwxMjg/dFtzKytdPUE6QTwyMDQ4Pyh0W3MrK109MTkyfEE+Pj42LHRbcysrXT0xMjh8NjMmQSk6QTw2NTUzNj8odFtzKytdPTIyNHxBPj4+MTIsdFtzKytdPTEyOHxBPj4+NiY2Myx0W3MrK109MTI4fDYzJkEpOih0W3MrK109MjQwfEE+Pj4xOCx0W3MrK109MTI4fEE+Pj4xMiY2Myx0W3MrK109MTI4fEE+Pj42JjYzLHRbcysrXT0xMjh8NjMmQSk7cmV0dXJuIHR9LFdlPShlLHQpPT57Y29uc3QgQT10fHxlLmxlbmd0aDtpZigiZnVuY3Rpb24iPT10eXBlb2YgVGV4dERlY29kZXImJlRleHREZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUpcmV0dXJuKG5ldyBUZXh0RGVjb2RlcikuZGVjb2RlKGUuc3ViYXJyYXkoMCx0KSk7bGV0IHIsbjtjb25zdCBzPW5ldyBBcnJheSgyKkEpO2ZvcihuPTAscj0wO3I8QTspe2xldCB0PWVbcisrXTtpZih0PDEyOCl7c1tuKytdPXQ7Y29udGludWV9bGV0IGk9emVbdF07aWYoaT40KXNbbisrXT02NTUzMyxyKz1pLTE7ZWxzZXtmb3IodCY9Mj09PWk/MzE6Mz09PWk/MTU6NztpPjEmJnI8QTspdD10PDw2fDYzJmVbcisrXSxpLS07aT4xP3NbbisrXT02NTUzMzp0PDY1NTM2P3NbbisrXT10Oih0LT02NTUzNixzW24rK109NTUyOTZ8dD4+MTAmMTAyMyxzW24rK109NTYzMjB8MTAyMyZ0KX19cmV0dXJuKChlLHQpPT57aWYodDw2NTUzNCYmZS5zdWJhcnJheSYmR2UpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxlLmxlbmd0aD09PXQ/ZTplLnN1YmFycmF5KDAsdCkpO2xldCBBPSIiO2ZvcihsZXQgcj0wO3I8dDtyKyspQSs9U3RyaW5nLmZyb21DaGFyQ29kZShlW3JdKTtyZXR1cm4gQX0pKHMsbil9LFhlPShlLHQpPT57KHQ9dHx8ZS5sZW5ndGgpPmUubGVuZ3RoJiYodD1lLmxlbmd0aCk7bGV0IEE9dC0xO2Zvcig7QT49MCYmMTI4PT0oMTkyJmVbQV0pOylBLS07cmV0dXJuIEE8MHx8MD09PUE/dDpBK3plW2VbQV1dPnQ/QTp0fSxZZT1mdW5jdGlvbigpe3RoaXMuaW5wdXQ9bnVsbCx0aGlzLm5leHRfaW49MCx0aGlzLmF2YWlsX2luPTAsdGhpcy50b3RhbF9pbj0wLHRoaXMub3V0cHV0PW51bGwsdGhpcy5uZXh0X291dD0wLHRoaXMuYXZhaWxfb3V0PTAsdGhpcy50b3RhbF9vdXQ9MCx0aGlzLm1zZz0iIix0aGlzLnN0YXRlPW51bGwsdGhpcy5kYXRhX3R5cGU9Mix0aGlzLmFkbGVyPTB9O2NvbnN0IEplPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcse1pfTk9fRkxVU0g6WmUsWl9TWU5DX0ZMVVNIOiRlLFpfRlVMTF9GTFVTSDpldCxaX0ZJTklTSDp0dCxaX09LOkF0LFpfU1RSRUFNX0VORDpydCxaX0RFRkFVTFRfQ09NUFJFU1NJT046bnQsWl9ERUZBVUxUX1NUUkFURUdZOnN0LFpfREVGTEFURUQ6aXR9PU07ZnVuY3Rpb24gb3QoZSl7dGhpcy5vcHRpb25zPUtlKHtsZXZlbDpudCxtZXRob2Q6aXQsY2h1bmtTaXplOjE2Mzg0LHdpbmRvd0JpdHM6MTUsbWVtTGV2ZWw6OCxzdHJhdGVneTpzdH0sZXx8e30pO2xldCB0PXRoaXMub3B0aW9uczt0LnJhdyYmdC53aW5kb3dCaXRzPjA/dC53aW5kb3dCaXRzPS10LndpbmRvd0JpdHM6dC5nemlwJiZ0LndpbmRvd0JpdHM+MCYmdC53aW5kb3dCaXRzPDE2JiYodC53aW5kb3dCaXRzKz0xNiksdGhpcy5lcnI9MCx0aGlzLm1zZz0iIix0aGlzLmVuZGVkPSExLHRoaXMuY2h1bmtzPVtdLHRoaXMuc3RybT1uZXcgWWUsdGhpcy5zdHJtLmF2YWlsX291dD0wO2xldCBBPVBlKHRoaXMuc3RybSx0LmxldmVsLHQubWV0aG9kLHQud2luZG93Qml0cyx0Lm1lbUxldmVsLHQuc3RyYXRlZ3kpO2lmKEEhPT1BdCl0aHJvdyBuZXcgRXJyb3IoT1tBXSk7aWYodC5oZWFkZXImJlRlKHRoaXMuc3RybSx0LmhlYWRlciksdC5kaWN0aW9uYXJ5KXtsZXQgZTtpZihlPSJzdHJpbmciPT10eXBlb2YgdC5kaWN0aW9uYXJ5P3FlKHQuZGljdGlvbmFyeSk6IltvYmplY3QgQXJyYXlCdWZmZXJdIj09PUplLmNhbGwodC5kaWN0aW9uYXJ5KT9uZXcgVWludDhBcnJheSh0LmRpY3Rpb25hcnkpOnQuZGljdGlvbmFyeSxBPURlKHRoaXMuc3RybSxlKSxBIT09QXQpdGhyb3cgbmV3IEVycm9yKE9bQV0pO3RoaXMuX2RpY3Rfc2V0PSEwfX1mdW5jdGlvbiBhdChlLHQpe2NvbnN0IEE9bmV3IG90KHQpO2lmKEEucHVzaChlLCEwKSxBLmVycil0aHJvdyBBLm1zZ3x8T1tBLmVycl07cmV0dXJuIEEucmVzdWx0fW90LnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGUsdCl7Y29uc3QgQT10aGlzLnN0cm0scj10aGlzLm9wdGlvbnMuY2h1bmtTaXplO2xldCBuLHM7aWYodGhpcy5lbmRlZClyZXR1cm4hMTtmb3Iocz10PT09fn50P3Q6ITA9PT10P3R0OlplLCJzdHJpbmciPT10eXBlb2YgZT9BLmlucHV0PXFlKGUpOiJbb2JqZWN0IEFycmF5QnVmZmVyXSI9PT1KZS5jYWxsKGUpP0EuaW5wdXQ9bmV3IFVpbnQ4QXJyYXkoZSk6QS5pbnB1dD1lLEEubmV4dF9pbj0wLEEuYXZhaWxfaW49QS5pbnB1dC5sZW5ndGg7OylpZigwPT09QS5hdmFpbF9vdXQmJihBLm91dHB1dD1uZXcgVWludDhBcnJheShyKSxBLm5leHRfb3V0PTAsQS5hdmFpbF9vdXQ9ciksKHM9PT0kZXx8cz09PWV0KSYmQS5hdmFpbF9vdXQ8PTYpdGhpcy5vbkRhdGEoQS5vdXRwdXQuc3ViYXJyYXkoMCxBLm5leHRfb3V0KSksQS5hdmFpbF9vdXQ9MDtlbHNle2lmKG49T2UoQSxzKSxuPT09cnQpcmV0dXJuIEEubmV4dF9vdXQ+MCYmdGhpcy5vbkRhdGEoQS5vdXRwdXQuc3ViYXJyYXkoMCxBLm5leHRfb3V0KSksbj1NZSh0aGlzLnN0cm0pLHRoaXMub25FbmQobiksdGhpcy5lbmRlZD0hMCxuPT09QXQ7aWYoMCE9PUEuYXZhaWxfb3V0KXtpZihzPjAmJkEubmV4dF9vdXQ+MCl0aGlzLm9uRGF0YShBLm91dHB1dC5zdWJhcnJheSgwLEEubmV4dF9vdXQpKSxBLmF2YWlsX291dD0wO2Vsc2UgaWYoMD09PUEuYXZhaWxfaW4pYnJlYWt9ZWxzZSB0aGlzLm9uRGF0YShBLm91dHB1dCl9cmV0dXJuITB9LG90LnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24oZSl7dGhpcy5jaHVua3MucHVzaChlKX0sb3QucHJvdG90eXBlLm9uRW5kPWZ1bmN0aW9uKGUpe2U9PT1BdCYmKHRoaXMucmVzdWx0PVZlKHRoaXMuY2h1bmtzKSksdGhpcy5jaHVua3M9W10sdGhpcy5lcnI9ZSx0aGlzLm1zZz10aGlzLnN0cm0ubXNnfTt2YXIgbHQ9e0RlZmxhdGU6b3QsZGVmbGF0ZTphdCxkZWZsYXRlUmF3OmZ1bmN0aW9uKGUsdCl7cmV0dXJuKHQ9dHx8e30pLnJhdz0hMCxhdChlLHQpfSxnemlwOmZ1bmN0aW9uKGUsdCl7cmV0dXJuKHQ9dHx8e30pLmd6aXA9ITAsYXQoZSx0KX0sY29uc3RhbnRzOk19O2NvbnN0IGN0PTE2MjA5O3ZhciB1dD1mdW5jdGlvbihlLHQpe2xldCBBLHIsbixzLGksbyxhLGwsYyx1LGgsZCxmLHAsZyxtLHcsQix5LHYsYixDLF8sajtjb25zdCB4PWUuc3RhdGU7QT1lLm5leHRfaW4sXz1lLmlucHV0LHI9QSsoZS5hdmFpbF9pbi01KSxuPWUubmV4dF9vdXQsaj1lLm91dHB1dCxzPW4tKHQtZS5hdmFpbF9vdXQpLGk9bisoZS5hdmFpbF9vdXQtMjU3KSxvPXguZG1heCxhPXgud3NpemUsbD14LndoYXZlLGM9eC53bmV4dCx1PXgud2luZG93LGg9eC5ob2xkLGQ9eC5iaXRzLGY9eC5sZW5jb2RlLHA9eC5kaXN0Y29kZSxnPSgxPDx4LmxlbmJpdHMpLTEsbT0oMTw8eC5kaXN0Yml0cyktMTtlOmRve2Q8MTUmJihoKz1fW0ErK108PGQsZCs9OCxoKz1fW0ErK108PGQsZCs9OCksdz1mW2gmZ107dDpmb3IoOzspe2lmKEI9dz4+PjI0LGg+Pj49QixkLT1CLEI9dz4+PjE2JjI1NSwwPT09QilqW24rK109NjU1MzUmdztlbHNle2lmKCEoMTYmQikpe2lmKDY0JkIpe2lmKDMyJkIpe3gubW9kZT0xNjE5MTticmVhayBlfWUubXNnPSJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUiLHgubW9kZT1jdDticmVhayBlfXc9ZlsoNjU1MzUmdykrKGgmKDE8PEIpLTEpXTtjb250aW51ZSB0fWZvcih5PTY1NTM1JncsQiY9MTUsQiYmKGQ8QiYmKGgrPV9bQSsrXTw8ZCxkKz04KSx5Kz1oJigxPDxCKS0xLGg+Pj49QixkLT1CKSxkPDE1JiYoaCs9X1tBKytdPDxkLGQrPTgsaCs9X1tBKytdPDxkLGQrPTgpLHc9cFtoJm1dOzspe2lmKEI9dz4+PjI0LGg+Pj49QixkLT1CLEI9dz4+PjE2JjI1NSwxNiZCKXtpZih2PTY1NTM1JncsQiY9MTUsZDxCJiYoaCs9X1tBKytdPDxkLGQrPTgsZDxCJiYoaCs9X1tBKytdPDxkLGQrPTgpKSx2Kz1oJigxPDxCKS0xLHY+byl7ZS5tc2c9ImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIix4Lm1vZGU9Y3Q7YnJlYWsgZX1pZihoPj4+PUIsZC09QixCPW4tcyx2PkIpe2lmKEI9di1CLEI+bCYmeC5zYW5lKXtlLm1zZz0iaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siLHgubW9kZT1jdDticmVhayBlfWlmKGI9MCxDPXUsMD09PWMpe2lmKGIrPWEtQixCPHkpe3ktPUI7ZG97altuKytdPXVbYisrXX13aGlsZSgtLUIpO2I9bi12LEM9an19ZWxzZSBpZihjPEIpe2lmKGIrPWErYy1CLEItPWMsQjx5KXt5LT1CO2Rve2pbbisrXT11W2IrK119d2hpbGUoLS1CKTtpZihiPTAsYzx5KXtCPWMseS09Qjtkb3tqW24rK109dVtiKytdfXdoaWxlKC0tQik7Yj1uLXYsQz1qfX19ZWxzZSBpZihiKz1jLUIsQjx5KXt5LT1CO2Rve2pbbisrXT11W2IrK119d2hpbGUoLS1CKTtiPW4tdixDPWp9Zm9yKDt5PjI7KWpbbisrXT1DW2IrK10saltuKytdPUNbYisrXSxqW24rK109Q1tiKytdLHktPTM7eSYmKGpbbisrXT1DW2IrK10seT4xJiYoaltuKytdPUNbYisrXSkpfWVsc2V7Yj1uLXY7ZG97altuKytdPWpbYisrXSxqW24rK109altiKytdLGpbbisrXT1qW2IrK10seS09M313aGlsZSh5PjIpO3kmJihqW24rK109altiKytdLHk+MSYmKGpbbisrXT1qW2IrK10pKX1icmVha31pZig2NCZCKXtlLm1zZz0iaW52YWxpZCBkaXN0YW5jZSBjb2RlIix4Lm1vZGU9Y3Q7YnJlYWsgZX13PXBbKDY1NTM1JncpKyhoJigxPDxCKS0xKV19fWJyZWFrfX13aGlsZShBPHImJm48aSk7eT1kPj4zLEEtPXksZC09eTw8MyxoJj0oMTw8ZCktMSxlLm5leHRfaW49QSxlLm5leHRfb3V0PW4sZS5hdmFpbF9pbj1BPHI/ci1BKzU6NS0oQS1yKSxlLmF2YWlsX291dD1uPGk/aS1uKzI1NzoyNTctKG4taSkseC5ob2xkPWgseC5iaXRzPWR9O2NvbnN0IGh0PW5ldyBVaW50MTZBcnJheShbMyw0LDUsNiw3LDgsOSwxMCwxMSwxMywxNSwxNywxOSwyMywyNywzMSwzNSw0Myw1MSw1OSw2Nyw4Myw5OSwxMTUsMTMxLDE2MywxOTUsMjI3LDI1OCwwLDBdKSxkdD1uZXcgVWludDhBcnJheShbMTYsMTYsMTYsMTYsMTYsMTYsMTYsMTYsMTcsMTcsMTcsMTcsMTgsMTgsMTgsMTgsMTksMTksMTksMTksMjAsMjAsMjAsMjAsMjEsMjEsMjEsMjEsMTYsNzIsNzhdKSxmdD1uZXcgVWludDE2QXJyYXkoWzEsMiwzLDQsNSw3LDksMTMsMTcsMjUsMzMsNDksNjUsOTcsMTI5LDE5MywyNTcsMzg1LDUxMyw3NjksMTAyNSwxNTM3LDIwNDksMzA3Myw0MDk3LDYxNDUsODE5MywxMjI4OSwxNjM4NSwyNDU3NywwLDBdKSxwdD1uZXcgVWludDhBcnJheShbMTYsMTYsMTYsMTYsMTcsMTcsMTgsMTgsMTksMTksMjAsMjAsMjEsMjEsMjIsMjIsMjMsMjMsMjQsMjQsMjUsMjUsMjYsMjYsMjcsMjcsMjgsMjgsMjksMjksNjQsNjRdKTt2YXIgZ3Q9KGUsdCxBLHIsbixzLGksbyk9Pntjb25zdCBhPW8uYml0cztsZXQgbCxjLHUsaCxkLGYscD0wLGc9MCxtPTAsdz0wLEI9MCx5PTAsdj0wLGI9MCxDPTAsXz0wLGo9bnVsbDtjb25zdCB4PW5ldyBVaW50MTZBcnJheSgxNiksRj1uZXcgVWludDE2QXJyYXkoMTYpO2xldCBRLFUsRSxTPW51bGw7Zm9yKHA9MDtwPD0xNTtwKyspeFtwXT0wO2ZvcihnPTA7ZzxyO2crKyl4W3RbQStnXV0rKztmb3IoQj1hLHc9MTU7dz49MSYmMD09PXhbd107dy0tKTtpZihCPncmJihCPXcpLDA9PT13KXJldHVybiBuW3MrK109MjA5NzE1MjAsbltzKytdPTIwOTcxNTIwLG8uYml0cz0xLDA7Zm9yKG09MTttPHcmJjA9PT14W21dO20rKyk7Zm9yKEI8bSYmKEI9bSksYj0xLHA9MTtwPD0xNTtwKyspaWYoYjw8PTEsYi09eFtwXSxiPDApcmV0dXJuLTE7aWYoYj4wJiYoMD09PWV8fDEhPT13KSlyZXR1cm4tMTtmb3IoRlsxXT0wLHA9MTtwPDE1O3ArKylGW3ArMV09RltwXSt4W3BdO2ZvcihnPTA7ZzxyO2crKykwIT09dFtBK2ddJiYoaVtGW3RbQStnXV0rK109Zyk7aWYoMD09PWU/KGo9Uz1pLGY9MjApOjE9PT1lPyhqPWh0LFM9ZHQsZj0yNTcpOihqPWZ0LFM9cHQsZj0wKSxfPTAsZz0wLHA9bSxkPXMseT1CLHY9MCx1PS0xLEM9MTw8QixoPUMtMSwxPT09ZSYmQz44NTJ8fDI9PT1lJiZDPjU5MilyZXR1cm4gMTtmb3IoOzspe1E9cC12LGlbZ10rMTxmPyhVPTAsRT1pW2ddKTppW2ddPj1mPyhVPVNbaVtnXS1mXSxFPWpbaVtnXS1mXSk6KFU9OTYsRT0wKSxsPTE8PHAtdixjPTE8PHksbT1jO2Rve2MtPWwsbltkKyhfPj52KStjXT1RPDwyNHxVPDwxNnxFfXdoaWxlKDAhPT1jKTtmb3IobD0xPDxwLTE7XyZsOylsPj49MTtpZigwIT09bD8oXyY9bC0xLF8rPWwpOl89MCxnKyssMD09PS0teFtwXSl7aWYocD09PXcpYnJlYWs7cD10W0EraVtnXV19aWYocD5CJiYoXyZoKSE9PXUpe2ZvcigwPT09diYmKHY9QiksZCs9bSx5PXAtdixiPTE8PHk7eSt2PHcmJihiLT14W3krdl0sIShiPD0wKSk7KXkrKyxiPDw9MTtpZihDKz0xPDx5LDE9PT1lJiZDPjg1Mnx8Mj09PWUmJkM+NTkyKXJldHVybiAxO3U9XyZoLG5bdV09Qjw8MjR8eTw8MTZ8ZC1zfX1yZXR1cm4gMCE9PV8mJihuW2QrX109cC12PDwyNHw2NDw8MTYpLG8uYml0cz1CLDB9O2NvbnN0e1pfRklOSVNIOm10LFpfQkxPQ0s6d3QsWl9UUkVFUzpCdCxaX09LOnl0LFpfU1RSRUFNX0VORDp2dCxaX05FRURfRElDVDpidCxaX1NUUkVBTV9FUlJPUjpDdCxaX0RBVEFfRVJST1I6X3QsWl9NRU1fRVJST1I6anQsWl9CVUZfRVJST1I6eHQsWl9ERUZMQVRFRDpGdH09TSxRdD0xNjE4MCxVdD0xNjE5MCxFdD0xNjE5MSxTdD0xNjE5MixMdD0xNjE5NCxJdD0xNjE5OSxOdD0xNjIwMCxrdD0xNjIwNixIdD0xNjIwOSxQdD1lPT4oZT4+PjI0JjI1NSkrKGU+Pj44JjY1MjgwKSsoKDY1MjgwJmUpPDw4KSsoKDI1NSZlKTw8MjQpO2Z1bmN0aW9uIFR0KCl7dGhpcy5zdHJtPW51bGwsdGhpcy5tb2RlPTAsdGhpcy5sYXN0PSExLHRoaXMud3JhcD0wLHRoaXMuaGF2ZWRpY3Q9ITEsdGhpcy5mbGFncz0wLHRoaXMuZG1heD0wLHRoaXMuY2hlY2s9MCx0aGlzLnRvdGFsPTAsdGhpcy5oZWFkPW51bGwsdGhpcy53Yml0cz0wLHRoaXMud3NpemU9MCx0aGlzLndoYXZlPTAsdGhpcy53bmV4dD0wLHRoaXMud2luZG93PW51bGwsdGhpcy5ob2xkPTAsdGhpcy5iaXRzPTAsdGhpcy5sZW5ndGg9MCx0aGlzLm9mZnNldD0wLHRoaXMuZXh0cmE9MCx0aGlzLmxlbmNvZGU9bnVsbCx0aGlzLmRpc3Rjb2RlPW51bGwsdGhpcy5sZW5iaXRzPTAsdGhpcy5kaXN0Yml0cz0wLHRoaXMubmNvZGU9MCx0aGlzLm5sZW49MCx0aGlzLm5kaXN0PTAsdGhpcy5oYXZlPTAsdGhpcy5uZXh0PW51bGwsdGhpcy5sZW5zPW5ldyBVaW50MTZBcnJheSgzMjApLHRoaXMud29yaz1uZXcgVWludDE2QXJyYXkoMjg4KSx0aGlzLmxlbmR5bj1udWxsLHRoaXMuZGlzdGR5bj1udWxsLHRoaXMuc2FuZT0wLHRoaXMuYmFjaz0wLHRoaXMud2FzPTB9Y29uc3QgT3Q9ZT0+e2lmKCFlKXJldHVybiAxO2NvbnN0IHQ9ZS5zdGF0ZTtyZXR1cm4hdHx8dC5zdHJtIT09ZXx8dC5tb2RlPFF0fHx0Lm1vZGU+MTYyMTE/MTowfSxNdD1lPT57aWYoT3QoZSkpcmV0dXJuIEN0O2NvbnN0IHQ9ZS5zdGF0ZTtyZXR1cm4gZS50b3RhbF9pbj1lLnRvdGFsX291dD10LnRvdGFsPTAsZS5tc2c9IiIsdC53cmFwJiYoZS5hZGxlcj0xJnQud3JhcCksdC5tb2RlPVF0LHQubGFzdD0wLHQuaGF2ZWRpY3Q9MCx0LmZsYWdzPS0xLHQuZG1heD0zMjc2OCx0LmhlYWQ9bnVsbCx0LmhvbGQ9MCx0LmJpdHM9MCx0LmxlbmNvZGU9dC5sZW5keW49bmV3IEludDMyQXJyYXkoODUyKSx0LmRpc3Rjb2RlPXQuZGlzdGR5bj1uZXcgSW50MzJBcnJheSg1OTIpLHQuc2FuZT0xLHQuYmFjaz0tMSx5dH0sRHQ9ZT0+e2lmKE90KGUpKXJldHVybiBDdDtjb25zdCB0PWUuc3RhdGU7cmV0dXJuIHQud3NpemU9MCx0LndoYXZlPTAsdC53bmV4dD0wLE10KGUpfSxSdD0oZSx0KT0+e2xldCBBO2lmKE90KGUpKXJldHVybiBDdDtjb25zdCByPWUuc3RhdGU7cmV0dXJuIHQ8MD8oQT0wLHQ9LXQpOihBPTUrKHQ+PjQpLHQ8NDgmJih0Jj0xNSkpLHQmJih0PDh8fHQ+MTUpP0N0OihudWxsIT09ci53aW5kb3cmJnIud2JpdHMhPT10JiYoci53aW5kb3c9bnVsbCksci53cmFwPUEsci53Yml0cz10LER0KGUpKX0sS3Q9KGUsdCk9PntpZighZSlyZXR1cm4gQ3Q7Y29uc3QgQT1uZXcgVHQ7ZS5zdGF0ZT1BLEEuc3RybT1lLEEud2luZG93PW51bGwsQS5tb2RlPVF0O2NvbnN0IHI9UnQoZSx0KTtyZXR1cm4gciE9PXl0JiYoZS5zdGF0ZT1udWxsKSxyfTtsZXQgVnQsR3QsenQ9ITA7Y29uc3QgcXQ9ZT0+e2lmKHp0KXtWdD1uZXcgSW50MzJBcnJheSg1MTIpLEd0PW5ldyBJbnQzMkFycmF5KDMyKTtsZXQgdD0wO2Zvcig7dDwxNDQ7KWUubGVuc1t0KytdPTg7Zm9yKDt0PDI1NjspZS5sZW5zW3QrK109OTtmb3IoO3Q8MjgwOyllLmxlbnNbdCsrXT03O2Zvcig7dDwyODg7KWUubGVuc1t0KytdPTg7Zm9yKGd0KDEsZS5sZW5zLDAsMjg4LFZ0LDAsZS53b3JrLHtiaXRzOjl9KSx0PTA7dDwzMjspZS5sZW5zW3QrK109NTtndCgyLGUubGVucywwLDMyLEd0LDAsZS53b3JrLHtiaXRzOjV9KSx6dD0hMX1lLmxlbmNvZGU9VnQsZS5sZW5iaXRzPTksZS5kaXN0Y29kZT1HdCxlLmRpc3RiaXRzPTV9LFd0PShlLHQsQSxyKT0+e2xldCBuO2NvbnN0IHM9ZS5zdGF0ZTtyZXR1cm4gbnVsbD09PXMud2luZG93JiYocy53c2l6ZT0xPDxzLndiaXRzLHMud25leHQ9MCxzLndoYXZlPTAscy53aW5kb3c9bmV3IFVpbnQ4QXJyYXkocy53c2l6ZSkpLHI+PXMud3NpemU/KHMud2luZG93LnNldCh0LnN1YmFycmF5KEEtcy53c2l6ZSxBKSwwKSxzLnduZXh0PTAscy53aGF2ZT1zLndzaXplKToobj1zLndzaXplLXMud25leHQsbj5yJiYobj1yKSxzLndpbmRvdy5zZXQodC5zdWJhcnJheShBLXIsQS1yK24pLHMud25leHQpLChyLT1uKT8ocy53aW5kb3cuc2V0KHQuc3ViYXJyYXkoQS1yLEEpLDApLHMud25leHQ9cixzLndoYXZlPXMud3NpemUpOihzLnduZXh0Kz1uLHMud25leHQ9PT1zLndzaXplJiYocy53bmV4dD0wKSxzLndoYXZlPHMud3NpemUmJihzLndoYXZlKz1uKSkpLDB9O3ZhciBYdD1EdCxZdD1LdCxKdD0oZSx0KT0+e2xldCBBLHIsbixzLGksbyxhLGwsYyx1LGgsZCxmLHAsZyxtLHcsQix5LHYsYixDLF89MDtjb25zdCBqPW5ldyBVaW50OEFycmF5KDQpO2xldCB4LEY7Y29uc3QgUT1uZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pO2lmKE90KGUpfHwhZS5vdXRwdXR8fCFlLmlucHV0JiYwIT09ZS5hdmFpbF9pbilyZXR1cm4gQ3Q7QT1lLnN0YXRlLEEubW9kZT09PUV0JiYoQS5tb2RlPVN0KSxpPWUubmV4dF9vdXQsbj1lLm91dHB1dCxhPWUuYXZhaWxfb3V0LHM9ZS5uZXh0X2luLHI9ZS5pbnB1dCxvPWUuYXZhaWxfaW4sbD1BLmhvbGQsYz1BLmJpdHMsdT1vLGg9YSxDPXl0O2U6Zm9yKDs7KXN3aXRjaChBLm1vZGUpe2Nhc2UgUXQ6aWYoMD09PUEud3JhcCl7QS5tb2RlPVN0O2JyZWFrfWZvcig7YzwxNjspe2lmKDA9PT1vKWJyZWFrIGU7by0tLGwrPXJbcysrXTw8YyxjKz04fWlmKDImQS53cmFwJiYzNTYxNT09PWwpezA9PT1BLndiaXRzJiYoQS53Yml0cz0xNSksQS5jaGVjaz0wLGpbMF09MjU1JmwsalsxXT1sPj4+OCYyNTUsQS5jaGVjaz1UKEEuY2hlY2ssaiwyLDApLGw9MCxjPTAsQS5tb2RlPTE2MTgxO2JyZWFrfWlmKEEuaGVhZCYmKEEuaGVhZC5kb25lPSExKSwhKDEmQS53cmFwKXx8KCgoMjU1JmwpPDw4KSsobD4+OCkpJTMxKXtlLm1zZz0iaW5jb3JyZWN0IGhlYWRlciBjaGVjayIsQS5tb2RlPUh0O2JyZWFrfWlmKCgxNSZsKSE9PUZ0KXtlLm1zZz0idW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiLEEubW9kZT1IdDticmVha31pZihsPj4+PTQsYy09NCxiPTgrKDE1JmwpLDA9PT1BLndiaXRzJiYoQS53Yml0cz1iKSxiPjE1fHxiPkEud2JpdHMpe2UubXNnPSJpbnZhbGlkIHdpbmRvdyBzaXplIixBLm1vZGU9SHQ7YnJlYWt9QS5kbWF4PTE8PEEud2JpdHMsQS5mbGFncz0wLGUuYWRsZXI9QS5jaGVjaz0xLEEubW9kZT01MTImbD8xNjE4OTpFdCxsPTAsYz0wO2JyZWFrO2Nhc2UgMTYxODE6Zm9yKDtjPDE2Oyl7aWYoMD09PW8pYnJlYWsgZTtvLS0sbCs9cltzKytdPDxjLGMrPTh9aWYoQS5mbGFncz1sLCgyNTUmQS5mbGFncykhPT1GdCl7ZS5tc2c9InVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIixBLm1vZGU9SHQ7YnJlYWt9aWYoNTczNDQmQS5mbGFncyl7ZS5tc2c9InVua25vd24gaGVhZGVyIGZsYWdzIHNldCIsQS5tb2RlPUh0O2JyZWFrfUEuaGVhZCYmKEEuaGVhZC50ZXh0PWw+PjgmMSksNTEyJkEuZmxhZ3MmJjQmQS53cmFwJiYoalswXT0yNTUmbCxqWzFdPWw+Pj44JjI1NSxBLmNoZWNrPVQoQS5jaGVjayxqLDIsMCkpLGw9MCxjPTAsQS5tb2RlPTE2MTgyO2Nhc2UgMTYxODI6Zm9yKDtjPDMyOyl7aWYoMD09PW8pYnJlYWsgZTtvLS0sbCs9cltzKytdPDxjLGMrPTh9QS5oZWFkJiYoQS5oZWFkLnRpbWU9bCksNTEyJkEuZmxhZ3MmJjQmQS53cmFwJiYoalswXT0yNTUmbCxqWzFdPWw+Pj44JjI1NSxqWzJdPWw+Pj4xNiYyNTUsalszXT1sPj4+MjQmMjU1LEEuY2hlY2s9VChBLmNoZWNrLGosNCwwKSksbD0wLGM9MCxBLm1vZGU9MTYxODM7Y2FzZSAxNjE4Mzpmb3IoO2M8MTY7KXtpZigwPT09bylicmVhayBlO28tLSxsKz1yW3MrK108PGMsYys9OH1BLmhlYWQmJihBLmhlYWQueGZsYWdzPTI1NSZsLEEuaGVhZC5vcz1sPj44KSw1MTImQS5mbGFncyYmNCZBLndyYXAmJihqWzBdPTI1NSZsLGpbMV09bD4+PjgmMjU1LEEuY2hlY2s9VChBLmNoZWNrLGosMiwwKSksbD0wLGM9MCxBLm1vZGU9MTYxODQ7Y2FzZSAxNjE4NDppZigxMDI0JkEuZmxhZ3Mpe2Zvcig7YzwxNjspe2lmKDA9PT1vKWJyZWFrIGU7by0tLGwrPXJbcysrXTw8YyxjKz04fUEubGVuZ3RoPWwsQS5oZWFkJiYoQS5oZWFkLmV4dHJhX2xlbj1sKSw1MTImQS5mbGFncyYmNCZBLndyYXAmJihqWzBdPTI1NSZsLGpbMV09bD4+PjgmMjU1LEEuY2hlY2s9VChBLmNoZWNrLGosMiwwKSksbD0wLGM9MH1lbHNlIEEuaGVhZCYmKEEuaGVhZC5leHRyYT1udWxsKTtBLm1vZGU9MTYxODU7Y2FzZSAxNjE4NTppZigxMDI0JkEuZmxhZ3MmJihkPUEubGVuZ3RoLGQ+byYmKGQ9byksZCYmKEEuaGVhZCYmKGI9QS5oZWFkLmV4dHJhX2xlbi1BLmxlbmd0aCxBLmhlYWQuZXh0cmF8fChBLmhlYWQuZXh0cmE9bmV3IFVpbnQ4QXJyYXkoQS5oZWFkLmV4dHJhX2xlbikpLEEuaGVhZC5leHRyYS5zZXQoci5zdWJhcnJheShzLHMrZCksYikpLDUxMiZBLmZsYWdzJiY0JkEud3JhcCYmKEEuY2hlY2s9VChBLmNoZWNrLHIsZCxzKSksby09ZCxzKz1kLEEubGVuZ3RoLT1kKSxBLmxlbmd0aCkpYnJlYWsgZTtBLmxlbmd0aD0wLEEubW9kZT0xNjE4NjtjYXNlIDE2MTg2OmlmKDIwNDgmQS5mbGFncyl7aWYoMD09PW8pYnJlYWsgZTtkPTA7ZG97Yj1yW3MrZCsrXSxBLmhlYWQmJmImJkEubGVuZ3RoPDY1NTM2JiYoQS5oZWFkLm5hbWUrPVN0cmluZy5mcm9tQ2hhckNvZGUoYikpfXdoaWxlKGImJmQ8byk7aWYoNTEyJkEuZmxhZ3MmJjQmQS53cmFwJiYoQS5jaGVjaz1UKEEuY2hlY2sscixkLHMpKSxvLT1kLHMrPWQsYilicmVhayBlfWVsc2UgQS5oZWFkJiYoQS5oZWFkLm5hbWU9bnVsbCk7QS5sZW5ndGg9MCxBLm1vZGU9MTYxODc7Y2FzZSAxNjE4NzppZig0MDk2JkEuZmxhZ3Mpe2lmKDA9PT1vKWJyZWFrIGU7ZD0wO2Rve2I9cltzK2QrK10sQS5oZWFkJiZiJiZBLmxlbmd0aDw2NTUzNiYmKEEuaGVhZC5jb21tZW50Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGIpKX13aGlsZShiJiZkPG8pO2lmKDUxMiZBLmZsYWdzJiY0JkEud3JhcCYmKEEuY2hlY2s9VChBLmNoZWNrLHIsZCxzKSksby09ZCxzKz1kLGIpYnJlYWsgZX1lbHNlIEEuaGVhZCYmKEEuaGVhZC5jb21tZW50PW51bGwpO0EubW9kZT0xNjE4ODtjYXNlIDE2MTg4OmlmKDUxMiZBLmZsYWdzKXtmb3IoO2M8MTY7KXtpZigwPT09bylicmVhayBlO28tLSxsKz1yW3MrK108PGMsYys9OH1pZig0JkEud3JhcCYmbCE9PSg2NTUzNSZBLmNoZWNrKSl7ZS5tc2c9ImhlYWRlciBjcmMgbWlzbWF0Y2giLEEubW9kZT1IdDticmVha31sPTAsYz0wfUEuaGVhZCYmKEEuaGVhZC5oY3JjPUEuZmxhZ3M+PjkmMSxBLmhlYWQuZG9uZT0hMCksZS5hZGxlcj1BLmNoZWNrPTAsQS5tb2RlPUV0O2JyZWFrO2Nhc2UgMTYxODk6Zm9yKDtjPDMyOyl7aWYoMD09PW8pYnJlYWsgZTtvLS0sbCs9cltzKytdPDxjLGMrPTh9ZS5hZGxlcj1BLmNoZWNrPVB0KGwpLGw9MCxjPTAsQS5tb2RlPVV0O2Nhc2UgVXQ6aWYoMD09PUEuaGF2ZWRpY3QpcmV0dXJuIGUubmV4dF9vdXQ9aSxlLmF2YWlsX291dD1hLGUubmV4dF9pbj1zLGUuYXZhaWxfaW49byxBLmhvbGQ9bCxBLmJpdHM9YyxidDtlLmFkbGVyPUEuY2hlY2s9MSxBLm1vZGU9RXQ7Y2FzZSBFdDppZih0PT09d3R8fHQ9PT1CdClicmVhayBlO2Nhc2UgU3Q6aWYoQS5sYXN0KXtsPj4+PTcmYyxjLT03JmMsQS5tb2RlPWt0O2JyZWFrfWZvcig7YzwzOyl7aWYoMD09PW8pYnJlYWsgZTtvLS0sbCs9cltzKytdPDxjLGMrPTh9c3dpdGNoKEEubGFzdD0xJmwsbD4+Pj0xLGMtPTEsMyZsKXtjYXNlIDA6QS5tb2RlPTE2MTkzO2JyZWFrO2Nhc2UgMTppZihxdChBKSxBLm1vZGU9SXQsdD09PUJ0KXtsPj4+PTIsYy09MjticmVhayBlfWJyZWFrO2Nhc2UgMjpBLm1vZGU9MTYxOTY7YnJlYWs7Y2FzZSAzOmUubXNnPSJpbnZhbGlkIGJsb2NrIHR5cGUiLEEubW9kZT1IdH1sPj4+PTIsYy09MjticmVhaztjYXNlIDE2MTkzOmZvcihsPj4+PTcmYyxjLT03JmM7YzwzMjspe2lmKDA9PT1vKWJyZWFrIGU7by0tLGwrPXJbcysrXTw8YyxjKz04fWlmKCg2NTUzNSZsKSE9KGw+Pj4xNl42NTUzNSkpe2UubXNnPSJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzIixBLm1vZGU9SHQ7YnJlYWt9aWYoQS5sZW5ndGg9NjU1MzUmbCxsPTAsYz0wLEEubW9kZT1MdCx0PT09QnQpYnJlYWsgZTtjYXNlIEx0OkEubW9kZT0xNjE5NTtjYXNlIDE2MTk1OmlmKGQ9QS5sZW5ndGgsZCl7aWYoZD5vJiYoZD1vKSxkPmEmJihkPWEpLDA9PT1kKWJyZWFrIGU7bi5zZXQoci5zdWJhcnJheShzLHMrZCksaSksby09ZCxzKz1kLGEtPWQsaSs9ZCxBLmxlbmd0aC09ZDticmVha31BLm1vZGU9RXQ7YnJlYWs7Y2FzZSAxNjE5Njpmb3IoO2M8MTQ7KXtpZigwPT09bylicmVhayBlO28tLSxsKz1yW3MrK108PGMsYys9OH1pZihBLm5sZW49MjU3KygzMSZsKSxsPj4+PTUsYy09NSxBLm5kaXN0PTErKDMxJmwpLGw+Pj49NSxjLT01LEEubmNvZGU9NCsoMTUmbCksbD4+Pj00LGMtPTQsQS5ubGVuPjI4Nnx8QS5uZGlzdD4zMCl7ZS5tc2c9InRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzIixBLm1vZGU9SHQ7YnJlYWt9QS5oYXZlPTAsQS5tb2RlPTE2MTk3O2Nhc2UgMTYxOTc6Zm9yKDtBLmhhdmU8QS5uY29kZTspe2Zvcig7YzwzOyl7aWYoMD09PW8pYnJlYWsgZTtvLS0sbCs9cltzKytdPDxjLGMrPTh9QS5sZW5zW1FbQS5oYXZlKytdXT03JmwsbD4+Pj0zLGMtPTN9Zm9yKDtBLmhhdmU8MTk7KUEubGVuc1tRW0EuaGF2ZSsrXV09MDtpZihBLmxlbmNvZGU9QS5sZW5keW4sQS5sZW5iaXRzPTcseD17Yml0czpBLmxlbmJpdHN9LEM9Z3QoMCxBLmxlbnMsMCwxOSxBLmxlbmNvZGUsMCxBLndvcmsseCksQS5sZW5iaXRzPXguYml0cyxDKXtlLm1zZz0iaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0IixBLm1vZGU9SHQ7YnJlYWt9QS5oYXZlPTAsQS5tb2RlPTE2MTk4O2Nhc2UgMTYxOTg6Zm9yKDtBLmhhdmU8QS5ubGVuK0EubmRpc3Q7KXtmb3IoO189QS5sZW5jb2RlW2wmKDE8PEEubGVuYml0cyktMV0sZz1fPj4+MjQsbT1fPj4+MTYmMjU1LHc9NjU1MzUmXywhKGc8PWMpOyl7aWYoMD09PW8pYnJlYWsgZTtvLS0sbCs9cltzKytdPDxjLGMrPTh9aWYodzwxNilsPj4+PWcsYy09ZyxBLmxlbnNbQS5oYXZlKytdPXc7ZWxzZXtpZigxNj09PXcpe2ZvcihGPWcrMjtjPEY7KXtpZigwPT09bylicmVhayBlO28tLSxsKz1yW3MrK108PGMsYys9OH1pZihsPj4+PWcsYy09ZywwPT09QS5oYXZlKXtlLm1zZz0iaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCIsQS5tb2RlPUh0O2JyZWFrfWI9QS5sZW5zW0EuaGF2ZS0xXSxkPTMrKDMmbCksbD4+Pj0yLGMtPTJ9ZWxzZSBpZigxNz09PXcpe2ZvcihGPWcrMztjPEY7KXtpZigwPT09bylicmVhayBlO28tLSxsKz1yW3MrK108PGMsYys9OH1sPj4+PWcsYy09ZyxiPTAsZD0zKyg3JmwpLGw+Pj49MyxjLT0zfWVsc2V7Zm9yKEY9Zys3O2M8Rjspe2lmKDA9PT1vKWJyZWFrIGU7by0tLGwrPXJbcysrXTw8YyxjKz04fWw+Pj49ZyxjLT1nLGI9MCxkPTExKygxMjcmbCksbD4+Pj03LGMtPTd9aWYoQS5oYXZlK2Q+QS5ubGVuK0EubmRpc3Qpe2UubXNnPSJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IixBLm1vZGU9SHQ7YnJlYWt9Zm9yKDtkLS07KUEubGVuc1tBLmhhdmUrK109Yn19aWYoQS5tb2RlPT09SHQpYnJlYWs7aWYoMD09PUEubGVuc1syNTZdKXtlLm1zZz0iaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrIixBLm1vZGU9SHQ7YnJlYWt9aWYoQS5sZW5iaXRzPTkseD17Yml0czpBLmxlbmJpdHN9LEM9Z3QoMSxBLmxlbnMsMCxBLm5sZW4sQS5sZW5jb2RlLDAsQS53b3JrLHgpLEEubGVuYml0cz14LmJpdHMsQyl7ZS5tc2c9ImludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCIsQS5tb2RlPUh0O2JyZWFrfWlmKEEuZGlzdGJpdHM9NixBLmRpc3Rjb2RlPUEuZGlzdGR5bix4PXtiaXRzOkEuZGlzdGJpdHN9LEM9Z3QoMixBLmxlbnMsQS5ubGVuLEEubmRpc3QsQS5kaXN0Y29kZSwwLEEud29yayx4KSxBLmRpc3RiaXRzPXguYml0cyxDKXtlLm1zZz0iaW52YWxpZCBkaXN0YW5jZXMgc2V0IixBLm1vZGU9SHQ7YnJlYWt9aWYoQS5tb2RlPUl0LHQ9PT1CdClicmVhayBlO2Nhc2UgSXQ6QS5tb2RlPU50O2Nhc2UgTnQ6aWYobz49NiYmYT49MjU4KXtlLm5leHRfb3V0PWksZS5hdmFpbF9vdXQ9YSxlLm5leHRfaW49cyxlLmF2YWlsX2luPW8sQS5ob2xkPWwsQS5iaXRzPWMsdXQoZSxoKSxpPWUubmV4dF9vdXQsbj1lLm91dHB1dCxhPWUuYXZhaWxfb3V0LHM9ZS5uZXh0X2luLHI9ZS5pbnB1dCxvPWUuYXZhaWxfaW4sbD1BLmhvbGQsYz1BLmJpdHMsQS5tb2RlPT09RXQmJihBLmJhY2s9LTEpO2JyZWFrfWZvcihBLmJhY2s9MDtfPUEubGVuY29kZVtsJigxPDxBLmxlbmJpdHMpLTFdLGc9Xz4+PjI0LG09Xz4+PjE2JjI1NSx3PTY1NTM1Jl8sIShnPD1jKTspe2lmKDA9PT1vKWJyZWFrIGU7by0tLGwrPXJbcysrXTw8YyxjKz04fWlmKG0mJiEoMjQwJm0pKXtmb3IoQj1nLHk9bSx2PXc7Xz1BLmxlbmNvZGVbdisoKGwmKDE8PEIreSktMSk+PkIpXSxnPV8+Pj4yNCxtPV8+Pj4xNiYyNTUsdz02NTUzNSZfLCEoQitnPD1jKTspe2lmKDA9PT1vKWJyZWFrIGU7by0tLGwrPXJbcysrXTw8YyxjKz04fWw+Pj49QixjLT1CLEEuYmFjays9Qn1pZihsPj4+PWcsYy09ZyxBLmJhY2srPWcsQS5sZW5ndGg9dywwPT09bSl7QS5tb2RlPTE2MjA1O2JyZWFrfWlmKDMyJm0pe0EuYmFjaz0tMSxBLm1vZGU9RXQ7YnJlYWt9aWYoNjQmbSl7ZS5tc2c9ImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSIsQS5tb2RlPUh0O2JyZWFrfUEuZXh0cmE9MTUmbSxBLm1vZGU9MTYyMDE7Y2FzZSAxNjIwMTppZihBLmV4dHJhKXtmb3IoRj1BLmV4dHJhO2M8Rjspe2lmKDA9PT1vKWJyZWFrIGU7by0tLGwrPXJbcysrXTw8YyxjKz04fUEubGVuZ3RoKz1sJigxPDxBLmV4dHJhKS0xLGw+Pj49QS5leHRyYSxjLT1BLmV4dHJhLEEuYmFjays9QS5leHRyYX1BLndhcz1BLmxlbmd0aCxBLm1vZGU9MTYyMDI7Y2FzZSAxNjIwMjpmb3IoO189QS5kaXN0Y29kZVtsJigxPDxBLmRpc3RiaXRzKS0xXSxnPV8+Pj4yNCxtPV8+Pj4xNiYyNTUsdz02NTUzNSZfLCEoZzw9Yyk7KXtpZigwPT09bylicmVhayBlO28tLSxsKz1yW3MrK108PGMsYys9OH1pZighKDI0MCZtKSl7Zm9yKEI9Zyx5PW0sdj13O189QS5kaXN0Y29kZVt2KygobCYoMTw8Qit5KS0xKT4+QildLGc9Xz4+PjI0LG09Xz4+PjE2JjI1NSx3PTY1NTM1Jl8sIShCK2c8PWMpOyl7aWYoMD09PW8pYnJlYWsgZTtvLS0sbCs9cltzKytdPDxjLGMrPTh9bD4+Pj1CLGMtPUIsQS5iYWNrKz1CfWlmKGw+Pj49ZyxjLT1nLEEuYmFjays9Zyw2NCZtKXtlLm1zZz0iaW52YWxpZCBkaXN0YW5jZSBjb2RlIixBLm1vZGU9SHQ7YnJlYWt9QS5vZmZzZXQ9dyxBLmV4dHJhPTE1Jm0sQS5tb2RlPTE2MjAzO2Nhc2UgMTYyMDM6aWYoQS5leHRyYSl7Zm9yKEY9QS5leHRyYTtjPEY7KXtpZigwPT09bylicmVhayBlO28tLSxsKz1yW3MrK108PGMsYys9OH1BLm9mZnNldCs9bCYoMTw8QS5leHRyYSktMSxsPj4+PUEuZXh0cmEsYy09QS5leHRyYSxBLmJhY2srPUEuZXh0cmF9aWYoQS5vZmZzZXQ+QS5kbWF4KXtlLm1zZz0iaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siLEEubW9kZT1IdDticmVha31BLm1vZGU9MTYyMDQ7Y2FzZSAxNjIwNDppZigwPT09YSlicmVhayBlO2lmKGQ9aC1hLEEub2Zmc2V0PmQpe2lmKGQ9QS5vZmZzZXQtZCxkPkEud2hhdmUmJkEuc2FuZSl7ZS5tc2c9ImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIixBLm1vZGU9SHQ7YnJlYWt9ZD5BLnduZXh0PyhkLT1BLnduZXh0LGY9QS53c2l6ZS1kKTpmPUEud25leHQtZCxkPkEubGVuZ3RoJiYoZD1BLmxlbmd0aCkscD1BLndpbmRvd31lbHNlIHA9bixmPWktQS5vZmZzZXQsZD1BLmxlbmd0aDtkPmEmJihkPWEpLGEtPWQsQS5sZW5ndGgtPWQ7ZG97bltpKytdPXBbZisrXX13aGlsZSgtLWQpOzA9PT1BLmxlbmd0aCYmKEEubW9kZT1OdCk7YnJlYWs7Y2FzZSAxNjIwNTppZigwPT09YSlicmVhayBlO25baSsrXT1BLmxlbmd0aCxhLS0sQS5tb2RlPU50O2JyZWFrO2Nhc2Uga3Q6aWYoQS53cmFwKXtmb3IoO2M8MzI7KXtpZigwPT09bylicmVhayBlO28tLSxsfD1yW3MrK108PGMsYys9OH1pZihoLT1hLGUudG90YWxfb3V0Kz1oLEEudG90YWwrPWgsNCZBLndyYXAmJmgmJihlLmFkbGVyPUEuY2hlY2s9QS5mbGFncz9UKEEuY2hlY2ssbixoLGktaCk6SChBLmNoZWNrLG4saCxpLWgpKSxoPWEsNCZBLndyYXAmJihBLmZsYWdzP2w6UHQobCkpIT09QS5jaGVjayl7ZS5tc2c9ImluY29ycmVjdCBkYXRhIGNoZWNrIixBLm1vZGU9SHQ7YnJlYWt9bD0wLGM9MH1BLm1vZGU9MTYyMDc7Y2FzZSAxNjIwNzppZihBLndyYXAmJkEuZmxhZ3Mpe2Zvcig7YzwzMjspe2lmKDA9PT1vKWJyZWFrIGU7by0tLGwrPXJbcysrXTw8YyxjKz04fWlmKDQmQS53cmFwJiZsIT09KDQyOTQ5NjcyOTUmQS50b3RhbCkpe2UubXNnPSJpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrIixBLm1vZGU9SHQ7YnJlYWt9bD0wLGM9MH1BLm1vZGU9MTYyMDg7Y2FzZSAxNjIwODpDPXZ0O2JyZWFrIGU7Y2FzZSBIdDpDPV90O2JyZWFrIGU7Y2FzZSAxNjIxMDpyZXR1cm4ganQ7ZGVmYXVsdDpyZXR1cm4gQ3R9cmV0dXJuIGUubmV4dF9vdXQ9aSxlLmF2YWlsX291dD1hLGUubmV4dF9pbj1zLGUuYXZhaWxfaW49byxBLmhvbGQ9bCxBLmJpdHM9YywoQS53c2l6ZXx8aCE9PWUuYXZhaWxfb3V0JiZBLm1vZGU8SHQmJihBLm1vZGU8a3R8fHQhPT1tdCkpJiZXdChlLGUub3V0cHV0LGUubmV4dF9vdXQsaC1lLmF2YWlsX291dCksdS09ZS5hdmFpbF9pbixoLT1lLmF2YWlsX291dCxlLnRvdGFsX2luKz11LGUudG90YWxfb3V0Kz1oLEEudG90YWwrPWgsNCZBLndyYXAmJmgmJihlLmFkbGVyPUEuY2hlY2s9QS5mbGFncz9UKEEuY2hlY2ssbixoLGUubmV4dF9vdXQtaCk6SChBLmNoZWNrLG4saCxlLm5leHRfb3V0LWgpKSxlLmRhdGFfdHlwZT1BLmJpdHMrKEEubGFzdD82NDowKSsoQS5tb2RlPT09RXQ/MTI4OjApKyhBLm1vZGU9PT1JdHx8QS5tb2RlPT09THQ/MjU2OjApLCgwPT09dSYmMD09PWh8fHQ9PT1tdCkmJkM9PT15dCYmKEM9eHQpLEN9LFp0PWU9PntpZihPdChlKSlyZXR1cm4gQ3Q7bGV0IHQ9ZS5zdGF0ZTtyZXR1cm4gdC53aW5kb3cmJih0LndpbmRvdz1udWxsKSxlLnN0YXRlPW51bGwseXR9LCR0PShlLHQpPT57aWYoT3QoZSkpcmV0dXJuIEN0O2NvbnN0IEE9ZS5zdGF0ZTtyZXR1cm4gMiZBLndyYXA/KEEuaGVhZD10LHQuZG9uZT0hMSx5dCk6Q3R9LGVBPShlLHQpPT57Y29uc3QgQT10Lmxlbmd0aDtsZXQgcixuLHM7cmV0dXJuIE90KGUpP0N0OihyPWUuc3RhdGUsMCE9PXIud3JhcCYmci5tb2RlIT09VXQ/Q3Q6ci5tb2RlPT09VXQmJihuPTEsbj1IKG4sdCxBLDApLG4hPT1yLmNoZWNrKT9fdDoocz1XdChlLHQsQSxBKSxzPyhyLm1vZGU9MTYyMTAsanQpOihyLmhhdmVkaWN0PTEseXQpKSl9LHRBPWZ1bmN0aW9uKCl7dGhpcy50ZXh0PTAsdGhpcy50aW1lPTAsdGhpcy54ZmxhZ3M9MCx0aGlzLm9zPTAsdGhpcy5leHRyYT1udWxsLHRoaXMuZXh0cmFfbGVuPTAsdGhpcy5uYW1lPSIiLHRoaXMuY29tbWVudD0iIix0aGlzLmhjcmM9MCx0aGlzLmRvbmU9ITF9O2NvbnN0IEFBPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcse1pfTk9fRkxVU0g6ckEsWl9GSU5JU0g6bkEsWl9PSzpzQSxaX1NUUkVBTV9FTkQ6aUEsWl9ORUVEX0RJQ1Q6b0EsWl9TVFJFQU1fRVJST1I6YUEsWl9EQVRBX0VSUk9SOmxBLFpfTUVNX0VSUk9SOmNBfT1NO2Z1bmN0aW9uIHVBKGUpe3RoaXMub3B0aW9ucz1LZSh7Y2h1bmtTaXplOjY1NTM2LHdpbmRvd0JpdHM6MTUsdG86IiJ9LGV8fHt9KTtjb25zdCB0PXRoaXMub3B0aW9uczt0LnJhdyYmdC53aW5kb3dCaXRzPj0wJiZ0LndpbmRvd0JpdHM8MTYmJih0LndpbmRvd0JpdHM9LXQud2luZG93Qml0cywwPT09dC53aW5kb3dCaXRzJiYodC53aW5kb3dCaXRzPS0xNSkpLCEodC53aW5kb3dCaXRzPj0wJiZ0LndpbmRvd0JpdHM8MTYpfHxlJiZlLndpbmRvd0JpdHN8fCh0LndpbmRvd0JpdHMrPTMyKSx0LndpbmRvd0JpdHM+MTUmJnQud2luZG93Qml0czw0OCYmKDE1JnQud2luZG93Qml0c3x8KHQud2luZG93Qml0c3w9MTUpKSx0aGlzLmVycj0wLHRoaXMubXNnPSIiLHRoaXMuZW5kZWQ9ITEsdGhpcy5jaHVua3M9W10sdGhpcy5zdHJtPW5ldyBZZSx0aGlzLnN0cm0uYXZhaWxfb3V0PTA7bGV0IEE9WXQodGhpcy5zdHJtLHQud2luZG93Qml0cyk7aWYoQSE9PXNBKXRocm93IG5ldyBFcnJvcihPW0FdKTtpZih0aGlzLmhlYWRlcj1uZXcgdEEsJHQodGhpcy5zdHJtLHRoaXMuaGVhZGVyKSx0LmRpY3Rpb25hcnkmJigic3RyaW5nIj09dHlwZW9mIHQuZGljdGlvbmFyeT90LmRpY3Rpb25hcnk9cWUodC5kaWN0aW9uYXJ5KToiW29iamVjdCBBcnJheUJ1ZmZlcl0iPT09QUEuY2FsbCh0LmRpY3Rpb25hcnkpJiYodC5kaWN0aW9uYXJ5PW5ldyBVaW50OEFycmF5KHQuZGljdGlvbmFyeSkpLHQucmF3JiYoQT1lQSh0aGlzLnN0cm0sdC5kaWN0aW9uYXJ5KSxBIT09c0EpKSl0aHJvdyBuZXcgRXJyb3IoT1tBXSl9ZnVuY3Rpb24gaEEoZSx0KXtjb25zdCBBPW5ldyB1QSh0KTtpZihBLnB1c2goZSksQS5lcnIpdGhyb3cgQS5tc2d8fE9bQS5lcnJdO3JldHVybiBBLnJlc3VsdH11QS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe2NvbnN0IEE9dGhpcy5zdHJtLHI9dGhpcy5vcHRpb25zLmNodW5rU2l6ZSxuPXRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O2xldCBzLGksbztpZih0aGlzLmVuZGVkKXJldHVybiExO2ZvcihpPXQ9PT1+fnQ/dDohMD09PXQ/bkE6ckEsIltvYmplY3QgQXJyYXlCdWZmZXJdIj09PUFBLmNhbGwoZSk/QS5pbnB1dD1uZXcgVWludDhBcnJheShlKTpBLmlucHV0PWUsQS5uZXh0X2luPTAsQS5hdmFpbF9pbj1BLmlucHV0Lmxlbmd0aDs7KXtmb3IoMD09PUEuYXZhaWxfb3V0JiYoQS5vdXRwdXQ9bmV3IFVpbnQ4QXJyYXkociksQS5uZXh0X291dD0wLEEuYXZhaWxfb3V0PXIpLHM9SnQoQSxpKSxzPT09b0EmJm4mJihzPWVBKEEsbikscz09PXNBP3M9SnQoQSxpKTpzPT09bEEmJihzPW9BKSk7QS5hdmFpbF9pbj4wJiZzPT09aUEmJkEuc3RhdGUud3JhcD4wJiYwIT09ZVtBLm5leHRfaW5dOylYdChBKSxzPUp0KEEsaSk7c3dpdGNoKHMpe2Nhc2UgYUE6Y2FzZSBsQTpjYXNlIG9BOmNhc2UgY0E6cmV0dXJuIHRoaXMub25FbmQocyksdGhpcy5lbmRlZD0hMCwhMX1pZihvPUEuYXZhaWxfb3V0LEEubmV4dF9vdXQmJigwPT09QS5hdmFpbF9vdXR8fHM9PT1pQSkpaWYoInN0cmluZyI9PT10aGlzLm9wdGlvbnMudG8pe2xldCBlPVhlKEEub3V0cHV0LEEubmV4dF9vdXQpLHQ9QS5uZXh0X291dC1lLG49V2UoQS5vdXRwdXQsZSk7QS5uZXh0X291dD10LEEuYXZhaWxfb3V0PXItdCx0JiZBLm91dHB1dC5zZXQoQS5vdXRwdXQuc3ViYXJyYXkoZSxlK3QpLDApLHRoaXMub25EYXRhKG4pfWVsc2UgdGhpcy5vbkRhdGEoQS5vdXRwdXQubGVuZ3RoPT09QS5uZXh0X291dD9BLm91dHB1dDpBLm91dHB1dC5zdWJhcnJheSgwLEEubmV4dF9vdXQpKTtpZihzIT09c0F8fDAhPT1vKXtpZihzPT09aUEpcmV0dXJuIHM9WnQodGhpcy5zdHJtKSx0aGlzLm9uRW5kKHMpLHRoaXMuZW5kZWQ9ITAsITA7aWYoMD09PUEuYXZhaWxfaW4pYnJlYWt9fXJldHVybiEwfSx1QS5wcm90b3R5cGUub25EYXRhPWZ1bmN0aW9uKGUpe3RoaXMuY2h1bmtzLnB1c2goZSl9LHVBLnByb3RvdHlwZS5vbkVuZD1mdW5jdGlvbihlKXtlPT09c0EmJigic3RyaW5nIj09PXRoaXMub3B0aW9ucy50bz90aGlzLnJlc3VsdD10aGlzLmNodW5rcy5qb2luKCIiKTp0aGlzLnJlc3VsdD1WZSh0aGlzLmNodW5rcykpLHRoaXMuY2h1bmtzPVtdLHRoaXMuZXJyPWUsdGhpcy5tc2c9dGhpcy5zdHJtLm1zZ307dmFyIGRBPXtJbmZsYXRlOnVBLGluZmxhdGU6aEEsaW5mbGF0ZVJhdzpmdW5jdGlvbihlLHQpe3JldHVybih0PXR8fHt9KS5yYXc9ITAsaEEoZSx0KX0sdW5nemlwOmhBLGNvbnN0YW50czpNfTtjb25zdHtEZWZsYXRlOmZBLGRlZmxhdGU6cEEsZGVmbGF0ZVJhdzpnQSxnemlwOm1BfT1sdCx7SW5mbGF0ZTp3QSxpbmZsYXRlOkJBLGluZmxhdGVSYXc6eUEsdW5nemlwOnZBfT1kQTt2YXIgYkE9ZkEsQ0E9cEEsX0E9Z0EsakE9bUEseEE9d0EsRkE9QkEsUUE9eUEsVUE9dkEsRUE9TSxTQT17RGVmbGF0ZTpmQSxkZWZsYXRlOnBBLGRlZmxhdGVSYXc6Z0EsZ3ppcDptQSxJbmZsYXRlOndBLGluZmxhdGU6QkEsaW5mbGF0ZVJhdzp5QSx1bmd6aXA6dkEsY29uc3RhbnRzOk19fSwiLi9ub2RlX21vZHVsZXMvcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanMiOmZ1bmN0aW9uKGUpeyhmdW5jdGlvbigpe3ZhciB0LEEscixuLHMsaTsidW5kZWZpbmVkIiE9dHlwZW9mIHBlcmZvcm1hbmNlJiZudWxsIT09cGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdz9lLmV4cG9ydHM9ZnVuY3Rpb24oKXtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9OiJ1bmRlZmluZWQiIT10eXBlb2YgcHJvY2VzcyYmbnVsbCE9PXByb2Nlc3MmJnByb2Nlc3MuaHJ0aW1lPyhlLmV4cG9ydHM9ZnVuY3Rpb24oKXtyZXR1cm4odCgpLXMpLzFlNn0sQT1wcm9jZXNzLmhydGltZSxuPSh0PWZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIDFlOSooZT1BKCkpWzBdK2VbMV19KSgpLGk9MWU5KnByb2Nlc3MudXB0aW1lKCkscz1uLWkpOkRhdGUubm93PyhlLmV4cG9ydHM9ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKS1yfSxyPURhdGUubm93KCkpOihlLmV4cG9ydHM9ZnVuY3Rpb24oKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKS1yfSxyPShuZXcgRGF0ZSkuZ2V0VGltZSgpKX0pLmNhbGwodGhpcyl9LCIuL25vZGVfbW9kdWxlcy9yYWYvaW5kZXguanMiOmZ1bmN0aW9uKGUsdCxBKXtmb3IodmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanMiKSxuPSJ1bmRlZmluZWQiPT10eXBlb2Ygd2luZG93P2dsb2JhbDp3aW5kb3cscz1bIm1veiIsIndlYmtpdCJdLGk9IkFuaW1hdGlvbkZyYW1lIixvPW5bInJlcXVlc3QiK2ldLGE9blsiY2FuY2VsIitpXXx8blsiY2FuY2VsUmVxdWVzdCIraV0sbD0wOyFvJiZsPHMubGVuZ3RoO2wrKylvPW5bc1tsXSsiUmVxdWVzdCIraV0sYT1uW3NbbF0rIkNhbmNlbCIraV18fG5bc1tsXSsiQ2FuY2VsUmVxdWVzdCIraV07aWYoIW98fCFhKXt2YXIgYz0wLHU9MCxoPVtdLGQ9MWUzLzYwO289ZnVuY3Rpb24oZSl7aWYoMD09PWgubGVuZ3RoKXt2YXIgdD1yKCksQT1NYXRoLm1heCgwLGQtKHQtYykpO2M9QSt0LHNldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgZT1oLnNsaWNlKDApO2gubGVuZ3RoPTA7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0KyspaWYoIWVbdF0uY2FuY2VsbGVkKXRyeXtlW3RdLmNhbGxiYWNrKGMpfWNhdGNoKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlfSwwKX19LE1hdGgucm91bmQoQSkpfXJldHVybiBoLnB1c2goe2hhbmRsZTorK3UsY2FsbGJhY2s6ZSxjYW5jZWxsZWQ6ITF9KSx1fSxhPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wO3Q8aC5sZW5ndGg7dCsrKWhbdF0uaGFuZGxlPT09ZSYmKGhbdF0uY2FuY2VsbGVkPSEwKX19ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBvLmNhbGwobixlKX0sZS5leHBvcnRzLmNhbmNlbD1mdW5jdGlvbigpe2EuYXBwbHkobixhcmd1bWVudHMpfSxlLmV4cG9ydHMucG9seWZpbGw9ZnVuY3Rpb24oZSl7ZXx8KGU9biksZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9byxlLmNhbmNlbEFuaW1hdGlvbkZyYW1lPWF9fSwiLi9ub2RlX21vZHVsZXMvcmdiY29sb3IvaW5kZXguanMiOmZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1mdW5jdGlvbihlKXt0aGlzLm9rPSExLHRoaXMuYWxwaGE9MSwiIyI9PWUuY2hhckF0KDApJiYoZT1lLnN1YnN0cigxLDYpKSxlPShlPWUucmVwbGFjZSgvIC9nLCIiKSkudG9Mb3dlckNhc2UoKTt2YXIgdD17YWxpY2VibHVlOiJmMGY4ZmYiLGFudGlxdWV3aGl0ZToiZmFlYmQ3IixhcXVhOiIwMGZmZmYiLGFxdWFtYXJpbmU6IjdmZmZkNCIsYXp1cmU6ImYwZmZmZiIsYmVpZ2U6ImY1ZjVkYyIsYmlzcXVlOiJmZmU0YzQiLGJsYWNrOiIwMDAwMDAiLGJsYW5jaGVkYWxtb25kOiJmZmViY2QiLGJsdWU6IjAwMDBmZiIsYmx1ZXZpb2xldDoiOGEyYmUyIixicm93bjoiYTUyYTJhIixidXJseXdvb2Q6ImRlYjg4NyIsY2FkZXRibHVlOiI1ZjllYTAiLGNoYXJ0cmV1c2U6IjdmZmYwMCIsY2hvY29sYXRlOiJkMjY5MWUiLGNvcmFsOiJmZjdmNTAiLGNvcm5mbG93ZXJibHVlOiI2NDk1ZWQiLGNvcm5zaWxrOiJmZmY4ZGMiLGNyaW1zb246ImRjMTQzYyIsY3lhbjoiMDBmZmZmIixkYXJrYmx1ZToiMDAwMDhiIixkYXJrY3lhbjoiMDA4YjhiIixkYXJrZ29sZGVucm9kOiJiODg2MGIiLGRhcmtncmF5OiJhOWE5YTkiLGRhcmtncmVlbjoiMDA2NDAwIixkYXJra2hha2k6ImJkYjc2YiIsZGFya21hZ2VudGE6IjhiMDA4YiIsZGFya29saXZlZ3JlZW46IjU1NmIyZiIsZGFya29yYW5nZToiZmY4YzAwIixkYXJrb3JjaGlkOiI5OTMyY2MiLGRhcmtyZWQ6IjhiMDAwMCIsZGFya3NhbG1vbjoiZTk5NjdhIixkYXJrc2VhZ3JlZW46IjhmYmM4ZiIsZGFya3NsYXRlYmx1ZToiNDgzZDhiIixkYXJrc2xhdGVncmF5OiIyZjRmNGYiLGRhcmt0dXJxdW9pc2U6IjAwY2VkMSIsZGFya3Zpb2xldDoiOTQwMGQzIixkZWVwcGluazoiZmYxNDkzIixkZWVwc2t5Ymx1ZToiMDBiZmZmIixkaW1ncmF5OiI2OTY5NjkiLGRvZGdlcmJsdWU6IjFlOTBmZiIsZmVsZHNwYXI6ImQxOTI3NSIsZmlyZWJyaWNrOiJiMjIyMjIiLGZsb3JhbHdoaXRlOiJmZmZhZjAiLGZvcmVzdGdyZWVuOiIyMjhiMjIiLGZ1Y2hzaWE6ImZmMDBmZiIsZ2FpbnNib3JvOiJkY2RjZGMiLGdob3N0d2hpdGU6ImY4ZjhmZiIsZ29sZDoiZmZkNzAwIixnb2xkZW5yb2Q6ImRhYTUyMCIsZ3JheToiODA4MDgwIixncmVlbjoiMDA4MDAwIixncmVlbnllbGxvdzoiYWRmZjJmIixob25leWRldzoiZjBmZmYwIixob3RwaW5rOiJmZjY5YjQiLGluZGlhbnJlZDoiY2Q1YzVjIixpbmRpZ286IjRiMDA4MiIsaXZvcnk6ImZmZmZmMCIsa2hha2k6ImYwZTY4YyIsbGF2ZW5kZXI6ImU2ZTZmYSIsbGF2ZW5kZXJibHVzaDoiZmZmMGY1IixsYXduZ3JlZW46IjdjZmMwMCIsbGVtb25jaGlmZm9uOiJmZmZhY2QiLGxpZ2h0Ymx1ZToiYWRkOGU2IixsaWdodGNvcmFsOiJmMDgwODAiLGxpZ2h0Y3lhbjoiZTBmZmZmIixsaWdodGdvbGRlbnJvZHllbGxvdzoiZmFmYWQyIixsaWdodGdyZXk6ImQzZDNkMyIsbGlnaHRncmVlbjoiOTBlZTkwIixsaWdodHBpbms6ImZmYjZjMSIsbGlnaHRzYWxtb246ImZmYTA3YSIsbGlnaHRzZWFncmVlbjoiMjBiMmFhIixsaWdodHNreWJsdWU6Ijg3Y2VmYSIsbGlnaHRzbGF0ZWJsdWU6Ijg0NzBmZiIsbGlnaHRzbGF0ZWdyYXk6Ijc3ODg5OSIsbGlnaHRzdGVlbGJsdWU6ImIwYzRkZSIsbGlnaHR5ZWxsb3c6ImZmZmZlMCIsbGltZToiMDBmZjAwIixsaW1lZ3JlZW46IjMyY2QzMiIsbGluZW46ImZhZjBlNiIsbWFnZW50YToiZmYwMGZmIixtYXJvb246IjgwMDAwMCIsbWVkaXVtYXF1YW1hcmluZToiNjZjZGFhIixtZWRpdW1ibHVlOiIwMDAwY2QiLG1lZGl1bW9yY2hpZDoiYmE1NWQzIixtZWRpdW1wdXJwbGU6IjkzNzBkOCIsbWVkaXVtc2VhZ3JlZW46IjNjYjM3MSIsbWVkaXVtc2xhdGVibHVlOiI3YjY4ZWUiLG1lZGl1bXNwcmluZ2dyZWVuOiIwMGZhOWEiLG1lZGl1bXR1cnF1b2lzZToiNDhkMWNjIixtZWRpdW12aW9sZXRyZWQ6ImM3MTU4NSIsbWlkbmlnaHRibHVlOiIxOTE5NzAiLG1pbnRjcmVhbToiZjVmZmZhIixtaXN0eXJvc2U6ImZmZTRlMSIsbW9jY2FzaW46ImZmZTRiNSIsbmF2YWpvd2hpdGU6ImZmZGVhZCIsbmF2eToiMDAwMDgwIixvbGRsYWNlOiJmZGY1ZTYiLG9saXZlOiI4MDgwMDAiLG9saXZlZHJhYjoiNmI4ZTIzIixvcmFuZ2U6ImZmYTUwMCIsb3JhbmdlcmVkOiJmZjQ1MDAiLG9yY2hpZDoiZGE3MGQ2IixwYWxlZ29sZGVucm9kOiJlZWU4YWEiLHBhbGVncmVlbjoiOThmYjk4IixwYWxldHVycXVvaXNlOiJhZmVlZWUiLHBhbGV2aW9sZXRyZWQ6ImQ4NzA5MyIscGFwYXlhd2hpcDoiZmZlZmQ1IixwZWFjaHB1ZmY6ImZmZGFiOSIscGVydToiY2Q4NTNmIixwaW5rOiJmZmMwY2IiLHBsdW06ImRkYTBkZCIscG93ZGVyYmx1ZToiYjBlMGU2IixwdXJwbGU6IjgwMDA4MCIscmViZWNjYXB1cnBsZToiNjYzMzk5IixyZWQ6ImZmMDAwMCIscm9zeWJyb3duOiJiYzhmOGYiLHJveWFsYmx1ZToiNDE2OWUxIixzYWRkbGVicm93bjoiOGI0NTEzIixzYWxtb246ImZhODA3MiIsc2FuZHlicm93bjoiZjRhNDYwIixzZWFncmVlbjoiMmU4YjU3IixzZWFzaGVsbDoiZmZmNWVlIixzaWVubmE6ImEwNTIyZCIsc2lsdmVyOiJjMGMwYzAiLHNreWJsdWU6Ijg3Y2VlYiIsc2xhdGVibHVlOiI2YTVhY2QiLHNsYXRlZ3JheToiNzA4MDkwIixzbm93OiJmZmZhZmEiLHNwcmluZ2dyZWVuOiIwMGZmN2YiLHN0ZWVsYmx1ZToiNDY4MmI0Iix0YW46ImQyYjQ4YyIsdGVhbDoiMDA4MDgwIix0aGlzdGxlOiJkOGJmZDgiLHRvbWF0bzoiZmY2MzQ3Iix0dXJxdW9pc2U6IjQwZTBkMCIsdmlvbGV0OiJlZTgyZWUiLHZpb2xldHJlZDoiZDAyMDkwIix3aGVhdDoiZjVkZWIzIix3aGl0ZToiZmZmZmZmIix3aGl0ZXNtb2tlOiJmNWY1ZjUiLHllbGxvdzoiZmZmZjAwIix5ZWxsb3dncmVlbjoiOWFjZDMyIn07ZT10W2VdfHxlO2Zvcih2YXIgQT1be3JlOi9ecmdiYVwoKFxkezEsM30pLFxzKihcZHsxLDN9KSxccyooXGR7MSwzfSksXHMqKCg/OlxkP1wuKT9cZClcKSQvLGV4YW1wbGU6WyJyZ2JhKDEyMywgMjM0LCA0NSwgMC44KSIsInJnYmEoMjU1LDIzNCwyNDUsMS4wKSJdLHByb2Nlc3M6ZnVuY3Rpb24oZSl7cmV0dXJuW3BhcnNlSW50KGVbMV0pLHBhcnNlSW50KGVbMl0pLHBhcnNlSW50KGVbM10pLHBhcnNlRmxvYXQoZVs0XSldfX0se3JlOi9ecmdiXCgoXGR7MSwzfSksXHMqKFxkezEsM30pLFxzKihcZHsxLDN9KVwpJC8sZXhhbXBsZTpbInJnYigxMjMsIDIzNCwgNDUpIiwicmdiKDI1NSwyMzQsMjQ1KSJdLHByb2Nlc3M6ZnVuY3Rpb24oZSl7cmV0dXJuW3BhcnNlSW50KGVbMV0pLHBhcnNlSW50KGVbMl0pLHBhcnNlSW50KGVbM10pXX19LHtyZTovXihbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvLGV4YW1wbGU6WyIjMDBmZjAwIiwiMzM2Njk5Il0scHJvY2VzczpmdW5jdGlvbihlKXtyZXR1cm5bcGFyc2VJbnQoZVsxXSwxNikscGFyc2VJbnQoZVsyXSwxNikscGFyc2VJbnQoZVszXSwxNildfX0se3JlOi9eKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC8sZXhhbXBsZTpbIiNmYjAiLCJmMGYiXSxwcm9jZXNzOmZ1bmN0aW9uKGUpe3JldHVybltwYXJzZUludChlWzFdK2VbMV0sMTYpLHBhcnNlSW50KGVbMl0rZVsyXSwxNikscGFyc2VJbnQoZVszXStlWzNdLDE2KV19fV0scj0wO3I8QS5sZW5ndGg7cisrKXt2YXIgbj1BW3JdLnJlLHM9QVtyXS5wcm9jZXNzLGk9bi5leGVjKGUpO2lmKGkpe3ZhciBvPXMoaSk7dGhpcy5yPW9bMF0sdGhpcy5nPW9bMV0sdGhpcy5iPW9bMl0sby5sZW5ndGg+MyYmKHRoaXMuYWxwaGE9b1szXSksdGhpcy5vaz0hMH19dGhpcy5yPXRoaXMucjwwfHxpc05hTih0aGlzLnIpPzA6dGhpcy5yPjI1NT8yNTU6dGhpcy5yLHRoaXMuZz10aGlzLmc8MHx8aXNOYU4odGhpcy5nKT8wOnRoaXMuZz4yNTU/MjU1OnRoaXMuZyx0aGlzLmI9dGhpcy5iPDB8fGlzTmFOKHRoaXMuYik/MDp0aGlzLmI+MjU1PzI1NTp0aGlzLmIsdGhpcy5hbHBoYT10aGlzLmFscGhhPDA/MDp0aGlzLmFscGhhPjF8fGlzTmFOKHRoaXMuYWxwaGEpPzE6dGhpcy5hbHBoYSx0aGlzLnRvUkdCPWZ1bmN0aW9uKCl7cmV0dXJuInJnYigiK3RoaXMucisiLCAiK3RoaXMuZysiLCAiK3RoaXMuYisiKSJ9LHRoaXMudG9SR0JBPWZ1bmN0aW9uKCl7cmV0dXJuInJnYmEoIit0aGlzLnIrIiwgIit0aGlzLmcrIiwgIit0aGlzLmIrIiwgIit0aGlzLmFscGhhKyIpIn0sdGhpcy50b0hleD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuci50b1N0cmluZygxNiksdD10aGlzLmcudG9TdHJpbmcoMTYpLEE9dGhpcy5iLnRvU3RyaW5nKDE2KTtyZXR1cm4gMT09ZS5sZW5ndGgmJihlPSIwIitlKSwxPT10Lmxlbmd0aCYmKHQ9IjAiK3QpLDE9PUEubGVuZ3RoJiYoQT0iMCIrQSksIiMiK2UrdCtBfSx0aGlzLmdldEhlbHBYTUw9ZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IEFycmF5LHI9MDtyPEEubGVuZ3RoO3IrKylmb3IodmFyIG49QVtyXS5leGFtcGxlLHM9MDtzPG4ubGVuZ3RoO3MrKyllW2UubGVuZ3RoXT1uW3NdO2Zvcih2YXIgaSBpbiB0KWVbZS5sZW5ndGhdPWk7dmFyIG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidWwiKTtmb3Ioby5zZXRBdHRyaWJ1dGUoImlkIiwicmdiY29sb3ItZXhhbXBsZXMiKSxyPTA7cjxlLmxlbmd0aDtyKyspdHJ5e3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImxpIiksbD1uZXcgUkdCQ29sb3IoZVtyXSksYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtjLnN0eWxlLmNzc1RleHQ9Im1hcmdpbjogM3B4OyBib3JkZXI6IDFweCBzb2xpZCBibGFjazsgYmFja2dyb3VuZDoiK2wudG9IZXgoKSsiOyBjb2xvcjoiK2wudG9IZXgoKSxjLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCJ0ZXN0IikpO3ZhciB1PWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCIgIitlW3JdKyIgLT4gIitsLnRvUkdCKCkrIiAtPiAiK2wudG9IZXgoKSk7YS5hcHBlbmRDaGlsZChjKSxhLmFwcGVuZENoaWxkKHUpLG8uYXBwZW5kQ2hpbGQoYSl9Y2F0Y2goZSl7fXJldHVybiBvfX19LCIuL25vZGVfbW9kdWxlcy9zdGFja2JsdXItY2FudmFzL2Rpc3Qvc3RhY2tibHVyLWVzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIHI9ImZ1bmN0aW9uIj09dHlwZW9mIFN5bWJvbCYmInN5bWJvbCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmImZ1bmN0aW9uIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/InN5bWJvbCI6dHlwZW9mIGV9LHIoZSl9QS5yKHQpLEEuZCh0LHtCbHVyU3RhY2s6ZnVuY3Rpb24oKXtyZXR1cm4gaH0sY2FudmFzUkdCOmZ1bmN0aW9uKCl7cmV0dXJuIGN9LGNhbnZhc1JHQkE6ZnVuY3Rpb24oKXtyZXR1cm4gYX0saW1hZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gaX0saW1hZ2VEYXRhUkdCOmZ1bmN0aW9uKCl7cmV0dXJuIHV9LGltYWdlRGF0YVJHQkE6ZnVuY3Rpb24oKXtyZXR1cm4gbH19KTt2YXIgbj1bNTEyLDUxMiw0NTYsNTEyLDMyOCw0NTYsMzM1LDUxMiw0MDUsMzI4LDI3MSw0NTYsMzg4LDMzNSwyOTIsNTEyLDQ1NCw0MDUsMzY0LDMyOCwyOTgsMjcxLDQ5Niw0NTYsNDIwLDM4OCwzNjAsMzM1LDMxMiwyOTIsMjczLDUxMiw0ODIsNDU0LDQyOCw0MDUsMzgzLDM2NCwzNDUsMzI4LDMxMiwyOTgsMjg0LDI3MSwyNTksNDk2LDQ3NSw0NTYsNDM3LDQyMCw0MDQsMzg4LDM3NCwzNjAsMzQ3LDMzNSwzMjMsMzEyLDMwMiwyOTIsMjgyLDI3MywyNjUsNTEyLDQ5Nyw0ODIsNDY4LDQ1NCw0NDEsNDI4LDQxNyw0MDUsMzk0LDM4MywzNzMsMzY0LDM1NCwzNDUsMzM3LDMyOCwzMjAsMzEyLDMwNSwyOTgsMjkxLDI4NCwyNzgsMjcxLDI2NSwyNTksNTA3LDQ5Niw0ODUsNDc1LDQ2NSw0NTYsNDQ2LDQzNyw0MjgsNDIwLDQxMiw0MDQsMzk2LDM4OCwzODEsMzc0LDM2NywzNjAsMzU0LDM0NywzNDEsMzM1LDMyOSwzMjMsMzE4LDMxMiwzMDcsMzAyLDI5NywyOTIsMjg3LDI4MiwyNzgsMjczLDI2OSwyNjUsMjYxLDUxMiw1MDUsNDk3LDQ4OSw0ODIsNDc1LDQ2OCw0NjEsNDU0LDQ0Nyw0NDEsNDM1LDQyOCw0MjIsNDE3LDQxMSw0MDUsMzk5LDM5NCwzODksMzgzLDM3OCwzNzMsMzY4LDM2NCwzNTksMzU0LDM1MCwzNDUsMzQxLDMzNywzMzIsMzI4LDMyNCwzMjAsMzE2LDMxMiwzMDksMzA1LDMwMSwyOTgsMjk0LDI5MSwyODcsMjg0LDI4MSwyNzgsMjc0LDI3MSwyNjgsMjY1LDI2MiwyNTksMjU3LDUwNyw1MDEsNDk2LDQ5MSw0ODUsNDgwLDQ3NSw0NzAsNDY1LDQ2MCw0NTYsNDUxLDQ0Niw0NDIsNDM3LDQzMyw0MjgsNDI0LDQyMCw0MTYsNDEyLDQwOCw0MDQsNDAwLDM5NiwzOTIsMzg4LDM4NSwzODEsMzc3LDM3NCwzNzAsMzY3LDM2MywzNjAsMzU3LDM1NCwzNTAsMzQ3LDM0NCwzNDEsMzM4LDMzNSwzMzIsMzI5LDMyNiwzMjMsMzIwLDMxOCwzMTUsMzEyLDMxMCwzMDcsMzA0LDMwMiwyOTksMjk3LDI5NCwyOTIsMjg5LDI4NywyODUsMjgyLDI4MCwyNzgsMjc1LDI3MywyNzEsMjY5LDI2NywyNjUsMjYzLDI2MSwyNTldLHM9WzksMTEsMTIsMTMsMTMsMTQsMTQsMTUsMTUsMTUsMTUsMTYsMTYsMTYsMTYsMTcsMTcsMTcsMTcsMTcsMTcsMTcsMTgsMTgsMTgsMTgsMTgsMTgsMTgsMTgsMTgsMTksMTksMTksMTksMTksMTksMTksMTksMTksMTksMTksMTksMTksMTksMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjAsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjEsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjIsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjMsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjQsMjRdO2Z1bmN0aW9uIGkoZSx0LEEscixuLHMpe2lmKCJzdHJpbmciPT10eXBlb2YgZSYmKGU9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSkpLGUmJigiSFRNTEltYWdlRWxlbWVudCIhPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwtMSl8fCJuYXR1cmFsV2lkdGgiaW4gZSkpe3ZhciBpPW4/Im9mZnNldCI6Im5hdHVyYWwiLG89ZVtpKyJXaWR0aCJdLGw9ZVtpKyJIZWlnaHQiXTtpZigiSW1hZ2VCaXRtYXAiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpJiYobz1lLndpZHRoLGw9ZS5oZWlnaHQpLCJzdHJpbmciPT10eXBlb2YgdCYmKHQ9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodCkpLHQmJiJnZXRDb250ZXh0ImluIHQpe3N8fCh0LnN0eWxlLndpZHRoPW8rInB4Iix0LnN0eWxlLmhlaWdodD1sKyJweCIpLHQud2lkdGg9byx0LmhlaWdodD1sO3ZhciB1PXQuZ2V0Q29udGV4dCgiMmQiKTt1LmNsZWFyUmVjdCgwLDAsbyxsKSx1LmRyYXdJbWFnZShlLDAsMCxlLm5hdHVyYWxXaWR0aCxlLm5hdHVyYWxIZWlnaHQsMCwwLG8sbCksaXNOYU4oQSl8fEE8MXx8KHI/YSh0LDAsMCxvLGwsQSk6Yyh0LDAsMCxvLGwsQSkpfX19ZnVuY3Rpb24gbyhlLHQsQSxuLHMpe2lmKCJzdHJpbmciPT10eXBlb2YgZSYmKGU9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSkpLCFlfHwib2JqZWN0IiE9PXIoZSl8fCEoImdldENvbnRleHQiaW4gZSkpdGhyb3cgbmV3IFR5cGVFcnJvcigiRXhwZWN0aW5nIGNhbnZhcyB3aXRoIGBnZXRDb250ZXh0YCBtZXRob2QgaW4gcHJvY2Vzc0NhbnZhc1JHQihBKSBjYWxscyEiKTt2YXIgaT1lLmdldENvbnRleHQoIjJkIik7dHJ5e3JldHVybiBpLmdldEltYWdlRGF0YSh0LEEsbixzKX1jYXRjaChlKXt0aHJvdyBuZXcgRXJyb3IoInVuYWJsZSB0byBhY2Nlc3MgaW1hZ2UgZGF0YTogIitlKX19ZnVuY3Rpb24gYShlLHQsQSxyLG4scyl7aWYoIShpc05hTihzKXx8czwxKSl7c3w9MDt2YXIgaT1vKGUsdCxBLHIsbik7aT1sKGksMCwwLHIsbixzKSxlLmdldENvbnRleHQoIjJkIikucHV0SW1hZ2VEYXRhKGksdCxBKX19ZnVuY3Rpb24gbChlLHQsQSxyLGksbyl7Zm9yKHZhciBhLGw9ZS5kYXRhLGM9MipvKzEsdT1yLTEsZD1pLTEsZj1vKzEscD1mKihmKzEpLzIsZz1uZXcgaCxtPWcsdz0xO3c8Yzt3KyspbT1tLm5leHQ9bmV3IGgsdz09PWYmJihhPW0pO20ubmV4dD1nO2Zvcih2YXIgQj1udWxsLHk9bnVsbCx2PTAsYj0wLEM9bltvXSxfPXNbb10saj0wO2o8aTtqKyspe209Zztmb3IodmFyIHg9bFtiXSxGPWxbYisxXSxRPWxbYisyXSxVPWxbYiszXSxFPTA7RTxmO0UrKyltLnI9eCxtLmc9RixtLmI9USxtLmE9VSxtPW0ubmV4dDtmb3IodmFyIFM9MCxMPTAsST0wLE49MCxrPWYqeCxIPWYqRixQPWYqUSxUPWYqVSxPPXAqeCxNPXAqRixEPXAqUSxSPXAqVSxLPTE7SzxmO0srKyl7dmFyIFY9YisoKHU8Sz91OkspPDwyKSxHPWxbVl0sej1sW1YrMV0scT1sW1YrMl0sVz1sW1YrM10sWD1mLUs7Tys9KG0ucj1HKSpYLE0rPShtLmc9eikqWCxEKz0obS5iPXEpKlgsUis9KG0uYT1XKSpYLFMrPUcsTCs9eixJKz1xLE4rPVcsbT1tLm5leHR9Qj1nLHk9YTtmb3IodmFyIFk9MDtZPHI7WSsrKXt2YXIgSj1SKkM+Pj5fO2lmKGxbYiszXT1KLDAhPT1KKXt2YXIgWj0yNTUvSjtsW2JdPShPKkM+Pj5fKSpaLGxbYisxXT0oTSpDPj4+XykqWixsW2IrMl09KEQqQz4+Pl8pKlp9ZWxzZSBsW2JdPWxbYisxXT1sW2IrMl09MDtPLT1rLE0tPUgsRC09UCxSLT1ULGstPUIucixILT1CLmcsUC09Qi5iLFQtPUIuYTt2YXIgJD1ZK28rMTskPXYrKCQ8dT8kOnUpPDwyLE8rPVMrPUIucj1sWyRdLE0rPUwrPUIuZz1sWyQrMV0sRCs9SSs9Qi5iPWxbJCsyXSxSKz1OKz1CLmE9bFskKzNdLEI9Qi5uZXh0O3ZhciBlZT15LHRlPWVlLnIsQWU9ZWUuZyxyZT1lZS5iLG5lPWVlLmE7ays9dGUsSCs9QWUsUCs9cmUsVCs9bmUsUy09dGUsTC09QWUsSS09cmUsTi09bmUseT15Lm5leHQsYis9NH12Kz1yfWZvcih2YXIgc2U9MDtzZTxyO3NlKyspe3ZhciBpZT1sW2I9c2U8PDJdLG9lPWxbYisxXSxhZT1sW2IrMl0sbGU9bFtiKzNdLGNlPWYqaWUsdWU9ZipvZSxoZT1mKmFlLGRlPWYqbGUsZmU9cCppZSxwZT1wKm9lLGdlPXAqYWUsbWU9cCpsZTttPWc7Zm9yKHZhciB3ZT0wO3dlPGY7d2UrKyltLnI9aWUsbS5nPW9lLG0uYj1hZSxtLmE9bGUsbT1tLm5leHQ7Zm9yKHZhciBCZT1yLHllPTAsdmU9MCxiZT0wLENlPTAsX2U9MTtfZTw9bztfZSsrKXtiPUJlK3NlPDwyO3ZhciBqZT1mLV9lO2ZlKz0obS5yPWllPWxbYl0pKmplLHBlKz0obS5nPW9lPWxbYisxXSkqamUsZ2UrPShtLmI9YWU9bFtiKzJdKSpqZSxtZSs9KG0uYT1sZT1sW2IrM10pKmplLENlKz1pZSx5ZSs9b2UsdmUrPWFlLGJlKz1sZSxtPW0ubmV4dCxfZTxkJiYoQmUrPXIpfWI9c2UsQj1nLHk9YTtmb3IodmFyIHhlPTA7eGU8aTt4ZSsrKXt2YXIgRmU9Yjw8MjtsW0ZlKzNdPWxlPW1lKkM+Pj5fLGxlPjA/KGxlPTI1NS9sZSxsW0ZlXT0oZmUqQz4+Pl8pKmxlLGxbRmUrMV09KHBlKkM+Pj5fKSpsZSxsW0ZlKzJdPShnZSpDPj4+XykqbGUpOmxbRmVdPWxbRmUrMV09bFtGZSsyXT0wLGZlLT1jZSxwZS09dWUsZ2UtPWhlLG1lLT1kZSxjZS09Qi5yLHVlLT1CLmcsaGUtPUIuYixkZS09Qi5hLEZlPXNlKygoRmU9eGUrZik8ZD9GZTpkKSpyPDwyLGZlKz1DZSs9Qi5yPWxbRmVdLHBlKz15ZSs9Qi5nPWxbRmUrMV0sZ2UrPXZlKz1CLmI9bFtGZSsyXSxtZSs9YmUrPUIuYT1sW0ZlKzNdLEI9Qi5uZXh0LGNlKz1pZT15LnIsdWUrPW9lPXkuZyxoZSs9YWU9eS5iLGRlKz1sZT15LmEsQ2UtPWllLHllLT1vZSx2ZS09YWUsYmUtPWxlLHk9eS5uZXh0LGIrPXJ9fXJldHVybiBlfWZ1bmN0aW9uIGMoZSx0LEEscixuLHMpe2lmKCEoaXNOYU4ocyl8fHM8MSkpe3N8PTA7dmFyIGk9byhlLHQsQSxyLG4pO2k9dShpLDAsMCxyLG4scyksZS5nZXRDb250ZXh0KCIyZCIpLnB1dEltYWdlRGF0YShpLHQsQSl9fWZ1bmN0aW9uIHUoZSx0LEEscixpLG8pe2Zvcih2YXIgYSxsPWUuZGF0YSxjPTIqbysxLHU9ci0xLGQ9aS0xLGY9bysxLHA9ZiooZisxKS8yLGc9bmV3IGgsbT1nLHc9MTt3PGM7dysrKW09bS5uZXh0PW5ldyBoLHc9PT1mJiYoYT1tKTttLm5leHQ9Zztmb3IodmFyIEIseSx2PW51bGwsYj1udWxsLEM9bltvXSxfPXNbb10saj0wLHg9MCxGPTA7RjxpO0YrKyl7dmFyIFE9bFt4XSxVPWxbeCsxXSxFPWxbeCsyXSxTPWYqUSxMPWYqVSxJPWYqRSxOPXAqUSxrPXAqVSxIPXAqRTttPWc7Zm9yKHZhciBQPTA7UDxmO1ArKyltLnI9USxtLmc9VSxtLmI9RSxtPW0ubmV4dDtmb3IodmFyIFQ9MCxPPTAsTT0wLEQ9MTtEPGY7RCsrKUI9eCsoKHU8RD91OkQpPDwyKSxOKz0obS5yPVE9bFtCXSkqKHk9Zi1EKSxrKz0obS5nPVU9bFtCKzFdKSp5LEgrPShtLmI9RT1sW0IrMl0pKnksVCs9USxPKz1VLE0rPUUsbT1tLm5leHQ7dj1nLGI9YTtmb3IodmFyIFI9MDtSPHI7UisrKWxbeF09TipDPj4+XyxsW3grMV09aypDPj4+XyxsW3grMl09SCpDPj4+XyxOLT1TLGstPUwsSC09SSxTLT12LnIsTC09di5nLEktPXYuYixCPWorKChCPVIrbysxKTx1P0I6dSk8PDIsTis9VCs9di5yPWxbQl0says9Tys9di5nPWxbQisxXSxIKz1NKz12LmI9bFtCKzJdLHY9di5uZXh0LFMrPVE9Yi5yLEwrPVU9Yi5nLEkrPUU9Yi5iLFQtPVEsTy09VSxNLT1FLGI9Yi5uZXh0LHgrPTQ7ais9cn1mb3IodmFyIEs9MDtLPHI7SysrKXt2YXIgVj1sW3g9Szw8Ml0sRz1sW3grMV0sej1sW3grMl0scT1mKlYsVz1mKkcsWD1mKnosWT1wKlYsSj1wKkcsWj1wKno7bT1nO2Zvcih2YXIgJD0wOyQ8ZjskKyspbS5yPVYsbS5nPUcsbS5iPXosbT1tLm5leHQ7Zm9yKHZhciBlZT0wLHRlPTAsQWU9MCxyZT0xLG5lPXI7cmU8PW87cmUrKyl4PW5lK0s8PDIsWSs9KG0ucj1WPWxbeF0pKih5PWYtcmUpLEorPShtLmc9Rz1sW3grMV0pKnksWis9KG0uYj16PWxbeCsyXSkqeSxlZSs9Vix0ZSs9RyxBZSs9eixtPW0ubmV4dCxyZTxkJiYobmUrPXIpO3g9Syx2PWcsYj1hO2Zvcih2YXIgc2U9MDtzZTxpO3NlKyspbFtCPXg8PDJdPVkqQz4+Pl8sbFtCKzFdPUoqQz4+Pl8sbFtCKzJdPVoqQz4+Pl8sWS09cSxKLT1XLFotPVgscS09di5yLFctPXYuZyxYLT12LmIsQj1LKygoQj1zZStmKTxkP0I6ZCkqcjw8MixZKz1lZSs9di5yPWxbQl0sSis9dGUrPXYuZz1sW0IrMV0sWis9QWUrPXYuYj1sW0IrMl0sdj12Lm5leHQscSs9Vj1iLnIsVys9Rz1iLmcsWCs9ej1iLmIsZWUtPVYsdGUtPUcsQWUtPXosYj1iLm5leHQseCs9cn1yZXR1cm4gZX12YXIgaD1mdW5jdGlvbiBlKCl7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIil9KHRoaXMsZSksdGhpcy5yPTAsdGhpcy5nPTAsdGhpcy5iPTAsdGhpcy5hPTAsdGhpcy5uZXh0PW51bGx9fSwiLi9ub2RlX21vZHVsZXMvc3ZnLXBhdGhkYXRhL2xpYi9TVkdQYXRoRGF0YS5tb2R1bGUuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QS5yKHQpLEEuZCh0LHtDT01NQU5EX0FSR19DT1VOVFM6ZnVuY3Rpb24oKXtyZXR1cm4gQ30sU1ZHUGF0aERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gYn0sU1ZHUGF0aERhdGFQYXJzZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdn0sU1ZHUGF0aERhdGFUcmFuc2Zvcm1lcjpmdW5jdGlvbigpe3JldHVybiB1fSxlbmNvZGVTVkdQYXRoOmZ1bmN0aW9uKCl7cmV0dXJuIHN9fSk7dmFyIHI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4ocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIEEgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxBKSYmKGVbQV09dFtBXSl9KShlLHQpfTtmdW5jdGlvbiBuKGUsdCl7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoIkNsYXNzIGV4dGVuZHMgdmFsdWUgIitTdHJpbmcodCkrIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsIik7ZnVuY3Rpb24gQSgpe3RoaXMuY29uc3RydWN0b3I9ZX1yKGUsdCksZS5wcm90b3R5cGU9bnVsbD09PXQ/T2JqZWN0LmNyZWF0ZSh0KTooQS5wcm90b3R5cGU9dC5wcm90b3R5cGUsbmV3IEEpfWZ1bmN0aW9uIHMoZSl7dmFyIHQ9IiI7QXJyYXkuaXNBcnJheShlKXx8KGU9W2VdKTtmb3IodmFyIEE9MDtBPGUubGVuZ3RoO0ErKyl7dmFyIHI9ZVtBXTtpZihyLnR5cGU9PT1iLkNMT1NFX1BBVEgpdCs9InoiO2Vsc2UgaWYoci50eXBlPT09Yi5IT1JJWl9MSU5FX1RPKXQrPShyLnJlbGF0aXZlPyJoIjoiSCIpK3IueDtlbHNlIGlmKHIudHlwZT09PWIuVkVSVF9MSU5FX1RPKXQrPShyLnJlbGF0aXZlPyJ2IjoiViIpK3IueTtlbHNlIGlmKHIudHlwZT09PWIuTU9WRV9UTyl0Kz0oci5yZWxhdGl2ZT8ibSI6Ik0iKStyLngrIiAiK3IueTtlbHNlIGlmKHIudHlwZT09PWIuTElORV9UTyl0Kz0oci5yZWxhdGl2ZT8ibCI6IkwiKStyLngrIiAiK3IueTtlbHNlIGlmKHIudHlwZT09PWIuQ1VSVkVfVE8pdCs9KHIucmVsYXRpdmU/ImMiOiJDIikrci54MSsiICIrci55MSsiICIrci54MisiICIrci55MisiICIrci54KyIgIityLnk7ZWxzZSBpZihyLnR5cGU9PT1iLlNNT09USF9DVVJWRV9UTyl0Kz0oci5yZWxhdGl2ZT8icyI6IlMiKStyLngyKyIgIityLnkyKyIgIityLngrIiAiK3IueTtlbHNlIGlmKHIudHlwZT09PWIuUVVBRF9UTyl0Kz0oci5yZWxhdGl2ZT8icSI6IlEiKStyLngxKyIgIityLnkxKyIgIityLngrIiAiK3IueTtlbHNlIGlmKHIudHlwZT09PWIuU01PT1RIX1FVQURfVE8pdCs9KHIucmVsYXRpdmU/InQiOiJUIikrci54KyIgIityLnk7ZWxzZXtpZihyLnR5cGUhPT1iLkFSQyl0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29tbWFuZCB0eXBlICInK3IudHlwZSsnIiBhdCBpbmRleCAnK0ErIi4iKTt0Kz0oci5yZWxhdGl2ZT8iYSI6IkEiKStyLnJYKyIgIityLnJZKyIgIityLnhSb3QrIiAiKyArci5sQXJjRmxhZysiICIrICtyLnN3ZWVwRmxhZysiICIrci54KyIgIityLnl9fXJldHVybiB0fWZ1bmN0aW9uIGkoZSx0KXt2YXIgQT1lWzBdLHI9ZVsxXTtyZXR1cm5bQSpNYXRoLmNvcyh0KS1yKk1hdGguc2luKHQpLEEqTWF0aC5zaW4odCkrcipNYXRoLmNvcyh0KV19ZnVuY3Rpb24gbygpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllW3RdPWFyZ3VtZW50c1t0XTtmb3IodmFyIEE9MDtBPGUubGVuZ3RoO0ErKylpZigibnVtYmVyIiE9dHlwZW9mIGVbQV0pdGhyb3cgbmV3IEVycm9yKCJhc3NlcnROdW1iZXJzIGFyZ3VtZW50c1siK0ErIl0gaXMgbm90IGEgbnVtYmVyLiAiK3R5cGVvZiBlW0FdKyIgPT0gdHlwZW9mICIrZVtBXSk7cmV0dXJuITB9dmFyIGE9TWF0aC5QSTtmdW5jdGlvbiBsKGUsdCxBKXtlLmxBcmNGbGFnPTA9PT1lLmxBcmNGbGFnPzA6MSxlLnN3ZWVwRmxhZz0wPT09ZS5zd2VlcEZsYWc/MDoxO3ZhciByPWUuclgsbj1lLnJZLHM9ZS54LG89ZS55O3I9TWF0aC5hYnMoZS5yWCksbj1NYXRoLmFicyhlLnJZKTt2YXIgbD1pKFsodC1zKS8yLChBLW8pLzJdLC1lLnhSb3QvMTgwKmEpLGM9bFswXSx1PWxbMV0saD1NYXRoLnBvdyhjLDIpL01hdGgucG93KHIsMikrTWF0aC5wb3codSwyKS9NYXRoLnBvdyhuLDIpOzE8aCYmKHIqPU1hdGguc3FydChoKSxuKj1NYXRoLnNxcnQoaCkpLGUuclg9cixlLnJZPW47dmFyIGQ9TWF0aC5wb3cociwyKSpNYXRoLnBvdyh1LDIpK01hdGgucG93KG4sMikqTWF0aC5wb3coYywyKSxmPShlLmxBcmNGbGFnIT09ZS5zd2VlcEZsYWc/MTotMSkqTWF0aC5zcXJ0KE1hdGgubWF4KDAsKE1hdGgucG93KHIsMikqTWF0aC5wb3cobiwyKS1kKS9kKSkscD1yKnUvbipmLGc9LW4qYy9yKmYsbT1pKFtwLGddLGUueFJvdC8xODAqYSk7ZS5jWD1tWzBdKyh0K3MpLzIsZS5jWT1tWzFdKyhBK28pLzIsZS5waGkxPU1hdGguYXRhbjIoKHUtZykvbiwoYy1wKS9yKSxlLnBoaTI9TWF0aC5hdGFuMigoLXUtZykvbiwoLWMtcCkvciksMD09PWUuc3dlZXBGbGFnJiZlLnBoaTI+ZS5waGkxJiYoZS5waGkyLT0yKmEpLDE9PT1lLnN3ZWVwRmxhZyYmZS5waGkyPGUucGhpMSYmKGUucGhpMis9MiphKSxlLnBoaTEqPTE4MC9hLGUucGhpMio9MTgwL2F9ZnVuY3Rpb24gYyhlLHQsQSl7byhlLHQsQSk7dmFyIHI9ZSplK3QqdC1BKkE7aWYoMD5yKXJldHVybltdO2lmKDA9PT1yKXJldHVybltbZSpBLyhlKmUrdCp0KSx0KkEvKGUqZSt0KnQpXV07dmFyIG49TWF0aC5zcXJ0KHIpO3JldHVybltbKGUqQSt0Km4pLyhlKmUrdCp0KSwodCpBLWUqbikvKGUqZSt0KnQpXSxbKGUqQS10Km4pLyhlKmUrdCp0KSwodCpBK2UqbikvKGUqZSt0KnQpXV19dmFyIHUsaD1NYXRoLlBJLzE4MDtmdW5jdGlvbiBkKGUsdCxBKXtyZXR1cm4oMS1BKSplK0EqdH1mdW5jdGlvbiBmKGUsdCxBLHIpe3JldHVybiBlK01hdGguY29zKHIvMTgwKmEpKnQrTWF0aC5zaW4oci8xODAqYSkqQX1mdW5jdGlvbiBwKGUsdCxBLHIpe3ZhciBuPTFlLTYscz10LWUsaT1BLXQsbz0zKnMrMyooci1BKS02KmksYT02KihpLXMpLGw9MypzO3JldHVybiBNYXRoLmFicyhvKTxuP1stbC9hXTpmdW5jdGlvbihlLHQsQSl7dm9pZCAwPT09QSYmKEE9MWUtNik7dmFyIHI9ZSplLzQtdDtpZihyPC1BKXJldHVybltdO2lmKHI8PUEpcmV0dXJuWy1lLzJdO3ZhciBuPU1hdGguc3FydChyKTtyZXR1cm5bLWUvMi1uLC1lLzIrbl19KGEvbyxsL28sbil9ZnVuY3Rpb24gZyhlLHQsQSxyLG4pe3ZhciBzPTEtbjtyZXR1cm4gZSoocypzKnMpK3QqKDMqcypzKm4pK0EqKDMqcypuKm4pK3IqKG4qbipuKX0hZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBuKGZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gZS5yZWxhdGl2ZSYmKHZvaWQgMCE9PWUueDEmJihlLngxKz10KSx2b2lkIDAhPT1lLnkxJiYoZS55MSs9QSksdm9pZCAwIT09ZS54MiYmKGUueDIrPXQpLHZvaWQgMCE9PWUueTImJihlLnkyKz1BKSx2b2lkIDAhPT1lLngmJihlLngrPXQpLHZvaWQgMCE9PWUueSYmKGUueSs9QSksZS5yZWxhdGl2ZT0hMSksZX0pfWZ1bmN0aW9uIEEoKXt2YXIgZT1OYU4sdD1OYU4sQT1OYU4scj1OYU47cmV0dXJuIG4oZnVuY3Rpb24obixzLGkpe3JldHVybiBuLnR5cGUmYi5TTU9PVEhfQ1VSVkVfVE8mJihuLnR5cGU9Yi5DVVJWRV9UTyxlPWlzTmFOKGUpP3M6ZSx0PWlzTmFOKHQpP2k6dCxuLngxPW4ucmVsYXRpdmU/cy1lOjIqcy1lLG4ueTE9bi5yZWxhdGl2ZT9pLXQ6MippLXQpLG4udHlwZSZiLkNVUlZFX1RPPyhlPW4ucmVsYXRpdmU/cytuLngyOm4ueDIsdD1uLnJlbGF0aXZlP2krbi55MjpuLnkyKTooZT1OYU4sdD1OYU4pLG4udHlwZSZiLlNNT09USF9RVUFEX1RPJiYobi50eXBlPWIuUVVBRF9UTyxBPWlzTmFOKEEpP3M6QSxyPWlzTmFOKHIpP2k6cixuLngxPW4ucmVsYXRpdmU/cy1BOjIqcy1BLG4ueTE9bi5yZWxhdGl2ZT9pLXI6MippLXIpLG4udHlwZSZiLlFVQURfVE8/KEE9bi5yZWxhdGl2ZT9zK24ueDE6bi54MSxyPW4ucmVsYXRpdmU/aStuLnkxOm4ueTEpOihBPU5hTixyPU5hTiksbn0pfWZ1bmN0aW9uIHIoKXt2YXIgZT1OYU4sdD1OYU47cmV0dXJuIG4oZnVuY3Rpb24oQSxyLG4pe2lmKEEudHlwZSZiLlNNT09USF9RVUFEX1RPJiYoQS50eXBlPWIuUVVBRF9UTyxlPWlzTmFOKGUpP3I6ZSx0PWlzTmFOKHQpP246dCxBLngxPUEucmVsYXRpdmU/ci1lOjIqci1lLEEueTE9QS5yZWxhdGl2ZT9uLXQ6MipuLXQpLEEudHlwZSZiLlFVQURfVE8pe2U9QS5yZWxhdGl2ZT9yK0EueDE6QS54MSx0PUEucmVsYXRpdmU/bitBLnkxOkEueTE7dmFyIHM9QS54MSxpPUEueTE7QS50eXBlPWIuQ1VSVkVfVE8sQS54MT0oKEEucmVsYXRpdmU/MDpyKSsyKnMpLzMsQS55MT0oKEEucmVsYXRpdmU/MDpuKSsyKmkpLzMsQS54Mj0oQS54KzIqcykvMyxBLnkyPShBLnkrMippKS8zfWVsc2UgZT1OYU4sdD1OYU47cmV0dXJuIEF9KX1mdW5jdGlvbiBuKGUpe3ZhciB0PTAsQT0wLHI9TmFOLG49TmFOO3JldHVybiBmdW5jdGlvbihzKXtpZihpc05hTihyKSYmIShzLnR5cGUmYi5NT1ZFX1RPKSl0aHJvdyBuZXcgRXJyb3IoInBhdGggbXVzdCBzdGFydCB3aXRoIG1vdmV0byIpO3ZhciBpPWUocyx0LEEscixuKTtyZXR1cm4gcy50eXBlJmIuQ0xPU0VfUEFUSCYmKHQ9cixBPW4pLHZvaWQgMCE9PXMueCYmKHQ9cy5yZWxhdGl2ZT90K3MueDpzLngpLHZvaWQgMCE9PXMueSYmKEE9cy5yZWxhdGl2ZT9BK3MueTpzLnkpLHMudHlwZSZiLk1PVkVfVE8mJihyPXQsbj1BKSxpfX1mdW5jdGlvbiBzKGUsdCxBLHIscyxpKXtyZXR1cm4gbyhlLHQsQSxyLHMsaSksbihmdW5jdGlvbihuLG8sYSxsKXt2YXIgYz1uLngxLHU9bi54MixoPW4ucmVsYXRpdmUmJiFpc05hTihsKSxkPXZvaWQgMCE9PW4ueD9uLng6aD8wOm8sZj12b2lkIDAhPT1uLnk/bi55Omg/MDphO2Z1bmN0aW9uIHAoZSl7cmV0dXJuIGUqZX1uLnR5cGUmYi5IT1JJWl9MSU5FX1RPJiYwIT09dCYmKG4udHlwZT1iLkxJTkVfVE8sbi55PW4ucmVsYXRpdmU/MDphKSxuLnR5cGUmYi5WRVJUX0xJTkVfVE8mJjAhPT1BJiYobi50eXBlPWIuTElORV9UTyxuLng9bi5yZWxhdGl2ZT8wOm8pLHZvaWQgMCE9PW4ueCYmKG4ueD1uLngqZStmKkErKGg/MDpzKSksdm9pZCAwIT09bi55JiYobi55PWQqdCtuLnkqcisoaD8wOmkpKSx2b2lkIDAhPT1uLngxJiYobi54MT1uLngxKmUrbi55MSpBKyhoPzA6cykpLHZvaWQgMCE9PW4ueTEmJihuLnkxPWMqdCtuLnkxKnIrKGg/MDppKSksdm9pZCAwIT09bi54MiYmKG4ueDI9bi54MiplK24ueTIqQSsoaD8wOnMpKSx2b2lkIDAhPT1uLnkyJiYobi55Mj11KnQrbi55MipyKyhoPzA6aSkpO3ZhciBnPWUqci10KkE7aWYodm9pZCAwIT09bi54Um90JiYoMSE9PWV8fDAhPT10fHwwIT09QXx8MSE9PXIpKWlmKDA9PT1nKWRlbGV0ZSBuLnJYLGRlbGV0ZSBuLnJZLGRlbGV0ZSBuLnhSb3QsZGVsZXRlIG4ubEFyY0ZsYWcsZGVsZXRlIG4uc3dlZXBGbGFnLG4udHlwZT1iLkxJTkVfVE87ZWxzZXt2YXIgbT1uLnhSb3QqTWF0aC5QSS8xODAsdz1NYXRoLnNpbihtKSxCPU1hdGguY29zKG0pLHk9MS9wKG4uclgpLHY9MS9wKG4uclkpLEM9cChCKSp5K3AodykqdixfPTIqdypCKih5LXYpLGo9cCh3KSp5K3AoQikqdix4PUMqcipyLV8qdCpyK2oqdCp0LEY9XyooZSpyK3QqQSktMiooQypBKnIraiplKnQpLFE9QypBKkEtXyplKkEraiplKmUsVT0oTWF0aC5hdGFuMihGLHgtUSkrTWF0aC5QSSklTWF0aC5QSS8yLEU9TWF0aC5zaW4oVSksUz1NYXRoLmNvcyhVKTtuLnJYPU1hdGguYWJzKGcpL01hdGguc3FydCh4KnAoUykrRipFKlMrUSpwKEUpKSxuLnJZPU1hdGguYWJzKGcpL01hdGguc3FydCh4KnAoRSktRipFKlMrUSpwKFMpKSxuLnhSb3Q9MTgwKlUvTWF0aC5QSX1yZXR1cm4gdm9pZCAwIT09bi5zd2VlcEZsYWcmJjA+ZyYmKG4uc3dlZXBGbGFnPSshbi5zd2VlcEZsYWcpLG59KX1lLlJPVU5EPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIE1hdGgucm91bmQodCplKS9lfXJldHVybiB2b2lkIDA9PT1lJiYoZT0xZTEzKSxvKGUpLGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1lLngxJiYoZS54MT10KGUueDEpKSx2b2lkIDAhPT1lLnkxJiYoZS55MT10KGUueTEpKSx2b2lkIDAhPT1lLngyJiYoZS54Mj10KGUueDIpKSx2b2lkIDAhPT1lLnkyJiYoZS55Mj10KGUueTIpKSx2b2lkIDAhPT1lLngmJihlLng9dChlLngpKSx2b2lkIDAhPT1lLnkmJihlLnk9dChlLnkpKSx2b2lkIDAhPT1lLnJYJiYoZS5yWD10KGUuclgpKSx2b2lkIDAhPT1lLnJZJiYoZS5yWT10KGUuclkpKSxlfX0sZS5UT19BQlM9dCxlLlRPX1JFTD1mdW5jdGlvbigpe3JldHVybiBuKGZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gZS5yZWxhdGl2ZXx8KHZvaWQgMCE9PWUueDEmJihlLngxLT10KSx2b2lkIDAhPT1lLnkxJiYoZS55MS09QSksdm9pZCAwIT09ZS54MiYmKGUueDItPXQpLHZvaWQgMCE9PWUueTImJihlLnkyLT1BKSx2b2lkIDAhPT1lLngmJihlLngtPXQpLHZvaWQgMCE9PWUueSYmKGUueS09QSksZS5yZWxhdGl2ZT0hMCksZX0pfSxlLk5PUk1BTElaRV9IVlo9ZnVuY3Rpb24oZSx0LEEpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMCksdm9pZCAwPT09dCYmKHQ9ITApLHZvaWQgMD09PUEmJihBPSEwKSxuKGZ1bmN0aW9uKHIsbixzLGksbyl7aWYoaXNOYU4oaSkmJiEoci50eXBlJmIuTU9WRV9UTykpdGhyb3cgbmV3IEVycm9yKCJwYXRoIG11c3Qgc3RhcnQgd2l0aCBtb3ZldG8iKTtyZXR1cm4gdCYmci50eXBlJmIuSE9SSVpfTElORV9UTyYmKHIudHlwZT1iLkxJTkVfVE8sci55PXIucmVsYXRpdmU/MDpzKSxBJiZyLnR5cGUmYi5WRVJUX0xJTkVfVE8mJihyLnR5cGU9Yi5MSU5FX1RPLHIueD1yLnJlbGF0aXZlPzA6biksZSYmci50eXBlJmIuQ0xPU0VfUEFUSCYmKHIudHlwZT1iLkxJTkVfVE8sci54PXIucmVsYXRpdmU/aS1uOmksci55PXIucmVsYXRpdmU/by1zOm8pLHIudHlwZSZiLkFSQyYmKDA9PT1yLnJYfHwwPT09ci5yWSkmJihyLnR5cGU9Yi5MSU5FX1RPLGRlbGV0ZSByLnJYLGRlbGV0ZSByLnJZLGRlbGV0ZSByLnhSb3QsZGVsZXRlIHIubEFyY0ZsYWcsZGVsZXRlIHIuc3dlZXBGbGFnKSxyfSl9LGUuTk9STUFMSVpFX1NUPUEsZS5RVF9UT19DPXIsZS5JTkZPPW4sZS5TQU5JVElaRT1mdW5jdGlvbihlKXt2b2lkIDA9PT1lJiYoZT0wKSxvKGUpO3ZhciB0PU5hTixBPU5hTixyPU5hTixzPU5hTjtyZXR1cm4gbihmdW5jdGlvbihuLGksbyxhLGwpe3ZhciBjPU1hdGguYWJzLHU9ITEsaD0wLGQ9MDtpZihuLnR5cGUmYi5TTU9PVEhfQ1VSVkVfVE8mJihoPWlzTmFOKHQpPzA6aS10LGQ9aXNOYU4oQSk/MDpvLUEpLG4udHlwZSYoYi5DVVJWRV9UT3xiLlNNT09USF9DVVJWRV9UTyk/KHQ9bi5yZWxhdGl2ZT9pK24ueDI6bi54MixBPW4ucmVsYXRpdmU/bytuLnkyOm4ueTIpOih0PU5hTixBPU5hTiksbi50eXBlJmIuU01PT1RIX1FVQURfVE8/KHI9aXNOYU4ocik/aToyKmktcixzPWlzTmFOKHMpP286MipvLXMpOm4udHlwZSZiLlFVQURfVE8/KHI9bi5yZWxhdGl2ZT9pK24ueDE6bi54MSxzPW4ucmVsYXRpdmU/bytuLnkxOm4ueTIpOihyPU5hTixzPU5hTiksbi50eXBlJmIuTElORV9DT01NQU5EU3x8bi50eXBlJmIuQVJDJiYoMD09PW4uclh8fDA9PT1uLnJZfHwhbi5sQXJjRmxhZyl8fG4udHlwZSZiLkNVUlZFX1RPfHxuLnR5cGUmYi5TTU9PVEhfQ1VSVkVfVE98fG4udHlwZSZiLlFVQURfVE98fG4udHlwZSZiLlNNT09USF9RVUFEX1RPKXt2YXIgZj12b2lkIDA9PT1uLng/MDpuLnJlbGF0aXZlP24ueDpuLngtaSxwPXZvaWQgMD09PW4ueT8wOm4ucmVsYXRpdmU/bi55Om4ueS1vO2g9aXNOYU4ocik/dm9pZCAwPT09bi54MT9oOm4ucmVsYXRpdmU/bi54Om4ueDEtaTpyLWksZD1pc05hTihzKT92b2lkIDA9PT1uLnkxP2Q6bi5yZWxhdGl2ZT9uLnk6bi55MS1vOnMtbzt2YXIgZz12b2lkIDA9PT1uLngyPzA6bi5yZWxhdGl2ZT9uLng6bi54Mi1pLG09dm9pZCAwPT09bi55Mj8wOm4ucmVsYXRpdmU/bi55Om4ueTItbztjKGYpPD1lJiZjKHApPD1lJiZjKGgpPD1lJiZjKGQpPD1lJiZjKGcpPD1lJiZjKG0pPD1lJiYodT0hMCl9cmV0dXJuIG4udHlwZSZiLkNMT1NFX1BBVEgmJmMoaS1hKTw9ZSYmYyhvLWwpPD1lJiYodT0hMCksdT9bXTpufSl9LGUuTUFUUklYPXMsZS5ST1RBVEU9ZnVuY3Rpb24oZSx0LEEpe3ZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PUEmJihBPTApLG8oZSx0LEEpO3ZhciByPU1hdGguc2luKGUpLG49TWF0aC5jb3MoZSk7cmV0dXJuIHMobixyLC1yLG4sdC10Km4rQSpyLEEtdCpyLUEqbil9LGUuVFJBTlNMQVRFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLG8oZSx0KSxzKDEsMCwwLDEsZSx0KX0sZS5TQ0FMRT1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD1lKSxvKGUsdCkscyhlLDAsMCx0LDAsMCl9LGUuU0tFV19YPWZ1bmN0aW9uKGUpe3JldHVybiBvKGUpLHMoMSwwLE1hdGguYXRhbihlKSwxLDAsMCl9LGUuU0tFV19ZPWZ1bmN0aW9uKGUpe3JldHVybiBvKGUpLHMoMSxNYXRoLmF0YW4oZSksMCwxLDAsMCl9LGUuWF9BWElTX1NZTU1FVFJZPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSxvKGUpLHMoLTEsMCwwLDEsZSwwKX0sZS5ZX0FYSVNfU1lNTUVUUlk9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLG8oZSkscygxLDAsMCwtMSwwLGUpfSxlLkFfVE9fQz1mdW5jdGlvbigpe3JldHVybiBuKGZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gYi5BUkM9PT1lLnR5cGU/ZnVuY3Rpb24oZSx0LEEpe3ZhciByLG4scyxvO2UuY1h8fGwoZSx0LEEpO2Zvcih2YXIgYT1NYXRoLm1pbihlLnBoaTEsZS5waGkyKSxjPU1hdGgubWF4KGUucGhpMSxlLnBoaTIpLWEsdT1NYXRoLmNlaWwoYy85MCksZj1uZXcgQXJyYXkodSkscD10LGc9QSxtPTA7bTx1O20rKyl7dmFyIHc9ZChlLnBoaTEsZS5waGkyLG0vdSksQj1kKGUucGhpMSxlLnBoaTIsKG0rMSkvdSkseT1CLXcsdj00LzMqTWF0aC50YW4oeSpoLzQpLEM9W01hdGguY29zKHcqaCktdipNYXRoLnNpbih3KmgpLE1hdGguc2luKHcqaCkrdipNYXRoLmNvcyh3KmgpXSxfPUNbMF0saj1DWzFdLHg9W01hdGguY29zKEIqaCksTWF0aC5zaW4oQipoKV0sRj14WzBdLFE9eFsxXSxVPVtGK3YqTWF0aC5zaW4oQipoKSxRLXYqTWF0aC5jb3MoQipoKV0sRT1VWzBdLFM9VVsxXTtmW21dPXtyZWxhdGl2ZTplLnJlbGF0aXZlLHR5cGU6Yi5DVVJWRV9UT307dmFyIEw9ZnVuY3Rpb24odCxBKXt2YXIgcj1pKFt0KmUuclgsQSplLnJZXSxlLnhSb3QpLG49clswXSxzPXJbMV07cmV0dXJuW2UuY1grbixlLmNZK3NdfTtyPUwoXyxqKSxmW21dLngxPXJbMF0sZlttXS55MT1yWzFdLG49TChFLFMpLGZbbV0ueDI9blswXSxmW21dLnkyPW5bMV0scz1MKEYsUSksZlttXS54PXNbMF0sZlttXS55PXNbMV0sZS5yZWxhdGl2ZSYmKGZbbV0ueDEtPXAsZlttXS55MS09ZyxmW21dLngyLT1wLGZbbV0ueTItPWcsZlttXS54LT1wLGZbbV0ueS09ZykscD0obz1bZlttXS54LGZbbV0ueV0pWzBdLGc9b1sxXX1yZXR1cm4gZn0oZSxlLnJlbGF0aXZlPzA6dCxlLnJlbGF0aXZlPzA6QSk6ZX0pfSxlLkFOTk9UQVRFX0FSQ1M9ZnVuY3Rpb24oKXtyZXR1cm4gbihmdW5jdGlvbihlLHQsQSl7cmV0dXJuIGUucmVsYXRpdmUmJih0PTAsQT0wKSxiLkFSQz09PWUudHlwZSYmbChlLHQsQSksZX0pfSxlLkNMT05FPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PXt9O2Zvcih2YXIgQSBpbiBlKXRbQV09ZVtBXTtyZXR1cm4gdH19LGUuQ0FMQ1VMQVRFX0JPVU5EUz1mdW5jdGlvbigpe3ZhciBlPXQoKSxzPXIoKSxpPUEoKSxvPW4oZnVuY3Rpb24odCxBLHIpe3ZhciBuPWkocyhlKGZ1bmN0aW9uKGUpe3ZhciB0PXt9O2Zvcih2YXIgQSBpbiBlKXRbQV09ZVtBXTtyZXR1cm4gdH0odCkpKSk7ZnVuY3Rpb24gYShlKXtlPm8ubWF4WCYmKG8ubWF4WD1lKSxlPG8ubWluWCYmKG8ubWluWD1lKX1mdW5jdGlvbiB1KGUpe2U+by5tYXhZJiYoby5tYXhZPWUpLGU8by5taW5ZJiYoby5taW5ZPWUpfWlmKG4udHlwZSZiLkRSQVdJTkdfQ09NTUFORFMmJihhKEEpLHUocikpLG4udHlwZSZiLkhPUklaX0xJTkVfVE8mJmEobi54KSxuLnR5cGUmYi5WRVJUX0xJTkVfVE8mJnUobi55KSxuLnR5cGUmYi5MSU5FX1RPJiYoYShuLngpLHUobi55KSksbi50eXBlJmIuQ1VSVkVfVE8pe2Eobi54KSx1KG4ueSk7Zm9yKHZhciBoPTAsZD1wKEEsbi54MSxuLngyLG4ueCk7aDxkLmxlbmd0aDtoKyspMDwoST1kW2hdKSYmMT5JJiZhKGcoQSxuLngxLG4ueDIsbi54LEkpKTtmb3IodmFyIG09MCx3PXAocixuLnkxLG4ueTIsbi55KTttPHcubGVuZ3RoO20rKykwPChJPXdbbV0pJiYxPkkmJnUoZyhyLG4ueTEsbi55MixuLnksSSkpfWlmKG4udHlwZSZiLkFSQyl7YShuLngpLHUobi55KSxsKG4sQSxyKTtmb3IodmFyIEI9bi54Um90LzE4MCpNYXRoLlBJLHk9TWF0aC5jb3MoQikqbi5yWCx2PU1hdGguc2luKEIpKm4uclgsQz0tTWF0aC5zaW4oQikqbi5yWSxfPU1hdGguY29zKEIpKm4uclksaj1uLnBoaTE8bi5waGkyP1tuLnBoaTEsbi5waGkyXTotMTgwPm4ucGhpMj9bbi5waGkyKzM2MCxuLnBoaTErMzYwXTpbbi5waGkyLG4ucGhpMV0seD1qWzBdLEY9alsxXSxRPWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0sQT1lWzFdLHI9MTgwKk1hdGguYXRhbjIoQSx0KS9NYXRoLlBJO3JldHVybiByPHg/ciszNjA6cn0sVT0wLEU9YyhDLC15LDApLm1hcChRKTtVPEUubGVuZ3RoO1UrKykoST1FW1VdKT54JiZJPEYmJmEoZihuLmNYLHksQyxJKSk7Zm9yKHZhciBTPTAsTD1jKF8sLXYsMCkubWFwKFEpO1M8TC5sZW5ndGg7UysrKXt2YXIgSTsoST1MW1NdKT54JiZJPEYmJnUoZihuLmNZLHYsXyxJKSl9fXJldHVybiB0fSk7cmV0dXJuIG8ubWluWD0xLzAsby5tYXhYPS0xLzAsby5taW5ZPTEvMCxvLm1heFk9LTEvMCxvfX0odXx8KHU9e30pKTt2YXIgbSx3PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuUk9VTkQoZSkpfSxlLnByb3RvdHlwZS50b0Ficz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlRPX0FCUygpKX0sZS5wcm90b3R5cGUudG9SZWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5UT19SRUwoKSl9LGUucHJvdG90eXBlLm5vcm1hbGl6ZUhWWj1mdW5jdGlvbihlLHQsQSl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuTk9STUFMSVpFX0hWWihlLHQsQSkpfSxlLnByb3RvdHlwZS5ub3JtYWxpemVTVD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1Lk5PUk1BTElaRV9TVCgpKX0sZS5wcm90b3R5cGUucXRUb0M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5RVF9UT19DKCkpfSxlLnByb3RvdHlwZS5hVG9DPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuQV9UT19DKCkpfSxlLnByb3RvdHlwZS5zYW5pdGl6ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5TQU5JVElaRShlKSl9LGUucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlRSQU5TTEFURShlLHQpKX0sZS5wcm90b3R5cGUuc2NhbGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5TQ0FMRShlLHQpKX0sZS5wcm90b3R5cGUucm90YXRlPWZ1bmN0aW9uKGUsdCxBKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5ST1RBVEUoZSx0LEEpKX0sZS5wcm90b3R5cGUubWF0cml4PWZ1bmN0aW9uKGUsdCxBLHIsbixzKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5NQVRSSVgoZSx0LEEscixuLHMpKX0sZS5wcm90b3R5cGUuc2tld1g9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuU0tFV19YKGUpKX0sZS5wcm90b3R5cGUuc2tld1k9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudHJhbnNmb3JtKHUuU0tFV19ZKGUpKX0sZS5wcm90b3R5cGUueFN5bW1ldHJ5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRyYW5zZm9ybSh1LlhfQVhJU19TWU1NRVRSWShlKSl9LGUucHJvdG90eXBlLnlTeW1tZXRyeT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5ZX0FYSVNfU1lNTUVUUlkoZSkpfSxlLnByb3RvdHlwZS5hbm5vdGF0ZUFyY3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm0odS5BTk5PVEFURV9BUkNTKCkpfSxlfSgpLEI9ZnVuY3Rpb24oZSl7cmV0dXJuIiAiPT09ZXx8Ilx0Ij09PWV8fCJcciI9PT1lfHwiXG4iPT09ZX0seT1mdW5jdGlvbihlKXtyZXR1cm4iMCIuY2hhckNvZGVBdCgwKTw9ZS5jaGFyQ29kZUF0KDApJiZlLmNoYXJDb2RlQXQoMCk8PSI5Ii5jaGFyQ29kZUF0KDApfSx2PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgdD1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHQuY3VyTnVtYmVyPSIiLHQuY3VyQ29tbWFuZFR5cGU9LTEsdC5jdXJDb21tYW5kUmVsYXRpdmU9ITEsdC5jYW5QYXJzZUNvbW1hbmRPckNvbW1hPSEwLHQuY3VyTnVtYmVySGFzRXhwPSExLHQuY3VyTnVtYmVySGFzRXhwRGlnaXRzPSExLHQuY3VyTnVtYmVySGFzRGVjaW1hbD0hMSx0LmN1ckFyZ3M9W10sdH1yZXR1cm4gbih0LGUpLHQucHJvdG90eXBlLmZpbmlzaD1mdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lJiYoZT1bXSksdGhpcy5wYXJzZSgiICIsZSksMCE9PXRoaXMuY3VyQXJncy5sZW5ndGh8fCF0aGlzLmNhblBhcnNlQ29tbWFuZE9yQ29tbWEpdGhyb3cgbmV3IFN5bnRheEVycm9yKCJVbnRlcm1pbmF0ZWQgY29tbWFuZCBhdCB0aGUgcGF0aCBlbmQuIik7cmV0dXJuIGV9LHQucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKGUsdCl7dmFyIEE9dGhpczt2b2lkIDA9PT10JiYodD1bXSk7Zm9yKHZhciByPWZ1bmN0aW9uKGUpe3QucHVzaChlKSxBLmN1ckFyZ3MubGVuZ3RoPTAsQS5jYW5QYXJzZUNvbW1hbmRPckNvbW1hPSEwfSxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBzPWVbbl0saT0hKHRoaXMuY3VyQ29tbWFuZFR5cGUhPT1iLkFSQ3x8MyE9PXRoaXMuY3VyQXJncy5sZW5ndGgmJjQhPT10aGlzLmN1ckFyZ3MubGVuZ3RofHwxIT09dGhpcy5jdXJOdW1iZXIubGVuZ3RofHwiMCIhPT10aGlzLmN1ck51bWJlciYmIjEiIT09dGhpcy5jdXJOdW1iZXIpLG89eShzKSYmKCIwIj09PXRoaXMuY3VyTnVtYmVyJiYiMCI9PT1zfHxpKTtpZigheShzKXx8bylpZigiZSIhPT1zJiYiRSIhPT1zKWlmKCItIiE9PXMmJiIrIiE9PXN8fCF0aGlzLmN1ck51bWJlckhhc0V4cHx8dGhpcy5jdXJOdW1iZXJIYXNFeHBEaWdpdHMpaWYoIi4iIT09c3x8dGhpcy5jdXJOdW1iZXJIYXNFeHB8fHRoaXMuY3VyTnVtYmVySGFzRGVjaW1hbHx8aSl7aWYodGhpcy5jdXJOdW1iZXImJi0xIT09dGhpcy5jdXJDb21tYW5kVHlwZSl7dmFyIGE9TnVtYmVyKHRoaXMuY3VyTnVtYmVyKTtpZihpc05hTihhKSl0aHJvdyBuZXcgU3ludGF4RXJyb3IoIkludmFsaWQgbnVtYmVyIGVuZGluZyBhdCAiK24pO2lmKHRoaXMuY3VyQ29tbWFuZFR5cGU9PT1iLkFSQylpZigwPT09dGhpcy5jdXJBcmdzLmxlbmd0aHx8MT09PXRoaXMuY3VyQXJncy5sZW5ndGgpe2lmKDA+YSl0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0V4cGVjdGVkIHBvc2l0aXZlIG51bWJlciwgZ290ICInK2ErJyIgYXQgaW5kZXggIicrbisnIicpfWVsc2UgaWYoKDM9PT10aGlzLmN1ckFyZ3MubGVuZ3RofHw0PT09dGhpcy5jdXJBcmdzLmxlbmd0aCkmJiIwIiE9PXRoaXMuY3VyTnVtYmVyJiYiMSIhPT10aGlzLmN1ck51bWJlcil0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0V4cGVjdGVkIGEgZmxhZywgZ290ICInK3RoaXMuY3VyTnVtYmVyKyciIGF0IGluZGV4ICInK24rJyInKTt0aGlzLmN1ckFyZ3MucHVzaChhKSx0aGlzLmN1ckFyZ3MubGVuZ3RoPT09Q1t0aGlzLmN1ckNvbW1hbmRUeXBlXSYmKGIuSE9SSVpfTElORV9UTz09PXRoaXMuY3VyQ29tbWFuZFR5cGU/cih7dHlwZTpiLkhPUklaX0xJTkVfVE8scmVsYXRpdmU6dGhpcy5jdXJDb21tYW5kUmVsYXRpdmUseDphfSk6Yi5WRVJUX0xJTkVfVE89PT10aGlzLmN1ckNvbW1hbmRUeXBlP3Ioe3R5cGU6Yi5WRVJUX0xJTkVfVE8scmVsYXRpdmU6dGhpcy5jdXJDb21tYW5kUmVsYXRpdmUseTphfSk6dGhpcy5jdXJDb21tYW5kVHlwZT09PWIuTU9WRV9UT3x8dGhpcy5jdXJDb21tYW5kVHlwZT09PWIuTElORV9UT3x8dGhpcy5jdXJDb21tYW5kVHlwZT09PWIuU01PT1RIX1FVQURfVE8/KHIoe3R5cGU6dGhpcy5jdXJDb21tYW5kVHlwZSxyZWxhdGl2ZTp0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZSx4OnRoaXMuY3VyQXJnc1swXSx5OnRoaXMuY3VyQXJnc1sxXX0pLGIuTU9WRV9UTz09PXRoaXMuY3VyQ29tbWFuZFR5cGUmJih0aGlzLmN1ckNvbW1hbmRUeXBlPWIuTElORV9UTykpOnRoaXMuY3VyQ29tbWFuZFR5cGU9PT1iLkNVUlZFX1RPP3Ioe3R5cGU6Yi5DVVJWRV9UTyxyZWxhdGl2ZTp0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZSx4MTp0aGlzLmN1ckFyZ3NbMF0seTE6dGhpcy5jdXJBcmdzWzFdLHgyOnRoaXMuY3VyQXJnc1syXSx5Mjp0aGlzLmN1ckFyZ3NbM10seDp0aGlzLmN1ckFyZ3NbNF0seTp0aGlzLmN1ckFyZ3NbNV19KTp0aGlzLmN1ckNvbW1hbmRUeXBlPT09Yi5TTU9PVEhfQ1VSVkVfVE8/cih7dHlwZTpiLlNNT09USF9DVVJWRV9UTyxyZWxhdGl2ZTp0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZSx4Mjp0aGlzLmN1ckFyZ3NbMF0seTI6dGhpcy5jdXJBcmdzWzFdLHg6dGhpcy5jdXJBcmdzWzJdLHk6dGhpcy5jdXJBcmdzWzNdfSk6dGhpcy5jdXJDb21tYW5kVHlwZT09PWIuUVVBRF9UTz9yKHt0eXBlOmIuUVVBRF9UTyxyZWxhdGl2ZTp0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZSx4MTp0aGlzLmN1ckFyZ3NbMF0seTE6dGhpcy5jdXJBcmdzWzFdLHg6dGhpcy5jdXJBcmdzWzJdLHk6dGhpcy5jdXJBcmdzWzNdfSk6dGhpcy5jdXJDb21tYW5kVHlwZT09PWIuQVJDJiZyKHt0eXBlOmIuQVJDLHJlbGF0aXZlOnRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlLHJYOnRoaXMuY3VyQXJnc1swXSxyWTp0aGlzLmN1ckFyZ3NbMV0seFJvdDp0aGlzLmN1ckFyZ3NbMl0sbEFyY0ZsYWc6dGhpcy5jdXJBcmdzWzNdLHN3ZWVwRmxhZzp0aGlzLmN1ckFyZ3NbNF0seDp0aGlzLmN1ckFyZ3NbNV0seTp0aGlzLmN1ckFyZ3NbNl19KSksdGhpcy5jdXJOdW1iZXI9IiIsdGhpcy5jdXJOdW1iZXJIYXNFeHBEaWdpdHM9ITEsdGhpcy5jdXJOdW1iZXJIYXNFeHA9ITEsdGhpcy5jdXJOdW1iZXJIYXNEZWNpbWFsPSExLHRoaXMuY2FuUGFyc2VDb21tYW5kT3JDb21tYT0hMH1pZighQihzKSlpZigiLCI9PT1zJiZ0aGlzLmNhblBhcnNlQ29tbWFuZE9yQ29tbWEpdGhpcy5jYW5QYXJzZUNvbW1hbmRPckNvbW1hPSExO2Vsc2UgaWYoIisiIT09cyYmIi0iIT09cyYmIi4iIT09cylpZihvKXRoaXMuY3VyTnVtYmVyPXMsdGhpcy5jdXJOdW1iZXJIYXNEZWNpbWFsPSExO2Vsc2V7aWYoMCE9PXRoaXMuY3VyQXJncy5sZW5ndGgpdGhyb3cgbmV3IFN5bnRheEVycm9yKCJVbnRlcm1pbmF0ZWQgY29tbWFuZCBhdCBpbmRleCAiK24rIi4iKTtpZighdGhpcy5jYW5QYXJzZUNvbW1hbmRPckNvbW1hKXRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBjaGFyYWN0ZXIgIicrcysnIiBhdCBpbmRleCAnK24rIi4gQ29tbWFuZCBjYW5ub3QgZm9sbG93IGNvbW1hIik7aWYodGhpcy5jYW5QYXJzZUNvbW1hbmRPckNvbW1hPSExLCJ6IiE9PXMmJiJaIiE9PXMpaWYoImgiPT09c3x8IkgiPT09cyl0aGlzLmN1ckNvbW1hbmRUeXBlPWIuSE9SSVpfTElORV9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT0iaCI9PT1zO2Vsc2UgaWYoInYiPT09c3x8IlYiPT09cyl0aGlzLmN1ckNvbW1hbmRUeXBlPWIuVkVSVF9MSU5FX1RPLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPSJ2Ij09PXM7ZWxzZSBpZigibSI9PT1zfHwiTSI9PT1zKXRoaXMuY3VyQ29tbWFuZFR5cGU9Yi5NT1ZFX1RPLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPSJtIj09PXM7ZWxzZSBpZigibCI9PT1zfHwiTCI9PT1zKXRoaXMuY3VyQ29tbWFuZFR5cGU9Yi5MSU5FX1RPLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPSJsIj09PXM7ZWxzZSBpZigiYyI9PT1zfHwiQyI9PT1zKXRoaXMuY3VyQ29tbWFuZFR5cGU9Yi5DVVJWRV9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT0iYyI9PT1zO2Vsc2UgaWYoInMiPT09c3x8IlMiPT09cyl0aGlzLmN1ckNvbW1hbmRUeXBlPWIuU01PT1RIX0NVUlZFX1RPLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPSJzIj09PXM7ZWxzZSBpZigicSI9PT1zfHwiUSI9PT1zKXRoaXMuY3VyQ29tbWFuZFR5cGU9Yi5RVUFEX1RPLHRoaXMuY3VyQ29tbWFuZFJlbGF0aXZlPSJxIj09PXM7ZWxzZSBpZigidCI9PT1zfHwiVCI9PT1zKXRoaXMuY3VyQ29tbWFuZFR5cGU9Yi5TTU9PVEhfUVVBRF9UTyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT0idCI9PT1zO2Vsc2V7aWYoImEiIT09cyYmIkEiIT09cyl0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyICInK3MrJyIgYXQgaW5kZXggJytuKyIuIik7dGhpcy5jdXJDb21tYW5kVHlwZT1iLkFSQyx0aGlzLmN1ckNvbW1hbmRSZWxhdGl2ZT0iYSI9PT1zfWVsc2UgdC5wdXNoKHt0eXBlOmIuQ0xPU0VfUEFUSH0pLHRoaXMuY2FuUGFyc2VDb21tYW5kT3JDb21tYT0hMCx0aGlzLmN1ckNvbW1hbmRUeXBlPS0xfWVsc2UgdGhpcy5jdXJOdW1iZXI9cyx0aGlzLmN1ck51bWJlckhhc0RlY2ltYWw9Ii4iPT09c31lbHNlIHRoaXMuY3VyTnVtYmVyKz1zLHRoaXMuY3VyTnVtYmVySGFzRGVjaW1hbD0hMDtlbHNlIHRoaXMuY3VyTnVtYmVyKz1zO2Vsc2UgdGhpcy5jdXJOdW1iZXIrPXMsdGhpcy5jdXJOdW1iZXJIYXNFeHA9ITA7ZWxzZSB0aGlzLmN1ck51bWJlcis9cyx0aGlzLmN1ck51bWJlckhhc0V4cERpZ2l0cz10aGlzLmN1ck51bWJlckhhc0V4cH1yZXR1cm4gdH0sdC5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuY3JlYXRlKHRoaXMse3BhcnNlOnt2YWx1ZTpmdW5jdGlvbih0LEEpe3ZvaWQgMD09PUEmJihBPVtdKTtmb3IodmFyIHI9MCxuPU9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZS5jYWxsKHRoaXMsdCk7cjxuLmxlbmd0aDtyKyspe3ZhciBzPW5bcl0saT1lKHMpO0FycmF5LmlzQXJyYXkoaSk/QS5wdXNoLmFwcGx5KEEsaSk6QS5wdXNoKGkpfXJldHVybiBBfX19KX0sdH0odyksYj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KEEpe3ZhciByPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci5jb21tYW5kcz0ic3RyaW5nIj09dHlwZW9mIEE/dC5wYXJzZShBKTpBLHJ9cmV0dXJuIG4odCxlKSx0LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdC5lbmNvZGUodGhpcy5jb21tYW5kcyl9LHQucHJvdG90eXBlLmdldEJvdW5kcz1mdW5jdGlvbigpe3ZhciBlPXUuQ0FMQ1VMQVRFX0JPVU5EUygpO3JldHVybiB0aGlzLnRyYW5zZm9ybShlKSxlfSx0LnByb3RvdHlwZS50cmFuc2Zvcm09ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLEE9MCxyPXRoaXMuY29tbWFuZHM7QTxyLmxlbmd0aDtBKyspe3ZhciBuPWUocltBXSk7QXJyYXkuaXNBcnJheShuKT90LnB1c2guYXBwbHkodCxuKTp0LnB1c2gobil9cmV0dXJuIHRoaXMuY29tbWFuZHM9dCx0aGlzfSx0LmVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm4gcyhlKX0sdC5wYXJzZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgdixBPVtdO3JldHVybiB0LnBhcnNlKGUsQSksdC5maW5pc2goQSksQX0sdC5DTE9TRV9QQVRIPTEsdC5NT1ZFX1RPPTIsdC5IT1JJWl9MSU5FX1RPPTQsdC5WRVJUX0xJTkVfVE89OCx0LkxJTkVfVE89MTYsdC5DVVJWRV9UTz0zMix0LlNNT09USF9DVVJWRV9UTz02NCx0LlFVQURfVE89MTI4LHQuU01PT1RIX1FVQURfVE89MjU2LHQuQVJDPTUxMix0LkxJTkVfQ09NTUFORFM9dC5MSU5FX1RPfHQuSE9SSVpfTElORV9UT3x0LlZFUlRfTElORV9UTyx0LkRSQVdJTkdfQ09NTUFORFM9dC5IT1JJWl9MSU5FX1RPfHQuVkVSVF9MSU5FX1RPfHQuTElORV9UT3x0LkNVUlZFX1RPfHQuU01PT1RIX0NVUlZFX1RPfHQuUVVBRF9UT3x0LlNNT09USF9RVUFEX1RPfHQuQVJDLHR9KHcpLEM9KChtPXt9KVtiLk1PVkVfVE9dPTIsbVtiLkxJTkVfVE9dPTIsbVtiLkhPUklaX0xJTkVfVE9dPTEsbVtiLlZFUlRfTElORV9UT109MSxtW2IuQ0xPU0VfUEFUSF09MCxtW2IuUVVBRF9UT109NCxtW2IuU01PT1RIX1FVQURfVE9dPTIsbVtiLkNVUlZFX1RPXT02LG1bYi5TTU9PVEhfQ1VSVkVfVE9dPTQsbVtiLkFSQ109NyxtKX0sIi4vc3JjL3BsdWdpbi9oeXBlcmxpbmtzLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO0Eucih0KSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubGluay5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuaXRlcmF0b3IuY29uc3RydWN0b3IuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLmZvci1lYWNoLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMiKTt2YXIgcj1BKCIuL3NyYy93b3JrZXIuanMiKSxuPUEoIi4vc3JjL3V0aWxzLmpzIikscz1bXSxpPXt0b0NvbnRhaW5lcjpyLmRlZmF1bHQucHJvdG90eXBlLnRvQ29udGFpbmVyLHRvUGRmOnIuZGVmYXVsdC5wcm90b3R5cGUudG9QZGZ9O3IuZGVmYXVsdC5wcm90b3R5cGUudG9Db250YWluZXI9ZnVuY3Rpb24oKXtyZXR1cm4gaS50b0NvbnRhaW5lci5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24oKXtpZih0aGlzLm9wdC5lbmFibGVMaW5rcyl7dmFyIGU9dGhpcy5wcm9wLmNvbnRhaW5lcix0PWUucXVlcnlTZWxlY3RvckFsbCgiYSIpLEE9KDAsbi51bml0Q29udmVydCkoZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx0aGlzLnByb3AucGFnZVNpemUuayk7cz1bXSxBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHQsZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUuZ2V0Q2xpZW50UmVjdHMoKSxyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBpPSgwLG4udW5pdENvbnZlcnQpKHRbcl0sdGhpcy5wcm9wLnBhZ2VTaXplLmspO2kubGVmdC09QS5sZWZ0LGkudG9wLT1BLnRvcDt2YXIgbz1NYXRoLmZsb29yKGkudG9wL3RoaXMucHJvcC5wYWdlU2l6ZS5pbm5lci5oZWlnaHQpKzEsYT10aGlzLm9wdC5tYXJnaW5bMF0raS50b3AldGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLmhlaWdodCxsPXRoaXMub3B0Lm1hcmdpblsxXStpLmxlZnQ7cy5wdXNoKHtwYWdlOm8sdG9wOmEsbGVmdDpsLGNsaWVudFJlY3Q6aSxsaW5rOmV9KX19LHRoaXMpfX0pfSxyLmRlZmF1bHQucHJvdG90eXBlLnRvUGRmPWZ1bmN0aW9uKCl7cmV0dXJuIGkudG9QZGYuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uKCl7aWYodGhpcy5vcHQuZW5hYmxlTGlua3Mpe3MuZm9yRWFjaChmdW5jdGlvbihlKXt0aGlzLnByb3AucGRmLnNldFBhZ2UoZS5wYWdlKSx0aGlzLnByb3AucGRmLmxpbmsoZS5sZWZ0LGUudG9wLGUuY2xpZW50UmVjdC53aWR0aCxlLmNsaWVudFJlY3QuaGVpZ2h0LHt1cmw6ZS5saW5rLmhyZWZ9KX0sdGhpcyk7dmFyIGU9dGhpcy5wcm9wLnBkZi5pbnRlcm5hbC5nZXROdW1iZXJPZlBhZ2VzKCk7dGhpcy5wcm9wLnBkZi5zZXRQYWdlKGUpfX0pfX0sIi4vc3JjL3BsdWdpbi9qc3BkZi1wbHVnaW4uanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7QS5yKHQpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIik7dmFyIHI9QSgiLi9ub2RlX21vZHVsZXMvanNwZGYvZGlzdC9qc3BkZi5lcy5taW4uanMiKTtmdW5jdGlvbiBuKGUpe3JldHVybiBuPSJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJiJzeW1ib2wiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJiJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlPyJzeW1ib2wiOnR5cGVvZiBlfSxuKGUpfXIuanNQREYuZ2V0UGFnZVNpemU9ZnVuY3Rpb24oZSx0LEEpe2lmKCJvYmplY3QiPT09bihlKSl7dmFyIHI9ZTtlPXIub3JpZW50YXRpb24sdD1yLnVuaXR8fHQsQT1yLmZvcm1hdHx8QX10PXR8fCJtbSIsQT1BfHwiYTQiLGU9KCIiKyhlfHwiUCIpKS50b0xvd2VyQ2FzZSgpO3ZhciBzPSgiIitBKS50b0xvd2VyQ2FzZSgpLGk9e2EwOlsyMzgzLjk0LDMzNzAuMzldLGExOlsxNjgzLjc4LDIzODMuOTRdLGEyOlsxMTkwLjU1LDE2ODMuNzhdLGEzOls4NDEuODksMTE5MC41NV0sYTQ6WzU5NS4yOCw4NDEuODldLGE1Ols0MTkuNTMsNTk1LjI4XSxhNjpbMjk3LjY0LDQxOS41M10sYTc6WzIwOS43NiwyOTcuNjRdLGE4OlsxNDcuNCwyMDkuNzZdLGE5OlsxMDQuODgsMTQ3LjRdLGExMDpbNzMuNywxMDQuODhdLGIwOlsyODM0LjY1LDQwMDguMTldLGIxOlsyMDA0LjA5LDI4MzQuNjVdLGIyOlsxNDE3LjMyLDIwMDQuMDldLGIzOlsxMDAwLjYzLDE0MTcuMzJdLGI0Ols3MDguNjYsMTAwMC42M10sYjU6WzQ5OC45LDcwOC42Nl0sYjY6WzM1NC4zMyw0OTguOV0sYjc6WzI0OS40NSwzNTQuMzNdLGI4OlsxNzUuNzUsMjQ5LjQ1XSxiOTpbMTI0LjcyLDE3NS43NV0sYjEwOls4Ny44NywxMjQuNzJdLGMwOlsyNTk5LjM3LDM2NzYuNTRdLGMxOlsxODM2Ljg1LDI1OTkuMzddLGMyOlsxMjk4LjI3LDE4MzYuODVdLGMzOls5MTguNDMsMTI5OC4yN10sYzQ6WzY0OS4xMyw5MTguNDNdLGM1Ols0NTkuMjEsNjQ5LjEzXSxjNjpbMzIzLjE1LDQ1OS4yMV0sYzc6WzIyOS42MSwzMjMuMTVdLGM4OlsxNjEuNTcsMjI5LjYxXSxjOTpbMTEzLjM5LDE2MS41N10sYzEwOls3OS4zNywxMTMuMzldLGRsOlszMTEuODEsNjIzLjYyXSxsZXR0ZXI6WzYxMiw3OTJdLCJnb3Zlcm5tZW50LWxldHRlciI6WzU3Niw3NTZdLGxlZ2FsOls2MTIsMTAwOF0sImp1bmlvci1sZWdhbCI6WzU3NiwzNjBdLGxlZGdlcjpbMTIyNCw3OTJdLHRhYmxvaWQ6Wzc5MiwxMjI0XSwiY3JlZGl0LWNhcmQiOlsxNTMsMjQzXX07c3dpdGNoKHQpe2Nhc2UicHQiOnZhciBvPTE7YnJlYWs7Y2FzZSJtbSI6bz03Mi8yNS40O2JyZWFrO2Nhc2UiY20iOm89NzIvMi41NDticmVhaztjYXNlImluIjpvPTcyO2JyZWFrO2Nhc2UicHgiOm89Ljc1O2JyZWFrO2Nhc2UicGMiOmNhc2UiZW0iOm89MTI7YnJlYWs7Y2FzZSJleCI6bz02O2JyZWFrO2RlZmF1bHQ6dGhyb3ciSW52YWxpZCB1bml0OiAiK3R9aWYoaS5oYXNPd25Qcm9wZXJ0eShzKSl2YXIgYT1pW3NdWzFdL28sbD1pW3NdWzBdL287ZWxzZSB0cnl7YT1BWzFdLGw9QVswXX1jYXRjaChlKXt0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgZm9ybWF0OiAiK0EpfWlmKCJwIj09PWV8fCJwb3J0cmFpdCI9PT1lKXtpZihlPSJwIixsPmEpe3ZhciBjPWw7bD1hLGE9Y319ZWxzZXtpZigibCIhPT1lJiYibGFuZHNjYXBlIiE9PWUpdGhyb3ciSW52YWxpZCBvcmllbnRhdGlvbjogIitlO2U9ImwiLGE+bCYmKGM9bCxsPWEsYT1jKX1yZXR1cm57d2lkdGg6bCxoZWlnaHQ6YSx1bml0OnQsazpvfX0sdC5kZWZhdWx0PXIuanNQREZ9LCIuL3NyYy9wbHVnaW4vcGFnZWJyZWFrcy5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtBLnIodCksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLmNvbnN0cnVjdG9yLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5pdGVyYXRvci5mb3ItZWFjaC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzIik7dmFyIHI9QSgiLi9zcmMvd29ya2VyLmpzIiksbj1BKCIuL3NyYy91dGlscy5qcyIpLHM9e3RvQ29udGFpbmVyOnIuZGVmYXVsdC5wcm90b3R5cGUudG9Db250YWluZXJ9O3IuZGVmYXVsdC50ZW1wbGF0ZS5vcHQucGFnZWJyZWFrPXttb2RlOlsiY3NzIiwibGVnYWN5Il0sYmVmb3JlOltdLGFmdGVyOltdLGF2b2lkOltdfSxyLmRlZmF1bHQucHJvdG90eXBlLnRvQ29udGFpbmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHMudG9Db250YWluZXIuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wLmNvbnRhaW5lcix0PXRoaXMucHJvcC5wYWdlU2l6ZS5pbm5lci5weC5oZWlnaHQsQT1bXS5jb25jYXQodGhpcy5vcHQucGFnZWJyZWFrLm1vZGUpLHI9e2F2b2lkQWxsOi0xIT09QS5pbmRleE9mKCJhdm9pZC1hbGwiKSxjc3M6LTEhPT1BLmluZGV4T2YoImNzcyIpLGxlZ2FjeTotMSE9PUEuaW5kZXhPZigibGVnYWN5Iil9LHM9e30saT10aGlzO1siYmVmb3JlIiwiYWZ0ZXIiLCJhdm9pZCJdLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIEE9ci5hdm9pZEFsbCYmImF2b2lkIj09PXQ7c1t0XT1BP1tdOltdLmNvbmNhdChpLm9wdC5wYWdlYnJlYWtbdF18fFtdKSxzW3RdLmxlbmd0aD4wJiYoc1t0XT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLnF1ZXJ5U2VsZWN0b3JBbGwoc1t0XS5qb2luKCIsICIpKSkpfSk7dmFyIG89ZS5xdWVyeVNlbGVjdG9yQWxsKCIuaHRtbDJwZGZfX3BhZ2UtYnJlYWsiKTtvPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG8pO3ZhciBhPWUucXVlcnlTZWxlY3RvckFsbCgiKiIpO0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYSxmdW5jdGlvbihlKXt2YXIgQT17YmVmb3JlOiExLGFmdGVyOnIubGVnYWN5JiYtMSE9PW8uaW5kZXhPZihlKSxhdm9pZDpyLmF2b2lkQWxsfTtpZihyLmNzcyl7dmFyIGk9d2luZG93LmdldENvbXB1dGVkU3R5bGUoZSksYT1bImFsd2F5cyIsInBhZ2UiLCJsZWZ0IiwicmlnaHQiXTtBPXtiZWZvcmU6QS5iZWZvcmV8fC0xIT09YS5pbmRleE9mKGkuYnJlYWtCZWZvcmV8fGkucGFnZUJyZWFrQmVmb3JlKSxhZnRlcjpBLmFmdGVyfHwtMSE9PWEuaW5kZXhPZihpLmJyZWFrQWZ0ZXJ8fGkucGFnZUJyZWFrQWZ0ZXIpLGF2b2lkOkEuYXZvaWR8fC0xIT09WyJhdm9pZCIsImF2b2lkLXBhZ2UiXS5pbmRleE9mKGkuYnJlYWtJbnNpZGV8fGkucGFnZUJyZWFrSW5zaWRlKX19T2JqZWN0LmtleXMoQSkuZm9yRWFjaChmdW5jdGlvbih0KXtBW3RdPUFbdF18fC0xIT09c1t0XS5pbmRleE9mKGUpfSk7dmFyIGw9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihBLmF2b2lkJiYhQS5iZWZvcmUpe3ZhciBjPU1hdGguZmxvb3IobC50b3AvdCksdT1NYXRoLmZsb29yKGwuYm90dG9tL3QpLGg9TWF0aC5hYnMobC5ib3R0b20tbC50b3ApL3Q7dSE9PWMmJmg8PTEmJihBLmJlZm9yZT0hMCl9aWYoQS5iZWZvcmUpe3ZhciBkPSgwLG4uY3JlYXRlRWxlbWVudCkoImRpdiIse3N0eWxlOntkaXNwbGF5OiJibG9jayIsaGVpZ2h0OnQtbC50b3AldCsicHgifX0pO2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZCxlKX1BLmFmdGVyJiYoZD0oMCxuLmNyZWF0ZUVsZW1lbnQpKCJkaXYiLHtzdHlsZTp7ZGlzcGxheToiYmxvY2siLGhlaWdodDp0LWwuYm90dG9tJXQrInB4In19KSxlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGQsZS5uZXh0U2libGluZykpfSl9KX19LCIuL3NyYy9zbmFwZG9tL2Nsb25lLmpzIjpmdW5jdGlvbihlLHQsQSl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIoZSx0KXt2YXIgQT0idW5kZWZpbmVkIiE9dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdfHxlWyJAQGl0ZXJhdG9yIl07aWYoIUEpe2lmKEFycmF5LmlzQXJyYXkoZSl8fChBPWZ1bmN0aW9uKGUsdCl7aWYoZSl7aWYoInN0cmluZyI9PXR5cGVvZiBlKXJldHVybiBuKGUsdCk7dmFyIEE9e30udG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKTtyZXR1cm4iT2JqZWN0Ij09PUEmJmUuY29uc3RydWN0b3ImJihBPWUuY29uc3RydWN0b3IubmFtZSksIk1hcCI9PT1BfHwiU2V0Ij09PUE/QXJyYXkuZnJvbShlKToiQXJndW1lbnRzIj09PUF8fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KEEpP24oZSx0KTp2b2lkIDB9fShlKSl8fHQmJmUmJiJudW1iZXIiPT10eXBlb2YgZS5sZW5ndGgpe0EmJihlPUEpO3ZhciByPTAscz1mdW5jdGlvbigpe307cmV0dXJue3M6cyxuOmZ1bmN0aW9uKCl7cmV0dXJuIHI+PWUubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTplW3IrK119fSxlOmZ1bmN0aW9uKGUpe3Rocm93IGV9LGY6c319dGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLiIpfXZhciBpLG89ITAsYT0hMTtyZXR1cm57czpmdW5jdGlvbigpe0E9QS5jYWxsKGUpfSxuOmZ1bmN0aW9uKCl7dmFyIGU9QS5uZXh0KCk7cmV0dXJuIG89ZS5kb25lLGV9LGU6ZnVuY3Rpb24oZSl7YT0hMCxpPWV9LGY6ZnVuY3Rpb24oKXt0cnl7b3x8bnVsbD09QS5yZXR1cm58fEEucmV0dXJuKCl9ZmluYWxseXtpZihhKXRocm93IGl9fX19ZnVuY3Rpb24gbihlLHQpeyhudWxsPT10fHx0PmUubGVuZ3RoKSYmKHQ9ZS5sZW5ndGgpO2Zvcih2YXIgQT0wLHI9QXJyYXkodCk7QTx0O0ErKylyW0FdPWVbQV07cmV0dXJuIHJ9ZnVuY3Rpb24gcyhlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgbm9kZSIpO3ZhciB0LEE9bmV3IFNldCxuPW51bGw7aWYoZS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFKXJldHVybiBlLmNsb25lTm9kZSghMCk7aWYoZS5ub2RlVHlwZSE9PU5vZGUuRUxFTUVOVF9OT0RFKXJldHVybiBlLmNsb25lTm9kZSghMCk7aWYoIklGUkFNRSI9PT1lLnRhZ05hbWUpe3ZhciBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO3JldHVybiBpLnN0eWxlLmNzc1RleHQ9IndpZHRoOiIuY29uY2F0KGUub2Zmc2V0V2lkdGgsInB4O2hlaWdodDoiKS5jb25jYXQoZS5vZmZzZXRIZWlnaHQsInB4O2JhY2tncm91bmQtaW1hZ2U6cmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCg0NWRlZywjZGRkLCNkZGQgNXB4LCNmOWY5ZjkgNXB4LCNmOWY5ZjkgMTBweCk7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2ZvbnQtc2l6ZToxMnB4O2NvbG9yOiM1NTU7Ym9yZGVyOjFweCBzb2xpZCAjYWFhOyIpLGl9aWYoIkNBTlZBUyI9PT1lLnRhZ05hbWUpe3ZhciBvPWUudG9EYXRhVVJMKCksYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTtyZXR1cm4gYS5zcmM9byxhLndpZHRoPWUud2lkdGgsYS5oZWlnaHQ9ZS5oZWlnaHQsYX10cnl7dD1lLmNsb25lTm9kZSghMSksIklNRyI9PT1lLnRhZ05hbWUmJmZ1bmN0aW9uKGUsdCl7dHJ5e3ZhciBBPWUuY3VycmVudFNyY3x8ZS5zcmN8fCIiO2lmKCFBKXJldHVybjt0LnNldEF0dHJpYnV0ZSgic3JjIixBKSx0LnJlbW92ZUF0dHJpYnV0ZSgic3Jjc2V0IiksdC5yZW1vdmVBdHRyaWJ1dGUoInNpemVzIiksdC5sb2FkaW5nPSJlYWdlciIsdC5kZWNvZGluZz0ic3luYyJ9Y2F0Y2goZSl7fX0oZSx0KX1jYXRjaCh0KXt0aHJvdyBjb25zb2xlLmVycm9yKCJbU25hcGRvbV0gRmFpbGVkIHRvIGNsb25lIG5vZGU6IixlLHQpLHR9aWYoZSBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQpe3QudGV4dENvbnRlbnQ9ZS52YWx1ZSx0LnZhbHVlPWUudmFsdWU7dmFyIGw9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm4gdC5zdHlsZS5ib3hTaXppbmc9ImJvcmRlci1ib3giLHQuc3R5bGUud2lkdGg9IiIuY29uY2F0KGwud2lkdGgsInB4IiksdC5zdHlsZS5oZWlnaHQ9IiIuY29uY2F0KGwuaGVpZ2h0LCJweCIpLHR9aWYoZSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJihlLmhhc0F0dHJpYnV0ZSgidmFsdWUiKSYmKHQudmFsdWU9ZS52YWx1ZSx0LnNldEF0dHJpYnV0ZSgidmFsdWUiLGUudmFsdWUpKSx2b2lkIDAhPT1lLmNoZWNrZWQmJih0LmNoZWNrZWQ9ZS5jaGVja2VkLGUuY2hlY2tlZCYmdC5zZXRBdHRyaWJ1dGUoImNoZWNrZWQiLCIiKSxlLmluZGV0ZXJtaW5hdGUmJih0LmluZGV0ZXJtaW5hdGU9ZS5pbmRldGVybWluYXRlKSkpLGUgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCYmKG49ZS52YWx1ZSksZS5zaGFkb3dSb290KWlmKEFycmF5LmZyb20oZS5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoInNsb3QiKSkubGVuZ3RoPjApO2Vsc2V7dmFyIGMsdT1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksaD1yKGUuc2hhZG93Um9vdC5jaGlsZE5vZGVzKTt0cnl7Zm9yKGgucygpOyEoYz1oLm4oKSkuZG9uZTspe3ZhciBkPWMudmFsdWU7aWYoZC5ub2RlVHlwZSE9PU5vZGUuRUxFTUVOVF9OT0RFfHwiU1RZTEUiIT09ZC50YWdOYW1lKXt2YXIgZj1zKGQpO2YmJnUuYXBwZW5kQ2hpbGQoZil9fX1jYXRjaChlKXtoLmUoZSl9ZmluYWxseXtoLmYoKX10LmFwcGVuZENoaWxkKHUpfWlmKCJTTE9UIj09PWUudGFnTmFtZSl7dmFyIHAsZyxtPShudWxsPT09KHA9ZS5hc3NpZ25lZE5vZGVzKXx8dm9pZCAwPT09cD92b2lkIDA6cC5jYWxsKGUse2ZsYXR0ZW46ITB9KSl8fFtdLHc9bS5sZW5ndGg+MD9tOkFycmF5LmZyb20oZS5jaGlsZE5vZGVzKSxCPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSx5PXIodyk7dHJ5e2Zvcih5LnMoKTshKGc9eS5uKCkpLmRvbmU7KXt2YXIgdj1zKGcudmFsdWUpO3YmJkIuYXBwZW5kQ2hpbGQodil9fWNhdGNoKGUpe3kuZShlKX1maW5hbGx5e3kuZigpfXJldHVybiBCfXZhciBiLEM9cihlLmNoaWxkTm9kZXMpO3RyeXtmb3IoQy5zKCk7IShiPUMubigpKS5kb25lOyl7dmFyIF89Yi52YWx1ZTtpZighQS5oYXMoXykpe3ZhciBqPXMoXyk7aiYmdC5hcHBlbmRDaGlsZChqKX19fWNhdGNoKGUpe0MuZShlKX1maW5hbGx5e0MuZigpfWlmKG51bGwhPT1uJiZ0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpe3QudmFsdWU9bjt2YXIgeCxGPXIodC5vcHRpb25zKTt0cnl7Zm9yKEYucygpOyEoeD1GLm4oKSkuZG9uZTspe3ZhciBRPXgudmFsdWU7US52YWx1ZT09PW4/US5zZXRBdHRyaWJ1dGUoInNlbGVjdGVkIiwiIik6US5yZW1vdmVBdHRyaWJ1dGUoInNlbGVjdGVkIil9fWNhdGNoKGUpe0YuZShlKX1maW5hbGx5e0YuZigpfX12YXIgVT1lLnNjcm9sbExlZnQsRT1lLnNjcm9sbFRvcDtpZigoVXx8RSkmJnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCl7dC5zdHlsZS5vdmVyZmxvdz0iaGlkZGVuIix0LnN0eWxlLnNjcm9sbGJhcldpZHRoPSJub25lIix0LnN0eWxlLm1zT3ZlcmZsb3dTdHlsZT0ibm9uZSI7dmFyIFM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7Zm9yKFMuc3R5bGUudHJhbnNmb3JtPSJ0cmFuc2xhdGUoIi5jb25jYXQoLVUsInB4LCAiKS5jb25jYXQoLUUsInB4KSIpLFMuc3R5bGUud2lsbENoYW5nZT0idHJhbnNmb3JtIixTLnN0eWxlLmRpc3BsYXk9ImlubGluZS1ibG9jayIsUy5zdHlsZS53aWR0aD0iMTAwJSI7dC5maXJzdENoaWxkOylTLmFwcGVuZENoaWxkKHQuZmlyc3RDaGlsZCk7dC5hcHBlbmRDaGlsZChTKX1yZXR1cm4gdH1BLnIodCksQS5kKHQse2RlZXBDbG9uZUJhc2ljOmZ1bmN0aW9uKCl7cmV0dXJuIHN9fSksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudGVzdC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnNldC5hZGQtYWxsLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQuZGVsZXRlLWFsbC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LmRpZmZlcmVuY2UuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnNldC5ldmVyeS5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LmZpbHRlci5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LmZpbmQuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnNldC5pbnRlcnNlY3Rpb24uanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnNldC5pcy1kaXNqb2ludC1mcm9tLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQuaXMtc3Vic2V0LW9mLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQuaXMtc3VwZXJzZXQtb2YuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0LnNldC5qb2luLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQubWFwLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQucmVkdWNlLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQuc29tZS5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuc2V0LnN5bW1ldHJpYy1kaWZmZXJlbmNlLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5zZXQudW5pb24uanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIpfSwiLi9zcmMvdXRpbHMuanMiOmZ1bmN0aW9uKGUsdCxBKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gcj0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgZX0scihlKX1BLnIodCksQS5kKHQse2NyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gc30sb2JqVHlwZTpmdW5jdGlvbigpe3JldHVybiBufSx0b1B4OmZ1bmN0aW9uKCl7cmV0dXJuIG99LHVuaXRDb252ZXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIGl9fSksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIik7dmFyIG49ZnVuY3Rpb24oZSl7dmFyIHQ9cihlKTtyZXR1cm4idW5kZWZpbmVkIj09PXQ/InVuZGVmaW5lZCI6InN0cmluZyI9PT10fHxlIGluc3RhbmNlb2YgU3RyaW5nPyJzdHJpbmciOiJudW1iZXIiPT09dHx8ZSBpbnN0YW5jZW9mIE51bWJlcj8ibnVtYmVyIjoiZnVuY3Rpb24iPT09dHx8ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uPyJmdW5jdGlvbiI6ZSYmZS5jb25zdHJ1Y3Rvcj09PUFycmF5PyJhcnJheSI6ZSYmMT09PWUubm9kZVR5cGU/ImVsZW1lbnQiOiJvYmplY3QiPT09dD8ib2JqZWN0IjoidW5rbm93biJ9LHM9ZnVuY3Rpb24oZSx0KXt2YXIgQT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpO2lmKHQuY2xhc3NOYW1lJiYoQS5jbGFzc05hbWU9dC5jbGFzc05hbWUpLHQuaW5uZXJIVE1MKXtBLmlubmVySFRNTD10LmlubmVySFRNTDtmb3IodmFyIHI9QS5nZXRFbGVtZW50c0J5VGFnTmFtZSgic2NyaXB0Iiksbj1yLmxlbmd0aDtuLS0gPjA7bnVsbClyW25dLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocltuXSl9Zm9yKHZhciBzIGluIHQuc3R5bGUpQS5zdHlsZVtzXT10LnN0eWxlW3NdO3JldHVybiBBfSxpPWZ1bmN0aW9uKGUsdCl7aWYoIm51bWJlciI9PT1uKGUpKXJldHVybiA3MiplLzk2L3Q7dmFyIEE9e307Zm9yKHZhciByIGluIGUpQVtyXT03MiplW3JdLzk2L3Q7cmV0dXJuIEF9LG89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gTWF0aC5mbG9vcihlKnQvNzIqOTYpfX0sIi4vc3JjL3dvcmtlci5qcyI6ZnVuY3Rpb24oZSx0LEEpeyJ1c2Ugc3RyaWN0IjtBLnIodCksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5qc29uLnN0cmluZ2lmeS5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5pdGVyYXRvci5jb25zdHJ1Y3Rvci5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuaXRlcmF0b3IuZm9yLWVhY2guanMiKSxBKCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLm1hcC5qcyIpLEEoIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzIiksQSgiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiKTt2YXIgcj1BKCIuL25vZGVfbW9kdWxlcy9qc3BkZi9kaXN0L2pzcGRmLmVzLm1pbi5qcyIpLG49QSgiLi9ub2RlX21vZHVsZXMvaHRtbDJjYW52YXMvZGlzdC9odG1sMmNhbnZhcy5qcyIpLHM9QS5uKG4pLGk9QSgiLi9zcmMvc25hcGRvbS9jbG9uZS5qcyIpLG89QSgiLi9zcmMvdXRpbHMuanMiKSxhPWZ1bmN0aW9uIGUodCl7dmFyIEE9T2JqZWN0LmFzc2lnbihlLmNvbnZlcnQoUHJvbWlzZS5yZXNvbHZlKCkpLEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZS50ZW1wbGF0ZSkpKSxyPWUuY29udmVydChQcm9taXNlLnJlc29sdmUoKSxBKTtyZXR1cm4ocj1yLnNldFByb2dyZXNzKDEsZSwxLFtlXSkpLnNldCh0KX07KGEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1hLGEuY29udmVydD1mdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10fHxhLnByb3RvdHlwZSxlfSxhLnRlbXBsYXRlPXtwcm9wOntzcmM6bnVsbCxjb250YWluZXI6bnVsbCxvdmVybGF5Om51bGwsY2FudmFzOm51bGwsaW1nOm51bGwscGRmOm51bGwscGFnZVNpemU6bnVsbH0scHJvZ3Jlc3M6e3ZhbDowLHN0YXRlOm51bGwsbjowLHN0YWNrOltdfSxvcHQ6e2ZpbGVuYW1lOiJmaWxlLnBkZiIsbWFyZ2luOlswLDAsMCwwXSxpbWFnZTp7dHlwZToianBlZyIscXVhbGl0eTouOTV9LGVuYWJsZUxpbmtzOiEwLGh0bWwyY2FudmFzOnt9LGpzUERGOnt9fX0sYS5wcm90b3R5cGUuZnJvbT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24oKXtzd2l0Y2godD10fHxmdW5jdGlvbihlKXtzd2l0Y2goKDAsby5vYmpUeXBlKShlKSl7Y2FzZSJzdHJpbmciOnJldHVybiJzdHJpbmciO2Nhc2UiZWxlbWVudCI6cmV0dXJuIGUubm9kZU5hbWUudG9Mb3dlckNhc2UmJiJjYW52YXMiPT09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPyJjYW52YXMiOiJlbGVtZW50IjtkZWZhdWx0OnJldHVybiJ1bmtub3duIn19KGUpLHQpe2Nhc2Uic3RyaW5nIjpyZXR1cm4gdGhpcy5zZXQoe3NyYzooMCxvLmNyZWF0ZUVsZW1lbnQpKCJkaXYiLHtpbm5lckhUTUw6ZX0pfSk7Y2FzZSJlbGVtZW50IjpyZXR1cm4gdGhpcy5zZXQoe3NyYzplfSk7Y2FzZSJjYW52YXMiOnJldHVybiB0aGlzLnNldCh7Y2FudmFzOmV9KTtjYXNlImltZyI6cmV0dXJuIHRoaXMuc2V0KHtpbWc6ZX0pO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZXJyb3IoIlVua25vd24gc291cmNlIHR5cGUuIil9fSl9LGEucHJvdG90eXBlLnRvPWZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlImNvbnRhaW5lciI6cmV0dXJuIHRoaXMudG9Db250YWluZXIoKTtjYXNlImNhbnZhcyI6cmV0dXJuIHRoaXMudG9DYW52YXMoKTtjYXNlImltZyI6cmV0dXJuIHRoaXMudG9JbWcoKTtjYXNlInBkZiI6cmV0dXJuIHRoaXMudG9QZGYoKTtkZWZhdWx0OnJldHVybiB0aGlzLmVycm9yKCJJbnZhbGlkIHRhcmdldC4iKX19LGEucHJvdG90eXBlLnRvQ29udGFpbmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhlbkxpc3QoW2Z1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcC5zcmN8fHRoaXMuZXJyb3IoIkNhbm5vdCBkdXBsaWNhdGUgLSBubyBzb3VyY2UgSFRNTC4iKX0sZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wLnBhZ2VTaXplfHx0aGlzLnNldFBhZ2VTaXplKCl9XSkudGhlbihmdW5jdGlvbigpe3ZhciBlPXtwb3NpdGlvbjoiZml4ZWQiLG92ZXJmbG93OiJoaWRkZW4iLHpJbmRleDoxZTMsbGVmdDowLHJpZ2h0OjAsYm90dG9tOjAsdG9wOjAsYmFja2dyb3VuZENvbG9yOiJyZ2JhKDAsMCwwLDAuOCkifSx0PXtwb3NpdGlvbjoiYWJzb2x1dGUiLHdpZHRoOnRoaXMucHJvcC5wYWdlU2l6ZS5pbm5lci53aWR0aCt0aGlzLnByb3AucGFnZVNpemUudW5pdCxsZWZ0OjAscmlnaHQ6MCx0b3A6MCxoZWlnaHQ6ImF1dG8iLG1hcmdpbjoiYXV0byIsYmFja2dyb3VuZENvbG9yOiJ3aGl0ZSJ9O2Uub3BhY2l0eT0wO3ZhciBBPSgwLGkuZGVlcENsb25lQmFzaWMpKHRoaXMucHJvcC5zcmMpO3JldHVybiB0aGlzLnByb3Aub3ZlcmxheT0oMCxvLmNyZWF0ZUVsZW1lbnQpKCJkaXYiLHtjbGFzc05hbWU6Imh0bWwycGRmX19vdmVybGF5IixzdHlsZTplfSksdGhpcy5wcm9wLmNvbnRhaW5lcj0oMCxvLmNyZWF0ZUVsZW1lbnQpKCJkaXYiLHtjbGFzc05hbWU6Imh0bWwycGRmX19jb250YWluZXIiLHN0eWxlOnR9KSx0aGlzLnByb3AuY29udGFpbmVyLmFwcGVuZENoaWxkKEEpLHRoaXMucHJvcC5vdmVybGF5LmFwcGVuZENoaWxkKHRoaXMucHJvcC5jb250YWluZXIpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wcm9wLm92ZXJsYXkpLG5ldyBQcm9taXNlKGZ1bmN0aW9uKGUpe3JldHVybiBzZXRUaW1lb3V0KGUsMTApfSl9KX0sYS5wcm90b3R5cGUudG9DYW52YXM9ZnVuY3Rpb24oKXt2YXIgZT1bZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnByb3AuY29udGFpbmVyKXx8dGhpcy50b0NvbnRhaW5lcigpfV07cmV0dXJuIHRoaXMudGhlbkxpc3QoZSkudGhlbihmdW5jdGlvbigpe3ZhciBlPU9iamVjdC5hc3NpZ24oe30sdGhpcy5vcHQuaHRtbDJjYW52YXMpO3JldHVybiBkZWxldGUgZS5vbnJlbmRlcmVkLHMoKSh0aGlzLnByb3AuY29udGFpbmVyLGUpfSkudGhlbihmdW5jdGlvbihlKXsodGhpcy5vcHQuaHRtbDJjYW52YXMub25yZW5kZXJlZHx8ZnVuY3Rpb24oKXt9KShlKSx0aGlzLnByb3AuY2FudmFzPWUsZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLnByb3Aub3ZlcmxheSl9KX0sYS5wcm90b3R5cGUudG9JbWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGVuTGlzdChbZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wLmNhbnZhc3x8dGhpcy50b0NhbnZhcygpfV0pLnRoZW4oZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3AuY2FudmFzLnRvRGF0YVVSTCgiaW1hZ2UvIit0aGlzLm9wdC5pbWFnZS50eXBlLHRoaXMub3B0LmltYWdlLnF1YWxpdHkpO3RoaXMucHJvcC5pbWc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW1nIiksdGhpcy5wcm9wLmltZy5zcmM9ZX0pfSxhLnByb3RvdHlwZS50b1BkZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AuY2FudmFzfHx0aGlzLnRvQ2FudmFzKCl9LGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcC5wYWdlU2l6ZXx8dGhpcy5zZXRQYWdlU2l6ZSgpfV0pLnRoZW4oZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3AuY2FudmFzLHQ9dGhpcy5vcHQsQT1lLmhlaWdodCxuPU1hdGguZmxvb3IoZS53aWR0aCp0aGlzLnByb3AucGFnZVNpemUuaW5uZXIucmF0aW8pLHM9TWF0aC5jZWlsKEEvbiksaT10aGlzLnByb3AucGFnZVNpemUuaW5uZXIuaGVpZ2h0LG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIiksYT1vLmdldENvbnRleHQoIjJkIik7by53aWR0aD1lLndpZHRoLG8uaGVpZ2h0PW4sdGhpcy5wcm9wLnBkZj10aGlzLnByb3AucGRmfHxuZXcgci5qc1BERih0LmpzUERGKTtmb3IodmFyIGw9MDtsPHM7bCsrKXtsPT09cy0xJiZBJW4hPT0wJiYoby5oZWlnaHQ9QSVuLGk9by5oZWlnaHQqdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLndpZHRoL28ud2lkdGgpO3ZhciBjPW8ud2lkdGgsdT1vLmhlaWdodDthLmZpbGxTdHlsZT0id2hpdGUiLGEuZmlsbFJlY3QoMCwwLGMsdSksYS5kcmF3SW1hZ2UoZSwwLGwqbixjLHUsMCwwLGMsdSksbCYmdGhpcy5wcm9wLnBkZi5hZGRQYWdlKCk7dmFyIGg9by50b0RhdGFVUkwoImltYWdlLyIrdC5pbWFnZS50eXBlLHQuaW1hZ2UucXVhbGl0eSk7dGhpcy5wcm9wLnBkZi5hZGRJbWFnZShoLHQuaW1hZ2UudHlwZSx0Lm1hcmdpblsxXSx0Lm1hcmdpblswXSx0aGlzLnByb3AucGFnZVNpemUuaW5uZXIud2lkdGgsaSl9fSl9LGEucHJvdG90eXBlLm91dHB1dD1mdW5jdGlvbihlLHQsQSl7cmV0dXJuImltZyI9PT0oQT1BfHwicGRmIikudG9Mb3dlckNhc2UoKXx8ImltYWdlIj09PUEudG9Mb3dlckNhc2UoKT90aGlzLm91dHB1dEltZyhlLHQpOnRoaXMub3V0cHV0UGRmKGUsdCl9LGEucHJvdG90eXBlLm91dHB1dFBkZj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AucGRmfHx0aGlzLnRvUGRmKCl9XSkudGhlbihmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AucGRmLm91dHB1dChlLHQpfSl9LGEucHJvdG90eXBlLm91dHB1dEltZz1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AuaW1nfHx0aGlzLnRvSW1nKCl9XSkudGhlbihmdW5jdGlvbigpe3N3aXRjaChlKXtjYXNlIHZvaWQgMDpjYXNlImltZyI6cmV0dXJuIHRoaXMucHJvcC5pbWc7Y2FzZSJkYXRhdXJpc3RyaW5nIjpjYXNlImRhdGF1cmxzdHJpbmciOnJldHVybiB0aGlzLnByb3AuaW1nLnNyYztjYXNlImRhdGF1cmkiOmNhc2UiZGF0YXVybCI6cmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhyZWY9dGhpcy5wcm9wLmltZy5zcmM7ZGVmYXVsdDp0aHJvdydJbWFnZSBvdXRwdXQgdHlwZSAiJytlKyciIGlzIG5vdCBzdXBwb3J0ZWQuJ319KX0sYS5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aGVuTGlzdChbZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wLnBkZnx8dGhpcy50b1BkZigpfV0pLnNldChlP3tmaWxlbmFtZTplfTpudWxsKS50aGVuKGZ1bmN0aW9uKCl7dGhpcy5wcm9wLnBkZi5zYXZlKHRoaXMub3B0LmZpbGVuYW1lKX0pfSxhLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oZSl7aWYoIm9iamVjdCIhPT0oMCxvLm9ialR5cGUpKGUpKXJldHVybiB0aGlzO3ZhciB0PU9iamVjdC5rZXlzKGV8fHt9KS5tYXAoZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2UibWFyZ2luIjpyZXR1cm4gdGhpcy5zZXRNYXJnaW4uYmluZCh0aGlzLGUubWFyZ2luKTtjYXNlImpzUERGIjpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHQuanNQREY9ZS5qc1BERix0aGlzLnNldFBhZ2VTaXplKCl9O2Nhc2UicGFnZVNpemUiOnJldHVybiB0aGlzLnNldFBhZ2VTaXplLmJpbmQodGhpcyxlLnBhZ2VTaXplKTtkZWZhdWx0OnJldHVybiB0IGluIGEudGVtcGxhdGUucHJvcD9mdW5jdGlvbigpe3RoaXMucHJvcFt0XT1lW3RdfTpmdW5jdGlvbigpe3RoaXMub3B0W3RdPWVbdF19fX0sdGhpcyk7cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbigpe3JldHVybiB0aGlzLnRoZW5MaXN0KHQpfSl9LGEucHJvdG90eXBlLmdldD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24oKXt2YXIgQT1lIGluIGEudGVtcGxhdGUucHJvcD90aGlzLnByb3BbZV06dGhpcy5vcHRbZV07cmV0dXJuIHQ/dChBKTpBfSl9LGEucHJvdG90eXBlLnNldE1hcmdpbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKCl7c3dpdGNoKCgwLG8ub2JqVHlwZSkoZSkpe2Nhc2UibnVtYmVyIjplPVtlLGUsZSxlXTtjYXNlImFycmF5IjppZigyPT09ZS5sZW5ndGgmJihlPVtlWzBdLGVbMV0sZVswXSxlWzFdXSksND09PWUubGVuZ3RoKWJyZWFrO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZXJyb3IoIkludmFsaWQgbWFyZ2luIGFycmF5LiIpfXRoaXMub3B0Lm1hcmdpbj1lfSkudGhlbih0aGlzLnNldFBhZ2VTaXplKX0sYS5wcm90b3R5cGUuc2V0UGFnZVNpemU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbigpeyhlPWV8fHIuanNQREYuZ2V0UGFnZVNpemUodGhpcy5vcHQuanNQREYpKS5oYXNPd25Qcm9wZXJ0eSgiaW5uZXIiKXx8KGUuaW5uZXI9e3dpZHRoOmUud2lkdGgtdGhpcy5vcHQubWFyZ2luWzFdLXRoaXMub3B0Lm1hcmdpblszXSxoZWlnaHQ6ZS5oZWlnaHQtdGhpcy5vcHQubWFyZ2luWzBdLXRoaXMub3B0Lm1hcmdpblsyXX0sZS5pbm5lci5weD17d2lkdGg6KDAsby50b1B4KShlLmlubmVyLndpZHRoLGUuayksaGVpZ2h0OigwLG8udG9QeCkoZS5pbm5lci5oZWlnaHQsZS5rKX0sZS5pbm5lci5yYXRpbz1lLmlubmVyLmhlaWdodC9lLmlubmVyLndpZHRoKSx0aGlzLnByb3AucGFnZVNpemU9ZX0pfSxhLnByb3RvdHlwZS5zZXRQcm9ncmVzcz1mdW5jdGlvbihlLHQsQSxyKXtyZXR1cm4gbnVsbCE9ZSYmKHRoaXMucHJvZ3Jlc3MudmFsPWUpLG51bGwhPXQmJih0aGlzLnByb2dyZXNzLnN0YXRlPXQpLG51bGwhPUEmJih0aGlzLnByb2dyZXNzLm49QSksbnVsbCE9ciYmKHRoaXMucHJvZ3Jlc3Muc3RhY2s9ciksdGhpcy5wcm9ncmVzcy5yYXRpbz10aGlzLnByb2dyZXNzLnZhbC90aGlzLnByb2dyZXNzLnN0YXRlLHRoaXN9LGEucHJvdG90eXBlLnVwZGF0ZVByb2dyZXNzPWZ1bmN0aW9uKGUsdCxBLHIpe3JldHVybiB0aGlzLnNldFByb2dyZXNzKGU/dGhpcy5wcm9ncmVzcy52YWwrZTpudWxsLHR8fG51bGwsQT90aGlzLnByb2dyZXNzLm4rQTpudWxsLHI/dGhpcy5wcm9ncmVzcy5zdGFjay5jb25jYXQocik6bnVsbCl9LGEucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oZSx0KXt2YXIgQT10aGlzO3JldHVybiB0aGlzLnRoZW5Db3JlKGUsdCxmdW5jdGlvbihlLHQpe3JldHVybiBBLnVwZGF0ZVByb2dyZXNzKG51bGwsbnVsbCwxLFtlXSksUHJvbWlzZS5wcm90b3R5cGUudGhlbi5jYWxsKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIEEudXBkYXRlUHJvZ3Jlc3MobnVsbCxlKSx0fSkudGhlbihlLHQpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIEEudXBkYXRlUHJvZ3Jlc3MoMSksZX0pfSl9LGEucHJvdG90eXBlLnRoZW5Db3JlPWZ1bmN0aW9uKGUsdCxBKXtBPUF8fFByb21pc2UucHJvdG90eXBlLnRoZW47dmFyIHI9dGhpcztlJiYoZT1lLmJpbmQocikpLHQmJih0PXQuYmluZChyKSk7dmFyIG49LTEhPT1Qcm9taXNlLnRvU3RyaW5nKCkuaW5kZXhPZigiW25hdGl2ZSBjb2RlXSIpJiYiUHJvbWlzZSI9PT1Qcm9taXNlLm5hbWU/cjphLmNvbnZlcnQoT2JqZWN0LmFzc2lnbih7fSxyKSxQcm9taXNlLnByb3RvdHlwZSkscz1BLmNhbGwobixlLHQpO3JldHVybiBhLmNvbnZlcnQocyxyLl9fcHJvdG9fXyl9LGEucHJvdG90eXBlLnRoZW5FeHRlcm5hbD1mdW5jdGlvbihlLHQpe3JldHVybiBQcm9taXNlLnByb3RvdHlwZS50aGVuLmNhbGwodGhpcyxlLHQpfSxhLnByb3RvdHlwZS50aGVuTGlzdD1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSl7dD10LnRoZW5Db3JlKGUpfSksdH0sYS5wcm90b3R5cGUuY2F0Y2g9ZnVuY3Rpb24oZSl7ZSYmKGU9ZS5iaW5kKHRoaXMpKTt2YXIgdD1Qcm9taXNlLnByb3RvdHlwZS5jYXRjaC5jYWxsKHRoaXMsZSk7cmV0dXJuIGEuY29udmVydCh0LHRoaXMpfSxhLnByb3RvdHlwZS5jYXRjaEV4dGVybmFsPWZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnByb3RvdHlwZS5jYXRjaC5jYWxsKHRoaXMsZSl9LGEucHJvdG90eXBlLmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoZSl9KX0sYS5wcm90b3R5cGUudXNpbmc9YS5wcm90b3R5cGUuc2V0LGEucHJvdG90eXBlLnNhdmVBcz1hLnByb3RvdHlwZS5zYXZlLGEucHJvdG90eXBlLmV4cG9ydD1hLnByb3RvdHlwZS5vdXRwdXQsYS5wcm90b3R5cGUucnVuPWEucHJvdG90eXBlLnRoZW4sdC5kZWZhdWx0PWF9fSxyPXt9O2Z1bmN0aW9uIG4oZSl7dmFyIHQ9cltlXTtpZih2b2lkIDAhPT10KXJldHVybiB0LmV4cG9ydHM7dmFyIHM9cltlXT17ZXhwb3J0czp7fX07cmV0dXJuIEFbZV0uY2FsbChzLmV4cG9ydHMscyxzLmV4cG9ydHMsbikscy5leHBvcnRzfW4ubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbi5kKHQse2E6dH0pLHR9LHQ9T2JqZWN0LmdldFByb3RvdHlwZU9mP2Z1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9OmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX30sbi50PWZ1bmN0aW9uKEEscil7aWYoMSZyJiYoQT10aGlzKEEpKSw4JnIpcmV0dXJuIEE7aWYoIm9iamVjdCI9PXR5cGVvZiBBJiZBKXtpZig0JnImJkEuX19lc01vZHVsZSlyZXR1cm4gQTtpZigxNiZyJiYiZnVuY3Rpb24iPT10eXBlb2YgQS50aGVuKXJldHVybiBBfXZhciBzPU9iamVjdC5jcmVhdGUobnVsbCk7bi5yKHMpO3ZhciBpPXt9O2U9ZXx8W251bGwsdCh7fSksdChbXSksdCh0KV07Zm9yKHZhciBvPTImciYmQTsoIm9iamVjdCI9PXR5cGVvZiBvfHwiZnVuY3Rpb24iPT10eXBlb2YgbykmJiF+ZS5pbmRleE9mKG8pO289dChvKSlPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lbZV09ZnVuY3Rpb24oKXtyZXR1cm4gQVtlXX19KTtyZXR1cm4gaS5kZWZhdWx0PWZ1bmN0aW9uKCl7cmV0dXJuIEF9LG4uZChzLGkpLHN9LG4uZD1mdW5jdGlvbihlLHQpe2Zvcih2YXIgQSBpbiB0KW4ubyh0LEEpJiYhbi5vKGUsQSkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLEEse2VudW1lcmFibGU6ITAsZ2V0OnRbQV19KX0sbi5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxuLnI9ZnVuY3Rpb24oZSl7InVuZGVmaW5lZCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZToiTW9kdWxlIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KX07dmFyIHM9e307cmV0dXJuIGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO24ucihzKTt2YXIgZT1uKCIuL3NyYy93b3JrZXIuanMiKSx0PShuKCIuL3NyYy9wbHVnaW4vanNwZGYtcGx1Z2luLmpzIiksbigiLi9zcmMvcGx1Z2luL3BhZ2VicmVha3MuanMiKSxuKCIuL3NyYy9wbHVnaW4vaHlwZXJsaW5rcy5qcyIpLGZ1bmN0aW9uIGUodCxBKXt2YXIgcj1uZXcgZS5Xb3JrZXIoQSk7cmV0dXJuIHQ/ci5mcm9tKHQpLnNhdmUoKTpyfSk7dC5Xb3JrZXI9ZS5kZWZhdWx0LHMuZGVmYXVsdD10fSgpLHMuZGVmYXVsdH0oKX0pOwovLyMgc291cmNlTWFwcGluZ1VSTD1odG1sMnBkZi5idW5kbGUubWluLmpzLm1hcA==
            `;

      // Converti base64  Blob  URL JS valido
      const js = atob(html2pdf_base64.trim());
      const blob = new Blob([js], { type: "text/javascript" });
      const url = URL.createObjectURL(blob);

      // Carica la libreria dinamicamente
      const s = document.createElement("script");
      s.src = url;
      document.head.appendChild(s);

      console.log("library loaded");
    </script>
    <script>
      !(function (A, e) {
        "object" == typeof exports && "undefined" != typeof module
          ? (module.exports = e())
          : "function" == typeof define && define.amd
          ? define(e)
          : ((A =
              "undefined" != typeof globalThis
                ? globalThis
                : A || self).html2canvas = e());
      })(this, function () {
        "use strict";
        var r = function (A, e) {
          return (r =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (A, e) {
                A.__proto__ = e;
              }) ||
            function (A, e) {
              for (var t in e)
                Object.prototype.hasOwnProperty.call(e, t) && (A[t] = e[t]);
            })(A, e);
        };
        function A(A, e) {
          if ("function" != typeof e && null !== e)
            throw new TypeError(
              "Class extends value " +
                String(e) +
                " is not a constructor or null"
            );
          function t() {
            this.constructor = A;
          }
          r(A, e),
            (A.prototype =
              null === e
                ? Object.create(e)
                : ((t.prototype = e.prototype), new t()));
        }
        var h = function () {
          return (h =
            Object.assign ||
            function (A) {
              for (var e, t = 1, r = arguments.length; t < r; t++)
                for (var B in (e = arguments[t]))
                  Object.prototype.hasOwnProperty.call(e, B) && (A[B] = e[B]);
              return A;
            }).apply(this, arguments);
        };
        function a(A, s, o, i) {
          return new (o = o || Promise)(function (t, e) {
            function r(A) {
              try {
                n(i.next(A));
              } catch (A) {
                e(A);
              }
            }
            function B(A) {
              try {
                n(i.throw(A));
              } catch (A) {
                e(A);
              }
            }
            function n(A) {
              var e;
              A.done
                ? t(A.value)
                : ((e = A.value) instanceof o
                    ? e
                    : new o(function (A) {
                        A(e);
                      })
                  ).then(r, B);
            }
            n((i = i.apply(A, s || [])).next());
          });
        }
        function H(t, r) {
          var B,
            n,
            s,
            o = {
              label: 0,
              sent: function () {
                if (1 & s[0]) throw s[1];
                return s[1];
              },
              trys: [],
              ops: [],
            },
            A = { next: e(0), throw: e(1), return: e(2) };
          return (
            "function" == typeof Symbol &&
              (A[Symbol.iterator] = function () {
                return this;
              }),
            A
          );
          function e(e) {
            return function (A) {
              return (function (e) {
                if (B) throw new TypeError("Generator is already executing.");
                for (; o; )
                  try {
                    if (
                      ((B = 1),
                      n &&
                        (s =
                          2 & e[0]
                            ? n.return
                            : e[0]
                            ? n.throw || ((s = n.return) && s.call(n), 0)
                            : n.next) &&
                        !(s = s.call(n, e[1])).done)
                    )
                      return s;
                    switch (((n = 0), (e = s ? [2 & e[0], s.value] : e)[0])) {
                      case 0:
                      case 1:
                        s = e;
                        break;
                      case 4:
                        return o.label++, { value: e[1], done: !1 };
                      case 5:
                        o.label++, (n = e[1]), (e = [0]);
                        continue;
                      case 7:
                        (e = o.ops.pop()), o.trys.pop();
                        continue;
                      default:
                        if (
                          !(s = 0 < (s = o.trys).length && s[s.length - 1]) &&
                          (6 === e[0] || 2 === e[0])
                        ) {
                          o = 0;
                          continue;
                        }
                        if (
                          3 === e[0] &&
                          (!s || (e[1] > s[0] && e[1] < s[3]))
                        ) {
                          o.label = e[1];
                          break;
                        }
                        if (6 === e[0] && o.label < s[1]) {
                          (o.label = s[1]), (s = e);
                          break;
                        }
                        if (s && o.label < s[2]) {
                          (o.label = s[2]), o.ops.push(e);
                          break;
                        }
                        s[2] && o.ops.pop(), o.trys.pop();
                        continue;
                    }
                    e = r.call(t, o);
                  } catch (A) {
                    (e = [6, A]), (n = 0);
                  } finally {
                    B = s = 0;
                  }
                if (5 & e[0]) throw e[1];
                return { value: e[0] ? e[1] : void 0, done: !0 };
              })([e, A]);
            };
          }
        }
        function t(A, e, t) {
          if (t || 2 === arguments.length)
            for (var r, B = 0, n = e.length; B < n; B++)
              (!r && B in e) ||
                ((r = r || Array.prototype.slice.call(e, 0, B))[B] = e[B]);
          return A.concat(r || e);
        }
        var d =
          ((B.prototype.add = function (A, e, t, r) {
            return new B(
              this.left + A,
              this.top + e,
              this.width + t,
              this.height + r
            );
          }),
          (B.fromClientRect = function (A, e) {
            return new B(
              e.left + A.windowBounds.left,
              e.top + A.windowBounds.top,
              e.width,
              e.height
            );
          }),
          (B.fromDOMRectList = function (A, e) {
            e = Array.from(e).find(function (A) {
              return 0 !== A.width;
            });
            return e
              ? new B(
                  e.left + A.windowBounds.left,
                  e.top + A.windowBounds.top,
                  e.width,
                  e.height
                )
              : B.EMPTY;
          }),
          (B.EMPTY = new B(0, 0, 0, 0)),
          B);
        function B(A, e, t, r) {
          (this.left = A), (this.top = e), (this.width = t), (this.height = r);
        }
        for (
          var f = function (A, e) {
              return d.fromClientRect(A, e.getBoundingClientRect());
            },
            Q = function (A) {
              for (var e = [], t = 0, r = A.length; t < r; ) {
                var B,
                  n = A.charCodeAt(t++);
                55296 <= n && n <= 56319 && t < r
                  ? 56320 == (64512 & (B = A.charCodeAt(t++)))
                    ? e.push(((1023 & n) << 10) + (1023 & B) + 65536)
                    : (e.push(n), t--)
                  : e.push(n);
              }
              return e;
            },
            g = function () {
              for (var A = [], e = 0; e < arguments.length; e++)
                A[e] = arguments[e];
              if (String.fromCodePoint)
                return String.fromCodePoint.apply(String, A);
              var t = A.length;
              if (!t) return "";
              for (var r = [], B = -1, n = ""; ++B < t; ) {
                var s = A[B];
                s <= 65535
                  ? r.push(s)
                  : ((s -= 65536),
                    r.push(55296 + (s >> 10), (s % 1024) + 56320)),
                  (B + 1 === t || 16384 < r.length) &&
                    ((n += String.fromCharCode.apply(String, r)),
                    (r.length = 0));
              }
              return n;
            },
            e =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            n = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256),
            s = 0;
          s < e.length;
          s++
        )
          n[e.charCodeAt(s)] = s;
        for (
          var o =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            c = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256),
            i = 0;
          i < o.length;
          i++
        )
          c[o.charCodeAt(i)] = i;
        function w(A, e, t) {
          return A.slice
            ? A.slice(e, t)
            : new Uint16Array(Array.prototype.slice.call(A, e, t));
        }
        var U =
          ((l.prototype.get = function (A) {
            var e;
            if (0 <= A) {
              if (A < 55296 || (56319 < A && A <= 65535))
                return (
                  (e = this.index[A >> 5]), this.data[(e = (e << 2) + (31 & A))]
                );
              if (A <= 65535)
                return (
                  (e = this.index[2048 + ((A - 55296) >> 5)]),
                  this.data[(e = (e << 2) + (31 & A))]
                );
              if (A < this.highStart)
                return (
                  (e = this.index[(e = 2080 + (A >> 11))]),
                  (e = this.index[(e += (A >> 5) & 63)]),
                  this.data[(e = (e << 2) + (31 & A))]
                );
              if (A <= 1114111) return this.data[this.highValueIndex];
            }
            return this.errorValue;
          }),
          l);
        function l(A, e, t, r, B, n) {
          (this.initialValue = A),
            (this.errorValue = e),
            (this.highStart = t),
            (this.highValueIndex = r),
            (this.index = B),
            (this.data = n);
        }
        for (
          var C =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            u = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256),
            F = 0;
          F < C.length;
          F++
        )
          u[C.charCodeAt(F)] = F;
        function p(A, e, t, r) {
          var B = r[t];
          if (Array.isArray(A) ? -1 !== A.indexOf(B) : A === B)
            for (var n = t; n <= r.length; ) {
              if ((o = r[++n]) === e) return 1;
              if (o !== D) break;
            }
          if (B === D)
            for (n = t; 0 < n; ) {
              var s = r[--n];
              if (Array.isArray(A) ? -1 !== A.indexOf(s) : A === s)
                for (var o, i = t; i <= r.length; ) {
                  if ((o = r[++i]) === e) return 1;
                  if (o !== D) break;
                }
              if (s !== D) break;
            }
        }
        function E(A, e) {
          for (var t = A; 0 <= t; ) {
            var r = e[t];
            if (r !== D) return r;
            t--;
          }
          return 0;
        }
        function I(t, A) {
          var e = (B = (function (A, r) {
              void 0 === r && (r = "strict");
              var B = [],
                n = [],
                s = [];
              return (
                A.forEach(function (A, e) {
                  var t = rA.get(A);
                  if (
                    (50 < t ? (s.push(!0), (t -= 50)) : s.push(!1),
                    -1 !== ["normal", "auto", "loose"].indexOf(r) &&
                      -1 !== [8208, 8211, 12316, 12448].indexOf(A))
                  )
                    return n.push(e), B.push(16);
                  if (4 !== t && 11 !== t)
                    return (
                      n.push(e),
                      31 === t
                        ? B.push("strict" === r ? O : q)
                        : t === AA || 29 === t
                        ? B.push(J)
                        : 43 === t
                        ? (131072 <= A && A <= 196605) ||
                          (196608 <= A && A <= 262141)
                          ? B.push(q)
                          : B.push(J)
                        : void B.push(t)
                    );
                  if (0 === e) return n.push(e), B.push(J);
                  t = B[e - 1];
                  return -1 === iA.indexOf(t)
                    ? (n.push(n[e - 1]), B.push(t))
                    : (n.push(e), B.push(J));
                }),
                [n, B, s]
              );
            })(
              t,
              (A = A || { lineBreak: "normal", wordBreak: "normal" }).lineBreak
            ))[0],
            r = B[1],
            B = B[2];
          return [
            e,
            (r =
              "break-all" === A.wordBreak || "break-word" === A.wordBreak
                ? r.map(function (A) {
                    return -1 !== [R, J, AA].indexOf(A) ? q : A;
                  })
                : r),
            "keep-all" === A.wordBreak
              ? B.map(function (A, e) {
                  return A && 19968 <= t[e] && t[e] <= 40959;
                })
              : void 0,
          ];
        }
        var y,
          K,
          m,
          L,
          b,
          D = 10,
          v = 13,
          x = 15,
          M = 17,
          S = 18,
          T = 19,
          G = 20,
          O = 21,
          V = 22,
          k = 24,
          R = 25,
          N = 26,
          P = 27,
          X = 28,
          J = 30,
          Y = 32,
          W = 33,
          Z = 34,
          _ = 35,
          q = 37,
          j = 38,
          z = 39,
          $ = 40,
          AA = 42,
          eA = [9001, 65288],
          tA = "",
          rA =
            ((m = (function (A) {
              var e,
                t,
                r,
                B,
                n = 0.75 * A.length,
                s = A.length,
                o = 0;
              "=" === A[A.length - 1] && (n--, "=" === A[A.length - 2] && n--);
              for (
                var n = new (
                    "undefined" != typeof ArrayBuffer &&
                    "undefined" != typeof Uint8Array &&
                    void 0 !== Uint8Array.prototype.slice
                      ? ArrayBuffer
                      : Array
                  )(n),
                  i = Array.isArray(n) ? n : new Uint8Array(n),
                  Q = 0;
                Q < s;
                Q += 4
              )
                (e = c[A.charCodeAt(Q)]),
                  (t = c[A.charCodeAt(Q + 1)]),
                  (r = c[A.charCodeAt(Q + 2)]),
                  (B = c[A.charCodeAt(Q + 3)]),
                  (i[o++] = (e << 2) | (t >> 4)),
                  (i[o++] = ((15 & t) << 4) | (r >> 2)),
                  (i[o++] = ((3 & r) << 6) | (63 & B));
              return n;
            })(
              (y =
                "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==")
            )),
            (L = Array.isArray(m)
              ? (function (A) {
                  for (var e = A.length, t = [], r = 0; r < e; r += 4)
                    t.push(
                      (A[r + 3] << 24) |
                        (A[r + 2] << 16) |
                        (A[r + 1] << 8) |
                        A[r]
                    );
                  return t;
                })(m)
              : new Uint32Array(m)),
            (b = Array.isArray(m)
              ? (function (A) {
                  for (var e = A.length, t = [], r = 0; r < e; r += 2)
                    t.push((A[r + 1] << 8) | A[r]);
                  return t;
                })(m)
              : new Uint16Array(m)),
            (y = w(b, 12, L[4] / 2)),
            (K =
              2 === L[5]
                ? w(b, (24 + L[4]) / 2)
                : ((m = L),
                  (b = Math.ceil((24 + L[4]) / 4)),
                  m.slice
                    ? m.slice(b, K)
                    : new Uint32Array(Array.prototype.slice.call(m, b, K)))),
            new U(L[0], L[1], L[2], L[3], y, K)),
          BA = [J, 36],
          nA = [1, 2, 3, 5],
          sA = [D, 8],
          oA = [P, N],
          iA = nA.concat(sA),
          QA = [j, z, $, Z, _],
          cA = [x, v],
          aA =
            ((gA.prototype.slice = function () {
              return g.apply(
                void 0,
                this.codePoints.slice(this.start, this.end)
              );
            }),
            gA);
        function gA(A, e, t, r) {
          (this.codePoints = A),
            (this.required = "!" === e),
            (this.start = t),
            (this.end = r);
        }
        function wA(A, e) {
          var t = Q(A),
            r = (e = I(t, e))[0],
            B = e[1],
            n = e[2],
            s = t.length,
            o = 0,
            i = 0;
          return {
            next: function () {
              if (s <= i) return { done: !0, value: null };
              for (
                var A = tA;
                i < s &&
                (A = (function (A, e, t, r, B) {
                  if (0 === t[r]) return tA;
                  var n = r - 1;
                  if (Array.isArray(B) && !0 === B[n]) return tA;
                  var s = n - 1,
                    o = 1 + n,
                    i = e[n],
                    r = 0 <= s ? e[s] : 0,
                    B = e[o];
                  if (2 === i && 3 === B) return tA;
                  if (-1 !== nA.indexOf(i)) return "!";
                  if (-1 !== nA.indexOf(B)) return tA;
                  if (-1 !== sA.indexOf(B)) return tA;
                  if (8 === E(n, e)) return "";
                  if (11 === rA.get(A[n])) return tA;
                  if ((i === Y || i === W) && 11 === rA.get(A[o])) return tA;
                  if (7 === i || 7 === B) return tA;
                  if (9 === i) return tA;
                  if (-1 === [D, v, x].indexOf(i) && 9 === B) return tA;
                  if (-1 !== [M, S, T, k, X].indexOf(B)) return tA;
                  if (E(n, e) === V) return tA;
                  if (p(23, V, n, e)) return tA;
                  if (p([M, S], O, n, e)) return tA;
                  if (p(12, 12, n, e)) return tA;
                  if (i === D) return "";
                  if (23 === i || 23 === B) return tA;
                  if (16 === B || 16 === i) return "";
                  if (-1 !== [v, x, O].indexOf(B) || 14 === i) return tA;
                  if (36 === r && -1 !== cA.indexOf(i)) return tA;
                  if (i === X && 36 === B) return tA;
                  if (B === G) return tA;
                  if (
                    (-1 !== BA.indexOf(B) && i === R) ||
                    (-1 !== BA.indexOf(i) && B === R)
                  )
                    return tA;
                  if (
                    (i === P && -1 !== [q, Y, W].indexOf(B)) ||
                    (-1 !== [q, Y, W].indexOf(i) && B === N)
                  )
                    return tA;
                  if (
                    (-1 !== BA.indexOf(i) && -1 !== oA.indexOf(B)) ||
                    (-1 !== oA.indexOf(i) && -1 !== BA.indexOf(B))
                  )
                    return tA;
                  if (
                    (-1 !== [P, N].indexOf(i) &&
                      (B === R ||
                        (-1 !== [V, x].indexOf(B) && e[1 + o] === R))) ||
                    (-1 !== [V, x].indexOf(i) && B === R) ||
                    (i === R && -1 !== [R, X, k].indexOf(B))
                  )
                    return tA;
                  if (-1 !== [R, X, k, M, S].indexOf(B))
                    for (var Q = n; 0 <= Q; ) {
                      if ((c = e[Q]) === R) return tA;
                      if (-1 === [X, k].indexOf(c)) break;
                      Q--;
                    }
                  if (-1 !== [P, N].indexOf(B))
                    for (
                      var c, Q = -1 !== [M, S].indexOf(i) ? s : n;
                      0 <= Q;

                    ) {
                      if ((c = e[Q]) === R) return tA;
                      if (-1 === [X, k].indexOf(c)) break;
                      Q--;
                    }
                  if (
                    (j === i && -1 !== [j, z, Z, _].indexOf(B)) ||
                    (-1 !== [z, Z].indexOf(i) && -1 !== [z, $].indexOf(B)) ||
                    (-1 !== [$, _].indexOf(i) && B === $)
                  )
                    return tA;
                  if (
                    (-1 !== QA.indexOf(i) && -1 !== [G, N].indexOf(B)) ||
                    (-1 !== QA.indexOf(B) && i === P)
                  )
                    return tA;
                  if (-1 !== BA.indexOf(i) && -1 !== BA.indexOf(B)) return tA;
                  if (i === k && -1 !== BA.indexOf(B)) return tA;
                  if (
                    (-1 !== BA.concat(R).indexOf(i) &&
                      B === V &&
                      -1 === eA.indexOf(A[o])) ||
                    (-1 !== BA.concat(R).indexOf(B) && i === S)
                  )
                    return tA;
                  if (41 === i && 41 === B) {
                    for (var a = t[n], g = 1; 0 < a && 41 === e[--a]; ) g++;
                    if (g % 2 != 0) return tA;
                  }
                  return i === Y && B === W ? tA : "";
                })(t, B, r, ++i, n)) === tA;

              );
              if (A === tA && i !== s) return { done: !0, value: null };
              var e = new aA(t, A, o, i);
              return (o = i), { value: e, done: !1 };
            },
          };
        }
        function UA(A) {
          return 48 <= A && A <= 57;
        }
        function lA(A) {
          return UA(A) || (65 <= A && A <= 70) || (97 <= A && A <= 102);
        }
        function CA(A) {
          return 10 === A || 9 === A || 32 === A;
        }
        function uA(A) {
          return (
            (97 <= (t = e = A) && t <= 122) ||
            (65 <= (e = e) && e <= 90) ||
            128 <= A ||
            95 === A
          );
          var e, t;
        }
        function FA(A) {
          return uA(A) || UA(A) || 45 === A;
        }
        function hA(A, e) {
          return 92 === A && 10 !== e;
        }
        function dA(A, e, t) {
          return 45 === A
            ? uA(e) || hA(e, t)
            : !!uA(A) || (92 === A && 10 !== e);
        }
        function fA(A, e, t) {
          return 43 === A || 45 === A
            ? !!UA(e) || (46 === e && UA(t))
            : UA(46 === A ? e : A);
        }
        var HA = { type: 2 },
          pA = { type: 3 },
          EA = { type: 4 },
          IA = { type: 13 },
          yA = { type: 8 },
          KA = { type: 21 },
          mA = { type: 9 },
          LA = { type: 10 },
          bA = { type: 11 },
          DA = { type: 12 },
          vA = { type: 14 },
          xA = { type: 23 },
          MA = { type: 1 },
          SA = { type: 25 },
          TA = { type: 24 },
          GA = { type: 26 },
          OA = { type: 27 },
          VA = { type: 28 },
          kA = { type: 29 },
          RA = { type: 31 },
          NA = { type: 32 },
          PA =
            ((XA.prototype.write = function (A) {
              this._value = this._value.concat(Q(A));
            }),
            (XA.prototype.read = function () {
              for (var A = [], e = this.consumeToken(); e !== NA; )
                A.push(e), (e = this.consumeToken());
              return A;
            }),
            (XA.prototype.consumeToken = function () {
              var A = this.consumeCodePoint();
              switch (A) {
                case 34:
                  return this.consumeStringToken(34);
                case 35:
                  var e = this.peekCodePoint(0),
                    t = this.peekCodePoint(1),
                    r = this.peekCodePoint(2);
                  if (FA(e) || hA(t, r)) {
                    var B = dA(e, t, r) ? 2 : 1;
                    return { type: 5, value: this.consumeName(), flags: B };
                  }
                  break;
                case 36:
                  if (61 === this.peekCodePoint(0))
                    return this.consumeCodePoint(), IA;
                  break;
                case 39:
                  return this.consumeStringToken(39);
                case 40:
                  return HA;
                case 41:
                  return pA;
                case 42:
                  if (61 === this.peekCodePoint(0))
                    return this.consumeCodePoint(), vA;
                  break;
                case 43:
                  if (fA(A, this.peekCodePoint(0), this.peekCodePoint(1)))
                    return (
                      this.reconsumeCodePoint(A), this.consumeNumericToken()
                    );
                  break;
                case 44:
                  return EA;
                case 45:
                  var r = A,
                    B = this.peekCodePoint(0),
                    n = this.peekCodePoint(1);
                  if (fA(r, B, n))
                    return (
                      this.reconsumeCodePoint(A), this.consumeNumericToken()
                    );
                  if (dA(r, B, n))
                    return (
                      this.reconsumeCodePoint(A), this.consumeIdentLikeToken()
                    );
                  if (45 === B && 62 === n)
                    return this.consumeCodePoint(), this.consumeCodePoint(), TA;
                  break;
                case 46:
                  if (fA(A, this.peekCodePoint(0), this.peekCodePoint(1)))
                    return (
                      this.reconsumeCodePoint(A), this.consumeNumericToken()
                    );
                  break;
                case 47:
                  if (42 === this.peekCodePoint(0))
                    for (this.consumeCodePoint(); ; ) {
                      var s = this.consumeCodePoint();
                      if (42 === s && 47 === (s = this.consumeCodePoint()))
                        return this.consumeToken();
                      if (-1 === s) return this.consumeToken();
                    }
                  break;
                case 58:
                  return GA;
                case 59:
                  return OA;
                case 60:
                  if (
                    33 === this.peekCodePoint(0) &&
                    45 === this.peekCodePoint(1) &&
                    45 === this.peekCodePoint(2)
                  )
                    return this.consumeCodePoint(), this.consumeCodePoint(), SA;
                  break;
                case 64:
                  var n = this.peekCodePoint(0),
                    o = this.peekCodePoint(1),
                    i = this.peekCodePoint(2);
                  if (dA(n, o, i))
                    return { type: 7, value: this.consumeName() };
                  break;
                case 91:
                  return VA;
                case 92:
                  if (hA(A, this.peekCodePoint(0)))
                    return (
                      this.reconsumeCodePoint(A), this.consumeIdentLikeToken()
                    );
                  break;
                case 93:
                  return kA;
                case 61:
                  if (61 === this.peekCodePoint(0))
                    return this.consumeCodePoint(), yA;
                  break;
                case 123:
                  return bA;
                case 125:
                  return DA;
                case 117:
                case 85:
                  (o = this.peekCodePoint(0)), (i = this.peekCodePoint(1));
                  return (
                    43 !== o ||
                      (!lA(i) && 63 !== i) ||
                      (this.consumeCodePoint(),
                      this.consumeUnicodeRangeToken()),
                    this.reconsumeCodePoint(A),
                    this.consumeIdentLikeToken()
                  );
                case 124:
                  if (61 === this.peekCodePoint(0))
                    return this.consumeCodePoint(), mA;
                  if (124 === this.peekCodePoint(0))
                    return this.consumeCodePoint(), KA;
                  break;
                case 126:
                  if (61 === this.peekCodePoint(0))
                    return this.consumeCodePoint(), LA;
                  break;
                case -1:
                  return NA;
              }
              return CA(A)
                ? (this.consumeWhiteSpace(), RA)
                : UA(A)
                ? (this.reconsumeCodePoint(A), this.consumeNumericToken())
                : uA(A)
                ? (this.reconsumeCodePoint(A), this.consumeIdentLikeToken())
                : { type: 6, value: g(A) };
            }),
            (XA.prototype.consumeCodePoint = function () {
              var A = this._value.shift();
              return void 0 === A ? -1 : A;
            }),
            (XA.prototype.reconsumeCodePoint = function (A) {
              this._value.unshift(A);
            }),
            (XA.prototype.peekCodePoint = function (A) {
              return A >= this._value.length ? -1 : this._value[A];
            }),
            (XA.prototype.consumeUnicodeRangeToken = function () {
              for (
                var A = [], e = this.consumeCodePoint();
                lA(e) && A.length < 6;

              )
                A.push(e), (e = this.consumeCodePoint());
              for (var t = !1; 63 === e && A.length < 6; )
                A.push(e), (e = this.consumeCodePoint()), (t = !0);
              if (t)
                return {
                  type: 30,
                  start: parseInt(
                    g.apply(
                      void 0,
                      A.map(function (A) {
                        return 63 === A ? 48 : A;
                      })
                    ),
                    16
                  ),
                  end: parseInt(
                    g.apply(
                      void 0,
                      A.map(function (A) {
                        return 63 === A ? 70 : A;
                      })
                    ),
                    16
                  ),
                };
              var r = parseInt(g.apply(void 0, A), 16);
              if (45 === this.peekCodePoint(0) && lA(this.peekCodePoint(1))) {
                this.consumeCodePoint();
                for (
                  var e = this.consumeCodePoint(), B = [];
                  lA(e) && B.length < 6;

                )
                  B.push(e), (e = this.consumeCodePoint());
                return {
                  type: 30,
                  start: r,
                  end: parseInt(g.apply(void 0, B), 16),
                };
              }
              return { type: 30, start: r, end: r };
            }),
            (XA.prototype.consumeIdentLikeToken = function () {
              var A = this.consumeName();
              return "url" === A.toLowerCase() && 40 === this.peekCodePoint(0)
                ? (this.consumeCodePoint(), this.consumeUrlToken())
                : 40 === this.peekCodePoint(0)
                ? (this.consumeCodePoint(), { type: 19, value: A })
                : { type: 20, value: A };
            }),
            (XA.prototype.consumeUrlToken = function () {
              var A = [];
              if ((this.consumeWhiteSpace(), -1 === this.peekCodePoint(0)))
                return { type: 22, value: "" };
              var e,
                t = this.peekCodePoint(0);
              if (39 === t || 34 === t) {
                t = this.consumeStringToken(this.consumeCodePoint());
                return 0 === t.type &&
                  (this.consumeWhiteSpace(),
                  -1 === this.peekCodePoint(0) || 41 === this.peekCodePoint(0))
                  ? (this.consumeCodePoint(), { type: 22, value: t.value })
                  : (this.consumeBadUrlRemnants(), xA);
              }
              for (;;) {
                var r = this.consumeCodePoint();
                if (-1 === r || 41 === r)
                  return { type: 22, value: g.apply(void 0, A) };
                if (CA(r))
                  return (
                    this.consumeWhiteSpace(),
                    -1 === this.peekCodePoint(0) || 41 === this.peekCodePoint(0)
                      ? (this.consumeCodePoint(),
                        { type: 22, value: g.apply(void 0, A) })
                      : (this.consumeBadUrlRemnants(), xA)
                  );
                if (
                  34 === r ||
                  39 === r ||
                  40 === r ||
                  (0 <= (e = r) && e <= 8) ||
                  11 === e ||
                  (14 <= e && e <= 31) ||
                  127 === e
                )
                  return this.consumeBadUrlRemnants(), xA;
                if (92 === r) {
                  if (!hA(r, this.peekCodePoint(0)))
                    return this.consumeBadUrlRemnants(), xA;
                  A.push(this.consumeEscapedCodePoint());
                } else A.push(r);
              }
            }),
            (XA.prototype.consumeWhiteSpace = function () {
              for (; CA(this.peekCodePoint(0)); ) this.consumeCodePoint();
            }),
            (XA.prototype.consumeBadUrlRemnants = function () {
              for (;;) {
                var A = this.consumeCodePoint();
                if (41 === A || -1 === A) return;
                hA(A, this.peekCodePoint(0)) && this.consumeEscapedCodePoint();
              }
            }),
            (XA.prototype.consumeStringSlice = function (A) {
              for (var e = ""; 0 < A; ) {
                var t = Math.min(5e4, A);
                (e += g.apply(void 0, this._value.splice(0, t))), (A -= t);
              }
              return this._value.shift(), e;
            }),
            (XA.prototype.consumeStringToken = function (A) {
              for (var e = "", t = 0; ; ) {
                var r,
                  B = this._value[t];
                if (-1 === B || void 0 === B || B === A)
                  return { type: 0, value: (e += this.consumeStringSlice(t)) };
                if (10 === B) return this._value.splice(0, t), MA;
                92 !== B ||
                  (-1 !== (r = this._value[t + 1]) &&
                    void 0 !== r &&
                    (10 === r
                      ? ((e += this.consumeStringSlice(t)),
                        (t = -1),
                        this._value.shift())
                      : hA(B, r) &&
                        ((e += this.consumeStringSlice(t)),
                        (e += g(this.consumeEscapedCodePoint())),
                        (t = -1)))),
                  t++;
              }
            }),
            (XA.prototype.consumeNumber = function () {
              var A = [],
                e = 4;
              for (
                (43 !== (t = this.peekCodePoint(0)) && 45 !== t) ||
                A.push(this.consumeCodePoint());
                UA(this.peekCodePoint(0));

              )
                A.push(this.consumeCodePoint());
              var t = this.peekCodePoint(0),
                r = this.peekCodePoint(1);
              if (46 === t && UA(r))
                for (
                  A.push(this.consumeCodePoint(), this.consumeCodePoint()),
                    e = 8;
                  UA(this.peekCodePoint(0));

                )
                  A.push(this.consumeCodePoint());
              t = this.peekCodePoint(0);
              var r = this.peekCodePoint(1),
                B = this.peekCodePoint(2);
              if (
                (69 === t || 101 === t) &&
                (((43 === r || 45 === r) && UA(B)) || UA(r))
              )
                for (
                  A.push(this.consumeCodePoint(), this.consumeCodePoint()),
                    e = 8;
                  UA(this.peekCodePoint(0));

                )
                  A.push(this.consumeCodePoint());
              return [
                (function (A) {
                  var e = 0,
                    t = 1;
                  (43 !== A[e] && 45 !== A[e]) ||
                    (45 === A[e] && (t = -1), e++);
                  for (var r = []; UA(A[e]); ) r.push(A[e++]);
                  var B = r.length ? parseInt(g.apply(void 0, r), 10) : 0;
                  46 === A[e] && e++;
                  for (var n = []; UA(A[e]); ) n.push(A[e++]);
                  var s = n.length,
                    o = s ? parseInt(g.apply(void 0, n), 10) : 0;
                  (69 !== A[e] && 101 !== A[e]) || e++;
                  var i = 1;
                  (43 !== A[e] && 45 !== A[e]) ||
                    (45 === A[e] && (i = -1), e++);
                  for (var Q = []; UA(A[e]); ) Q.push(A[e++]);
                  var c = Q.length ? parseInt(g.apply(void 0, Q), 10) : 0;
                  return t * (B + o * Math.pow(10, -s)) * Math.pow(10, i * c);
                })(A),
                e,
              ];
            }),
            (XA.prototype.consumeNumericToken = function () {
              var A = this.consumeNumber(),
                e = A[0],
                t = A[1],
                r = this.peekCodePoint(0),
                B = this.peekCodePoint(1),
                A = this.peekCodePoint(2);
              return dA(r, B, A)
                ? { type: 15, number: e, flags: t, unit: this.consumeName() }
                : 37 === r
                ? (this.consumeCodePoint(), { type: 16, number: e, flags: t })
                : { type: 17, number: e, flags: t };
            }),
            (XA.prototype.consumeEscapedCodePoint = function () {
              var A,
                e = this.consumeCodePoint();
              if (lA(e)) {
                for (var t = g(e); lA(this.peekCodePoint(0)) && t.length < 6; )
                  t += g(this.consumeCodePoint());
                CA(this.peekCodePoint(0)) && this.consumeCodePoint();
                var r = parseInt(t, 16);
                return 0 === r ||
                  (55296 <= (A = r) && A <= 57343) ||
                  1114111 < r
                  ? 65533
                  : r;
              }
              return -1 === e ? 65533 : e;
            }),
            (XA.prototype.consumeName = function () {
              for (var A = ""; ; ) {
                var e = this.consumeCodePoint();
                if (FA(e)) A += g(e);
                else {
                  if (!hA(e, this.peekCodePoint(0)))
                    return this.reconsumeCodePoint(e), A;
                  A += g(this.consumeEscapedCodePoint());
                }
              }
            }),
            XA);
        function XA() {
          this._value = [];
        }
        var JA =
          ((YA.create = function (A) {
            var e = new PA();
            return e.write(A), new YA(e.read());
          }),
          (YA.parseValue = function (A) {
            return YA.create(A).parseComponentValue();
          }),
          (YA.parseValues = function (A) {
            return YA.create(A).parseComponentValues();
          }),
          (YA.prototype.parseComponentValue = function () {
            for (var A = this.consumeToken(); 31 === A.type; )
              A = this.consumeToken();
            if (32 === A.type)
              throw new SyntaxError(
                "Error parsing CSS component value, unexpected EOF"
              );
            this.reconsumeToken(A);
            for (
              var e = this.consumeComponentValue();
              31 === (A = this.consumeToken()).type;

            );
            if (32 === A.type) return e;
            throw new SyntaxError(
              "Error parsing CSS component value, multiple values found when expecting only one"
            );
          }),
          (YA.prototype.parseComponentValues = function () {
            for (var A = []; ; ) {
              var e = this.consumeComponentValue();
              if (32 === e.type) return A;
              A.push(e), A.push();
            }
          }),
          (YA.prototype.consumeComponentValue = function () {
            var A = this.consumeToken();
            switch (A.type) {
              case 11:
              case 28:
              case 2:
                return this.consumeSimpleBlock(A.type);
              case 19:
                return this.consumeFunction(A);
            }
            return A;
          }),
          (YA.prototype.consumeSimpleBlock = function (A) {
            for (var e = { type: A, values: [] }, t = this.consumeToken(); ; ) {
              if (32 === t.type || ce(t, A)) return e;
              this.reconsumeToken(t),
                e.values.push(this.consumeComponentValue()),
                (t = this.consumeToken());
            }
          }),
          (YA.prototype.consumeFunction = function (A) {
            for (var e = { name: A.value, values: [], type: 18 }; ; ) {
              var t = this.consumeToken();
              if (32 === t.type || 3 === t.type) return e;
              this.reconsumeToken(t),
                e.values.push(this.consumeComponentValue());
            }
          }),
          (YA.prototype.consumeToken = function () {
            var A = this._tokens.shift();
            return void 0 === A ? NA : A;
          }),
          (YA.prototype.reconsumeToken = function (A) {
            this._tokens.unshift(A);
          }),
          YA);
        function YA(A) {
          this._tokens = A;
        }
        function WA(A) {
          return 15 === A.type;
        }
        function ZA(A) {
          return 17 === A.type;
        }
        function _A(A) {
          return 20 === A.type;
        }
        function qA(A) {
          return 0 === A.type;
        }
        function jA(A, e) {
          return _A(A) && A.value === e;
        }
        function zA(A) {
          return 31 !== A.type;
        }
        function $A(A) {
          return 31 !== A.type && 4 !== A.type;
        }
        function Ae(A) {
          var e = [],
            t = [];
          return (
            A.forEach(function (A) {
              if (4 === A.type) {
                if (0 === t.length)
                  throw new Error(
                    "Error parsing function args, zero tokens for arg"
                  );
                return e.push(t), void (t = []);
              }
              31 !== A.type && t.push(A);
            }),
            t.length && e.push(t),
            e
          );
        }
        function ee(A) {
          return 17 === A.type || 15 === A.type;
        }
        function te(A) {
          return 16 === A.type || ee(A);
        }
        function re(A) {
          return 1 < A.length ? [A[0], A[1]] : [A[0]];
        }
        function Be(A, e, t) {
          var r = A[0],
            A = A[1];
          return [Ue(r, e), Ue(void 0 !== A ? A : r, t)];
        }
        function ne(A) {
          return (
            15 === A.type &&
            ("deg" === A.unit ||
              "grad" === A.unit ||
              "rad" === A.unit ||
              "turn" === A.unit)
          );
        }
        function se(A) {
          switch (
            A.filter(_A)
              .map(function (A) {
                return A.value;
              })
              .join(" ")
          ) {
            case "to bottom right":
            case "to right bottom":
            case "left top":
            case "top left":
              return [ae, ae];
            case "to top":
            case "bottom":
              return Ce(0);
            case "to bottom left":
            case "to left bottom":
            case "right top":
            case "top right":
              return [ae, we];
            case "to right":
            case "left":
              return Ce(90);
            case "to top left":
            case "to left top":
            case "right bottom":
            case "bottom right":
              return [we, we];
            case "to bottom":
            case "top":
              return Ce(180);
            case "to top right":
            case "to right top":
            case "left bottom":
            case "bottom left":
              return [we, ae];
            case "to left":
            case "right":
              return Ce(270);
          }
          return 0;
        }
        function oe(A) {
          return 0 == (255 & A);
        }
        function ie(A) {
          var e = 255 & A,
            t = 255 & (A >> 8),
            r = 255 & (A >> 16),
            A = 255 & (A >> 24);
          return e < 255
            ? "rgba(" + A + "," + r + "," + t + "," + e / 255 + ")"
            : "rgb(" + A + "," + r + "," + t + ")";
        }
        function Qe(A, e) {
          if (17 === A.type) return A.number;
          if (16 !== A.type) return 0;
          var t = 3 === e ? 1 : 255;
          return 3 === e
            ? (A.number / 100) * t
            : Math.round((A.number / 100) * t);
        }
        var ce = function (A, e) {
            return (
              (11 === e && 12 === A.type) ||
              (28 === e && 29 === A.type) ||
              (2 === e && 3 === A.type)
            );
          },
          ae = { type: 17, number: 0, flags: 4 },
          ge = { type: 16, number: 50, flags: 4 },
          we = { type: 16, number: 100, flags: 4 },
          Ue = function (A, e) {
            if (16 === A.type) return (A.number / 100) * e;
            if (WA(A))
              switch (A.unit) {
                case "rem":
                case "em":
                  return 16 * A.number;
                default:
                  return A.number;
              }
            return A.number;
          },
          le = function (A, e) {
            if (15 === e.type)
              switch (e.unit) {
                case "deg":
                  return (Math.PI * e.number) / 180;
                case "grad":
                  return (Math.PI / 200) * e.number;
                case "rad":
                  return e.number;
                case "turn":
                  return 2 * Math.PI * e.number;
              }
            throw new Error("Unsupported angle type");
          },
          Ce = function (A) {
            return (Math.PI * A) / 180;
          },
          ue = function (A, e) {
            if (18 === e.type) {
              var t = me[e.name];
              if (void 0 === t)
                throw new Error(
                  'Attempting to parse an unsupported color function "' +
                    e.name +
                    '"'
                );
              return t(A, e.values);
            }
            if (5 === e.type) {
              if (3 === e.value.length) {
                var r = e.value.substring(0, 1),
                  B = e.value.substring(1, 2),
                  n = e.value.substring(2, 3);
                return Fe(
                  parseInt(r + r, 16),
                  parseInt(B + B, 16),
                  parseInt(n + n, 16),
                  1
                );
              }
              if (4 === e.value.length) {
                var r = e.value.substring(0, 1),
                  B = e.value.substring(1, 2),
                  n = e.value.substring(2, 3),
                  s = e.value.substring(3, 4);
                return Fe(
                  parseInt(r + r, 16),
                  parseInt(B + B, 16),
                  parseInt(n + n, 16),
                  parseInt(s + s, 16) / 255
                );
              }
              if (6 === e.value.length) {
                (r = e.value.substring(0, 2)),
                  (B = e.value.substring(2, 4)),
                  (n = e.value.substring(4, 6));
                return Fe(parseInt(r, 16), parseInt(B, 16), parseInt(n, 16), 1);
              }
              if (8 === e.value.length) {
                (r = e.value.substring(0, 2)),
                  (B = e.value.substring(2, 4)),
                  (n = e.value.substring(4, 6)),
                  (s = e.value.substring(6, 8));
                return Fe(
                  parseInt(r, 16),
                  parseInt(B, 16),
                  parseInt(n, 16),
                  parseInt(s, 16) / 255
                );
              }
            }
            if (20 === e.type) {
              e = Le[e.value.toUpperCase()];
              if (void 0 !== e) return e;
            }
            return Le.TRANSPARENT;
          },
          Fe = function (A, e, t, r) {
            return (
              ((A << 24) |
                (e << 16) |
                (t << 8) |
                (Math.round(255 * r) << 0)) >>>
              0
            );
          },
          he = function (A, e) {
            e = e.filter($A);
            if (3 === e.length) {
              var t = e.map(Qe),
                r = t[0],
                B = t[1],
                t = t[2];
              return Fe(r, B, t, 1);
            }
            if (4 !== e.length) return 0;
            (e = e.map(Qe)), (r = e[0]), (B = e[1]), (t = e[2]), (e = e[3]);
            return Fe(r, B, t, e);
          };
        function de(A, e, t) {
          return (
            t < 0 && (t += 1),
            1 <= t && --t,
            t < 1 / 6
              ? (e - A) * t * 6 + A
              : t < 0.5
              ? e
              : t < 2 / 3
              ? 6 * (e - A) * (2 / 3 - t) + A
              : A
          );
        }
        function fe(A, e) {
          return ue(A, JA.create(e).parseComponentValue());
        }
        function He(A, e) {
          return (
            (A = ue(A, e[0])),
            (e = e[1]) && te(e)
              ? { color: A, stop: e }
              : { color: A, stop: null }
          );
        }
        function pe(A, t) {
          var e = A[0],
            r = A[A.length - 1];
          null === e.stop && (e.stop = ae), null === r.stop && (r.stop = we);
          for (var B = [], n = 0, s = 0; s < A.length; s++) {
            var o = A[s].stop;
            null !== o
              ? (n < (o = Ue(o, t)) ? B.push(o) : B.push(n), (n = o))
              : B.push(null);
          }
          for (var i = null, s = 0; s < B.length; s++) {
            var Q = B[s];
            if (null === Q) null === i && (i = s);
            else if (null !== i) {
              for (
                var c = s - i, a = (Q - B[i - 1]) / (1 + c), g = 1;
                g <= c;
                g++
              )
                B[i + g - 1] = a * g;
              i = null;
            }
          }
          return A.map(function (A, e) {
            return { color: A.color, stop: Math.max(Math.min(1, B[e] / t), 0) };
          });
        }
        function Ee(A, e, t) {
          var r =
              "number" == typeof A
                ? A
                : ((s = e / 2),
                  (r = (n = t) / 2),
                  (s = Ue((B = A)[0], e) - s),
                  (n = r - Ue(B[1], n)),
                  (Math.atan2(n, s) + 2 * Math.PI) % (2 * Math.PI)),
            B = Math.abs(e * Math.sin(r)) + Math.abs(t * Math.cos(r)),
            n = e / 2,
            s = t / 2,
            e = B / 2,
            t = Math.sin(r - Math.PI / 2) * e,
            e = Math.cos(r - Math.PI / 2) * e;
          return [B, n - e, n + e, s - t, s + t];
        }
        function Ie(A, e) {
          return Math.sqrt(A * A + e * e);
        }
        function ye(A, e, B, n, s) {
          return [
            [0, 0],
            [0, e],
            [A, 0],
            [A, e],
          ].reduce(
            function (A, e) {
              var t = e[0],
                r = e[1],
                r = Ie(B - t, n - r);
              return (s ? r < A.optimumDistance : r > A.optimumDistance)
                ? { optimumCorner: e, optimumDistance: r }
                : A;
            },
            { optimumDistance: s ? 1 / 0 : -1 / 0, optimumCorner: null }
          ).optimumCorner;
        }
        var Ke = function (A, e) {
            var t = e.filter($A),
              r = t[0],
              B = t[1],
              n = t[2],
              e = t[3],
              t = (17 === r.type ? Ce(r.number) : le(A, r)) / (2 * Math.PI),
              A = te(B) ? B.number / 100 : 0,
              r = te(n) ? n.number / 100 : 0,
              B = void 0 !== e && te(e) ? Ue(e, 1) : 1;
            if (0 == A) return Fe(255 * r, 255 * r, 255 * r, 1);
            (n = r <= 0.5 ? r * (1 + A) : r + A - r * A),
              (e = 2 * r - n),
              (A = de(e, n, t + 1 / 3)),
              (r = de(e, n, t)),
              (t = de(e, n, t - 1 / 3));
            return Fe(255 * A, 255 * r, 255 * t, B);
          },
          me = { hsl: Ke, hsla: Ke, rgb: he, rgba: he },
          Le = {
            ALICEBLUE: 4042850303,
            ANTIQUEWHITE: 4209760255,
            AQUA: 16777215,
            AQUAMARINE: 2147472639,
            AZURE: 4043309055,
            BEIGE: 4126530815,
            BISQUE: 4293182719,
            BLACK: 255,
            BLANCHEDALMOND: 4293643775,
            BLUE: 65535,
            BLUEVIOLET: 2318131967,
            BROWN: 2771004159,
            BURLYWOOD: 3736635391,
            CADETBLUE: 1604231423,
            CHARTREUSE: 2147418367,
            CHOCOLATE: 3530104575,
            CORAL: 4286533887,
            CORNFLOWERBLUE: 1687547391,
            CORNSILK: 4294499583,
            CRIMSON: 3692313855,
            CYAN: 16777215,
            DARKBLUE: 35839,
            DARKCYAN: 9145343,
            DARKGOLDENROD: 3095837695,
            DARKGRAY: 2846468607,
            DARKGREEN: 6553855,
            DARKGREY: 2846468607,
            DARKKHAKI: 3182914559,
            DARKMAGENTA: 2332068863,
            DARKOLIVEGREEN: 1433087999,
            DARKORANGE: 4287365375,
            DARKORCHID: 2570243327,
            DARKRED: 2332033279,
            DARKSALMON: 3918953215,
            DARKSEAGREEN: 2411499519,
            DARKSLATEBLUE: 1211993087,
            DARKSLATEGRAY: 793726975,
            DARKSLATEGREY: 793726975,
            DARKTURQUOISE: 13554175,
            DARKVIOLET: 2483082239,
            DEEPPINK: 4279538687,
            DEEPSKYBLUE: 12582911,
            DIMGRAY: 1768516095,
            DIMGREY: 1768516095,
            DODGERBLUE: 512819199,
            FIREBRICK: 2988581631,
            FLORALWHITE: 4294635775,
            FORESTGREEN: 579543807,
            FUCHSIA: 4278255615,
            GAINSBORO: 3705462015,
            GHOSTWHITE: 4177068031,
            GOLD: 4292280575,
            GOLDENROD: 3668254975,
            GRAY: 2155905279,
            GREEN: 8388863,
            GREENYELLOW: 2919182335,
            GREY: 2155905279,
            HONEYDEW: 4043305215,
            HOTPINK: 4285117695,
            INDIANRED: 3445382399,
            INDIGO: 1258324735,
            IVORY: 4294963455,
            KHAKI: 4041641215,
            LAVENDER: 3873897215,
            LAVENDERBLUSH: 4293981695,
            LAWNGREEN: 2096890111,
            LEMONCHIFFON: 4294626815,
            LIGHTBLUE: 2916673279,
            LIGHTCORAL: 4034953471,
            LIGHTCYAN: 3774873599,
            LIGHTGOLDENRODYELLOW: 4210742015,
            LIGHTGRAY: 3553874943,
            LIGHTGREEN: 2431553791,
            LIGHTGREY: 3553874943,
            LIGHTPINK: 4290167295,
            LIGHTSALMON: 4288707327,
            LIGHTSEAGREEN: 548580095,
            LIGHTSKYBLUE: 2278488831,
            LIGHTSLATEGRAY: 2005441023,
            LIGHTSLATEGREY: 2005441023,
            LIGHTSTEELBLUE: 2965692159,
            LIGHTYELLOW: 4294959359,
            LIME: 16711935,
            LIMEGREEN: 852308735,
            LINEN: 4210091775,
            MAGENTA: 4278255615,
            MAROON: 2147483903,
            MEDIUMAQUAMARINE: 1724754687,
            MEDIUMBLUE: 52735,
            MEDIUMORCHID: 3126187007,
            MEDIUMPURPLE: 2473647103,
            MEDIUMSEAGREEN: 1018393087,
            MEDIUMSLATEBLUE: 2070474495,
            MEDIUMSPRINGGREEN: 16423679,
            MEDIUMTURQUOISE: 1221709055,
            MEDIUMVIOLETRED: 3340076543,
            MIDNIGHTBLUE: 421097727,
            MINTCREAM: 4127193855,
            MISTYROSE: 4293190143,
            MOCCASIN: 4293178879,
            NAVAJOWHITE: 4292783615,
            NAVY: 33023,
            OLDLACE: 4260751103,
            OLIVE: 2155872511,
            OLIVEDRAB: 1804477439,
            ORANGE: 4289003775,
            ORANGERED: 4282712319,
            ORCHID: 3664828159,
            PALEGOLDENROD: 4008225535,
            PALEGREEN: 2566625535,
            PALETURQUOISE: 2951671551,
            PALEVIOLETRED: 3681588223,
            PAPAYAWHIP: 4293907967,
            PEACHPUFF: 4292524543,
            PERU: 3448061951,
            PINK: 4290825215,
            PLUM: 3718307327,
            POWDERBLUE: 2967529215,
            PURPLE: 2147516671,
            REBECCAPURPLE: 1714657791,
            RED: 4278190335,
            ROSYBROWN: 3163525119,
            ROYALBLUE: 1097458175,
            SADDLEBROWN: 2336560127,
            SALMON: 4202722047,
            SANDYBROWN: 4104413439,
            SEAGREEN: 780883967,
            SEASHELL: 4294307583,
            SIENNA: 2689740287,
            SILVER: 3233857791,
            SKYBLUE: 2278484991,
            SLATEBLUE: 1784335871,
            SLATEGRAY: 1887473919,
            SLATEGREY: 1887473919,
            SNOW: 4294638335,
            SPRINGGREEN: 16744447,
            STEELBLUE: 1182971135,
            TAN: 3535047935,
            TEAL: 8421631,
            THISTLE: 3636451583,
            TOMATO: 4284696575,
            TRANSPARENT: 0,
            TURQUOISE: 1088475391,
            VIOLET: 4001558271,
            WHEAT: 4125012991,
            WHITE: 4294967295,
            WHITESMOKE: 4126537215,
            YELLOW: 4294902015,
            YELLOWGREEN: 2597139199,
          },
          be = {
            name: "background-clip",
            initialValue: "border-box",
            prefix: !1,
            type: 1,
            parse: function (A, e) {
              return e.map(function (A) {
                if (_A(A))
                  switch (A.value) {
                    case "padding-box":
                      return 1;
                    case "content-box":
                      return 2;
                  }
                return 0;
              });
            },
          },
          De = {
            name: "background-color",
            initialValue: "transparent",
            prefix: !1,
            type: 3,
            format: "color",
          },
          Ke = function (t, A) {
            var r = Ce(180),
              B = [];
            return (
              Ae(A).forEach(function (A, e) {
                if (0 === e) {
                  e = A[0];
                  if (
                    20 === e.type &&
                    -1 !== ["top", "left", "right", "bottom"].indexOf(e.value)
                  )
                    return void (r = se(A));
                  if (ne(e)) return void (r = (le(t, e) + Ce(270)) % Ce(360));
                }
                A = He(t, A);
                B.push(A);
              }),
              { angle: r, stops: B, type: 1 }
            );
          },
          ve = "closest-side",
          xe = "farthest-side",
          Me = "closest-corner",
          Se = "farthest-corner",
          Te = "ellipse",
          Ge = "contain",
          he = function (r, A) {
            var B = 0,
              n = 3,
              s = [],
              o = [];
            return (
              Ae(A).forEach(function (A, e) {
                var t = !0;
                0 === e
                  ? (t = A.reduce(function (A, e) {
                      if (_A(e))
                        switch (e.value) {
                          case "center":
                            return o.push(ge), !1;
                          case "top":
                          case "left":
                            return o.push(ae), !1;
                          case "right":
                          case "bottom":
                            return o.push(we), !1;
                        }
                      else if (te(e) || ee(e)) return o.push(e), !1;
                      return A;
                    }, t))
                  : 1 === e &&
                    (t = A.reduce(function (A, e) {
                      if (_A(e))
                        switch (e.value) {
                          case "circle":
                            return (B = 0), !1;
                          case Te:
                            return !(B = 1);
                          case Ge:
                          case ve:
                            return (n = 0), !1;
                          case xe:
                            return !(n = 1);
                          case Me:
                            return !(n = 2);
                          case "cover":
                          case Se:
                            return !(n = 3);
                        }
                      else if (ee(e) || te(e))
                        return (n = !Array.isArray(n) ? [] : n).push(e), !1;
                      return A;
                    }, t)),
                  t && ((A = He(r, A)), s.push(A));
              }),
              { size: n, shape: B, stops: s, position: o, type: 2 }
            );
          },
          Oe = function (A, e) {
            if (22 === e.type) {
              var t = { url: e.value, type: 0 };
              return A.cache.addImage(e.value), t;
            }
            if (18 !== e.type)
              throw new Error("Unsupported image type " + e.type);
            t = ke[e.name];
            if (void 0 === t)
              throw new Error(
                'Attempting to parse an unsupported image function "' +
                  e.name +
                  '"'
              );
            return t(A, e.values);
          };
        var Ve,
          ke = {
            "linear-gradient": function (t, A) {
              var r = Ce(180),
                B = [];
              return (
                Ae(A).forEach(function (A, e) {
                  if (0 === e) {
                    e = A[0];
                    if (20 === e.type && "to" === e.value)
                      return void (r = se(A));
                    if (ne(e)) return void (r = le(t, e));
                  }
                  A = He(t, A);
                  B.push(A);
                }),
                { angle: r, stops: B, type: 1 }
              );
            },
            "-moz-linear-gradient": Ke,
            "-ms-linear-gradient": Ke,
            "-o-linear-gradient": Ke,
            "-webkit-linear-gradient": Ke,
            "radial-gradient": function (B, A) {
              var n = 0,
                s = 3,
                o = [],
                i = [];
              return (
                Ae(A).forEach(function (A, e) {
                  var t,
                    r = !0;
                  0 === e &&
                    ((t = !1),
                    (r = A.reduce(function (A, e) {
                      if (t)
                        if (_A(e))
                          switch (e.value) {
                            case "center":
                              return i.push(ge), A;
                            case "top":
                            case "left":
                              return i.push(ae), A;
                            case "right":
                            case "bottom":
                              return i.push(we), A;
                          }
                        else (te(e) || ee(e)) && i.push(e);
                      else if (_A(e))
                        switch (e.value) {
                          case "circle":
                            return (n = 0), !1;
                          case Te:
                            return !(n = 1);
                          case "at":
                            return !(t = !0);
                          case ve:
                            return (s = 0), !1;
                          case "cover":
                          case xe:
                            return !(s = 1);
                          case Ge:
                          case Me:
                            return !(s = 2);
                          case Se:
                            return !(s = 3);
                        }
                      else if (ee(e) || te(e))
                        return (s = !Array.isArray(s) ? [] : s).push(e), !1;
                      return A;
                    }, r))),
                    r && ((A = He(B, A)), o.push(A));
                }),
                { size: s, shape: n, stops: o, position: i, type: 2 }
              );
            },
            "-moz-radial-gradient": he,
            "-ms-radial-gradient": he,
            "-o-radial-gradient": he,
            "-webkit-radial-gradient": he,
            "-webkit-gradient": function (r, A) {
              var e = Ce(180),
                B = [],
                n = 1;
              return (
                Ae(A).forEach(function (A, e) {
                  var t,
                    A = A[0];
                  if (0 === e) {
                    if (_A(A) && "linear" === A.value) return void (n = 1);
                    if (_A(A) && "radial" === A.value) return void (n = 2);
                  }
                  18 === A.type &&
                    ("from" === A.name
                      ? ((t = ue(r, A.values[0])),
                        B.push({ stop: ae, color: t }))
                      : "to" === A.name
                      ? ((t = ue(r, A.values[0])),
                        B.push({ stop: we, color: t }))
                      : "color-stop" !== A.name ||
                        (2 === (A = A.values.filter($A)).length &&
                          ((t = ue(r, A[1])),
                          (A = A[0]),
                          ZA(A) &&
                            B.push({
                              stop: {
                                type: 16,
                                number: 100 * A.number,
                                flags: A.flags,
                              },
                              color: t,
                            }))));
                }),
                1 === n
                  ? { angle: (e + Ce(180)) % Ce(360), stops: B, type: n }
                  : { size: 3, shape: 0, stops: B, position: [], type: n }
              );
            },
          },
          Re = {
            name: "background-image",
            initialValue: "none",
            type: 1,
            prefix: !1,
            parse: function (e, A) {
              if (0 === A.length) return [];
              var t = A[0];
              return 20 === t.type && "none" === t.value
                ? []
                : A.filter(function (A) {
                    return (
                      $A(A) &&
                      !(
                        (20 === (A = A).type && "none" === A.value) ||
                        (18 === A.type && !ke[A.name])
                      )
                    );
                  }).map(function (A) {
                    return Oe(e, A);
                  });
            },
          },
          Ne = {
            name: "background-origin",
            initialValue: "border-box",
            prefix: !1,
            type: 1,
            parse: function (A, e) {
              return e.map(function (A) {
                if (_A(A))
                  switch (A.value) {
                    case "padding-box":
                      return 1;
                    case "content-box":
                      return 2;
                  }
                return 0;
              });
            },
          },
          Pe = {
            name: "background-position",
            initialValue: "0% 0%",
            type: 1,
            prefix: !1,
            parse: function (A, e) {
              return Ae(e)
                .map(function (A) {
                  return A.filter(te);
                })
                .map(re);
            },
          },
          Xe = {
            name: "background-repeat",
            initialValue: "repeat",
            prefix: !1,
            type: 1,
            parse: function (A, e) {
              return Ae(e)
                .map(function (A) {
                  return A.filter(_A)
                    .map(function (A) {
                      return A.value;
                    })
                    .join(" ");
                })
                .map(Je);
            },
          },
          Je = function (A) {
            switch (A) {
              case "no-repeat":
                return 1;
              case "repeat-x":
              case "repeat no-repeat":
                return 2;
              case "repeat-y":
              case "no-repeat repeat":
                return 3;
              default:
                return 0;
            }
          };
        ((he = Ve = Ve || {}).AUTO = "auto"), (he.CONTAIN = "contain");
        function Ye(A, e) {
          return _A(A) && "normal" === A.value
            ? 1.2 * e
            : 17 === A.type
            ? e * A.number
            : te(A)
            ? Ue(A, e)
            : e;
        }
        var We,
          Ze,
          _e = {
            name: "background-size",
            initialValue: "0",
            prefix: !(he.COVER = "cover"),
            type: 1,
            parse: function (A, e) {
              return Ae(e).map(function (A) {
                return A.filter(qe);
              });
            },
          },
          qe = function (A) {
            return _A(A) || te(A);
          },
          he = function (A) {
            return {
              name: "border-" + A + "-color",
              initialValue: "transparent",
              prefix: !1,
              type: 3,
              format: "color",
            };
          },
          je = he("top"),
          ze = he("right"),
          $e = he("bottom"),
          At = he("left"),
          he = function (A) {
            return {
              name: "border-radius-" + A,
              initialValue: "0 0",
              prefix: !1,
              type: 1,
              parse: function (A, e) {
                return re(e.filter(te));
              },
            };
          },
          et = he("top-left"),
          tt = he("top-right"),
          rt = he("bottom-right"),
          Bt = he("bottom-left"),
          he = function (A) {
            return {
              name: "border-" + A + "-style",
              initialValue: "solid",
              prefix: !1,
              type: 2,
              parse: function (A, e) {
                switch (e) {
                  case "none":
                    return 0;
                  case "dashed":
                    return 2;
                  case "dotted":
                    return 3;
                  case "double":
                    return 4;
                }
                return 1;
              },
            };
          },
          nt = he("top"),
          st = he("right"),
          ot = he("bottom"),
          it = he("left"),
          he = function (A) {
            return {
              name: "border-" + A + "-width",
              initialValue: "0",
              type: 0,
              prefix: !1,
              parse: function (A, e) {
                return WA(e) ? e.number : 0;
              },
            };
          },
          Qt = he("top"),
          ct = he("right"),
          at = he("bottom"),
          gt = he("left"),
          wt = {
            name: "color",
            initialValue: "transparent",
            prefix: !1,
            type: 3,
            format: "color",
          },
          Ut = {
            name: "direction",
            initialValue: "ltr",
            prefix: !1,
            type: 2,
            parse: function (A, e) {
              return "rtl" !== e ? 0 : 1;
            },
          },
          lt = {
            name: "display",
            initialValue: "inline-block",
            prefix: !1,
            type: 1,
            parse: function (A, e) {
              return e.filter(_A).reduce(function (A, e) {
                return A | Ct(e.value);
              }, 0);
            },
          },
          Ct = function (A) {
            switch (A) {
              case "block":
              case "-webkit-box":
                return 2;
              case "inline":
                return 4;
              case "run-in":
                return 8;
              case "flow":
                return 16;
              case "flow-root":
                return 32;
              case "table":
                return 64;
              case "flex":
              case "-webkit-flex":
                return 128;
              case "grid":
              case "-ms-grid":
                return 256;
              case "ruby":
                return 512;
              case "subgrid":
                return 1024;
              case "list-item":
                return 2048;
              case "table-row-group":
                return 4096;
              case "table-header-group":
                return 8192;
              case "table-footer-group":
                return 16384;
              case "table-row":
                return 32768;
              case "table-cell":
                return 65536;
              case "table-column-group":
                return 131072;
              case "table-column":
                return 262144;
              case "table-caption":
                return 524288;
              case "ruby-base":
                return 1048576;
              case "ruby-text":
                return 2097152;
              case "ruby-base-container":
                return 4194304;
              case "ruby-text-container":
                return 8388608;
              case "contents":
                return 16777216;
              case "inline-block":
                return 33554432;
              case "inline-list-item":
                return 67108864;
              case "inline-table":
                return 134217728;
              case "inline-flex":
                return 268435456;
              case "inline-grid":
                return 536870912;
            }
            return 0;
          },
          ut = {
            name: "float",
            initialValue: "none",
            prefix: !1,
            type: 2,
            parse: function (A, e) {
              switch (e) {
                case "left":
                  return 1;
                case "right":
                  return 2;
                case "inline-start":
                  return 3;
                case "inline-end":
                  return 4;
              }
              return 0;
            },
          },
          Ft = {
            name: "letter-spacing",
            initialValue: "0",
            prefix: !1,
            type: 0,
            parse: function (A, e) {
              return !(
                (20 === e.type && "normal" === e.value) ||
                (17 !== e.type && 15 !== e.type)
              )
                ? e.number
                : 0;
            },
          },
          ht = {
            name: "line-break",
            initialValue: ((he = We = We || {}).NORMAL = "normal"),
            prefix: !(he.STRICT = "strict"),
            type: 2,
            parse: function (A, e) {
              return "strict" !== e ? We.NORMAL : We.STRICT;
            },
          },
          dt = {
            name: "line-height",
            initialValue: "normal",
            prefix: !1,
            type: 4,
          },
          ft = {
            name: "list-style-image",
            initialValue: "none",
            type: 0,
            prefix: !1,
            parse: function (A, e) {
              return 20 === e.type && "none" === e.value ? null : Oe(A, e);
            },
          },
          Ht = {
            name: "list-style-position",
            initialValue: "outside",
            prefix: !1,
            type: 2,
            parse: function (A, e) {
              return "inside" !== e ? 1 : 0;
            },
          },
          pt = {
            name: "list-style-type",
            initialValue: "none",
            prefix: !1,
            type: 2,
            parse: function (A, e) {
              switch (e) {
                case "disc":
                  return 0;
                case "circle":
                  return 1;
                case "square":
                  return 2;
                case "decimal":
                  return 3;
                case "cjk-decimal":
                  return 4;
                case "decimal-leading-zero":
                  return 5;
                case "lower-roman":
                  return 6;
                case "upper-roman":
                  return 7;
                case "lower-greek":
                  return 8;
                case "lower-alpha":
                  return 9;
                case "upper-alpha":
                  return 10;
                case "arabic-indic":
                  return 11;
                case "armenian":
                  return 12;
                case "bengali":
                  return 13;
                case "cambodian":
                  return 14;
                case "cjk-earthly-branch":
                  return 15;
                case "cjk-heavenly-stem":
                  return 16;
                case "cjk-ideographic":
                  return 17;
                case "devanagari":
                  return 18;
                case "ethiopic-numeric":
                  return 19;
                case "georgian":
                  return 20;
                case "gujarati":
                  return 21;
                case "gurmukhi":
                case "hebrew":
                  return 22;
                case "hiragana":
                  return 23;
                case "hiragana-iroha":
                  return 24;
                case "japanese-formal":
                  return 25;
                case "japanese-informal":
                  return 26;
                case "kannada":
                  return 27;
                case "katakana":
                  return 28;
                case "katakana-iroha":
                  return 29;
                case "khmer":
                  return 30;
                case "korean-hangul-formal":
                  return 31;
                case "korean-hanja-formal":
                  return 32;
                case "korean-hanja-informal":
                  return 33;
                case "lao":
                  return 34;
                case "lower-armenian":
                  return 35;
                case "malayalam":
                  return 36;
                case "mongolian":
                  return 37;
                case "myanmar":
                  return 38;
                case "oriya":
                  return 39;
                case "persian":
                  return 40;
                case "simp-chinese-formal":
                  return 41;
                case "simp-chinese-informal":
                  return 42;
                case "tamil":
                  return 43;
                case "telugu":
                  return 44;
                case "thai":
                  return 45;
                case "tibetan":
                  return 46;
                case "trad-chinese-formal":
                  return 47;
                case "trad-chinese-informal":
                  return 48;
                case "upper-armenian":
                  return 49;
                case "disclosure-open":
                  return 50;
                case "disclosure-closed":
                  return 51;
                default:
                  return -1;
              }
            },
          },
          he = function (A) {
            return {
              name: "margin-" + A,
              initialValue: "0",
              prefix: !1,
              type: 4,
            };
          },
          Et = he("top"),
          It = he("right"),
          yt = he("bottom"),
          Kt = he("left"),
          mt = {
            name: "overflow",
            initialValue: "visible",
            prefix: !1,
            type: 1,
            parse: function (A, e) {
              return e.filter(_A).map(function (A) {
                switch (A.value) {
                  case "hidden":
                    return 1;
                  case "scroll":
                    return 2;
                  case "clip":
                    return 3;
                  case "auto":
                    return 4;
                  default:
                    return 0;
                }
              });
            },
          },
          Lt = {
            name: "overflow-wrap",
            initialValue: "normal",
            prefix: !1,
            type: 2,
            parse: function (A, e) {
              return "break-word" !== e ? "normal" : "break-word";
            },
          },
          he = function (A) {
            return {
              name: "padding-" + A,
              initialValue: "0",
              prefix: !1,
              type: 3,
              format: "length-percentage",
            };
          },
          bt = he("top"),
          Dt = he("right"),
          vt = he("bottom"),
          xt = he("left"),
          Mt = {
            name: "text-align",
            initialValue: "left",
            prefix: !1,
            type: 2,
            parse: function (A, e) {
              switch (e) {
                case "right":
                  return 2;
                case "center":
                case "justify":
                  return 1;
                default:
                  return 0;
              }
            },
          },
          St = {
            name: "position",
            initialValue: "static",
            prefix: !1,
            type: 2,
            parse: function (A, e) {
              switch (e) {
                case "relative":
                  return 1;
                case "absolute":
                  return 2;
                case "fixed":
                  return 3;
                case "sticky":
                  return 4;
              }
              return 0;
            },
          },
          Tt = {
            name: "text-shadow",
            initialValue: "none",
            type: 1,
            prefix: !1,
            parse: function (n, A) {
              return 1 === A.length && jA(A[0], "none")
                ? []
                : Ae(A).map(function (A) {
                    for (
                      var e = {
                          color: Le.TRANSPARENT,
                          offsetX: ae,
                          offsetY: ae,
                          blur: ae,
                        },
                        t = 0,
                        r = 0;
                      r < A.length;
                      r++
                    ) {
                      var B = A[r];
                      ee(B)
                        ? (0 === t
                            ? (e.offsetX = B)
                            : 1 === t
                            ? (e.offsetY = B)
                            : (e.blur = B),
                          t++)
                        : (e.color = ue(n, B));
                    }
                    return e;
                  });
            },
          },
          Gt = {
            name: "text-transform",
            initialValue: "none",
            prefix: !1,
            type: 2,
            parse: function (A, e) {
              switch (e) {
                case "uppercase":
                  return 2;
                case "lowercase":
                  return 1;
                case "capitalize":
                  return 3;
              }
              return 0;
            },
          },
          Ot = {
            name: "transform",
            initialValue: "none",
            prefix: !0,
            type: 0,
            parse: function (A, e) {
              if (20 === e.type && "none" === e.value) return null;
              if (18 !== e.type) return null;
              var t = Vt[e.name];
              if (void 0 === t)
                throw new Error(
                  'Attempting to parse an unsupported transform function "' +
                    e.name +
                    '"'
                );
              return t(e.values);
            },
          },
          Vt = {
            matrix: function (A) {
              A = A.filter(function (A) {
                return 17 === A.type;
              }).map(function (A) {
                return A.number;
              });
              return 6 === A.length ? A : null;
            },
            matrix3d: function (A) {
              var e = A.filter(function (A) {
                  return 17 === A.type;
                }).map(function (A) {
                  return A.number;
                }),
                t = e[0],
                r = e[1];
              e[2], e[3];
              var B = e[4],
                n = e[5];
              e[6], e[7], e[8], e[9], e[10], e[11];
              var s = e[12],
                A = e[13];
              return e[14], e[15], 16 === e.length ? [t, r, B, n, s, A] : null;
            },
          },
          he = { type: 16, number: 50, flags: 4 },
          kt = [he, he],
          Rt = {
            name: "transform-origin",
            initialValue: "50% 50%",
            prefix: !0,
            type: 1,
            parse: function (A, e) {
              e = e.filter(te);
              return 2 !== e.length ? kt : [e[0], e[1]];
            },
          },
          Nt = {
            name: "visible",
            initialValue: "none",
            prefix: !1,
            type: 2,
            parse: function (A, e) {
              switch (e) {
                case "hidden":
                  return 1;
                case "collapse":
                  return 2;
                default:
                  return 0;
              }
            },
          };
        ((he = Ze = Ze || {}).NORMAL = "normal"), (he.BREAK_ALL = "break-all");
        function Pt(A, e) {
          return 0 != (A & e);
        }
        function Xt(A, e, t) {
          return (A = A && A[Math.min(e, A.length - 1)])
            ? t
              ? A.open
              : A.close
            : "";
        }
        var Jt = {
            name: "word-break",
            initialValue: "normal",
            prefix: !(he.KEEP_ALL = "keep-all"),
            type: 2,
            parse: function (A, e) {
              switch (e) {
                case "break-all":
                  return Ze.BREAK_ALL;
                case "keep-all":
                  return Ze.KEEP_ALL;
                default:
                  return Ze.NORMAL;
              }
            },
          },
          Yt = {
            name: "z-index",
            initialValue: "auto",
            prefix: !1,
            type: 0,
            parse: function (A, e) {
              if (20 === e.type) return { auto: !0, order: 0 };
              if (ZA(e)) return { auto: !1, order: e.number };
              throw new Error("Invalid z-index number parsed");
            },
          },
          Wt = function (A, e) {
            if (15 === e.type)
              switch (e.unit.toLowerCase()) {
                case "s":
                  return 1e3 * e.number;
                case "ms":
                  return e.number;
              }
            throw new Error("Unsupported time type");
          },
          Zt = {
            name: "opacity",
            initialValue: "1",
            type: 0,
            prefix: !1,
            parse: function (A, e) {
              return ZA(e) ? e.number : 1;
            },
          },
          _t = {
            name: "text-decoration-color",
            initialValue: "transparent",
            prefix: !1,
            type: 3,
            format: "color",
          },
          qt = {
            name: "text-decoration-line",
            initialValue: "none",
            prefix: !1,
            type: 1,
            parse: function (A, e) {
              return e
                .filter(_A)
                .map(function (A) {
                  switch (A.value) {
                    case "underline":
                      return 1;
                    case "overline":
                      return 2;
                    case "line-through":
                      return 3;
                    case "none":
                      return 4;
                  }
                  return 0;
                })
                .filter(function (A) {
                  return 0 !== A;
                });
            },
          },
          jt = {
            name: "font-family",
            initialValue: "",
            prefix: !1,
            type: 1,
            parse: function (A, e) {
              var t = [],
                r = [];
              return (
                e.forEach(function (A) {
                  switch (A.type) {
                    case 20:
                    case 0:
                      t.push(A.value);
                      break;
                    case 17:
                      t.push(A.number.toString());
                      break;
                    case 4:
                      r.push(t.join(" ")), (t.length = 0);
                  }
                }),
                t.length && r.push(t.join(" ")),
                r.map(function (A) {
                  return -1 === A.indexOf(" ") ? A : "'" + A + "'";
                })
              );
            },
          },
          zt = {
            name: "font-size",
            initialValue: "0",
            prefix: !1,
            type: 3,
            format: "length",
          },
          $t = {
            name: "font-weight",
            initialValue: "normal",
            type: 0,
            prefix: !1,
            parse: function (A, e) {
              return ZA(e)
                ? e.number
                : !_A(e) || "bold" !== e.value
                ? 400
                : 700;
            },
          },
          Ar = {
            name: "font-variant",
            initialValue: "none",
            type: 1,
            prefix: !1,
            parse: function (A, e) {
              return e.filter(_A).map(function (A) {
                return A.value;
              });
            },
          },
          er = {
            name: "font-style",
            initialValue: "normal",
            prefix: !1,
            type: 2,
            parse: function (A, e) {
              switch (e) {
                case "oblique":
                  return "oblique";
                case "italic":
                  return "italic";
                default:
                  return "normal";
              }
            },
          },
          tr = {
            name: "content",
            initialValue: "none",
            type: 1,
            prefix: !1,
            parse: function (A, e) {
              if (0 === e.length) return [];
              var t = e[0];
              return 20 === t.type && "none" === t.value ? [] : e;
            },
          },
          rr = {
            name: "counter-increment",
            initialValue: "none",
            prefix: !0,
            type: 1,
            parse: function (A, e) {
              if (0 === e.length) return null;
              var t = e[0];
              if (20 === t.type && "none" === t.value) return null;
              for (var r = [], B = e.filter(zA), n = 0; n < B.length; n++) {
                var s = B[n],
                  o = B[n + 1];
                20 === s.type &&
                  ((o = o && ZA(o) ? o.number : 1),
                  r.push({ counter: s.value, increment: o }));
              }
              return r;
            },
          },
          Br = {
            name: "counter-reset",
            initialValue: "none",
            prefix: !0,
            type: 1,
            parse: function (A, e) {
              if (0 === e.length) return [];
              for (var t = [], r = e.filter(zA), B = 0; B < r.length; B++) {
                var n = r[B],
                  s = r[B + 1];
                _A(n) &&
                  "none" !== n.value &&
                  ((s = s && ZA(s) ? s.number : 0),
                  t.push({ counter: n.value, reset: s }));
              }
              return t;
            },
          },
          nr = {
            name: "duration",
            initialValue: "0s",
            prefix: !1,
            type: 1,
            parse: function (e, A) {
              return A.filter(WA).map(function (A) {
                return Wt(e, A);
              });
            },
          },
          sr = {
            name: "quotes",
            initialValue: "none",
            prefix: !0,
            type: 1,
            parse: function (A, e) {
              if (0 === e.length) return null;
              var t = e[0];
              if (20 === t.type && "none" === t.value) return null;
              var r = [],
                B = e.filter(qA);
              if (B.length % 2 != 0) return null;
              for (var n = 0; n < B.length; n += 2) {
                var s = B[n].value,
                  o = B[n + 1].value;
                r.push({ open: s, close: o });
              }
              return r;
            },
          },
          or = {
            name: "box-shadow",
            initialValue: "none",
            type: 1,
            prefix: !1,
            parse: function (n, A) {
              return 1 === A.length && jA(A[0], "none")
                ? []
                : Ae(A).map(function (A) {
                    for (
                      var e = {
                          color: 255,
                          offsetX: ae,
                          offsetY: ae,
                          blur: ae,
                          spread: ae,
                          inset: !1,
                        },
                        t = 0,
                        r = 0;
                      r < A.length;
                      r++
                    ) {
                      var B = A[r];
                      jA(B, "inset")
                        ? (e.inset = !0)
                        : ee(B)
                        ? (0 === t
                            ? (e.offsetX = B)
                            : 1 === t
                            ? (e.offsetY = B)
                            : 2 === t
                            ? (e.blur = B)
                            : (e.spread = B),
                          t++)
                        : (e.color = ue(n, B));
                    }
                    return e;
                  });
            },
          },
          ir = {
            name: "paint-order",
            initialValue: "normal",
            prefix: !1,
            type: 1,
            parse: function (A, e) {
              var t = [];
              return (
                e.filter(_A).forEach(function (A) {
                  switch (A.value) {
                    case "stroke":
                      t.push(1);
                      break;
                    case "fill":
                      t.push(0);
                      break;
                    case "markers":
                      t.push(2);
                  }
                }),
                [0, 1, 2].forEach(function (A) {
                  -1 === t.indexOf(A) && t.push(A);
                }),
                t
              );
            },
          },
          Qr = {
            name: "-webkit-text-stroke-color",
            initialValue: "currentcolor",
            prefix: !1,
            type: 3,
            format: "color",
          },
          cr = {
            name: "-webkit-text-stroke-width",
            initialValue: "0",
            type: 0,
            prefix: !1,
            parse: function (A, e) {
              return WA(e) ? e.number : 0;
            },
          },
          ar =
            ((gr.prototype.isVisible = function () {
              return (
                0 < this.display && 0 < this.opacity && 0 === this.visibility
              );
            }),
            (gr.prototype.isTransparent = function () {
              return oe(this.backgroundColor);
            }),
            (gr.prototype.isTransformed = function () {
              return null !== this.transform;
            }),
            (gr.prototype.isPositioned = function () {
              return 0 !== this.position;
            }),
            (gr.prototype.isPositionedWithZIndex = function () {
              return this.isPositioned() && !this.zIndex.auto;
            }),
            (gr.prototype.isFloating = function () {
              return 0 !== this.float;
            }),
            (gr.prototype.isInlineLevel = function () {
              return (
                Pt(this.display, 4) ||
                Pt(this.display, 33554432) ||
                Pt(this.display, 268435456) ||
                Pt(this.display, 536870912) ||
                Pt(this.display, 67108864) ||
                Pt(this.display, 134217728)
              );
            }),
            gr);
        function gr(A, e) {
          (this.animationDuration = lr(A, nr, e.animationDuration)),
            (this.backgroundClip = lr(A, be, e.backgroundClip)),
            (this.backgroundColor = lr(A, De, e.backgroundColor)),
            (this.backgroundImage = lr(A, Re, e.backgroundImage)),
            (this.backgroundOrigin = lr(A, Ne, e.backgroundOrigin)),
            (this.backgroundPosition = lr(A, Pe, e.backgroundPosition)),
            (this.backgroundRepeat = lr(A, Xe, e.backgroundRepeat)),
            (this.backgroundSize = lr(A, _e, e.backgroundSize)),
            (this.borderTopColor = lr(A, je, e.borderTopColor)),
            (this.borderRightColor = lr(A, ze, e.borderRightColor)),
            (this.borderBottomColor = lr(A, $e, e.borderBottomColor)),
            (this.borderLeftColor = lr(A, At, e.borderLeftColor)),
            (this.borderTopLeftRadius = lr(A, et, e.borderTopLeftRadius)),
            (this.borderTopRightRadius = lr(A, tt, e.borderTopRightRadius)),
            (this.borderBottomRightRadius = lr(
              A,
              rt,
              e.borderBottomRightRadius
            )),
            (this.borderBottomLeftRadius = lr(A, Bt, e.borderBottomLeftRadius)),
            (this.borderTopStyle = lr(A, nt, e.borderTopStyle)),
            (this.borderRightStyle = lr(A, st, e.borderRightStyle)),
            (this.borderBottomStyle = lr(A, ot, e.borderBottomStyle)),
            (this.borderLeftStyle = lr(A, it, e.borderLeftStyle)),
            (this.borderTopWidth = lr(A, Qt, e.borderTopWidth)),
            (this.borderRightWidth = lr(A, ct, e.borderRightWidth)),
            (this.borderBottomWidth = lr(A, at, e.borderBottomWidth)),
            (this.borderLeftWidth = lr(A, gt, e.borderLeftWidth)),
            (this.boxShadow = lr(A, or, e.boxShadow)),
            (this.color = lr(A, wt, e.color)),
            (this.direction = lr(A, Ut, e.direction)),
            (this.display = lr(A, lt, e.display)),
            (this.float = lr(A, ut, e.cssFloat)),
            (this.fontFamily = lr(A, jt, e.fontFamily)),
            (this.fontSize = lr(A, zt, e.fontSize)),
            (this.fontStyle = lr(A, er, e.fontStyle)),
            (this.fontVariant = lr(A, Ar, e.fontVariant)),
            (this.fontWeight = lr(A, $t, e.fontWeight)),
            (this.letterSpacing = lr(A, Ft, e.letterSpacing)),
            (this.lineBreak = lr(A, ht, e.lineBreak)),
            (this.lineHeight = lr(A, dt, e.lineHeight)),
            (this.listStyleImage = lr(A, ft, e.listStyleImage)),
            (this.listStylePosition = lr(A, Ht, e.listStylePosition)),
            (this.listStyleType = lr(A, pt, e.listStyleType)),
            (this.marginTop = lr(A, Et, e.marginTop)),
            (this.marginRight = lr(A, It, e.marginRight)),
            (this.marginBottom = lr(A, yt, e.marginBottom)),
            (this.marginLeft = lr(A, Kt, e.marginLeft)),
            (this.opacity = lr(A, Zt, e.opacity));
          var t = lr(A, mt, e.overflow);
          (this.overflowX = t[0]),
            (this.overflowY = t[1 < t.length ? 1 : 0]),
            (this.overflowWrap = lr(A, Lt, e.overflowWrap)),
            (this.paddingTop = lr(A, bt, e.paddingTop)),
            (this.paddingRight = lr(A, Dt, e.paddingRight)),
            (this.paddingBottom = lr(A, vt, e.paddingBottom)),
            (this.paddingLeft = lr(A, xt, e.paddingLeft)),
            (this.paintOrder = lr(A, ir, e.paintOrder)),
            (this.position = lr(A, St, e.position)),
            (this.textAlign = lr(A, Mt, e.textAlign)),
            (this.textDecorationColor = lr(
              A,
              _t,
              null !== (t = e.textDecorationColor) && void 0 !== t ? t : e.color
            )),
            (this.textDecorationLine = lr(
              A,
              qt,
              null !== (t = e.textDecorationLine) && void 0 !== t
                ? t
                : e.textDecoration
            )),
            (this.textShadow = lr(A, Tt, e.textShadow)),
            (this.textTransform = lr(A, Gt, e.textTransform)),
            (this.transform = lr(A, Ot, e.transform)),
            (this.transformOrigin = lr(A, Rt, e.transformOrigin)),
            (this.visibility = lr(A, Nt, e.visibility)),
            (this.webkitTextStrokeColor = lr(A, Qr, e.webkitTextStrokeColor)),
            (this.webkitTextStrokeWidth = lr(A, cr, e.webkitTextStrokeWidth)),
            (this.wordBreak = lr(A, Jt, e.wordBreak)),
            (this.zIndex = lr(A, Yt, e.zIndex));
        }
        for (
          var wr = function (A, e) {
              (this.content = lr(A, tr, e.content)),
                (this.quotes = lr(A, sr, e.quotes));
            },
            Ur = function (A, e) {
              (this.counterIncrement = lr(A, rr, e.counterIncrement)),
                (this.counterReset = lr(A, Br, e.counterReset));
            },
            lr = function (A, e, t) {
              var r = new PA(),
                t = null != t ? t.toString() : e.initialValue;
              r.write(t);
              var B = new JA(r.read());
              switch (e.type) {
                case 2:
                  var n = B.parseComponentValue();
                  return e.parse(A, _A(n) ? n.value : e.initialValue);
                case 0:
                  return e.parse(A, B.parseComponentValue());
                case 1:
                  return e.parse(A, B.parseComponentValues());
                case 4:
                  return B.parseComponentValue();
                case 3:
                  switch (e.format) {
                    case "angle":
                      return le(A, B.parseComponentValue());
                    case "color":
                      return ue(A, B.parseComponentValue());
                    case "image":
                      return Oe(A, B.parseComponentValue());
                    case "length":
                      var s = B.parseComponentValue();
                      return ee(s) ? s : ae;
                    case "length-percentage":
                      s = B.parseComponentValue();
                      return te(s) ? s : ae;
                    case "time":
                      return Wt(A, B.parseComponentValue());
                  }
              }
            },
            Cr = function (A, e) {
              A = (function (A) {
                switch (A.getAttribute("data-html2canvas-debug")) {
                  case "all":
                    return 1;
                  case "clone":
                    return 2;
                  case "parse":
                    return 3;
                  case "render":
                    return 4;
                  default:
                    return 0;
                }
              })(A);
              return 1 === A || e === A;
            },
            ur = function (A, e) {
              (this.context = A),
                (this.textNodes = []),
                (this.elements = []),
                (this.flags = 0),
                Cr(e, 3),
                (this.styles = new ar(A, window.getComputedStyle(e, null))),
                JB(e) &&
                  (this.styles.animationDuration.some(function (A) {
                    return 0 < A;
                  }) && (e.style.animationDuration = "0s"),
                  null !== this.styles.transform &&
                    (e.style.transform = "none")),
                (this.bounds = f(this.context, e)),
                Cr(e, 4) && (this.flags |= 16);
            },
            Fr =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            hr = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256),
            dr = 0;
          dr < Fr.length;
          dr++
        )
          hr[Fr.charCodeAt(dr)] = dr;
        function fr(A, e, t) {
          return A.slice
            ? A.slice(e, t)
            : new Uint16Array(Array.prototype.slice.call(A, e, t));
        }
        var Hr =
          ((pr.prototype.get = function (A) {
            var e;
            if (0 <= A) {
              if (A < 55296 || (56319 < A && A <= 65535))
                return (
                  (e = this.index[A >> 5]), this.data[(e = (e << 2) + (31 & A))]
                );
              if (A <= 65535)
                return (
                  (e = this.index[2048 + ((A - 55296) >> 5)]),
                  this.data[(e = (e << 2) + (31 & A))]
                );
              if (A < this.highStart)
                return (
                  (e = this.index[(e = 2080 + (A >> 11))]),
                  (e = this.index[(e += (A >> 5) & 63)]),
                  this.data[(e = (e << 2) + (31 & A))]
                );
              if (A <= 1114111) return this.data[this.highValueIndex];
            }
            return this.errorValue;
          }),
          pr);
        function pr(A, e, t, r, B, n) {
          (this.initialValue = A),
            (this.errorValue = e),
            (this.highStart = t),
            (this.highValueIndex = r),
            (this.index = B),
            (this.data = n);
        }
        for (
          var Er =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            Ir = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256),
            yr = 0;
          yr < Er.length;
          yr++
        )
          Ir[Er.charCodeAt(yr)] = yr;
        function Kr(A) {
          return kr.get(A);
        }
        function mr(A) {
          var t = (function (A) {
              for (var e = [], t = 0, r = A.length; t < r; ) {
                var B,
                  n = A.charCodeAt(t++);
                55296 <= n && n <= 56319 && t < r
                  ? 56320 == (64512 & (B = A.charCodeAt(t++)))
                    ? e.push(((1023 & n) << 10) + (1023 & B) + 65536)
                    : (e.push(n), t--)
                  : e.push(n);
              }
              return e;
            })(A),
            r = t.length,
            B = 0,
            n = 0,
            s = t.map(Kr);
          return {
            next: function () {
              if (r <= B) return { done: !0, value: null };
              for (
                var A = Rr;
                B < r &&
                (A = (function (A, e) {
                  var t = e - 2,
                    r = A[t],
                    B = A[e - 1],
                    e = A[e];
                  if (2 === B && 3 === e) return Rr;
                  if (2 === B || 3 === B || 4 === B) return "";
                  if (2 === e || 3 === e || 4 === e) return "";
                  if (B === Tr && -1 !== [Tr, Gr, Or, Vr].indexOf(e)) return Rr;
                  if (!((B !== Or && B !== Gr) || (e !== Gr && 10 !== e)))
                    return Rr;
                  if ((B === Vr || 10 === B) && 10 === e) return Rr;
                  if (13 === e || 5 === e) return Rr;
                  if (7 === e) return Rr;
                  if (1 === B) return Rr;
                  if (13 === B && 14 === e) {
                    for (; 5 === r; ) r = A[--t];
                    if (14 === r) return Rr;
                  }
                  if (15 === B && 15 === e) {
                    for (var n = 0; 15 === r; ) n++, (r = A[--t]);
                    if (n % 2 == 0) return Rr;
                  }
                  return "";
                })(s, ++B)) === Rr;

              );
              if (A === Rr && B !== r) return { done: !0, value: null };
              var e = function () {
                for (var A = [], e = 0; e < arguments.length; e++)
                  A[e] = arguments[e];
                if (String.fromCodePoint)
                  return String.fromCodePoint.apply(String, A);
                var t = A.length;
                if (!t) return "";
                for (var r = [], B = -1, n = ""; ++B < t; ) {
                  var s = A[B];
                  s <= 65535
                    ? r.push(s)
                    : ((s -= 65536),
                      r.push(55296 + (s >> 10), (s % 1024) + 56320)),
                    (B + 1 === t || 16384 < r.length) &&
                      ((n += String.fromCharCode.apply(String, r)),
                      (r.length = 0));
                }
                return n;
              }.apply(null, t.slice(n, B));
              return (n = B), { value: e, done: !1 };
            },
          };
        }
        function Lr(A) {
          return 0 === A[0] && 255 === A[1] && 0 === A[2] && 255 === A[3];
        }
        var br,
          Dr,
          vr,
          xr,
          Mr,
          Sr,
          Tr = 8,
          Gr = 9,
          Or = 11,
          Vr = 12,
          kr =
            ((vr = (function (A) {
              var e,
                t,
                r,
                B,
                n = 0.75 * A.length,
                s = A.length,
                o = 0;
              "=" === A[A.length - 1] && (n--, "=" === A[A.length - 2] && n--);
              for (
                var n = new (
                    "undefined" != typeof ArrayBuffer &&
                    "undefined" != typeof Uint8Array &&
                    void 0 !== Uint8Array.prototype.slice
                      ? ArrayBuffer
                      : Array
                  )(n),
                  i = Array.isArray(n) ? n : new Uint8Array(n),
                  Q = 0;
                Q < s;
                Q += 4
              )
                (e = hr[A.charCodeAt(Q)]),
                  (t = hr[A.charCodeAt(Q + 1)]),
                  (r = hr[A.charCodeAt(Q + 2)]),
                  (B = hr[A.charCodeAt(Q + 3)]),
                  (i[o++] = (e << 2) | (t >> 4)),
                  (i[o++] = ((15 & t) << 4) | (r >> 2)),
                  (i[o++] = ((3 & r) << 6) | (63 & B));
              return n;
            })(
              (br =
                "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=")
            )),
            (xr = Array.isArray(vr)
              ? (function (A) {
                  for (var e = A.length, t = [], r = 0; r < e; r += 4)
                    t.push(
                      (A[r + 3] << 24) |
                        (A[r + 2] << 16) |
                        (A[r + 1] << 8) |
                        A[r]
                    );
                  return t;
                })(vr)
              : new Uint32Array(vr)),
            (Mr = Array.isArray(vr)
              ? (function (A) {
                  for (var e = A.length, t = [], r = 0; r < e; r += 2)
                    t.push((A[r + 1] << 8) | A[r]);
                  return t;
                })(vr)
              : new Uint16Array(vr)),
            (br = fr(Mr, 12, xr[4] / 2)),
            (Dr =
              2 === xr[5]
                ? fr(Mr, (24 + xr[4]) / 2)
                : ((vr = xr),
                  (Mr = Math.ceil((24 + xr[4]) / 4)),
                  vr.slice
                    ? vr.slice(Mr, Dr)
                    : new Uint32Array(Array.prototype.slice.call(vr, Mr, Dr)))),
            new Hr(xr[0], xr[1], xr[2], xr[3], br, Dr)),
          Rr = "",
          Nr = function (A, e, t, r, B) {
            var n = "http://www.w3.org/2000/svg",
              s = document.createElementNS(n, "svg"),
              n = document.createElementNS(n, "foreignObject");
            return (
              s.setAttributeNS(null, "width", A.toString()),
              s.setAttributeNS(null, "height", e.toString()),
              n.setAttributeNS(null, "width", "100%"),
              n.setAttributeNS(null, "height", "100%"),
              n.setAttributeNS(null, "x", t.toString()),
              n.setAttributeNS(null, "y", r.toString()),
              n.setAttributeNS(null, "externalResourcesRequired", "true"),
              s.appendChild(n),
              n.appendChild(B),
              s
            );
          },
          Pr = function (r) {
            return new Promise(function (A, e) {
              var t = new Image();
              (t.onload = function () {
                return A(t);
              }),
                (t.onerror = e),
                (t.src =
                  "data:image/svg+xml;charset=utf-8," +
                  encodeURIComponent(new XMLSerializer().serializeToString(r)));
            });
          },
          Xr = {
            get SUPPORT_RANGE_BOUNDS() {
              var A = (function (A) {
                if (A.createRange) {
                  var e = A.createRange();
                  if (e.getBoundingClientRect) {
                    var t = A.createElement("boundtest");
                    (t.style.height = "123px"),
                      (t.style.display = "block"),
                      A.body.appendChild(t),
                      e.selectNode(t);
                    (e = e.getBoundingClientRect()), (e = Math.round(e.height));
                    if ((A.body.removeChild(t), 123 === e)) return !0;
                  }
                }
                return !1;
              })(document);
              return (
                Object.defineProperty(Xr, "SUPPORT_RANGE_BOUNDS", { value: A }),
                A
              );
            },
            get SUPPORT_WORD_BREAKING() {
              var A =
                Xr.SUPPORT_RANGE_BOUNDS &&
                (function (A) {
                  var e = A.createElement("boundtest");
                  (e.style.width = "50px"),
                    (e.style.display = "block"),
                    (e.style.fontSize = "12px"),
                    (e.style.letterSpacing = "0px"),
                    (e.style.wordSpacing = "0px"),
                    A.body.appendChild(e);
                  var r = A.createRange();
                  e.innerHTML =
                    "function" == typeof "".repeat
                      ? "&#128104;".repeat(10)
                      : "";
                  var B = e.firstChild,
                    t = Q(B.data).map(function (A) {
                      return g(A);
                    }),
                    n = 0,
                    s = {},
                    t = t.every(function (A, e) {
                      r.setStart(B, n), r.setEnd(B, n + A.length);
                      var t = r.getBoundingClientRect();
                      n += A.length;
                      A = t.x > s.x || t.y > s.y;
                      return (s = t), 0 === e || A;
                    });
                  return A.body.removeChild(e), t;
                })(document);
              return (
                Object.defineProperty(Xr, "SUPPORT_WORD_BREAKING", {
                  value: A,
                }),
                A
              );
            },
            get SUPPORT_SVG_DRAWING() {
              var A = (function (A) {
                var e = new Image(),
                  t = A.createElement("canvas"),
                  A = t.getContext("2d");
                if (!A) return !1;
                e.src =
                  "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
                try {
                  A.drawImage(e, 0, 0), t.toDataURL();
                } catch (A) {
                  return !1;
                }
                return !0;
              })(document);
              return (
                Object.defineProperty(Xr, "SUPPORT_SVG_DRAWING", { value: A }),
                A
              );
            },
            get SUPPORT_FOREIGNOBJECT_DRAWING() {
              var A =
                "function" == typeof Array.from &&
                "function" == typeof window.fetch
                  ? (function (t) {
                      var A = t.createElement("canvas"),
                        r = 100;
                      (A.width = r), (A.height = r);
                      var B = A.getContext("2d");
                      if (!B) return Promise.reject(!1);
                      (B.fillStyle = "rgb(0, 255, 0)"), B.fillRect(0, 0, r, r);
                      var e = new Image(),
                        n = A.toDataURL();
                      e.src = n;
                      e = Nr(r, r, 0, 0, e);
                      return (
                        (B.fillStyle = "red"),
                        B.fillRect(0, 0, r, r),
                        Pr(e)
                          .then(function (A) {
                            B.drawImage(A, 0, 0);
                            var e = B.getImageData(0, 0, r, r).data;
                            (B.fillStyle = "red"), B.fillRect(0, 0, r, r);
                            A = t.createElement("div");
                            return (
                              (A.style.backgroundImage = "url(" + n + ")"),
                              (A.style.height = "100px"),
                              Lr(e) ? Pr(Nr(r, r, 0, 0, A)) : Promise.reject(!1)
                            );
                          })
                          .then(function (A) {
                            return (
                              B.drawImage(A, 0, 0),
                              Lr(B.getImageData(0, 0, r, r).data)
                            );
                          })
                          .catch(function () {
                            return !1;
                          })
                      );
                    })(document)
                  : Promise.resolve(!1);
              return (
                Object.defineProperty(Xr, "SUPPORT_FOREIGNOBJECT_DRAWING", {
                  value: A,
                }),
                A
              );
            },
            get SUPPORT_CORS_IMAGES() {
              var A = void 0 !== new Image().crossOrigin;
              return (
                Object.defineProperty(Xr, "SUPPORT_CORS_IMAGES", { value: A }),
                A
              );
            },
            get SUPPORT_RESPONSE_TYPE() {
              var A = "string" == typeof new XMLHttpRequest().responseType;
              return (
                Object.defineProperty(Xr, "SUPPORT_RESPONSE_TYPE", {
                  value: A,
                }),
                A
              );
            },
            get SUPPORT_CORS_XHR() {
              var A = "withCredentials" in new XMLHttpRequest();
              return (
                Object.defineProperty(Xr, "SUPPORT_CORS_XHR", { value: A }), A
              );
            },
            get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
              var A = !("undefined" == typeof Intl || !Intl.Segmenter);
              return (
                Object.defineProperty(Xr, "SUPPORT_NATIVE_TEXT_SEGMENTATION", {
                  value: A,
                }),
                A
              );
            },
          },
          Jr = function (A, e) {
            (this.text = A), (this.bounds = e);
          },
          Yr = function (A, e) {
            var t = e.ownerDocument;
            if (t) {
              var r = t.createElement("html2canvaswrapper");
              r.appendChild(e.cloneNode(!0));
              t = e.parentNode;
              if (t) {
                t.replaceChild(r, e);
                A = f(A, r);
                return r.firstChild && t.replaceChild(r.firstChild, r), A;
              }
            }
            return d.EMPTY;
          },
          Wr = function (A, e, t) {
            var r = A.ownerDocument;
            if (!r) throw new Error("Node has no owner document");
            r = r.createRange();
            return r.setStart(A, e), r.setEnd(A, e + t), r;
          },
          Zr = function (A) {
            if (Xr.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
              var e = new Intl.Segmenter(void 0, { granularity: "grapheme" });
              return Array.from(e.segment(A)).map(function (A) {
                return A.segment;
              });
            }
            return (function (A) {
              for (var e, t = mr(A), r = []; !(e = t.next()).done; )
                e.value && r.push(e.value.slice());
              return r;
            })(A);
          },
          _r = function (A, e) {
            return 0 !== e.letterSpacing
              ? Zr(A)
              : (function (A, e) {
                  if (Xr.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
                    var t = new Intl.Segmenter(void 0, { granularity: "word" });
                    return Array.from(t.segment(A)).map(function (A) {
                      return A.segment;
                    });
                  }
                  return jr(A, e);
                })(A, e);
          },
          qr = [32, 160, 4961, 65792, 65793, 4153, 4241],
          jr = function (A, e) {
            for (
              var t,
                r = wA(A, {
                  lineBreak: e.lineBreak,
                  wordBreak:
                    "break-word" === e.overflowWrap
                      ? "break-word"
                      : e.wordBreak,
                }),
                B = [];
              !(t = r.next()).done;

            )
              !(function () {
                var A, e;
                t.value &&
                  ((A = t.value.slice()),
                  (A = Q(A)),
                  (e = ""),
                  A.forEach(function (A) {
                    -1 === qr.indexOf(A)
                      ? (e += g(A))
                      : (e.length && B.push(e), B.push(g(A)), (e = ""));
                  }),
                  e.length && B.push(e));
              })();
            return B;
          },
          zr = function (A, e, t) {
            var B, n, s, o, i;
            (this.text = $r(e.data, t.textTransform)),
              (this.textBounds =
                ((B = A),
                (A = this.text),
                (s = e),
                (A = _r(A, (n = t))),
                (o = []),
                (i = 0),
                A.forEach(function (A) {
                  var e, t, r;
                  n.textDecorationLine.length || 0 < A.trim().length
                    ? Xr.SUPPORT_RANGE_BOUNDS
                      ? 1 < (r = Wr(s, i, A.length).getClientRects()).length
                        ? ((e = Zr(A)),
                          (t = 0),
                          e.forEach(function (A) {
                            o.push(
                              new Jr(
                                A,
                                d.fromDOMRectList(
                                  B,
                                  Wr(s, t + i, A.length).getClientRects()
                                )
                              )
                            ),
                              (t += A.length);
                          }))
                        : o.push(new Jr(A, d.fromDOMRectList(B, r)))
                      : ((r = s.splitText(A.length)),
                        o.push(new Jr(A, Yr(B, s))),
                        (s = r))
                    : Xr.SUPPORT_RANGE_BOUNDS || (s = s.splitText(A.length)),
                    (i += A.length);
                }),
                o));
          },
          $r = function (A, e) {
            switch (e) {
              case 1:
                return A.toLowerCase();
              case 3:
                return A.replace(AB, eB);
              case 2:
                return A.toUpperCase();
              default:
                return A;
            }
          },
          AB = /(^|\s|:|-|\(|\))([a-z])/g,
          eB = function (A, e, t) {
            return 0 < A.length ? e + t.toUpperCase() : A;
          },
          tB = (A(rB, (Sr = ur)), rB);
        function rB(A, e) {
          A = Sr.call(this, A, e) || this;
          return (
            (A.src = e.currentSrc || e.src),
            (A.intrinsicWidth = e.naturalWidth),
            (A.intrinsicHeight = e.naturalHeight),
            A.context.cache.addImage(A.src),
            A
          );
        }
        var BB,
          nB = (A(sB, (BB = ur)), sB);
        function sB(A, e) {
          A = BB.call(this, A, e) || this;
          return (
            (A.canvas = e),
            (A.intrinsicWidth = e.width),
            (A.intrinsicHeight = e.height),
            A
          );
        }
        var oB,
          iB = (A(QB, (oB = ur)), QB);
        function QB(A, e) {
          var t = oB.call(this, A, e) || this,
            r = new XMLSerializer(),
            A = f(A, e);
          return (
            e.setAttribute("width", A.width + "px"),
            e.setAttribute("height", A.height + "px"),
            (t.svg =
              "data:image/svg+xml," +
              encodeURIComponent(r.serializeToString(e))),
            (t.intrinsicWidth = e.width.baseVal.value),
            (t.intrinsicHeight = e.height.baseVal.value),
            t.context.cache.addImage(t.svg),
            t
          );
        }
        var cB,
          aB = (A(gB, (cB = ur)), gB);
        function gB(A, e) {
          A = cB.call(this, A, e) || this;
          return (A.value = e.value), A;
        }
        var wB,
          UB = (A(lB, (wB = ur)), lB);
        function lB(A, e) {
          A = wB.call(this, A, e) || this;
          return (
            (A.start = e.start),
            (A.reversed = "boolean" == typeof e.reversed && !0 === e.reversed),
            A
          );
        }
        var CB,
          uB = [{ type: 15, flags: 0, unit: "px", number: 3 }],
          FB = [{ type: 16, flags: 0, number: 50 }],
          hB = "checkbox",
          dB = "radio",
          fB = "password",
          HB = 707406591,
          pB = (A(EB, (CB = ur)), EB);
        function EB(A, e) {
          var t = CB.call(this, A, e) || this;
          switch (
            ((t.type = e.type.toLowerCase()),
            (t.checked = e.checked),
            (t.value =
              0 ===
              (e =
                (A = e).type === fB
                  ? new Array(A.value.length + 1).join("")
                  : A.value).length
                ? A.placeholder || ""
                : e),
            (t.type !== hB && t.type !== dB) ||
              ((t.styles.backgroundColor = 3739148031),
              (t.styles.borderTopColor =
                t.styles.borderRightColor =
                t.styles.borderBottomColor =
                t.styles.borderLeftColor =
                  2779096575),
              (t.styles.borderTopWidth =
                t.styles.borderRightWidth =
                t.styles.borderBottomWidth =
                t.styles.borderLeftWidth =
                  1),
              (t.styles.borderTopStyle =
                t.styles.borderRightStyle =
                t.styles.borderBottomStyle =
                t.styles.borderLeftStyle =
                  1),
              (t.styles.backgroundClip = [0]),
              (t.styles.backgroundOrigin = [0]),
              (t.bounds =
                (e = t.bounds).width > e.height
                  ? new d(
                      e.left + (e.width - e.height) / 2,
                      e.top,
                      e.height,
                      e.height
                    )
                  : e.width < e.height
                  ? new d(
                      e.left,
                      e.top + (e.height - e.width) / 2,
                      e.width,
                      e.width
                    )
                  : e)),
            t.type)
          ) {
            case hB:
              t.styles.borderTopRightRadius =
                t.styles.borderTopLeftRadius =
                t.styles.borderBottomRightRadius =
                t.styles.borderBottomLeftRadius =
                  uB;
              break;
            case dB:
              t.styles.borderTopRightRadius =
                t.styles.borderTopLeftRadius =
                t.styles.borderBottomRightRadius =
                t.styles.borderBottomLeftRadius =
                  FB;
          }
          return t;
        }
        var IB,
          yB = (A(KB, (IB = ur)), KB);
        function KB(A, e) {
          (A = IB.call(this, A, e) || this),
            (e = e.options[e.selectedIndex || 0]);
          return (A.value = (e && e.text) || ""), A;
        }
        var mB,
          LB = (A(bB, (mB = ur)), bB);
        function bB(A, e) {
          A = mB.call(this, A, e) || this;
          return (A.value = e.value), A;
        }
        var DB,
          vB = (A(xB, (DB = ur)), xB);
        function xB(A, e) {
          var t,
            r,
            B = DB.call(this, A, e) || this;
          (B.src = e.src),
            (B.width = parseInt(e.width, 10) || 0),
            (B.height = parseInt(e.height, 10) || 0),
            (B.backgroundColor = B.styles.backgroundColor);
          try {
            e.contentWindow &&
              e.contentWindow.document &&
              e.contentWindow.document.documentElement &&
              ((B.tree = kB(A, e.contentWindow.document.documentElement)),
              (t = e.contentWindow.document.documentElement
                ? fe(
                    A,
                    getComputedStyle(e.contentWindow.document.documentElement)
                      .backgroundColor
                  )
                : Le.TRANSPARENT),
              (r = e.contentWindow.document.body
                ? fe(
                    A,
                    getComputedStyle(e.contentWindow.document.body)
                      .backgroundColor
                  )
                : Le.TRANSPARENT),
              (B.backgroundColor = oe(t)
                ? oe(r)
                  ? B.styles.backgroundColor
                  : r
                : t));
          } catch (A) {}
          return B;
        }
        function MB(A) {
          return "VIDEO" === A.tagName;
        }
        function SB(A) {
          return "STYLE" === A.tagName;
        }
        function TB(A) {
          return 0 < A.tagName.indexOf("-");
        }
        var GB = ["OL", "UL", "MENU"],
          OB = function (e, A, t, r) {
            for (var B = A.firstChild; B; B = s) {
              var n,
                s = B.nextSibling;
              PB(B) && 0 < B.data.trim().length
                ? t.textNodes.push(new zr(e, B, t.styles))
                : XB(B) &&
                  (rn(B) && B.assignedNodes
                    ? B.assignedNodes().forEach(function (A) {
                        return OB(e, A, t, r);
                      })
                    : (n = VB(e, B)).styles.isVisible() &&
                      (RB(B, n, r)
                        ? (n.flags |= 4)
                        : NB(n.styles) && (n.flags |= 2),
                      -1 !== GB.indexOf(B.tagName) && (n.flags |= 8),
                      t.elements.push(n),
                      B.slot,
                      B.shadowRoot
                        ? OB(e, B.shadowRoot, n, r)
                        : en(B) || qB(B) || tn(B) || OB(e, B, n, r)));
            }
          },
          VB = function (A, e) {
            return new (
              $B(e)
                ? tB
                : zB(e)
                ? nB
                : qB(e)
                ? iB
                : WB(e)
                ? aB
                : ZB(e)
                ? UB
                : _B(e)
                ? pB
                : tn(e)
                ? yB
                : en(e)
                ? LB
                : An(e)
                ? vB
                : ur
            )(A, e);
          },
          kB = function (A, e) {
            var t = VB(A, e);
            return (t.flags |= 4), OB(A, e, t, t), t;
          },
          RB = function (A, e, t) {
            return (
              e.styles.isPositionedWithZIndex() ||
              e.styles.opacity < 1 ||
              e.styles.isTransformed() ||
              (jB(A) && t.styles.isTransparent())
            );
          },
          NB = function (A) {
            return A.isPositioned() || A.isFloating();
          },
          PB = function (A) {
            return A.nodeType === Node.TEXT_NODE;
          },
          XB = function (A) {
            return A.nodeType === Node.ELEMENT_NODE;
          },
          JB = function (A) {
            return XB(A) && void 0 !== A.style && !YB(A);
          },
          YB = function (A) {
            return "object" == typeof A.className;
          },
          WB = function (A) {
            return "LI" === A.tagName;
          },
          ZB = function (A) {
            return "OL" === A.tagName;
          },
          _B = function (A) {
            return "INPUT" === A.tagName;
          },
          qB = function (A) {
            return "svg" === A.tagName;
          },
          jB = function (A) {
            return "BODY" === A.tagName;
          },
          zB = function (A) {
            return "CANVAS" === A.tagName;
          },
          $B = function (A) {
            return "IMG" === A.tagName;
          },
          An = function (A) {
            return "IFRAME" === A.tagName;
          },
          en = function (A) {
            return "TEXTAREA" === A.tagName;
          },
          tn = function (A) {
            return "SELECT" === A.tagName;
          },
          rn = function (A) {
            return "SLOT" === A.tagName;
          },
          Bn =
            ((nn.prototype.getCounterValue = function (A) {
              A = this.counters[A];
              return A && A.length ? A[A.length - 1] : 1;
            }),
            (nn.prototype.getCounterValues = function (A) {
              A = this.counters[A];
              return A || [];
            }),
            (nn.prototype.pop = function (A) {
              var e = this;
              A.forEach(function (A) {
                return e.counters[A].pop();
              });
            }),
            (nn.prototype.parse = function (A) {
              var t = this,
                e = A.counterIncrement,
                A = A.counterReset,
                r = !0;
              null !== e &&
                e.forEach(function (A) {
                  var e = t.counters[A.counter];
                  e &&
                    0 !== A.increment &&
                    ((r = !1),
                    e.length || e.push(1),
                    (e[Math.max(0, e.length - 1)] += A.increment));
                });
              var B = [];
              return (
                r &&
                  A.forEach(function (A) {
                    var e = t.counters[A.counter];
                    B.push(A.counter),
                      (e = e || (t.counters[A.counter] = [])).push(A.reset);
                  }),
                B
              );
            }),
            nn);
        function nn() {
          this.counters = {};
        }
        function sn(r, A, e, B, t, n) {
          return r < A || e < r
            ? Fn(r, t, 0 < n.length)
            : B.integers.reduce(function (A, e, t) {
                for (; e <= r; ) (r -= e), (A += B.values[t]);
                return A;
              }, "") + n;
        }
        function on(A, e, t, r) {
          for (var B = ""; t || A--, (B = r(A) + B), e <= (A /= e) * e; );
          return B;
        }
        function Qn(A, e, t, r, B) {
          var n = t - e + 1;
          return (
            (A < 0 ? "-" : "") +
            (on(Math.abs(A), n, r, function (A) {
              return g(Math.floor(A % n) + e);
            }) +
              B)
          );
        }
        function cn(A, e, t) {
          void 0 === t && (t = ". ");
          var r = e.length;
          return (
            on(Math.abs(A), r, !1, function (A) {
              return e[Math.floor(A % r)];
            }) + t
          );
        }
        function an(A, e, t, r, B, n) {
          if (A < -9999 || 9999 < A) return Fn(A, 4, 0 < B.length);
          var s = Math.abs(A),
            o = B;
          if (0 === s) return e[0] + o;
          for (var i = 0; 0 < s && i <= 4; i++) {
            var Q = s % 10;
            0 == Q && Pt(n, 1) && "" !== o
              ? (o = e[Q] + o)
              : 1 < Q ||
                (1 == Q && 0 === i) ||
                (1 == Q && 1 === i && Pt(n, 2)) ||
                (1 == Q && 1 === i && Pt(n, 4) && 100 < A) ||
                (1 == Q && 1 < i && Pt(n, 8))
              ? (o = e[Q] + (0 < i ? t[i - 1] : "") + o)
              : 1 == Q && 0 < i && (o = t[i - 1] + o),
              (s = Math.floor(s / 10));
          }
          return (A < 0 ? r : "") + o;
        }
        var gn,
          wn = {
            integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
            values: [
              "M",
              "CM",
              "D",
              "CD",
              "C",
              "XC",
              "L",
              "XL",
              "X",
              "IX",
              "V",
              "IV",
              "I",
            ],
          },
          Un = {
            integers: [
              9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600,
              500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8,
              7, 6, 5, 4, 3, 2, 1,
            ],
            values: [
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
            ],
          },
          ln = {
            integers: [
              1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 400, 300, 200,
              100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 10, 9, 8,
              7, 6, 5, 4, 3, 2, 1,
            ],
            values: [
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
            ],
          },
          Cn = {
            integers: [
              1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700,
              600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10,
              9, 8, 7, 6, 5, 4, 3, 2, 1,
            ],
            values: [
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
            ],
          },
          un = "",
          Fn = function (A, e, t) {
            var r = t ? ". " : "",
              B = t ? "" : "",
              n = t ? ", " : "",
              s = t ? " " : "";
            switch (e) {
              case 0:
                return "" + s;
              case 1:
                return "" + s;
              case 2:
                return "" + s;
              case 5:
                var o = Qn(A, 48, 57, !0, r);
                return o.length < 4 ? "0" + o : o;
              case 4:
                return cn(A, "", B);
              case 6:
                return sn(A, 1, 3999, wn, 3, r).toLowerCase();
              case 7:
                return sn(A, 1, 3999, wn, 3, r);
              case 8:
                return Qn(A, 945, 969, !1, r);
              case 9:
                return Qn(A, 97, 122, !1, r);
              case 10:
                return Qn(A, 65, 90, !1, r);
              case 11:
                return Qn(A, 1632, 1641, !0, r);
              case 12:
              case 49:
                return sn(A, 1, 9999, Un, 3, r);
              case 35:
                return sn(A, 1, 9999, Un, 3, r).toLowerCase();
              case 13:
                return Qn(A, 2534, 2543, !0, r);
              case 14:
              case 30:
                return Qn(A, 6112, 6121, !0, r);
              case 15:
                return cn(A, "", B);
              case 16:
                return cn(A, "", B);
              case 17:
              case 48:
                return an(A, "", "", "", B, 14);
              case 47:
                return an(A, "", "", "", B, 15);
              case 42:
                return an(A, "", "", "", B, 14);
              case 41:
                return an(A, "", "", "", B, 15);
              case 26:
                return an(
                  A,
                  "",
                  "",
                  "",
                  B,
                  0
                );
              case 25:
                return an(
                  A,
                  "",
                  "",
                  "",
                  B,
                  7
                );
              case 31:
                return an(A, "", "", un, n, 7);
              case 33:
                return an(A, "", "", un, n, 0);
              case 32:
                return an(A, "", "", un, n, 7);
              case 18:
                return Qn(A, 2406, 2415, !0, r);
              case 20:
                return sn(A, 1, 19999, Cn, 3, r);
              case 21:
                return Qn(A, 2790, 2799, !0, r);
              case 22:
                return Qn(A, 2662, 2671, !0, r);
              case 22:
                return sn(A, 1, 10999, ln, 3, r);
              case 23:
                return cn(
                  A,
                  ""
                );
              case 24:
                return cn(
                  A,
                  ""
                );
              case 27:
                return Qn(A, 3302, 3311, !0, r);
              case 28:
                return cn(
                  A,
                  "",
                  B
                );
              case 29:
                return cn(
                  A,
                  "",
                  B
                );
              case 34:
                return Qn(A, 3792, 3801, !0, r);
              case 37:
                return Qn(A, 6160, 6169, !0, r);
              case 38:
                return Qn(A, 4160, 4169, !0, r);
              case 39:
                return Qn(A, 2918, 2927, !0, r);
              case 40:
                return Qn(A, 1776, 1785, !0, r);
              case 43:
                return Qn(A, 3046, 3055, !0, r);
              case 44:
                return Qn(A, 3174, 3183, !0, r);
              case 45:
                return Qn(A, 3664, 3673, !0, r);
              case 46:
                return Qn(A, 3872, 3881, !0, r);
              default:
                return Qn(A, 48, 57, !0, r);
            }
          },
          hn = "data-html2canvas-ignore",
          dn =
            ((fn.prototype.toIFrame = function (A, r) {
              var e = this,
                B = pn(A, r);
              if (!B.contentWindow)
                return Promise.reject("Unable to find iframe window");
              var t = A.defaultView.pageXOffset,
                n = A.defaultView.pageYOffset,
                s = B.contentWindow,
                o = s.document,
                A = In(B).then(function () {
                  return a(e, void 0, void 0, function () {
                    var e, t;
                    return H(this, function (A) {
                      switch (A.label) {
                        case 0:
                          return (
                            this.scrolledElements.forEach(bn),
                            s &&
                              (s.scrollTo(r.left, r.top),
                              !/(iPad|iPhone|iPod)/g.test(
                                navigator.userAgent
                              ) ||
                                (s.scrollY === r.top && s.scrollX === r.left) ||
                                (this.context.logger.warn(
                                  "Unable to restore scroll position for cloned document"
                                ),
                                (this.context.windowBounds =
                                  this.context.windowBounds.add(
                                    s.scrollX - r.left,
                                    s.scrollY - r.top,
                                    0,
                                    0
                                  )))),
                            (e = this.options.onclone),
                            void 0 === (t = this.clonedReferenceElement)
                              ? [
                                  2,
                                  Promise.reject(
                                    "Error finding the " +
                                      this.referenceElement.nodeName +
                                      " in the cloned document"
                                  ),
                                ]
                              : o.fonts && o.fonts.ready
                              ? [4, o.fonts.ready]
                              : [3, 2]
                          );
                        case 1:
                          A.sent(), (A.label = 2);
                        case 2:
                          return /(AppleWebKit)/g.test(navigator.userAgent)
                            ? [4, En(o)]
                            : [3, 4];
                        case 3:
                          A.sent(), (A.label = 4);
                        case 4:
                          return "function" == typeof e
                            ? [
                                2,
                                Promise.resolve()
                                  .then(function () {
                                    return e(o, t);
                                  })
                                  .then(function () {
                                    return B;
                                  }),
                              ]
                            : [2, B];
                      }
                    });
                  });
                });
              return (
                o.open(),
                o.write(mn(document.doctype) + "<html></html>"),
                Ln(this.referenceElement.ownerDocument, t, n),
                o.replaceChild(
                  o.adoptNode(this.documentElement),
                  o.documentElement
                ),
                o.close(),
                A
              );
            }),
            (fn.prototype.createElementClone = function (A) {
              if ((Cr(A, 2), zB(A))) return this.createCanvasClone(A);
              if (MB(A)) return this.createVideoClone(A);
              if (SB(A)) return this.createStyleClone(A);
              var e = A.cloneNode(!1);
              return (
                $B(e) &&
                  ($B(A) &&
                    A.currentSrc &&
                    A.currentSrc !== A.src &&
                    ((e.src = A.currentSrc), (e.srcset = "")),
                  "lazy" === e.loading && (e.loading = "eager")),
                TB(e) ? this.createCustomElementClone(e) : e
              );
            }),
            (fn.prototype.createCustomElementClone = function (A) {
              var e = document.createElement("html2canvascustomelement");
              return Kn(A.style, e), e;
            }),
            (fn.prototype.createStyleClone = function (A) {
              try {
                var e = A.sheet;
                if (e && e.cssRules) {
                  var t = [].slice.call(e.cssRules, 0).reduce(function (A, e) {
                      return e && "string" == typeof e.cssText
                        ? A + e.cssText
                        : A;
                    }, ""),
                    r = A.cloneNode(!1);
                  return (r.textContent = t), r;
                }
              } catch (A) {
                if (
                  (this.context.logger.error(
                    "Unable to access cssRules property",
                    A
                  ),
                  "SecurityError" !== A.name)
                )
                  throw A;
              }
              return A.cloneNode(!1);
            }),
            (fn.prototype.createCanvasClone = function (e) {
              var A;
              if (this.options.inlineImages && e.ownerDocument) {
                var t = e.ownerDocument.createElement("img");
                try {
                  return (t.src = e.toDataURL()), t;
                } catch (A) {
                  this.context.logger.info(
                    "Unable to inline canvas contents, canvas is tainted",
                    e
                  );
                }
              }
              t = e.cloneNode(!1);
              try {
                (t.width = e.width), (t.height = e.height);
                var r,
                  B,
                  n = e.getContext("2d"),
                  s = t.getContext("2d");
                return (
                  s &&
                    (!this.options.allowTaint && n
                      ? s.putImageData(
                          n.getImageData(0, 0, e.width, e.height),
                          0,
                          0
                        )
                      : (!(r =
                          null !== (A = e.getContext("webgl2")) && void 0 !== A
                            ? A
                            : e.getContext("webgl")) ||
                          (!1 ===
                            (null == (B = r.getContextAttributes())
                              ? void 0
                              : B.preserveDrawingBuffer) &&
                            this.context.logger.warn(
                              "Unable to clone WebGL context as it has preserveDrawingBuffer=false",
                              e
                            )),
                        s.drawImage(e, 0, 0))),
                  t
                );
              } catch (A) {
                this.context.logger.info(
                  "Unable to clone canvas as it is tainted",
                  e
                );
              }
              return t;
            }),
            (fn.prototype.createVideoClone = function (e) {
              var A = e.ownerDocument.createElement("canvas");
              (A.width = e.offsetWidth), (A.height = e.offsetHeight);
              var t = A.getContext("2d");
              try {
                return (
                  t &&
                    (t.drawImage(e, 0, 0, A.width, A.height),
                    this.options.allowTaint ||
                      t.getImageData(0, 0, A.width, A.height)),
                  A
                );
              } catch (A) {
                this.context.logger.info(
                  "Unable to clone video as it is tainted",
                  e
                );
              }
              A = e.ownerDocument.createElement("canvas");
              return (A.width = e.offsetWidth), (A.height = e.offsetHeight), A;
            }),
            (fn.prototype.appendChildNode = function (A, e, t) {
              (XB(e) &&
                ("SCRIPT" === e.tagName ||
                  e.hasAttribute(hn) ||
                  ("function" == typeof this.options.ignoreElements &&
                    this.options.ignoreElements(e)))) ||
                (this.options.copyStyles && XB(e) && SB(e)) ||
                A.appendChild(this.cloneNode(e, t));
            }),
            (fn.prototype.cloneChildNodes = function (A, e, t) {
              for (
                var r, B = this, n = (A.shadowRoot || A).firstChild;
                n;
                n = n.nextSibling
              )
                XB(n) && rn(n) && "function" == typeof n.assignedNodes
                  ? (r = n.assignedNodes()).length &&
                    r.forEach(function (A) {
                      return B.appendChildNode(e, A, t);
                    })
                  : this.appendChildNode(e, n, t);
            }),
            (fn.prototype.cloneNode = function (A, e) {
              if (PB(A)) return document.createTextNode(A.data);
              if (!A.ownerDocument) return A.cloneNode(!1);
              var t = A.ownerDocument.defaultView;
              if (t && XB(A) && (JB(A) || YB(A))) {
                var r = this.createElementClone(A);
                r.style.transitionProperty = "none";
                var B = t.getComputedStyle(A),
                  n = t.getComputedStyle(A, ":before"),
                  s = t.getComputedStyle(A, ":after");
                this.referenceElement === A &&
                  JB(r) &&
                  (this.clonedReferenceElement = r),
                  jB(r) && Mn(r);
                (t = this.counters.parse(new Ur(this.context, B))),
                  (n = this.resolvePseudoContent(A, r, n, gn.BEFORE));
                TB(A) && (e = !0),
                  MB(A) || this.cloneChildNodes(A, r, e),
                  n && r.insertBefore(n, r.firstChild);
                s = this.resolvePseudoContent(A, r, s, gn.AFTER);
                return (
                  s && r.appendChild(s),
                  this.counters.pop(t),
                  ((B && (this.options.copyStyles || YB(A)) && !An(A)) || e) &&
                    Kn(B, r),
                  (0 === A.scrollTop && 0 === A.scrollLeft) ||
                    this.scrolledElements.push([r, A.scrollLeft, A.scrollTop]),
                  (en(A) || tn(A)) && (en(r) || tn(r)) && (r.value = A.value),
                  r
                );
              }
              return A.cloneNode(!1);
            }),
            (fn.prototype.resolvePseudoContent = function (o, A, e, t) {
              var i = this;
              if (e) {
                var r = e.content,
                  Q = A.ownerDocument;
                if (
                  Q &&
                  r &&
                  "none" !== r &&
                  "-moz-alt-content" !== r &&
                  "none" !== e.display
                ) {
                  this.counters.parse(new Ur(this.context, e));
                  var c = new wr(this.context, e),
                    a = Q.createElement("html2canvaspseudoelement");
                  Kn(e, a),
                    c.content.forEach(function (A) {
                      if (0 === A.type)
                        a.appendChild(Q.createTextNode(A.value));
                      else if (22 === A.type) {
                        var e = Q.createElement("img");
                        (e.src = A.value),
                          (e.style.opacity = "1"),
                          a.appendChild(e);
                      } else if (18 === A.type) {
                        var t, r, B, n, s;
                        "attr" === A.name
                          ? (e = A.values.filter(_A)).length &&
                            a.appendChild(
                              Q.createTextNode(o.getAttribute(e[0].value) || "")
                            )
                          : "counter" === A.name
                          ? ((B = (r = A.values.filter($A))[0]),
                            (r = r[1]),
                            B &&
                              _A(B) &&
                              ((t = i.counters.getCounterValue(B.value)),
                              (s =
                                r && _A(r) ? pt.parse(i.context, r.value) : 3),
                              a.appendChild(Q.createTextNode(Fn(t, s, !1)))))
                          : "counters" === A.name &&
                            ((B = (t = A.values.filter($A))[0]),
                            (s = t[1]),
                            (r = t[2]),
                            B &&
                              _A(B) &&
                              ((B = i.counters.getCounterValues(B.value)),
                              (n =
                                r && _A(r) ? pt.parse(i.context, r.value) : 3),
                              (s = s && 0 === s.type ? s.value : ""),
                              (s = B.map(function (A) {
                                return Fn(A, n, !1);
                              }).join(s)),
                              a.appendChild(Q.createTextNode(s))));
                      } else if (20 === A.type)
                        switch (A.value) {
                          case "open-quote":
                            a.appendChild(
                              Q.createTextNode(Xt(c.quotes, i.quoteDepth++, !0))
                            );
                            break;
                          case "close-quote":
                            a.appendChild(
                              Q.createTextNode(Xt(c.quotes, --i.quoteDepth, !1))
                            );
                            break;
                          default:
                            a.appendChild(Q.createTextNode(A.value));
                        }
                    }),
                    (a.className = Dn + " " + vn);
                  t = t === gn.BEFORE ? " " + Dn : " " + vn;
                  return (
                    YB(A) ? (A.className.baseValue += t) : (A.className += t), a
                  );
                }
              }
            }),
            (fn.destroy = function (A) {
              return !!A.parentNode && (A.parentNode.removeChild(A), !0);
            }),
            fn);
        function fn(A, e, t) {
          if (
            ((this.context = A),
            (this.options = t),
            (this.scrolledElements = []),
            (this.referenceElement = e),
            (this.counters = new Bn()),
            (this.quoteDepth = 0),
            !e.ownerDocument)
          )
            throw new Error("Cloned element does not have an owner document");
          this.documentElement = this.cloneNode(
            e.ownerDocument.documentElement,
            !1
          );
        }
        ((he = gn = gn || {})[(he.BEFORE = 0)] = "BEFORE"),
          (he[(he.AFTER = 1)] = "AFTER");
        function Hn(e) {
          return new Promise(function (A) {
            !e.complete && e.src ? ((e.onload = A), (e.onerror = A)) : A();
          });
        }
        var pn = function (A, e) {
            var t = A.createElement("iframe");
            return (
              (t.className = "html2canvas-container"),
              (t.style.visibility = "hidden"),
              (t.style.position = "fixed"),
              (t.style.left = "-10000px"),
              (t.style.top = "0px"),
              (t.style.border = "0"),
              (t.width = e.width.toString()),
              (t.height = e.height.toString()),
              (t.scrolling = "no"),
              t.setAttribute(hn, "true"),
              A.body.appendChild(t),
              t
            );
          },
          En = function (A) {
            return Promise.all([].slice.call(A.images, 0).map(Hn));
          },
          In = function (B) {
            return new Promise(function (e, A) {
              var t = B.contentWindow;
              if (!t) return A("No window assigned for iframe");
              var r = t.document;
              t.onload = B.onload = function () {
                t.onload = B.onload = null;
                var A = setInterval(function () {
                  0 < r.body.childNodes.length &&
                    "complete" === r.readyState &&
                    (clearInterval(A), e(B));
                }, 50);
              };
            });
          },
          yn = ["all", "d", "content"],
          Kn = function (A, e) {
            for (var t = A.length - 1; 0 <= t; t--) {
              var r = A.item(t);
              -1 === yn.indexOf(r) &&
                e.style.setProperty(r, A.getPropertyValue(r));
            }
            return e;
          },
          mn = function (A) {
            var e = "";
            return (
              A &&
                ((e += "<!DOCTYPE "),
                A.name && (e += A.name),
                A.internalSubset && (e += A.internalSubset),
                A.publicId && (e += '"' + A.publicId + '"'),
                A.systemId && (e += '"' + A.systemId + '"'),
                (e += ">")),
              e
            );
          },
          Ln = function (A, e, t) {
            A &&
              A.defaultView &&
              (e !== A.defaultView.pageXOffset ||
                t !== A.defaultView.pageYOffset) &&
              A.defaultView.scrollTo(e, t);
          },
          bn = function (A) {
            var e = A[0],
              t = A[1],
              A = A[2];
            (e.scrollLeft = t), (e.scrollTop = A);
          },
          Dn = "___html2canvas___pseudoelement_before",
          vn = "___html2canvas___pseudoelement_after",
          xn =
            '{\n    content: "" !important;\n    display: none !important;\n}',
          Mn = function (A) {
            Sn(
              A,
              "." + Dn + ":before" + xn + "\n         ." + vn + ":after" + xn
            );
          },
          Sn = function (A, e) {
            var t = A.ownerDocument;
            t &&
              (((t = t.createElement("style")).textContent = e),
              A.appendChild(t));
          },
          Tn =
            ((Gn.getOrigin = function (A) {
              var e = Gn._link;
              return e
                ? ((e.href = A),
                  (e.href = e.href),
                  e.protocol + e.hostname + e.port)
                : "about:blank";
            }),
            (Gn.isSameOrigin = function (A) {
              return Gn.getOrigin(A) === Gn._origin;
            }),
            (Gn.setContext = function (A) {
              (Gn._link = A.document.createElement("a")),
                (Gn._origin = Gn.getOrigin(A.location.href));
            }),
            (Gn._origin = "about:blank"),
            Gn);
        function Gn() {}
        var On =
          ((Vn.prototype.addImage = function (A) {
            var e = Promise.resolve();
            return (
              this.has(A) ||
                ((Yn(A) || Pn(A)) &&
                  (this._cache[A] = this.loadImage(A)).catch(function () {})),
              e
            );
          }),
          (Vn.prototype.match = function (A) {
            return this._cache[A];
          }),
          (Vn.prototype.loadImage = function (s) {
            return a(this, void 0, void 0, function () {
              var e,
                r,
                t,
                B,
                n = this;
              return H(this, function (A) {
                switch (A.label) {
                  case 0:
                    return ((e = Tn.isSameOrigin(s)),
                    (r =
                      !Xn(s) &&
                      !0 === this._options.useCORS &&
                      Xr.SUPPORT_CORS_IMAGES &&
                      !e),
                    (t =
                      !Xn(s) &&
                      !e &&
                      !Yn(s) &&
                      "string" == typeof this._options.proxy &&
                      Xr.SUPPORT_CORS_XHR &&
                      !r),
                    e ||
                      !1 !== this._options.allowTaint ||
                      Xn(s) ||
                      Yn(s) ||
                      t ||
                      r)
                      ? ((B = s), t ? [4, this.proxy(B)] : [3, 2])
                      : [2];
                  case 1:
                    (B = A.sent()), (A.label = 2);
                  case 2:
                    return (
                      this.context.logger.debug(
                        "Added image " + s.substring(0, 256)
                      ),
                      [
                        4,
                        new Promise(function (A, e) {
                          var t = new Image();
                          (t.onload = function () {
                            return A(t);
                          }),
                            (t.onerror = e),
                            (Jn(B) || r) && (t.crossOrigin = "anonymous"),
                            (t.src = B),
                            !0 === t.complete &&
                              setTimeout(function () {
                                return A(t);
                              }, 500),
                            0 < n._options.imageTimeout &&
                              setTimeout(function () {
                                return e(
                                  "Timed out (" +
                                    n._options.imageTimeout +
                                    "ms) loading image"
                                );
                              }, n._options.imageTimeout);
                        }),
                      ]
                    );
                  case 3:
                    return [2, A.sent()];
                }
              });
            });
          }),
          (Vn.prototype.has = function (A) {
            return void 0 !== this._cache[A];
          }),
          (Vn.prototype.keys = function () {
            return Promise.resolve(Object.keys(this._cache));
          }),
          (Vn.prototype.proxy = function (s) {
            var o = this,
              i = this._options.proxy;
            if (!i) throw new Error("No proxy defined");
            var Q = s.substring(0, 256);
            return new Promise(function (e, t) {
              var r = Xr.SUPPORT_RESPONSE_TYPE ? "blob" : "text",
                B = new XMLHttpRequest();
              (B.onload = function () {
                var A;
                200 === B.status
                  ? "text" == r
                    ? e(B.response)
                    : ((A = new FileReader()).addEventListener(
                        "load",
                        function () {
                          return e(A.result);
                        },
                        !1
                      ),
                      A.addEventListener(
                        "error",
                        function (A) {
                          return t(A);
                        },
                        !1
                      ),
                      A.readAsDataURL(B.response))
                  : t(
                      "Failed to proxy resource " +
                        Q +
                        " with status code " +
                        B.status
                    );
              }),
                (B.onerror = t);
              var A,
                n = -1 < i.indexOf("?") ? "&" : "?";
              B.open(
                "GET",
                i + n + "url=" + encodeURIComponent(s) + "&responseType=" + r
              ),
                "text" != r &&
                  B instanceof XMLHttpRequest &&
                  (B.responseType = r),
                o._options.imageTimeout &&
                  ((A = o._options.imageTimeout),
                  (B.timeout = A),
                  (B.ontimeout = function () {
                    return t("Timed out (" + A + "ms) proxying " + Q);
                  })),
                B.send();
            });
          }),
          Vn);
        function Vn(A, e) {
          (this.context = A), (this._options = e), (this._cache = {});
        }
        var kn = /^data:image\/svg\+xml/i,
          Rn = /^data:image\/.*;base64,/i,
          Nn = /^data:image\/.*/i,
          Pn = function (A) {
            return Xr.SUPPORT_SVG_DRAWING || !Wn(A);
          },
          Xn = function (A) {
            return Nn.test(A);
          },
          Jn = function (A) {
            return Rn.test(A);
          },
          Yn = function (A) {
            return "blob" === A.substr(0, 4);
          },
          Wn = function (A) {
            return "svg" === A.substr(-3).toLowerCase() || kn.test(A);
          },
          Zn =
            ((_n.prototype.add = function (A, e) {
              return new _n(this.x + A, this.y + e);
            }),
            _n);
        function _n(A, e) {
          (this.type = 0), (this.x = A), (this.y = e);
        }
        function qn(A, e, t) {
          return new Zn(A.x + (e.x - A.x) * t, A.y + (e.y - A.y) * t);
        }
        var jn =
          ((zn.prototype.subdivide = function (A, e) {
            var t = qn(this.start, this.startControl, A),
              r = qn(this.startControl, this.endControl, A),
              B = qn(this.endControl, this.end, A),
              n = qn(t, r, A),
              r = qn(r, B, A),
              A = qn(n, r, A);
            return e ? new zn(this.start, t, n, A) : new zn(A, r, B, this.end);
          }),
          (zn.prototype.add = function (A, e) {
            return new zn(
              this.start.add(A, e),
              this.startControl.add(A, e),
              this.endControl.add(A, e),
              this.end.add(A, e)
            );
          }),
          (zn.prototype.reverse = function () {
            return new zn(
              this.end,
              this.endControl,
              this.startControl,
              this.start
            );
          }),
          zn);
        function zn(A, e, t, r) {
          (this.type = 1),
            (this.start = A),
            (this.startControl = e),
            (this.endControl = t),
            (this.end = r);
        }
        function $n(A) {
          return 1 === A.type;
        }
        var As,
          es = function (A) {
            var e = A.styles,
              t = A.bounds,
              r = (C = Be(e.borderTopLeftRadius, t.width, t.height))[0],
              B = C[1],
              n = (u = Be(e.borderTopRightRadius, t.width, t.height))[0],
              s = u[1],
              o = (F = Be(e.borderBottomRightRadius, t.width, t.height))[0],
              i = F[1],
              Q = (h = Be(e.borderBottomLeftRadius, t.width, t.height))[0],
              c = h[1];
            (d = []).push((r + n) / t.width),
              d.push((Q + o) / t.width),
              d.push((B + c) / t.height),
              d.push((s + i) / t.height),
              1 < (f = Math.max.apply(Math, d)) &&
                ((r /= f),
                (B /= f),
                (n /= f),
                (s /= f),
                (o /= f),
                (i /= f),
                (Q /= f),
                (c /= f));
            var a = t.width - n,
              g = t.height - i,
              w = t.width - o,
              U = t.height - c,
              l = e.borderTopWidth,
              C = e.borderRightWidth,
              u = e.borderBottomWidth,
              F = e.borderLeftWidth,
              h = Ue(e.paddingTop, A.bounds.width),
              d = Ue(e.paddingRight, A.bounds.width),
              f = Ue(e.paddingBottom, A.bounds.width),
              A = Ue(e.paddingLeft, A.bounds.width);
            (this.topLeftBorderDoubleOuterBox =
              0 < r || 0 < B
                ? ss(
                    t.left + F / 3,
                    t.top + l / 3,
                    r - F / 3,
                    B - l / 3,
                    As.TOP_LEFT
                  )
                : new Zn(t.left + F / 3, t.top + l / 3)),
              (this.topRightBorderDoubleOuterBox =
                0 < r || 0 < B
                  ? ss(
                      t.left + a,
                      t.top + l / 3,
                      n - C / 3,
                      s - l / 3,
                      As.TOP_RIGHT
                    )
                  : new Zn(t.left + t.width - C / 3, t.top + l / 3)),
              (this.bottomRightBorderDoubleOuterBox =
                0 < o || 0 < i
                  ? ss(
                      t.left + w,
                      t.top + g,
                      o - C / 3,
                      i - u / 3,
                      As.BOTTOM_RIGHT
                    )
                  : new Zn(t.left + t.width - C / 3, t.top + t.height - u / 3)),
              (this.bottomLeftBorderDoubleOuterBox =
                0 < Q || 0 < c
                  ? ss(
                      t.left + F / 3,
                      t.top + U,
                      Q - F / 3,
                      c - u / 3,
                      As.BOTTOM_LEFT
                    )
                  : new Zn(t.left + F / 3, t.top + t.height - u / 3)),
              (this.topLeftBorderDoubleInnerBox =
                0 < r || 0 < B
                  ? ss(
                      t.left + (2 * F) / 3,
                      t.top + (2 * l) / 3,
                      r - (2 * F) / 3,
                      B - (2 * l) / 3,
                      As.TOP_LEFT
                    )
                  : new Zn(t.left + (2 * F) / 3, t.top + (2 * l) / 3)),
              (this.topRightBorderDoubleInnerBox =
                0 < r || 0 < B
                  ? ss(
                      t.left + a,
                      t.top + (2 * l) / 3,
                      n - (2 * C) / 3,
                      s - (2 * l) / 3,
                      As.TOP_RIGHT
                    )
                  : new Zn(
                      t.left + t.width - (2 * C) / 3,
                      t.top + (2 * l) / 3
                    )),
              (this.bottomRightBorderDoubleInnerBox =
                0 < o || 0 < i
                  ? ss(
                      t.left + w,
                      t.top + g,
                      o - (2 * C) / 3,
                      i - (2 * u) / 3,
                      As.BOTTOM_RIGHT
                    )
                  : new Zn(
                      t.left + t.width - (2 * C) / 3,
                      t.top + t.height - (2 * u) / 3
                    )),
              (this.bottomLeftBorderDoubleInnerBox =
                0 < Q || 0 < c
                  ? ss(
                      t.left + (2 * F) / 3,
                      t.top + U,
                      Q - (2 * F) / 3,
                      c - (2 * u) / 3,
                      As.BOTTOM_LEFT
                    )
                  : new Zn(
                      t.left + (2 * F) / 3,
                      t.top + t.height - (2 * u) / 3
                    )),
              (this.topLeftBorderStroke =
                0 < r || 0 < B
                  ? ss(
                      t.left + F / 2,
                      t.top + l / 2,
                      r - F / 2,
                      B - l / 2,
                      As.TOP_LEFT
                    )
                  : new Zn(t.left + F / 2, t.top + l / 2)),
              (this.topRightBorderStroke =
                0 < r || 0 < B
                  ? ss(
                      t.left + a,
                      t.top + l / 2,
                      n - C / 2,
                      s - l / 2,
                      As.TOP_RIGHT
                    )
                  : new Zn(t.left + t.width - C / 2, t.top + l / 2)),
              (this.bottomRightBorderStroke =
                0 < o || 0 < i
                  ? ss(
                      t.left + w,
                      t.top + g,
                      o - C / 2,
                      i - u / 2,
                      As.BOTTOM_RIGHT
                    )
                  : new Zn(t.left + t.width - C / 2, t.top + t.height - u / 2)),
              (this.bottomLeftBorderStroke =
                0 < Q || 0 < c
                  ? ss(
                      t.left + F / 2,
                      t.top + U,
                      Q - F / 2,
                      c - u / 2,
                      As.BOTTOM_LEFT
                    )
                  : new Zn(t.left + F / 2, t.top + t.height - u / 2)),
              (this.topLeftBorderBox =
                0 < r || 0 < B
                  ? ss(t.left, t.top, r, B, As.TOP_LEFT)
                  : new Zn(t.left, t.top)),
              (this.topRightBorderBox =
                0 < n || 0 < s
                  ? ss(t.left + a, t.top, n, s, As.TOP_RIGHT)
                  : new Zn(t.left + t.width, t.top)),
              (this.bottomRightBorderBox =
                0 < o || 0 < i
                  ? ss(t.left + w, t.top + g, o, i, As.BOTTOM_RIGHT)
                  : new Zn(t.left + t.width, t.top + t.height)),
              (this.bottomLeftBorderBox =
                0 < Q || 0 < c
                  ? ss(t.left, t.top + U, Q, c, As.BOTTOM_LEFT)
                  : new Zn(t.left, t.top + t.height)),
              (this.topLeftPaddingBox =
                0 < r || 0 < B
                  ? ss(
                      t.left + F,
                      t.top + l,
                      Math.max(0, r - F),
                      Math.max(0, B - l),
                      As.TOP_LEFT
                    )
                  : new Zn(t.left + F, t.top + l)),
              (this.topRightPaddingBox =
                0 < n || 0 < s
                  ? ss(
                      t.left + Math.min(a, t.width - C),
                      t.top + l,
                      a > t.width + C ? 0 : Math.max(0, n - C),
                      Math.max(0, s - l),
                      As.TOP_RIGHT
                    )
                  : new Zn(t.left + t.width - C, t.top + l)),
              (this.bottomRightPaddingBox =
                0 < o || 0 < i
                  ? ss(
                      t.left + Math.min(w, t.width - F),
                      t.top + Math.min(g, t.height - u),
                      Math.max(0, o - C),
                      Math.max(0, i - u),
                      As.BOTTOM_RIGHT
                    )
                  : new Zn(t.left + t.width - C, t.top + t.height - u)),
              (this.bottomLeftPaddingBox =
                0 < Q || 0 < c
                  ? ss(
                      t.left + F,
                      t.top + Math.min(U, t.height - u),
                      Math.max(0, Q - F),
                      Math.max(0, c - u),
                      As.BOTTOM_LEFT
                    )
                  : new Zn(t.left + F, t.top + t.height - u)),
              (this.topLeftContentBox =
                0 < r || 0 < B
                  ? ss(
                      t.left + F + A,
                      t.top + l + h,
                      Math.max(0, r - (F + A)),
                      Math.max(0, B - (l + h)),
                      As.TOP_LEFT
                    )
                  : new Zn(t.left + F + A, t.top + l + h)),
              (this.topRightContentBox =
                0 < n || 0 < s
                  ? ss(
                      t.left + Math.min(a, t.width + F + A),
                      t.top + l + h,
                      a > t.width + F + A ? 0 : n - F + A,
                      s - (l + h),
                      As.TOP_RIGHT
                    )
                  : new Zn(t.left + t.width - (C + d), t.top + l + h)),
              (this.bottomRightContentBox =
                0 < o || 0 < i
                  ? ss(
                      t.left + Math.min(w, t.width - (F + A)),
                      t.top + Math.min(g, t.height + l + h),
                      Math.max(0, o - (C + d)),
                      i - (u + f),
                      As.BOTTOM_RIGHT
                    )
                  : new Zn(
                      t.left + t.width - (C + d),
                      t.top + t.height - (u + f)
                    )),
              (this.bottomLeftContentBox =
                0 < Q || 0 < c
                  ? ss(
                      t.left + F + A,
                      t.top + U,
                      Math.max(0, Q - (F + A)),
                      c - (u + f),
                      As.BOTTOM_LEFT
                    )
                  : new Zn(t.left + F + A, t.top + t.height - (u + f)));
          };
        ((he = As = As || {})[(he.TOP_LEFT = 0)] = "TOP_LEFT"),
          (he[(he.TOP_RIGHT = 1)] = "TOP_RIGHT"),
          (he[(he.BOTTOM_RIGHT = 2)] = "BOTTOM_RIGHT"),
          (he[(he.BOTTOM_LEFT = 3)] = "BOTTOM_LEFT");
        function ts(A) {
          return [
            A.topLeftBorderBox,
            A.topRightBorderBox,
            A.bottomRightBorderBox,
            A.bottomLeftBorderBox,
          ];
        }
        function rs(A) {
          return [
            A.topLeftPaddingBox,
            A.topRightPaddingBox,
            A.bottomRightPaddingBox,
            A.bottomLeftPaddingBox,
          ];
        }
        function Bs(A) {
          return 1 === A.type;
        }
        function ns(A, t) {
          return (
            A.length === t.length &&
            A.some(function (A, e) {
              return A === t[e];
            })
          );
        }
        var ss = function (A, e, t, r, B) {
            var n = ((Math.sqrt(2) - 1) / 3) * 4,
              s = t * n,
              o = r * n,
              i = A + t,
              Q = e + r;
            switch (B) {
              case As.TOP_LEFT:
                return new jn(
                  new Zn(A, Q),
                  new Zn(A, Q - o),
                  new Zn(i - s, e),
                  new Zn(i, e)
                );
              case As.TOP_RIGHT:
                return new jn(
                  new Zn(A, e),
                  new Zn(A + s, e),
                  new Zn(i, Q - o),
                  new Zn(i, Q)
                );
              case As.BOTTOM_RIGHT:
                return new jn(
                  new Zn(i, e),
                  new Zn(i, e + o),
                  new Zn(A + s, Q),
                  new Zn(A, Q)
                );
              default:
                As.BOTTOM_LEFT;
                return new jn(
                  new Zn(i, Q),
                  new Zn(i - s, Q),
                  new Zn(A, e + o),
                  new Zn(A, e)
                );
            }
          },
          os = function (A, e, t) {
            (this.offsetX = A),
              (this.offsetY = e),
              (this.matrix = t),
              (this.type = 0),
              (this.target = 6);
          },
          is = function (A, e) {
            (this.path = A), (this.target = e), (this.type = 1);
          },
          Qs = function (A) {
            (this.opacity = A), (this.type = 2), (this.target = 6);
          },
          cs = function (A) {
            (this.element = A),
              (this.inlineLevel = []),
              (this.nonInlineLevel = []),
              (this.negativeZIndex = []),
              (this.zeroOrAutoZIndexOrTransformedOrOpacity = []),
              (this.positiveZIndex = []),
              (this.nonPositionedFloats = []),
              (this.nonPositionedInlineLevel = []);
          },
          as =
            ((gs.prototype.getEffects = function (e) {
              for (
                var A = -1 === [2, 3].indexOf(this.container.styles.position),
                  t = this.parent,
                  r = this.effects.slice(0);
                t;

              ) {
                var B,
                  n,
                  s = t.effects.filter(function (A) {
                    return !Bs(A);
                  });
                A || 0 !== t.container.styles.position || !t.parent
                  ? (r.unshift.apply(r, s),
                    (A = -1 === [2, 3].indexOf(t.container.styles.position)),
                    0 !== t.container.styles.overflowX &&
                      ((B = ts(t.curves)),
                      (n = rs(t.curves)),
                      ns(B, n) || r.unshift(new is(n, 6))))
                  : r.unshift.apply(r, s),
                  (t = t.parent);
              }
              return r.filter(function (A) {
                return Pt(A.target, e);
              });
            }),
            gs);
        function gs(A, e) {
          var t, r;
          (this.container = A),
            (this.parent = e),
            (this.effects = []),
            (this.curves = new es(this.container)),
            this.container.styles.opacity < 1 &&
              this.effects.push(new Qs(this.container.styles.opacity)),
            null !== this.container.styles.transform &&
              ((e =
                this.container.bounds.left +
                this.container.styles.transformOrigin[0].number),
              (t =
                this.container.bounds.top +
                this.container.styles.transformOrigin[1].number),
              (r = this.container.styles.transform),
              this.effects.push(new os(e, t, r))),
            0 !== this.container.styles.overflowX &&
              ((t = ts(this.curves)),
              (r = rs(this.curves)),
              ns(t, r)
                ? this.effects.push(new is(t, 6))
                : (this.effects.push(new is(t, 2)),
                  this.effects.push(new is(r, 4))));
        }
        function ws(A, e) {
          switch (e) {
            case 0:
              return Hs(
                A.topLeftBorderBox,
                A.topLeftPaddingBox,
                A.topRightBorderBox,
                A.topRightPaddingBox
              );
            case 1:
              return Hs(
                A.topRightBorderBox,
                A.topRightPaddingBox,
                A.bottomRightBorderBox,
                A.bottomRightPaddingBox
              );
            case 2:
              return Hs(
                A.bottomRightBorderBox,
                A.bottomRightPaddingBox,
                A.bottomLeftBorderBox,
                A.bottomLeftPaddingBox
              );
            default:
              return Hs(
                A.bottomLeftBorderBox,
                A.bottomLeftPaddingBox,
                A.topLeftBorderBox,
                A.topLeftPaddingBox
              );
          }
        }
        function Us(A) {
          var e = A.bounds,
            A = A.styles;
          return e.add(
            A.borderLeftWidth,
            A.borderTopWidth,
            -(A.borderRightWidth + A.borderLeftWidth),
            -(A.borderTopWidth + A.borderBottomWidth)
          );
        }
        function ls(A) {
          var e = A.styles,
            t = A.bounds,
            r = Ue(e.paddingLeft, t.width),
            B = Ue(e.paddingRight, t.width),
            n = Ue(e.paddingTop, t.width),
            A = Ue(e.paddingBottom, t.width);
          return t.add(
            r + e.borderLeftWidth,
            n + e.borderTopWidth,
            -(e.borderRightWidth + e.borderLeftWidth + r + B),
            -(e.borderTopWidth + e.borderBottomWidth + n + A)
          );
        }
        function Cs(A, e, t) {
          var r =
              ((B = Es(A.styles.backgroundOrigin, e)),
              (n = A),
              0 === B ? n.bounds : (2 === B ? ls : Us)(n)),
            B =
              ((s = Es(A.styles.backgroundClip, e)),
              (o = A),
              0 === s ? o.bounds : (2 === s ? ls : Us)(o)),
            n = ps(Es(A.styles.backgroundSize, e), t, r),
            s = n[0],
            o = n[1],
            t = Be(
              Es(A.styles.backgroundPosition, e),
              r.width - s,
              r.height - o
            );
          return [
            Is(Es(A.styles.backgroundRepeat, e), t, n, r, B),
            Math.round(r.left + t[0]),
            Math.round(r.top + t[1]),
            s,
            o,
          ];
        }
        function us(A) {
          return _A(A) && A.value === Ve.AUTO;
        }
        function Fs(A) {
          return "number" == typeof A;
        }
        var hs = function (Q, c, a, g) {
            Q.container.elements.forEach(function (A) {
              var e = Pt(A.flags, 4),
                t = Pt(A.flags, 2),
                r = new as(A, Q);
              Pt(A.styles.display, 2048) && g.push(r);
              var B,
                n,
                s,
                o,
                i = Pt(A.flags, 8) ? [] : g;
              e || t
                ? ((B = e || A.styles.isPositioned() ? a : c),
                  (t = new cs(r)),
                  A.styles.isPositioned() ||
                  A.styles.opacity < 1 ||
                  A.styles.isTransformed()
                    ? (n = A.styles.zIndex.order) < 0
                      ? ((s = 0),
                        B.negativeZIndex.some(function (A, e) {
                          return n > A.element.container.styles.zIndex.order
                            ? ((s = e), !1)
                            : 0 < s;
                        }),
                        B.negativeZIndex.splice(s, 0, t))
                      : 0 < n
                      ? ((o = 0),
                        B.positiveZIndex.some(function (A, e) {
                          return n >= A.element.container.styles.zIndex.order
                            ? ((o = e + 1), !1)
                            : 0 < o;
                        }),
                        B.positiveZIndex.splice(o, 0, t))
                      : B.zeroOrAutoZIndexOrTransformedOrOpacity.push(t)
                    : (A.styles.isFloating()
                        ? B.nonPositionedFloats
                        : B.nonPositionedInlineLevel
                      ).push(t),
                  hs(r, t, e ? t : a, i))
                : ((A.styles.isInlineLevel()
                    ? c.inlineLevel
                    : c.nonInlineLevel
                  ).push(r),
                  hs(r, c, a, i)),
                Pt(A.flags, 8) && ds(A, i);
            });
          },
          ds = function (A, e) {
            for (
              var t = A instanceof UB ? A.start : 1,
                r = A instanceof UB && A.reversed,
                B = 0;
              B < e.length;
              B++
            ) {
              var n = e[B];
              n.container instanceof aB &&
                "number" == typeof n.container.value &&
                0 !== n.container.value &&
                (t = n.container.value),
                (n.listValue = Fn(t, n.container.styles.listStyleType, !0)),
                (t += r ? -1 : 1);
            }
          },
          fs = function (A, e) {
            var t = [];
            return (
              $n(A) ? t.push(A.subdivide(0.5, !1)) : t.push(A),
              $n(e) ? t.push(e.subdivide(0.5, !0)) : t.push(e),
              t
            );
          },
          Hs = function (A, e, t, r) {
            var B = [];
            return (
              $n(A) ? B.push(A.subdivide(0.5, !1)) : B.push(A),
              $n(t) ? B.push(t.subdivide(0.5, !0)) : B.push(t),
              $n(r) ? B.push(r.subdivide(0.5, !0).reverse()) : B.push(r),
              $n(e) ? B.push(e.subdivide(0.5, !1).reverse()) : B.push(e),
              B
            );
          },
          ps = function (A, e, t) {
            var r = e[0],
              B = e[1],
              n = e[2],
              s = A[0],
              o = A[1];
            if (!s) return [0, 0];
            if (te(s) && o && te(o)) return [Ue(s, t.width), Ue(o, t.height)];
            var i = Fs(n);
            if (_A(s) && (s.value === Ve.CONTAIN || s.value === Ve.COVER))
              return Fs(n)
                ? t.width / t.height < n != (s.value === Ve.COVER)
                  ? [t.width, t.width / n]
                  : [t.height * n, t.height]
                : [t.width, t.height];
            var Q = Fs(r),
              e = Fs(B),
              A = Q || e;
            if (us(s) && (!o || us(o)))
              return Q && e
                ? [r, B]
                : i || A
                ? A && i
                  ? [Q ? r : B * n, e ? B : r / n]
                  : [Q ? r : t.width, e ? B : t.height]
                : [t.width, t.height];
            if (i) {
              var c = 0,
                a = 0;
              return (
                te(s) ? (c = Ue(s, t.width)) : te(o) && (a = Ue(o, t.height)),
                us(s) ? (c = a * n) : (o && !us(o)) || (a = c / n),
                [c, a]
              );
            }
            (c = null), (a = null);
            if (
              (te(s)
                ? (c = Ue(s, t.width))
                : o && te(o) && (a = Ue(o, t.height)),
              null !==
                (c =
                  null !==
                    (a =
                      null !== c && (!o || us(o))
                        ? Q && e
                          ? (c / r) * B
                          : t.height
                        : a) && us(s)
                    ? Q && e
                      ? (a / B) * r
                      : t.width
                    : c) && null !== a)
            )
              return [c, a];
            throw new Error("Unable to calculate background-size for element");
          },
          Es = function (A, e) {
            e = A[e];
            return void 0 === e ? A[0] : e;
          },
          Is = function (A, e, t, r, B) {
            var n = e[0],
              s = e[1],
              o = t[0],
              i = t[1];
            switch (A) {
              case 2:
                return [
                  new Zn(Math.round(r.left), Math.round(r.top + s)),
                  new Zn(Math.round(r.left + r.width), Math.round(r.top + s)),
                  new Zn(
                    Math.round(r.left + r.width),
                    Math.round(i + r.top + s)
                  ),
                  new Zn(Math.round(r.left), Math.round(i + r.top + s)),
                ];
              case 3:
                return [
                  new Zn(Math.round(r.left + n), Math.round(r.top)),
                  new Zn(Math.round(r.left + n + o), Math.round(r.top)),
                  new Zn(
                    Math.round(r.left + n + o),
                    Math.round(r.height + r.top)
                  ),
                  new Zn(Math.round(r.left + n), Math.round(r.height + r.top)),
                ];
              case 1:
                return [
                  new Zn(Math.round(r.left + n), Math.round(r.top + s)),
                  new Zn(Math.round(r.left + n + o), Math.round(r.top + s)),
                  new Zn(Math.round(r.left + n + o), Math.round(r.top + s + i)),
                  new Zn(Math.round(r.left + n), Math.round(r.top + s + i)),
                ];
              default:
                return [
                  new Zn(Math.round(B.left), Math.round(B.top)),
                  new Zn(Math.round(B.left + B.width), Math.round(B.top)),
                  new Zn(
                    Math.round(B.left + B.width),
                    Math.round(B.height + B.top)
                  ),
                  new Zn(Math.round(B.left), Math.round(B.height + B.top)),
                ];
            }
          },
          ys = "Hidden Text",
          Ks =
            ((ms.prototype.parseMetrics = function (A, e) {
              var t = this._document.createElement("div"),
                r = this._document.createElement("img"),
                B = this._document.createElement("span"),
                n = this._document.body;
              (t.style.visibility = "hidden"),
                (t.style.fontFamily = A),
                (t.style.fontSize = e),
                (t.style.margin = "0"),
                (t.style.padding = "0"),
                (t.style.whiteSpace = "nowrap"),
                n.appendChild(t),
                (r.src =
                  "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"),
                (r.width = 1),
                (r.height = 1),
                (r.style.margin = "0"),
                (r.style.padding = "0"),
                (r.style.verticalAlign = "baseline"),
                (B.style.fontFamily = A),
                (B.style.fontSize = e),
                (B.style.margin = "0"),
                (B.style.padding = "0"),
                B.appendChild(this._document.createTextNode(ys)),
                t.appendChild(B),
                t.appendChild(r);
              e = r.offsetTop - B.offsetTop + 2;
              t.removeChild(B),
                t.appendChild(this._document.createTextNode(ys)),
                (t.style.lineHeight = "normal"),
                (r.style.verticalAlign = "super");
              r = r.offsetTop - t.offsetTop + 2;
              return n.removeChild(t), { baseline: e, middle: r };
            }),
            (ms.prototype.getMetrics = function (A, e) {
              var t = A + " " + e;
              return (
                void 0 === this._data[t] &&
                  (this._data[t] = this.parseMetrics(A, e)),
                this._data[t]
              );
            }),
            ms);
        function ms(A) {
          (this._data = {}), (this._document = A);
        }
        var Ls,
          he = function (A, e) {
            (this.context = A), (this.options = e);
          },
          bs =
            (A(Ds, (Ls = he)),
            (Ds.prototype.applyEffects = function (A) {
              for (var e = this; this._activeEffects.length; ) this.popEffect();
              A.forEach(function (A) {
                return e.applyEffect(A);
              });
            }),
            (Ds.prototype.applyEffect = function (A) {
              this.ctx.save(),
                2 === A.type && (this.ctx.globalAlpha = A.opacity),
                0 === A.type &&
                  (this.ctx.translate(A.offsetX, A.offsetY),
                  this.ctx.transform(
                    A.matrix[0],
                    A.matrix[1],
                    A.matrix[2],
                    A.matrix[3],
                    A.matrix[4],
                    A.matrix[5]
                  ),
                  this.ctx.translate(-A.offsetX, -A.offsetY)),
                Bs(A) && (this.path(A.path), this.ctx.clip()),
                this._activeEffects.push(A);
            }),
            (Ds.prototype.popEffect = function () {
              this._activeEffects.pop(), this.ctx.restore();
            }),
            (Ds.prototype.renderStack = function (e) {
              return a(this, void 0, void 0, function () {
                return H(this, function (A) {
                  switch (A.label) {
                    case 0:
                      return e.element.container.styles.isVisible()
                        ? [4, this.renderStackContent(e)]
                        : [3, 2];
                    case 1:
                      A.sent(), (A.label = 2);
                    case 2:
                      return [2];
                  }
                });
              });
            }),
            (Ds.prototype.renderNode = function (e) {
              return a(this, void 0, void 0, function () {
                return H(this, function (A) {
                  switch (A.label) {
                    case 0:
                      return (
                        Pt(e.container.flags, 16),
                        e.container.styles.isVisible()
                          ? [4, this.renderNodeBackgroundAndBorders(e)]
                          : [3, 3]
                      );
                    case 1:
                      return A.sent(), [4, this.renderNodeContent(e)];
                    case 2:
                      A.sent(), (A.label = 3);
                    case 3:
                      return [2];
                  }
                });
              });
            }),
            (Ds.prototype.renderTextWithLetterSpacing = function (t, A, r) {
              var B = this;
              0 === A
                ? this.ctx.fillText(t.text, t.bounds.left, t.bounds.top + r)
                : Zr(t.text).reduce(function (A, e) {
                    return (
                      B.ctx.fillText(e, A, t.bounds.top + r),
                      A + B.ctx.measureText(e).width
                    );
                  }, t.bounds.left);
            }),
            (Ds.prototype.createFontStyle = function (A) {
              var e = A.fontVariant
                  .filter(function (A) {
                    return "normal" === A || "small-caps" === A;
                  })
                  .join(""),
                t = Gs(A.fontFamily).join(", "),
                r = WA(A.fontSize)
                  ? "" + A.fontSize.number + A.fontSize.unit
                  : A.fontSize.number + "px";
              return [[A.fontStyle, e, A.fontWeight, r, t].join(" "), t, r];
            }),
            (Ds.prototype.renderTextNode = function (i, Q) {
              return a(this, void 0, void 0, function () {
                var e,
                  t,
                  r,
                  B,
                  n,
                  s,
                  o = this;
                return H(this, function (A) {
                  return (
                    (r = this.createFontStyle(Q)),
                    (e = r[0]),
                    (t = r[1]),
                    (r = r[2]),
                    (this.ctx.font = e),
                    (this.ctx.direction = 1 === Q.direction ? "rtl" : "ltr"),
                    (this.ctx.textAlign = "left"),
                    (this.ctx.textBaseline = "alphabetic"),
                    (r = this.fontMetrics.getMetrics(t, r)),
                    (B = r.baseline),
                    (n = r.middle),
                    (s = Q.paintOrder),
                    i.textBounds.forEach(function (t) {
                      s.forEach(function (A) {
                        switch (A) {
                          case 0:
                            (o.ctx.fillStyle = ie(Q.color)),
                              o.renderTextWithLetterSpacing(
                                t,
                                Q.letterSpacing,
                                B
                              );
                            var e = Q.textShadow;
                            e.length &&
                              t.text.trim().length &&
                              (e
                                .slice(0)
                                .reverse()
                                .forEach(function (A) {
                                  (o.ctx.shadowColor = ie(A.color)),
                                    (o.ctx.shadowOffsetX =
                                      A.offsetX.number * o.options.scale),
                                    (o.ctx.shadowOffsetY =
                                      A.offsetY.number * o.options.scale),
                                    (o.ctx.shadowBlur = A.blur.number),
                                    o.renderTextWithLetterSpacing(
                                      t,
                                      Q.letterSpacing,
                                      B
                                    );
                                }),
                              (o.ctx.shadowColor = ""),
                              (o.ctx.shadowOffsetX = 0),
                              (o.ctx.shadowOffsetY = 0),
                              (o.ctx.shadowBlur = 0)),
                              Q.textDecorationLine.length &&
                                ((o.ctx.fillStyle = ie(
                                  Q.textDecorationColor || Q.color
                                )),
                                Q.textDecorationLine.forEach(function (A) {
                                  switch (A) {
                                    case 1:
                                      o.ctx.fillRect(
                                        t.bounds.left,
                                        Math.round(t.bounds.top + B),
                                        t.bounds.width,
                                        1
                                      );
                                      break;
                                    case 2:
                                      o.ctx.fillRect(
                                        t.bounds.left,
                                        Math.round(t.bounds.top),
                                        t.bounds.width,
                                        1
                                      );
                                      break;
                                    case 3:
                                      o.ctx.fillRect(
                                        t.bounds.left,
                                        Math.ceil(t.bounds.top + n),
                                        t.bounds.width,
                                        1
                                      );
                                  }
                                }));
                            break;
                          case 1:
                            Q.webkitTextStrokeWidth &&
                              t.text.trim().length &&
                              ((o.ctx.strokeStyle = ie(
                                Q.webkitTextStrokeColor
                              )),
                              (o.ctx.lineWidth = Q.webkitTextStrokeWidth),
                              (o.ctx.lineJoin = window.chrome
                                ? "miter"
                                : "round"),
                              o.ctx.strokeText(
                                t.text,
                                t.bounds.left,
                                t.bounds.top + B
                              )),
                              (o.ctx.strokeStyle = ""),
                              (o.ctx.lineWidth = 0),
                              (o.ctx.lineJoin = "miter");
                        }
                      });
                    }),
                    [2]
                  );
                });
              });
            }),
            (Ds.prototype.renderReplacedElement = function (A, e, t) {
              var r;
              t &&
                0 < A.intrinsicWidth &&
                0 < A.intrinsicHeight &&
                ((r = ls(A)),
                (e = rs(e)),
                this.path(e),
                this.ctx.save(),
                this.ctx.clip(),
                this.ctx.drawImage(
                  t,
                  0,
                  0,
                  A.intrinsicWidth,
                  A.intrinsicHeight,
                  r.left,
                  r.top,
                  r.width,
                  r.height
                ),
                this.ctx.restore());
            }),
            (Ds.prototype.renderNodeContent = function (w) {
              return a(this, void 0, void 0, function () {
                var e, t, r, B, n, s, o, i, Q, c, a, g;
                return H(this, function (A) {
                  switch (A.label) {
                    case 0:
                      this.applyEffects(w.getEffects(4)),
                        (e = w.container),
                        (t = w.curves),
                        (r = e.styles),
                        (B = 0),
                        (n = e.textNodes),
                        (A.label = 1);
                    case 1:
                      return B < n.length
                        ? ((s = n[B]), [4, this.renderTextNode(s, r)])
                        : [3, 4];
                    case 2:
                      A.sent(), (A.label = 3);
                    case 3:
                      return B++, [3, 1];
                    case 4:
                      if (!(e instanceof tB)) return [3, 8];
                      A.label = 5;
                    case 5:
                      return (
                        A.trys.push([5, 7, , 8]),
                        [4, this.context.cache.match(e.src)]
                      );
                    case 6:
                      return (
                        (Q = A.sent()),
                        this.renderReplacedElement(e, t, Q),
                        [3, 8]
                      );
                    case 7:
                      return (
                        A.sent(),
                        this.context.logger.error(
                          "Error loading image " + e.src
                        ),
                        [3, 8]
                      );
                    case 8:
                      if (
                        (e instanceof nB &&
                          this.renderReplacedElement(e, t, e.canvas),
                        !(e instanceof iB))
                      )
                        return [3, 12];
                      A.label = 9;
                    case 9:
                      return (
                        A.trys.push([9, 11, , 12]),
                        [4, this.context.cache.match(e.svg)]
                      );
                    case 10:
                      return (
                        (Q = A.sent()),
                        this.renderReplacedElement(e, t, Q),
                        [3, 12]
                      );
                    case 11:
                      return (
                        A.sent(),
                        this.context.logger.error(
                          "Error loading svg " + e.svg.substring(0, 255)
                        ),
                        [3, 12]
                      );
                    case 12:
                      return e instanceof vB && e.tree
                        ? [
                            4,
                            new Ds(this.context, {
                              scale: this.options.scale,
                              backgroundColor: e.backgroundColor,
                              x: 0,
                              y: 0,
                              width: e.width,
                              height: e.height,
                            }).render(e.tree),
                          ]
                        : [3, 14];
                    case 13:
                      (s = A.sent()),
                        e.width &&
                          e.height &&
                          this.ctx.drawImage(
                            s,
                            0,
                            0,
                            e.width,
                            e.height,
                            e.bounds.left,
                            e.bounds.top,
                            e.bounds.width,
                            e.bounds.height
                          ),
                        (A.label = 14);
                    case 14:
                      if (
                        (e instanceof pB &&
                          ((i = Math.min(e.bounds.width, e.bounds.height)),
                          e.type === hB
                            ? e.checked &&
                              (this.ctx.save(),
                              this.path([
                                new Zn(
                                  e.bounds.left + 0.39363 * i,
                                  e.bounds.top + 0.79 * i
                                ),
                                new Zn(
                                  e.bounds.left + 0.16 * i,
                                  e.bounds.top + 0.5549 * i
                                ),
                                new Zn(
                                  e.bounds.left + 0.27347 * i,
                                  e.bounds.top + 0.44071 * i
                                ),
                                new Zn(
                                  e.bounds.left + 0.39694 * i,
                                  e.bounds.top + 0.5649 * i
                                ),
                                new Zn(
                                  e.bounds.left + 0.72983 * i,
                                  e.bounds.top + 0.23 * i
                                ),
                                new Zn(
                                  e.bounds.left + 0.84 * i,
                                  e.bounds.top + 0.34085 * i
                                ),
                                new Zn(
                                  e.bounds.left + 0.39363 * i,
                                  e.bounds.top + 0.79 * i
                                ),
                              ]),
                              (this.ctx.fillStyle = ie(HB)),
                              this.ctx.fill(),
                              this.ctx.restore())
                            : e.type === dB &&
                              e.checked &&
                              (this.ctx.save(),
                              this.ctx.beginPath(),
                              this.ctx.arc(
                                e.bounds.left + i / 2,
                                e.bounds.top + i / 2,
                                i / 4,
                                0,
                                2 * Math.PI,
                                !0
                              ),
                              (this.ctx.fillStyle = ie(HB)),
                              this.ctx.fill(),
                              this.ctx.restore())),
                        xs(e) && e.value.length)
                      ) {
                        switch (
                          ((c = this.createFontStyle(r)),
                          (a = c[0]),
                          (i = c[1]),
                          (c = this.fontMetrics.getMetrics(a, i).baseline),
                          (this.ctx.font = a),
                          (this.ctx.fillStyle = ie(r.color)),
                          (this.ctx.textBaseline = "alphabetic"),
                          (this.ctx.textAlign = Ss(e.styles.textAlign)),
                          (g = ls(e)),
                          (o = 0),
                          e.styles.textAlign)
                        ) {
                          case 1:
                            o += g.width / 2;
                            break;
                          case 2:
                            o += g.width;
                        }
                        (i = g.add(o, 0, 0, -g.height / 2 + 1)),
                          this.ctx.save(),
                          this.path([
                            new Zn(g.left, g.top),
                            new Zn(g.left + g.width, g.top),
                            new Zn(g.left + g.width, g.top + g.height),
                            new Zn(g.left, g.top + g.height),
                          ]),
                          this.ctx.clip(),
                          this.renderTextWithLetterSpacing(
                            new Jr(e.value, i),
                            r.letterSpacing,
                            c
                          ),
                          this.ctx.restore(),
                          (this.ctx.textBaseline = "alphabetic"),
                          (this.ctx.textAlign = "left");
                      }
                      if (!Pt(e.styles.display, 2048)) return [3, 20];
                      if (null === e.styles.listStyleImage) return [3, 19];
                      if (0 !== (c = e.styles.listStyleImage).type)
                        return [3, 18];
                      (Q = void 0), (c = c.url), (A.label = 15);
                    case 15:
                      return (
                        A.trys.push([15, 17, , 18]),
                        [4, this.context.cache.match(c)]
                      );
                    case 16:
                      return (
                        (Q = A.sent()),
                        this.ctx.drawImage(
                          Q,
                          e.bounds.left - (Q.width + 10),
                          e.bounds.top
                        ),
                        [3, 18]
                      );
                    case 17:
                      return (
                        A.sent(),
                        this.context.logger.error(
                          "Error loading list-style-image " + c
                        ),
                        [3, 18]
                      );
                    case 18:
                      return [3, 20];
                    case 19:
                      w.listValue &&
                        -1 !== e.styles.listStyleType &&
                        ((a = this.createFontStyle(r)[0]),
                        (this.ctx.font = a),
                        (this.ctx.fillStyle = ie(r.color)),
                        (this.ctx.textBaseline = "middle"),
                        (this.ctx.textAlign = "right"),
                        (g = new d(
                          e.bounds.left,
                          e.bounds.top +
                            Ue(e.styles.paddingTop, e.bounds.width),
                          e.bounds.width,
                          Ye(r.lineHeight, r.fontSize.number) / 2 + 1
                        )),
                        this.renderTextWithLetterSpacing(
                          new Jr(w.listValue, g),
                          r.letterSpacing,
                          Ye(r.lineHeight, r.fontSize.number) / 2 + 2
                        ),
                        (this.ctx.textBaseline = "bottom"),
                        (this.ctx.textAlign = "left")),
                        (A.label = 20);
                    case 20:
                      return [2];
                  }
                });
              });
            }),
            (Ds.prototype.renderStackContent = function (C) {
              return a(this, void 0, void 0, function () {
                var e, t, r, B, n, s, o, i, Q, c, a, g, w, U, l;
                return H(this, function (A) {
                  switch (A.label) {
                    case 0:
                      return (
                        Pt(C.element.container.flags, 16),
                        [4, this.renderNodeBackgroundAndBorders(C.element)]
                      );
                    case 1:
                      A.sent(), (e = 0), (t = C.negativeZIndex), (A.label = 2);
                    case 2:
                      return e < t.length
                        ? ((l = t[e]), [4, this.renderStack(l)])
                        : [3, 5];
                    case 3:
                      A.sent(), (A.label = 4);
                    case 4:
                      return e++, [3, 2];
                    case 5:
                      return [4, this.renderNodeContent(C.element)];
                    case 6:
                      A.sent(), (r = 0), (B = C.nonInlineLevel), (A.label = 7);
                    case 7:
                      return r < B.length
                        ? ((l = B[r]), [4, this.renderNode(l)])
                        : [3, 10];
                    case 8:
                      A.sent(), (A.label = 9);
                    case 9:
                      return r++, [3, 7];
                    case 10:
                      (n = 0), (s = C.nonPositionedFloats), (A.label = 11);
                    case 11:
                      return n < s.length
                        ? ((l = s[n]), [4, this.renderStack(l)])
                        : [3, 14];
                    case 12:
                      A.sent(), (A.label = 13);
                    case 13:
                      return n++, [3, 11];
                    case 14:
                      (o = 0), (i = C.nonPositionedInlineLevel), (A.label = 15);
                    case 15:
                      return o < i.length
                        ? ((l = i[o]), [4, this.renderStack(l)])
                        : [3, 18];
                    case 16:
                      A.sent(), (A.label = 17);
                    case 17:
                      return o++, [3, 15];
                    case 18:
                      (Q = 0), (c = C.inlineLevel), (A.label = 19);
                    case 19:
                      return Q < c.length
                        ? ((l = c[Q]), [4, this.renderNode(l)])
                        : [3, 22];
                    case 20:
                      A.sent(), (A.label = 21);
                    case 21:
                      return Q++, [3, 19];
                    case 22:
                      (a = 0),
                        (g = C.zeroOrAutoZIndexOrTransformedOrOpacity),
                        (A.label = 23);
                    case 23:
                      return a < g.length
                        ? ((l = g[a]), [4, this.renderStack(l)])
                        : [3, 26];
                    case 24:
                      A.sent(), (A.label = 25);
                    case 25:
                      return a++, [3, 23];
                    case 26:
                      (w = 0), (U = C.positiveZIndex), (A.label = 27);
                    case 27:
                      return w < U.length
                        ? ((l = U[w]), [4, this.renderStack(l)])
                        : [3, 30];
                    case 28:
                      A.sent(), (A.label = 29);
                    case 29:
                      return w++, [3, 27];
                    case 30:
                      return [2];
                  }
                });
              });
            }),
            (Ds.prototype.mask = function (A) {
              this.ctx.beginPath(),
                this.ctx.moveTo(0, 0),
                this.ctx.lineTo(this.canvas.width, 0),
                this.ctx.lineTo(this.canvas.width, this.canvas.height),
                this.ctx.lineTo(0, this.canvas.height),
                this.ctx.lineTo(0, 0),
                this.formatPath(A.slice(0).reverse()),
                this.ctx.closePath();
            }),
            (Ds.prototype.path = function (A) {
              this.ctx.beginPath(), this.formatPath(A), this.ctx.closePath();
            }),
            (Ds.prototype.formatPath = function (A) {
              var r = this;
              A.forEach(function (A, e) {
                var t = $n(A) ? A.start : A;
                0 === e ? r.ctx.moveTo(t.x, t.y) : r.ctx.lineTo(t.x, t.y),
                  $n(A) &&
                    r.ctx.bezierCurveTo(
                      A.startControl.x,
                      A.startControl.y,
                      A.endControl.x,
                      A.endControl.y,
                      A.end.x,
                      A.end.y
                    );
              });
            }),
            (Ds.prototype.renderRepeat = function (A, e, t, r) {
              this.path(A),
                (this.ctx.fillStyle = e),
                this.ctx.translate(t, r),
                this.ctx.fill(),
                this.ctx.translate(-t, -r);
            }),
            (Ds.prototype.resizeImage = function (A, e, t) {
              if (A.width === e && A.height === t) return A;
              var r = (
                null !== (r = this.canvas.ownerDocument) && void 0 !== r
                  ? r
                  : document
              ).createElement("canvas");
              return (
                (r.width = Math.max(1, e)),
                (r.height = Math.max(1, t)),
                r
                  .getContext("2d")
                  .drawImage(A, 0, 0, A.width, A.height, 0, 0, e, t),
                r
              );
            }),
            (Ds.prototype.renderBackgroundImage = function (f) {
              return a(this, void 0, void 0, function () {
                var h, e, d, t, r, B;
                return H(this, function (A) {
                  switch (A.label) {
                    case 0:
                      (h = f.styles.backgroundImage.length - 1),
                        (e = function (e) {
                          var t, r, B, n, s, o, i, Q, c, a, g, w, U, l, C, u, F;
                          return H(this, function (A) {
                            switch (A.label) {
                              case 0:
                                if (0 !== e.type) return [3, 5];
                                (t = void 0), (r = e.url), (A.label = 1);
                              case 1:
                                return (
                                  A.trys.push([1, 3, , 4]),
                                  [4, d.context.cache.match(r)]
                                );
                              case 2:
                                return (t = A.sent()), [3, 4];
                              case 3:
                                return (
                                  A.sent(),
                                  d.context.logger.error(
                                    "Error loading background-image " + r
                                  ),
                                  [3, 4]
                                );
                              case 4:
                                return (
                                  t &&
                                    ((B = Cs(f, h, [
                                      t.width,
                                      t.height,
                                      t.width / t.height,
                                    ])),
                                    (o = B[0]),
                                    (g = B[1]),
                                    (w = B[2]),
                                    (c = B[3]),
                                    (a = B[4]),
                                    (s = d.ctx.createPattern(
                                      d.resizeImage(t, c, a),
                                      "repeat"
                                    )),
                                    d.renderRepeat(o, s, g, w)),
                                  [3, 6]
                                );
                              case 5:
                                1 === e.type
                                  ? ((F = Cs(f, h, [null, null, null])),
                                    (o = F[0]),
                                    (g = F[1]),
                                    (w = F[2]),
                                    (c = F[3]),
                                    (a = F[4]),
                                    (C = Ee(e.angle, c, a)),
                                    (l = C[0]),
                                    (B = C[1]),
                                    (i = C[2]),
                                    (u = C[3]),
                                    (Q = C[4]),
                                    ((F =
                                      document.createElement("canvas")).width =
                                      c),
                                    (F.height = a),
                                    (C = F.getContext("2d")),
                                    (n = C.createLinearGradient(B, u, i, Q)),
                                    pe(e.stops, l).forEach(function (A) {
                                      return n.addColorStop(
                                        A.stop,
                                        ie(A.color)
                                      );
                                    }),
                                    (C.fillStyle = n),
                                    C.fillRect(0, 0, c, a),
                                    0 < c &&
                                      0 < a &&
                                      ((s = d.ctx.createPattern(F, "repeat")),
                                      d.renderRepeat(o, s, g, w)))
                                  : 2 === e.type &&
                                    ((u = Cs(f, h, [null, null, null])),
                                    (o = u[0]),
                                    (i = u[1]),
                                    (Q = u[2]),
                                    (c = u[3]),
                                    (a = u[4]),
                                    (l =
                                      0 === e.position.length
                                        ? [ge]
                                        : e.position),
                                    (g = Ue(l[0], c)),
                                    (w = Ue(l[l.length - 1], a)),
                                    (C = (function (A, e, t, r, B) {
                                      var n,
                                        s,
                                        o,
                                        i,
                                        Q = 0,
                                        c = 0;
                                      switch (A.size) {
                                        case 0:
                                          0 === A.shape
                                            ? (Q = c =
                                                Math.min(
                                                  Math.abs(e),
                                                  Math.abs(e - r),
                                                  Math.abs(t),
                                                  Math.abs(t - B)
                                                ))
                                            : 1 === A.shape &&
                                              ((Q = Math.min(
                                                Math.abs(e),
                                                Math.abs(e - r)
                                              )),
                                              (c = Math.min(
                                                Math.abs(t),
                                                Math.abs(t - B)
                                              )));
                                          break;
                                        case 2:
                                          0 === A.shape
                                            ? (Q = c =
                                                Math.min(
                                                  Ie(e, t),
                                                  Ie(e, t - B),
                                                  Ie(e - r, t),
                                                  Ie(e - r, t - B)
                                                ))
                                            : 1 === A.shape &&
                                              ((n =
                                                Math.min(
                                                  Math.abs(t),
                                                  Math.abs(t - B)
                                                ) /
                                                Math.min(
                                                  Math.abs(e),
                                                  Math.abs(e - r)
                                                )),
                                              (o = (s = ye(r, B, e, t, !0))[0]),
                                              (i = s[1]),
                                              (c =
                                                n *
                                                (Q = Ie(o - e, (i - t) / n))));
                                          break;
                                        case 1:
                                          0 === A.shape
                                            ? (Q = c =
                                                Math.max(
                                                  Math.abs(e),
                                                  Math.abs(e - r),
                                                  Math.abs(t),
                                                  Math.abs(t - B)
                                                ))
                                            : 1 === A.shape &&
                                              ((Q = Math.max(
                                                Math.abs(e),
                                                Math.abs(e - r)
                                              )),
                                              (c = Math.max(
                                                Math.abs(t),
                                                Math.abs(t - B)
                                              )));
                                          break;
                                        case 3:
                                          0 === A.shape
                                            ? (Q = c =
                                                Math.max(
                                                  Ie(e, t),
                                                  Ie(e, t - B),
                                                  Ie(e - r, t),
                                                  Ie(e - r, t - B)
                                                ))
                                            : 1 === A.shape &&
                                              ((n =
                                                Math.max(
                                                  Math.abs(t),
                                                  Math.abs(t - B)
                                                ) /
                                                Math.max(
                                                  Math.abs(e),
                                                  Math.abs(e - r)
                                                )),
                                              (o = (s = ye(r, B, e, t, !1))[0]),
                                              (i = s[1]),
                                              (c =
                                                n *
                                                (Q = Ie(o - e, (i - t) / n))));
                                      }
                                      return (
                                        Array.isArray(A.size) &&
                                          ((Q = Ue(A.size[0], r)),
                                          (c =
                                            2 === A.size.length
                                              ? Ue(A.size[1], B)
                                              : Q)),
                                        [Q, c]
                                      );
                                    })(e, g, w, c, a)),
                                    (F = C[0]),
                                    (u = C[1]),
                                    0 < F &&
                                      0 < u &&
                                      ((U = d.ctx.createRadialGradient(
                                        i + g,
                                        Q + w,
                                        0,
                                        i + g,
                                        Q + w,
                                        F
                                      )),
                                      pe(e.stops, 2 * F).forEach(function (A) {
                                        return U.addColorStop(
                                          A.stop,
                                          ie(A.color)
                                        );
                                      }),
                                      d.path(o),
                                      (d.ctx.fillStyle = U),
                                      F !== u
                                        ? ((l =
                                            f.bounds.left +
                                            0.5 * f.bounds.width),
                                          (C =
                                            f.bounds.top +
                                            0.5 * f.bounds.height),
                                          (F = 1 / (u = u / F)),
                                          d.ctx.save(),
                                          d.ctx.translate(l, C),
                                          d.ctx.transform(1, 0, 0, u, 0, 0),
                                          d.ctx.translate(-l, -C),
                                          d.ctx.fillRect(
                                            i,
                                            F * (Q - C) + C,
                                            c,
                                            a * F
                                          ),
                                          d.ctx.restore())
                                        : d.ctx.fill())),
                                  (A.label = 6);
                              case 6:
                                return h--, [2];
                            }
                          });
                        }),
                        (d = this),
                        (t = 0),
                        (r = f.styles.backgroundImage.slice(0).reverse()),
                        (A.label = 1);
                    case 1:
                      return t < r.length ? ((B = r[t]), [5, e(B)]) : [3, 4];
                    case 2:
                      A.sent(), (A.label = 3);
                    case 3:
                      return t++, [3, 1];
                    case 4:
                      return [2];
                  }
                });
              });
            }),
            (Ds.prototype.renderSolidBorder = function (e, t, r) {
              return a(this, void 0, void 0, function () {
                return H(this, function (A) {
                  return (
                    this.path(ws(r, t)),
                    (this.ctx.fillStyle = ie(e)),
                    this.ctx.fill(),
                    [2]
                  );
                });
              });
            }),
            (Ds.prototype.renderDoubleBorder = function (t, r, B, n) {
              return a(this, void 0, void 0, function () {
                var e;
                return H(this, function (A) {
                  switch (A.label) {
                    case 0:
                      return r < 3
                        ? [4, this.renderSolidBorder(t, B, n)]
                        : [3, 2];
                    case 1:
                      return A.sent(), [2];
                    case 2:
                      return (
                        (e = (function (A, e) {
                          switch (e) {
                            case 0:
                              return Hs(
                                A.topLeftBorderBox,
                                A.topLeftBorderDoubleOuterBox,
                                A.topRightBorderBox,
                                A.topRightBorderDoubleOuterBox
                              );
                            case 1:
                              return Hs(
                                A.topRightBorderBox,
                                A.topRightBorderDoubleOuterBox,
                                A.bottomRightBorderBox,
                                A.bottomRightBorderDoubleOuterBox
                              );
                            case 2:
                              return Hs(
                                A.bottomRightBorderBox,
                                A.bottomRightBorderDoubleOuterBox,
                                A.bottomLeftBorderBox,
                                A.bottomLeftBorderDoubleOuterBox
                              );
                            default:
                              return Hs(
                                A.bottomLeftBorderBox,
                                A.bottomLeftBorderDoubleOuterBox,
                                A.topLeftBorderBox,
                                A.topLeftBorderDoubleOuterBox
                              );
                          }
                        })(n, B)),
                        this.path(e),
                        (this.ctx.fillStyle = ie(t)),
                        this.ctx.fill(),
                        (e = (function (A, e) {
                          switch (e) {
                            case 0:
                              return Hs(
                                A.topLeftBorderDoubleInnerBox,
                                A.topLeftPaddingBox,
                                A.topRightBorderDoubleInnerBox,
                                A.topRightPaddingBox
                              );
                            case 1:
                              return Hs(
                                A.topRightBorderDoubleInnerBox,
                                A.topRightPaddingBox,
                                A.bottomRightBorderDoubleInnerBox,
                                A.bottomRightPaddingBox
                              );
                            case 2:
                              return Hs(
                                A.bottomRightBorderDoubleInnerBox,
                                A.bottomRightPaddingBox,
                                A.bottomLeftBorderDoubleInnerBox,
                                A.bottomLeftPaddingBox
                              );
                            default:
                              return Hs(
                                A.bottomLeftBorderDoubleInnerBox,
                                A.bottomLeftPaddingBox,
                                A.topLeftBorderDoubleInnerBox,
                                A.topLeftPaddingBox
                              );
                          }
                        })(n, B)),
                        this.path(e),
                        this.ctx.fill(),
                        [2]
                      );
                  }
                });
              });
            }),
            (Ds.prototype.renderNodeBackgroundAndBorders = function (c) {
              return a(this, void 0, void 0, function () {
                var e,
                  t,
                  r,
                  B,
                  n,
                  s,
                  o,
                  i,
                  Q = this;
                return H(this, function (A) {
                  switch (A.label) {
                    case 0:
                      return (this.applyEffects(c.getEffects(2)),
                      (e = c.container.styles),
                      (t = !oe(e.backgroundColor) || e.backgroundImage.length),
                      (r = [
                        {
                          style: e.borderTopStyle,
                          color: e.borderTopColor,
                          width: e.borderTopWidth,
                        },
                        {
                          style: e.borderRightStyle,
                          color: e.borderRightColor,
                          width: e.borderRightWidth,
                        },
                        {
                          style: e.borderBottomStyle,
                          color: e.borderBottomColor,
                          width: e.borderBottomWidth,
                        },
                        {
                          style: e.borderLeftStyle,
                          color: e.borderLeftColor,
                          width: e.borderLeftWidth,
                        },
                      ]),
                      (B = Ms(Es(e.backgroundClip, 0), c.curves)),
                      t || e.boxShadow.length)
                        ? (this.ctx.save(),
                          this.path(B),
                          this.ctx.clip(),
                          oe(e.backgroundColor) ||
                            ((this.ctx.fillStyle = ie(e.backgroundColor)),
                            this.ctx.fill()),
                          [4, this.renderBackgroundImage(c.container)])
                        : [3, 2];
                    case 1:
                      A.sent(),
                        this.ctx.restore(),
                        e.boxShadow
                          .slice(0)
                          .reverse()
                          .forEach(function (A) {
                            Q.ctx.save();
                            var t,
                              r,
                              B,
                              n,
                              e = ts(c.curves),
                              s = A.inset ? 0 : 1e4,
                              o =
                                ((t =
                                  -s + (A.inset ? 1 : -1) * A.spread.number),
                                (r = (A.inset ? 1 : -1) * A.spread.number),
                                (B = A.spread.number * (A.inset ? -2 : 2)),
                                (n = A.spread.number * (A.inset ? -2 : 2)),
                                e.map(function (A, e) {
                                  switch (e) {
                                    case 0:
                                      return A.add(t, r);
                                    case 1:
                                      return A.add(t + B, r);
                                    case 2:
                                      return A.add(t + B, r + n);
                                    case 3:
                                      return A.add(t, r + n);
                                  }
                                  return A;
                                }));
                            A.inset
                              ? (Q.path(e), Q.ctx.clip(), Q.mask(o))
                              : (Q.mask(e), Q.ctx.clip(), Q.path(o)),
                              (Q.ctx.shadowOffsetX = A.offsetX.number + s),
                              (Q.ctx.shadowOffsetY = A.offsetY.number),
                              (Q.ctx.shadowColor = ie(A.color)),
                              (Q.ctx.shadowBlur = A.blur.number),
                              (Q.ctx.fillStyle = A.inset
                                ? ie(A.color)
                                : "rgba(0,0,0,1)"),
                              Q.ctx.fill(),
                              Q.ctx.restore();
                          }),
                        (A.label = 2);
                    case 2:
                      (s = n = 0), (o = r), (A.label = 3);
                    case 3:
                      return s < o.length
                        ? 0 !== (i = o[s]).style && !oe(i.color) && 0 < i.width
                          ? 2 !== i.style
                            ? [3, 5]
                            : [
                                4,
                                this.renderDashedDottedBorder(
                                  i.color,
                                  i.width,
                                  n,
                                  c.curves,
                                  2
                                ),
                              ]
                          : [3, 11]
                        : [3, 13];
                    case 4:
                      return A.sent(), [3, 11];
                    case 5:
                      return 3 !== i.style
                        ? [3, 7]
                        : [
                            4,
                            this.renderDashedDottedBorder(
                              i.color,
                              i.width,
                              n,
                              c.curves,
                              3
                            ),
                          ];
                    case 6:
                      return A.sent(), [3, 11];
                    case 7:
                      return 4 !== i.style
                        ? [3, 9]
                        : [
                            4,
                            this.renderDoubleBorder(
                              i.color,
                              i.width,
                              n,
                              c.curves
                            ),
                          ];
                    case 8:
                      return A.sent(), [3, 11];
                    case 9:
                      return [4, this.renderSolidBorder(i.color, n, c.curves)];
                    case 10:
                      A.sent(), (A.label = 11);
                    case 11:
                      n++, (A.label = 12);
                    case 12:
                      return s++, [3, 3];
                    case 13:
                      return [2];
                  }
                });
              });
            }),
            (Ds.prototype.renderDashedDottedBorder = function (g, w, U, l, C) {
              return a(this, void 0, void 0, function () {
                var e, t, r, B, n, s, o, i, Q, c, a;
                return H(this, function (A) {
                  return (
                    this.ctx.save(),
                    (Q = (function (A, e) {
                      switch (e) {
                        case 0:
                          return fs(
                            A.topLeftBorderStroke,
                            A.topRightBorderStroke
                          );
                        case 1:
                          return fs(
                            A.topRightBorderStroke,
                            A.bottomRightBorderStroke
                          );
                        case 2:
                          return fs(
                            A.bottomRightBorderStroke,
                            A.bottomLeftBorderStroke
                          );
                        default:
                          return fs(
                            A.bottomLeftBorderStroke,
                            A.topLeftBorderStroke
                          );
                      }
                    })(l, U)),
                    (e = ws(l, U)),
                    2 === C && (this.path(e), this.ctx.clip()),
                    (s = $n(e[0])
                      ? ((t = e[0].start.x), e[0].start.y)
                      : ((t = e[0].x), e[0].y)),
                    (o = $n(e[1])
                      ? ((r = e[1].end.x), e[1].end.y)
                      : ((r = e[1].x), e[1].y)),
                    (B =
                      0 === U || 2 === U ? Math.abs(t - r) : Math.abs(s - o)),
                    this.ctx.beginPath(),
                    3 === C
                      ? this.formatPath(Q)
                      : this.formatPath(e.slice(0, 2)),
                    (n = w < 3 ? 3 * w : 2 * w),
                    (s = w < 3 ? 2 * w : w),
                    3 === C && (s = n = w),
                    (o = !0),
                    B <= 2 * n
                      ? (o = !1)
                      : B <= 2 * n + s
                      ? ((n *= i = B / (2 * n + s)), (s *= i))
                      : ((Q = Math.floor((B + s) / (n + s))),
                        (i = (B - Q * n) / (Q - 1)),
                        (s =
                          (Q = (B - (Q + 1) * n) / Q) <= 0 ||
                          Math.abs(s - i) < Math.abs(s - Q)
                            ? i
                            : Q)),
                    o &&
                      (3 === C
                        ? this.ctx.setLineDash([0, n + s])
                        : this.ctx.setLineDash([n, s])),
                    3 === C
                      ? ((this.ctx.lineCap = "round"), (this.ctx.lineWidth = w))
                      : (this.ctx.lineWidth = 2 * w + 1.1),
                    (this.ctx.strokeStyle = ie(g)),
                    this.ctx.stroke(),
                    this.ctx.setLineDash([]),
                    2 === C &&
                      ($n(e[0]) &&
                        ((c = e[3]),
                        (a = e[0]),
                        this.ctx.beginPath(),
                        this.formatPath([
                          new Zn(c.end.x, c.end.y),
                          new Zn(a.start.x, a.start.y),
                        ]),
                        this.ctx.stroke()),
                      $n(e[1]) &&
                        ((c = e[1]),
                        (a = e[2]),
                        this.ctx.beginPath(),
                        this.formatPath([
                          new Zn(c.end.x, c.end.y),
                          new Zn(a.start.x, a.start.y),
                        ]),
                        this.ctx.stroke())),
                    this.ctx.restore(),
                    [2]
                  );
                });
              });
            }),
            (Ds.prototype.render = function (B) {
              return a(this, void 0, void 0, function () {
                return H(this, function (A) {
                  switch (A.label) {
                    case 0:
                      return (
                        this.options.backgroundColor &&
                          ((this.ctx.fillStyle = ie(
                            this.options.backgroundColor
                          )),
                          this.ctx.fillRect(
                            this.options.x,
                            this.options.y,
                            this.options.width,
                            this.options.height
                          )),
                        (t = new as((e = B), null)),
                        (r = new cs(t)),
                        hs(t, r, r, (e = [])),
                        ds(t.container, e),
                        [4, this.renderStack(r)]
                      );
                    case 1:
                      return A.sent(), this.applyEffects([]), [2, this.canvas];
                  }
                  var e, t, r;
                });
              });
            }),
            Ds);
        function Ds(A, e) {
          A = Ls.call(this, A, e) || this;
          return (
            (A._activeEffects = []),
            (A.canvas = e.canvas || document.createElement("canvas")),
            (A.ctx = A.canvas.getContext("2d")),
            e.canvas ||
              ((A.canvas.width = Math.floor(e.width * e.scale)),
              (A.canvas.height = Math.floor(e.height * e.scale)),
              (A.canvas.style.width = e.width + "px"),
              (A.canvas.style.height = e.height + "px")),
            (A.fontMetrics = new Ks(document)),
            A.ctx.scale(A.options.scale, A.options.scale),
            A.ctx.translate(-e.x, -e.y),
            (A.ctx.textBaseline = "bottom"),
            (A._activeEffects = []),
            A.context.logger.debug(
              "Canvas renderer initialized (" +
                e.width +
                "x" +
                e.height +
                ") with scale " +
                e.scale
            ),
            A
          );
        }
        var vs,
          xs = function (A) {
            return (
              A instanceof LB ||
              A instanceof yB ||
              (A instanceof pB && A.type !== dB && A.type !== hB)
            );
          },
          Ms = function (A, e) {
            switch (A) {
              case 0:
                return ts(e);
              case 2:
                return [
                  e.topLeftContentBox,
                  e.topRightContentBox,
                  e.bottomRightContentBox,
                  e.bottomLeftContentBox,
                ];
              default:
                return rs(e);
            }
          },
          Ss = function (A) {
            switch (A) {
              case 1:
                return "center";
              case 2:
                return "right";
              default:
                return "left";
            }
          },
          Ts = ["-apple-system", "system-ui"],
          Gs = function (A) {
            return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent)
              ? A.filter(function (A) {
                  return -1 === Ts.indexOf(A);
                })
              : A;
          },
          Os =
            (A(Vs, (vs = he)),
            (Vs.prototype.render = function (t) {
              return a(this, void 0, void 0, function () {
                var e;
                return H(this, function (A) {
                  switch (A.label) {
                    case 0:
                      return (
                        (e = Nr(
                          this.options.width * this.options.scale,
                          this.options.height * this.options.scale,
                          this.options.scale,
                          this.options.scale,
                          t
                        )),
                        [4, ks(e)]
                      );
                    case 1:
                      return (
                        (e = A.sent()),
                        this.options.backgroundColor &&
                          ((this.ctx.fillStyle = ie(
                            this.options.backgroundColor
                          )),
                          this.ctx.fillRect(
                            0,
                            0,
                            this.options.width * this.options.scale,
                            this.options.height * this.options.scale
                          )),
                        this.ctx.drawImage(
                          e,
                          -this.options.x * this.options.scale,
                          -this.options.y * this.options.scale
                        ),
                        [2, this.canvas]
                      );
                  }
                });
              });
            }),
            Vs);
        function Vs(A, e) {
          A = vs.call(this, A, e) || this;
          return (
            (A.canvas = e.canvas || document.createElement("canvas")),
            (A.ctx = A.canvas.getContext("2d")),
            (A.options = e),
            (A.canvas.width = Math.floor(e.width * e.scale)),
            (A.canvas.height = Math.floor(e.height * e.scale)),
            (A.canvas.style.width = e.width + "px"),
            (A.canvas.style.height = e.height + "px"),
            A.ctx.scale(A.options.scale, A.options.scale),
            A.ctx.translate(-e.x, -e.y),
            A.context.logger.debug(
              "EXPERIMENTAL ForeignObject renderer initialized (" +
                e.width +
                "x" +
                e.height +
                " at " +
                e.x +
                "," +
                e.y +
                ") with scale " +
                e.scale
            ),
            A
          );
        }
        var ks = function (r) {
            return new Promise(function (A, e) {
              var t = new Image();
              (t.onload = function () {
                A(t);
              }),
                (t.onerror = e),
                (t.src =
                  "data:image/svg+xml;charset=utf-8," +
                  encodeURIComponent(new XMLSerializer().serializeToString(r)));
            });
          },
          Rs =
            ((Ns.prototype.debug = function () {
              for (var A = [], e = 0; e < arguments.length; e++)
                A[e] = arguments[e];
              this.enabled &&
                ("undefined" != typeof window &&
                window.console &&
                "function" == typeof console.debug
                  ? console.debug.apply(
                      console,
                      t([this.id, this.getTime() + "ms"], A)
                    )
                  : this.info.apply(this, A));
            }),
            (Ns.prototype.getTime = function () {
              return Date.now() - this.start;
            }),
            (Ns.prototype.info = function () {
              for (var A = [], e = 0; e < arguments.length; e++)
                A[e] = arguments[e];
              this.enabled &&
                "undefined" != typeof window &&
                window.console &&
                "function" == typeof console.info &&
                console.info.apply(
                  console,
                  t([this.id, this.getTime() + "ms"], A)
                );
            }),
            (Ns.prototype.warn = function () {
              for (var A = [], e = 0; e < arguments.length; e++)
                A[e] = arguments[e];
              this.enabled &&
                ("undefined" != typeof window &&
                window.console &&
                "function" == typeof console.warn
                  ? console.warn.apply(
                      console,
                      t([this.id, this.getTime() + "ms"], A)
                    )
                  : this.info.apply(this, A));
            }),
            (Ns.prototype.error = function () {
              for (var A = [], e = 0; e < arguments.length; e++)
                A[e] = arguments[e];
              this.enabled &&
                ("undefined" != typeof window &&
                window.console &&
                "function" == typeof console.error
                  ? console.error.apply(
                      console,
                      t([this.id, this.getTime() + "ms"], A)
                    )
                  : this.info.apply(this, A));
            }),
            (Ns.instances = {}),
            Ns);
        function Ns(A) {
          var e = A.id,
            A = A.enabled;
          (this.id = e), (this.enabled = A), (this.start = Date.now());
        }
        var Ps = ((Xs.instanceCount = 1), Xs);
        function Xs(A, e) {
          (this.windowBounds = e),
            (this.instanceName = "#" + Xs.instanceCount++),
            (this.logger = new Rs({
              id: this.instanceName,
              enabled: A.logging,
            })),
            (this.cache =
              null !== (e = A.cache) && void 0 !== e ? e : new On(this, A));
        }
        "undefined" != typeof window && Tn.setContext(window);
        var Js = function (u, F) {
            return a(void 0, void 0, void 0, function () {
              var e, t, r, B, n, s, o, i, Q, c, a, g, w, U, l, C;
              return H(this, function (A) {
                switch (A.label) {
                  case 0:
                    if (!u || "object" != typeof u)
                      return [
                        2,
                        Promise.reject(
                          "Invalid element provided as first argument"
                        ),
                      ];
                    if (!(e = u.ownerDocument))
                      throw new Error("Element is not attached to a Document");
                    if (!(t = e.defaultView))
                      throw new Error("Document is not attached to a Window");
                    return (
                      (w = {
                        allowTaint:
                          null !== (U = F.allowTaint) && void 0 !== U && U,
                        imageTimeout:
                          null !== (c = F.imageTimeout) && void 0 !== c
                            ? c
                            : 15e3,
                        proxy: F.proxy,
                        useCORS: null !== (a = F.useCORS) && void 0 !== a && a,
                      }),
                      (U = h(
                        {
                          logging:
                            null === (g = F.logging) || void 0 === g || g,
                          cache: F.cache,
                        },
                        w
                      )),
                      (c = {
                        windowWidth:
                          null !== (c = F.windowWidth) && void 0 !== c
                            ? c
                            : t.innerWidth,
                        windowHeight:
                          null !== (a = F.windowHeight) && void 0 !== a
                            ? a
                            : t.innerHeight,
                        scrollX:
                          null !== (g = F.scrollX) && void 0 !== g
                            ? g
                            : t.pageXOffset,
                        scrollY:
                          null !== (w = F.scrollY) && void 0 !== w
                            ? w
                            : t.pageYOffset,
                      }),
                      (a = new d(
                        c.scrollX,
                        c.scrollY,
                        c.windowWidth,
                        c.windowHeight
                      )),
                      (g = new Ps(U, a)),
                      (c =
                        null !== (w = F.foreignObjectRendering) &&
                        void 0 !== w &&
                        w),
                      (w = {
                        allowTaint:
                          null !== (U = F.allowTaint) && void 0 !== U && U,
                        onclone: F.onclone,
                        ignoreElements: F.ignoreElements,
                        inlineImages: c,
                        copyStyles: c,
                      }),
                      g.logger.debug(
                        "Starting document clone with size " +
                          a.width +
                          "x" +
                          a.height +
                          " scrolled to " +
                          -a.left +
                          "," +
                          -a.top
                      ),
                      (U = new dn(g, u, w)),
                      (w = U.clonedReferenceElement)
                        ? [4, U.toIFrame(e, a)]
                        : [
                            2,
                            Promise.reject(
                              "Unable to find element in cloned iframe"
                            ),
                          ]
                    );
                  case 1:
                    return ((r = A.sent()),
                    (l =
                      jB(w) || "HTML" === w.tagName
                        ? (function (A) {
                            var e = A.body,
                              t = A.documentElement;
                            if (!e || !t)
                              throw new Error("Unable to get document size");
                            (A = Math.max(
                              Math.max(e.scrollWidth, t.scrollWidth),
                              Math.max(e.offsetWidth, t.offsetWidth),
                              Math.max(e.clientWidth, t.clientWidth)
                            )),
                              (t = Math.max(
                                Math.max(e.scrollHeight, t.scrollHeight),
                                Math.max(e.offsetHeight, t.offsetHeight),
                                Math.max(e.clientHeight, t.clientHeight)
                              ));
                            return new d(0, 0, A, t);
                          })(w.ownerDocument)
                        : f(g, w)),
                    (B = l.width),
                    (n = l.height),
                    (s = l.left),
                    (o = l.top),
                    (i = Ys(g, w, F.backgroundColor)),
                    (l = {
                      canvas: F.canvas,
                      backgroundColor: i,
                      scale:
                        null !==
                          (l =
                            null !== (l = F.scale) && void 0 !== l
                              ? l
                              : t.devicePixelRatio) && void 0 !== l
                          ? l
                          : 1,
                      x: (null !== (l = F.x) && void 0 !== l ? l : 0) + s,
                      y: (null !== (l = F.y) && void 0 !== l ? l : 0) + o,
                      width:
                        null !== (l = F.width) && void 0 !== l
                          ? l
                          : Math.ceil(B),
                      height:
                        null !== (l = F.height) && void 0 !== l
                          ? l
                          : Math.ceil(n),
                    }),
                    c)
                      ? (g.logger.debug(
                          "Document cloned, using foreign object rendering"
                        ),
                        [4, new Os(g, l).render(w)])
                      : [3, 3];
                  case 2:
                    return (Q = A.sent()), [3, 5];
                  case 3:
                    return (
                      g.logger.debug(
                        "Document cloned, element located at " +
                          s +
                          "," +
                          o +
                          " with size " +
                          B +
                          "x" +
                          n +
                          " using computed rendering"
                      ),
                      g.logger.debug("Starting DOM parsing"),
                      (C = kB(g, w)),
                      i === C.styles.backgroundColor &&
                        (C.styles.backgroundColor = Le.TRANSPARENT),
                      g.logger.debug(
                        "Starting renderer for element at " +
                          l.x +
                          "," +
                          l.y +
                          " with size " +
                          l.width +
                          "x" +
                          l.height
                      ),
                      [4, new bs(g, l).render(C)]
                    );
                  case 4:
                    (Q = A.sent()), (A.label = 5);
                  case 5:
                    return (
                      (null !== (C = F.removeContainer) &&
                        void 0 !== C &&
                        !C) ||
                        dn.destroy(r) ||
                        g.logger.error(
                          "Cannot detach cloned iframe as it is not in the DOM anymore"
                        ),
                      g.logger.debug("Finished rendering"),
                      [2, Q]
                    );
                }
              });
            });
          },
          Ys = function (A, e, t) {
            var r = e.ownerDocument,
              B = r.documentElement
                ? fe(A, getComputedStyle(r.documentElement).backgroundColor)
                : Le.TRANSPARENT,
              n = r.body
                ? fe(A, getComputedStyle(r.body).backgroundColor)
                : Le.TRANSPARENT,
              t =
                "string" == typeof t
                  ? fe(A, t)
                  : null === t
                  ? Le.TRANSPARENT
                  : 4294967295;
            return e === r.documentElement ? (oe(B) ? (oe(n) ? t : n) : B) : t;
          };
        return function (A, e) {
          return Js(A, (e = void 0 === e ? {} : e));
        };
      });
    </script>
    <style>
      :root {
        --primary-color: #2563eb;
        --primary-hover: #1d4ed8;
        --bg-color: #f9fafb;
        --text-color: #111827;
        --border-color: #e5e7eb;
      }

      body {
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        padding: 0;
        line-height: 1.5;
      }

      .container {
        max-width: 56rem; /* max-w-4xl */
        margin: 0 auto;
        padding: 1rem;
      }

      @media (min-width: 768px) {
        .container {
          padding: 2rem;
        }
      }

      /* Header */
      header {
        background-color: white;
        padding: 1rem;
        border-radius: 0.75rem;
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 2rem;
      }

      h1 {
        font-size: 1.25rem;
        font-weight: 700;
        color: #1f2937;
        margin: 0;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        font-weight: 500;
        cursor: pointer;
        border: none;
        transition: background-color 0.2s;
        font-size: 0.875rem;
      }

      .btn-primary {
        background-color: var(--primary-color);
        color: white;
      }

      .btn-primary:hover {
        background-color: var(--primary-hover);
      }

      .btn-secondary {
        background-color: #f3f4f6;
        color: #374151;
      }

      .btn-secondary:hover {
        background-color: #e5e7eb;
      }

      .btn-blue-light {
        background-color: #eff6ff;
        color: #1d4ed8;
      }

      .btn-blue-light:hover {
        background-color: #dbeafe;
      }

      .wallet-badge {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background-color: #f0fdf4;
        color: #15803d;
        border: 1px solid #dcfce7;
        border-radius: 9999px;
        font-size: 0.875rem;
        font-weight: 500;
      }

      .status-dot {
        width: 0.5rem;
        height: 0.5rem;
        background-color: #22c55e;
        border-radius: 50%;
      }

      /* Main Content */
      .card {
        background-color: white;
        border-radius: 1rem;
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        border: 1px solid var(--border-color);
        padding: 1.5rem;
      }

      @media (min-width: 768px) {
        .card {
          padding: 2rem;
        }
      }

      .welcome-screen {
        text-align: center;
        padding: 5rem 0;
      }

      .icon-circle {
        width: 4rem;
        height: 4rem;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 1rem;
      }

      .bg-blue-50 {
        background-color: #eff6ff;
      }
      .bg-yellow-50 {
        background-color: #fefce8;
      }
      .text-blue-600 {
        color: #2563eb;
      }
      .text-yellow-600 {
        color: #ca8a04;
      }

      /* Form */
      .form-grid {
        display: grid;
        gap: 1.5rem;
      }

      @media (min-width: 768px) {
        .grid-cols-2 {
          grid-template-columns: repeat(2, 1fr);
        }
        .grid-cols-3 {
          grid-template-columns: repeat(3, 1fr);
        }
      }

      .form-group {
        margin-bottom: 0.5rem;
      }

      label {
        display: block;
        font-size: 0.875rem;
        font-weight: 500;
        color: #374151;
        margin-bottom: 0.25rem;
      }

      input[type="text"],
      input[type="date"],
      input[type="time"],
      textarea {
        width: 100%;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        border: 1px solid #e5e7eb;
        outline: none;
        box-sizing: border-box; /* Important for width: 100% */
      }

      input:focus,
      textarea:focus {
        border-color: #2563eb;
        box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
      }

      textarea {
        resize: none;
      }

      .checkbox-wrapper {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: 0.5rem;
      }

      /* Preview */
      .preview-container {
        padding: 2rem;
        border: 1px solid #e5e7eb;
        border-radius: 0.75rem;
        background-color: white;
        color: black;
        font-family: "Times New Roman", Times, serif;
        max-width: 42rem; /* max-w-2xl */
        margin: 0 auto;
      }

      .preview-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 2rem;
      }

      .digital-signature {
        font-family: monospace;
        font-size: 0.75rem;
        padding: 0.25rem;
        border-radius: 0.25rem;
        border: 1px solid #bbf7d0;
        background-color: #f0fdf4;
        color: #15803d;
        word-break: break-all;
        display: inline-block;
        margin-left: 8px;
        margin-top: 8px;
      }

      .agenda-box {
        padding-left: 1rem;
        border-left: 2px solid #d1d5db;
        white-space: pre-line;
      }

      .hidden {
        display: none !important;
      }

      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Comitato Studentesco</h1>
        <div id="wallet-controls">
          <button id="btn-connect" class="btn btn-primary">
            <svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M20 12V8H6a2 2 0 0 1-2-2c0-1.1.9-2 2-2h12v4" />
              <path d="M4 6v12a2 2 0 0 0 2 2h14v-4" />
              <path d="M18 12a2 2 0 0 0-2 2c0 1.1.9 2 2 2h4v-4h-4z" />
            </svg>
            Connect Wallet
          </button>
          <div
            id="wallet-info"
            class="hidden"
            style="display: flex; align-items: center; gap: 1rem"
          >
            <div class="wallet-badge">
              <div class="status-dot"></div>
              <span id="address-display"></span>
            </div>
            <button
              id="btn-disconnect"
              class="btn"
              style="color: #6b7280"
              title="Disconnetti"
            >
              <svg
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
                <polyline points="16 17 21 12 16 7" />
                <line x1="21" y1="12" x2="9" y2="12" />
              </svg>
            </button>
          </div>
        </div>
      </header>

      <main id="main-content">
        <!-- Welcome Screen -->
        <div id="welcome-screen" class="card welcome-screen">
          <div class="icon-circle bg-blue-50">
            <svg
              width="32"
              height="32"
              viewBox="0 0 24 24"
              fill="none"
              stroke="#2563eb"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M20 12V8H6a2 2 0 0 1-2-2c0-1.1.9-2 2-2h12v4" />
              <path d="M4 6v12a2 2 0 0 0 2 2h14v-4" />
              <path d="M18 12a2 2 0 0 0-2 2c0 1.1.9 2 2 2h4v-4h-4z" />
            </svg>
          </div>
          <h2
            style="
              font-size: 1.5rem;
              font-weight: 700;
              color: #111827;
              margin-bottom: 0.5rem;
            "
          >
            Welcome
          </h2>
          <p style="color: #6b7280; margin-bottom: 1.5rem">
            Please connect your wallet to continue.
          </p>
          <button
            id="btn-connect-hero"
            class="btn btn-primary"
            style="padding: 0.75rem 1.5rem; font-size: 1rem"
          >
            Connect MetaMask
          </button>
        </div>

        <!-- Access Restricted -->
        <div id="restricted-screen" class="card welcome-screen hidden">
          <div class="icon-circle bg-yellow-50">
            <svg
              width="32"
              height="32"
              viewBox="0 0 24 24"
              fill="none"
              stroke="#ca8a04"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />
              <line x1="12" y1="8" x2="12" y2="12" />
              <line x1="12" y1="16" x2="12.01" y2="16" />
            </svg>
          </div>
          <h2
            style="
              font-size: 1.5rem;
              font-weight: 700;
              color: #111827;
              margin-bottom: 0.5rem;
            "
          >
            Access Restricted
          </h2>
          <p style="color: #6b7280">
            Only Student Council representatives can access the system.
          </p>
        </div>

        <!-- Assembly Request -->
        <div id="app-screen" class="card hidden">
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 1.5rem;
            "
          >
            <div>
              <h2
                style="
                  font-size: 1.25rem;
                  font-weight: 700;
                  display: flex;
                  align-items: center;
                  gap: 0.5rem;
                "
              >
                <svg
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="#2563eb"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
                  />
                  <polyline points="14 2 14 8 20 8" />
                  <line x1="16" y1="13" x2="8" y2="13" />
                  <line x1="16" y1="17" x2="8" y2="17" />
                  <polyline points="10 9 9 9 8 9" />
                </svg>
                Richiesta Assemblea
              </h2>
              <p style="color: #6b7280; font-size: 0.875rem">
                Compila il modulo per generare la richiesta ufficiale.
              </p>
            </div>
            <button id="btn-toggle-view" class="btn btn-secondary">
              <span id="view-icon-edit" class="hidden">
                <svg
                  width="16"
                  height="16"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"
                  />
                  <path
                    d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"
                  />
                </svg>
              </span>
              <span id="view-icon-preview">
                <svg
                  width="16"
                  height="16"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
                  />
                  <polyline points="14 2 14 8 20 8" />
                  <line x1="16" y1="13" x2="8" y2="13" />
                  <line x1="16" y1="17" x2="8" y2="17" />
                  <polyline points="10 9 9 9 8 9" />
                </svg>
              </span>
              <span id="view-text">Anteprima</span>
            </button>
          </div>

          <!-- Edit Form -->
          <div id="edit-form" class="fade-in">
            <div class="form-grid grid-cols-2">
              <div class="form-group">
                <label>Nome Rappresentante</label>
                <input type="text" id="input-name" placeholder="Mario Rossi" />
              </div>
              <div class="form-group">
                <label>Luogo</label>
                <input type="text" id="input-location" value="Aula Magna" />
                <div class="checkbox-wrapper">
                  <input type="checkbox" id="input-mandatory" />
                  <label
                    for="input-mandatory"
                    style="cursor: pointer; user-select: none"
                    >Obbligo presenza rappresentanti</label
                  >
                </div>
              </div>
            </div>

            <div class="form-grid grid-cols-3" style="margin-top: 1.5rem">
              <div class="form-group">
                <label>Data</label>
                <input type="date" id="input-date" />
              </div>
              <div class="form-group">
                <label>Ora Inizio</label>
                <input type="time" id="input-start" value="08:00" />
              </div>
              <div class="form-group">
                <label>Ora Fine</label>
                <input type="time" id="input-end" value="10:00" />
              </div>
            </div>

            <div class="form-group" style="margin-top: 1.5rem">
              <label>Ordine del Giorno</label>
              <textarea
                id="input-agenda"
                rows="6"
                placeholder="Inserisci i punti dell'ordine del giorno..."
              >
1. Discussione problemi scolastici
2. Proposte attivit extrascolastiche
3. Varie ed eventuali</textarea
              >
            </div>
          </div>

          <!-- Preview -->
          <div id="preview-section" class="hidden fade-in">
            <div id="pdf-preview" class="preview-container">
              <div class="preview-header">
                <!-- Logo SVG -->
                <svg
                  width="100"
                  height="115"
                  viewBox="0 0 621 717"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M280.604 67.8977L43.8683 204.577L107.088 241.077L280.604 140.898V67.8977Z"
                    fill="#FFD900"
                  />
                  <path
                    d="M107.088 241.077L43.8683 204.577V512.577L75.4782 494.327L91.2831 485.202L107.088 476.077L107.088 241.077Z"
                    fill="#FF0062"
                  />
                  <path
                    d="M43.8683 512.577L280.604 649.257V576.257L107.088 476.077L91.2831 485.202L75.4782 494.327L43.8683 512.577Z"
                    fill="#FF4000"
                  />
                  <path
                    d="M340.604 140.898V308.577H370.604H400.604V175.539L514.12 241.077L545.73 222.827L577.34 204.577L340.604 67.8977V123.577V140.898Z"
                    fill="#FF0000"
                  />
                  <path
                    d="M340.604 368.577H400.604H514.12H576.821L576.604 308.577H514.12H447.5H400.604H370.604H340.604V368.577Z"
                    fill="#358445"
                  />
                  <path
                    fill-rule="evenodd"
                    clip-rule="evenodd"
                    d="M310.104 0.577148L619.708 179.327V536.827L310.104 715.577L0.5 536.827V179.327L310.104 0.577148ZM43.8683 204.577L280.604 67.8977V140.898L107.088 241.077L107.088 476.077L280.604 576.257V649.257L43.8683 512.577V204.577ZM340.604 308.577V140.898V123.577V67.8977L577.34 204.577L545.73 222.827L514.12 241.077L400.604 175.539V308.577H447.5H514.12H576.604L576.821 368.577L577.34 512.577L514.12 549.077L340.604 649.257V576.257L514.12 476.077V368.577H400.604H340.604V308.577Z"
                    fill="white"
                  />
                  <path
                    fill-rule="evenodd"
                    clip-rule="evenodd"
                    d="M514.12 476.077V368.577H576.821L577.34 512.577L514.12 549.077V476.077Z"
                    fill="#00B7FF"
                  />
                  <path
                    d="M340.604 576.257V649.257L514.12 549.077V476.077L340.604 576.257Z"
                    fill="#373636"
                  />
                  <path
                    d="M43.8683 204.577L280.604 67.8977V140.898L107.088 241.077M43.8683 204.577L107.088 241.077M43.8683 204.577V512.577M107.088 241.077L107.088 476.077M340.604 368.577H400.604H514.12M340.604 368.577V140.898M340.604 368.577V308.577M340.604 368.577H514.12M340.604 140.898V123.577V67.8977M340.604 140.898V67.8977M340.604 140.898V308.577M340.604 308.577H370.604H400.604M43.8683 512.577L280.604 649.257V576.257L107.088 476.077M43.8683 512.577L75.4782 494.327L91.2831 485.202M43.8683 512.577L91.2831 485.202M43.8683 512.577L107.088 476.077M514.12 476.077V368.577M514.12 476.077L340.604 576.257V649.257L514.12 549.077M514.12 476.077V549.077M107.088 476.077L91.2831 485.202M340.604 67.8977L577.34 204.577L545.73 222.827L514.12 241.077L400.604 175.539V308.577M400.604 308.577H447.5H514.12H576.604L576.821 368.577M514.12 368.577H576.821M576.821 368.577L577.34 512.577L514.12 549.077M619.708 179.327L310.104 0.577148L0.5 179.327V536.827L310.104 715.577L619.708 536.827V179.327Z"
                    stroke="#373636"
                  />
                </svg>
                <div style="text-align: right">
                  <p>Alla Dirigenza Scolastica</p>
                </div>
              </div>

              <div style="margin-bottom: 1.5rem">
                <p>
                  <span style="font-weight: bold">Oggetto:</span> Richiesta
                  Assemblea di Istituto
                </p>
              </div>

              <div style="line-height: 1.625; color: black">
                <p style="margin-bottom: 1rem">
                  Il sottoscritto Rappresentante degli Studenti
                  <strong id="preview-name">[Nome Cognome]</strong>,
                  <span id="signature-container">
                    <button
                      id="btn-sign-preview"
                      class="btn btn-blue-light"
                      style="
                        padding: 0.25rem 0.5rem;
                        font-size: 0.75rem;
                        vertical-align: middle;
                      "
                    >
                      <svg
                        width="12"
                        height="12"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                      >
                        <path d="M12 19l7-7 3 3-7 7-3-3z" />
                        <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z" />
                        <path d="M2 2l7.586 7.586" />
                        <circle cx="11" cy="11" r="2" />
                      </svg>
                      Firma con MetaMask
                    </button>
                  </span>
                </p>
                <p style="margin-bottom: 0">
                  CHIEDE A NOME DEL COMITATO STUDENTESCO
                </p>
                <p style="margin-top: 0">
                  di poter effettuare un'assemblea di istituto il giorno
                  <strong id="preview-date"></strong>
                  dalle ore <strong id="preview-start"></strong> alle ore
                  <strong id="preview-end"></strong> presso
                  <strong id="preview-location"></strong
                  ><span id="preview-mandatory"></span>.
                </p>
                <p>L'assemblea avr il seguente Ordine del Giorno:</p>
                <div id="preview-agenda" class="agenda-box"></div>
              </div>

              <div
                style="
                  margin-top: 3rem;
                  display: flex;
                  justify-content: flex-end;
                "
              >
                <div style="text-align: center">
                  <p>Il Rappresentante</p>
                  <div style="height: 3rem"></div>
                  <p
                    style="border-top: 1px solid #9ca3af; padding-top: 0.25rem"
                    id="preview-name-bottom"
                  >
                    Firma
                  </p>
                </div>
              </div>
            </div>
          </div>

          <!-- Footer Actions -->
          <div
            style="
              margin-top: 2rem;
              display: flex;
              justify-content: flex-end;
              padding-top: 1.5rem;
              border-top: 1px solid #f3f4f6;
            "
          >
            <button
              id="btn-action"
              class="btn btn-primary"
              style="padding: 0.625rem 1.5rem"
            >
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path
                  d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"
                />
                <polyline points="17 21 17 13 7 13 7 21" />
                <polyline points="7 3 7 8 15 8" />
              </svg>
              Firma e Salva
            </button>
          </div>
        </div>
      </main>
    </div>

    <script>
      // Configuration
      const CONTRACT_ADDRESS = "0x88F2D5c26395dEdbF978079e5142cAf548688e72";
      const ABI_FRAGMENT = [
        "function isRepresentative(address) view returns (bool)",
      ];

      // State
      const state = {
        address: null,
        isRepresentative: false,
        isEditing: true,
        signature: null,
        formData: {
          representativeName: "",
          date: new Date().toISOString().split("T")[0],
          startTime: "08:00",
          endTime: "10:00",
          location: "Aula Magna",
          mandatoryAttendance: false,
          agenda:
            "1. Discussione problemi scolastici\n2. Proposte attivit extrascolastiche\n3. Varie ed eventuali",
        },
      };

      // DOM Elements
      const els = {
        welcomeScreen: document.getElementById("welcome-screen"),
        restrictedScreen: document.getElementById("restricted-screen"),
        appScreen: document.getElementById("app-screen"),
        walletInfo: document.getElementById("wallet-info"),
        btnConnect: document.getElementById("btn-connect"),
        btnConnectHero: document.getElementById("btn-connect-hero"),
        btnDisconnect: document.getElementById("btn-disconnect"),
        addressDisplay: document.getElementById("address-display"),

        btnToggleView: document.getElementById("btn-toggle-view"),
        viewIconEdit: document.getElementById("view-icon-edit"),
        viewIconPreview: document.getElementById("view-icon-preview"),
        viewText: document.getElementById("view-text"),

        editForm: document.getElementById("edit-form"),
        previewSection: document.getElementById("preview-section"),

        inputs: {
          name: document.getElementById("input-name"),
          date: document.getElementById("input-date"),
          start: document.getElementById("input-start"),
          end: document.getElementById("input-end"),
          location: document.getElementById("input-location"),
          mandatory: document.getElementById("input-mandatory"),
          agenda: document.getElementById("input-agenda"),
        },

        preview: {
          name: document.getElementById("preview-name"),
          nameBottom: document.getElementById("preview-name-bottom"),
          date: document.getElementById("preview-date"),
          start: document.getElementById("preview-start"),
          end: document.getElementById("preview-end"),
          location: document.getElementById("preview-location"),
          mandatory: document.getElementById("preview-mandatory"),
          agenda: document.getElementById("preview-agenda"),
          signatureContainer: document.getElementById("signature-container"),
          pdf: document.getElementById("pdf-preview"),
        },

        btnAction: document.getElementById("btn-action"),
      };

      // Initialize
      function init() {
        setupEventListeners();
        updateUI();

        // Initial form values
        els.inputs.date.value = state.formData.date;
        els.inputs.agenda.value = state.formData.agenda;

        // Check if already connected
        if (typeof window.ethereum !== "undefined") {
          window.ethereum
            .request({ method: "eth_accounts" })
            .then((accounts) => {
              if (accounts.length > 0) {
                handleAccountsChanged(accounts);
              }
            })
            .catch(console.error);

          window.ethereum.on("accountsChanged", handleAccountsChanged);
        }
      }

      function setupEventListeners() {
        els.btnConnect.addEventListener("click", connectWallet);
        els.btnConnectHero.addEventListener("click", connectWallet);
        els.btnDisconnect.addEventListener("click", disconnectWallet);

        els.btnToggleView.addEventListener("click", toggleView);

        // Input listeners
        Object.keys(els.inputs).forEach((key) => {
          els.inputs[key].addEventListener("input", (e) => {
            const value =
              e.target.type === "checkbox" ? e.target.checked : e.target.value;
            state.formData[
              key === "name"
                ? "representativeName"
                : key === "start"
                ? "startTime"
                : key === "end"
                ? "endTime"
                : key
            ] = value;

            // Reset signature on change
            if (state.signature) {
              state.signature = null;
              updatePreviewSignature();
              updateActionButton();
            }
          });
        });

        // Agenda auto-numbering
        els.inputs.agenda.addEventListener("keydown", handleAgendaKeydown);

        // Action button (Sign & Save)
        els.btnAction.addEventListener("click", handleAction);
      }

      // Logic
      async function connectWallet() {
        if (typeof window.ethereum === "undefined") {
          alert("MetaMask non installato!");
          return;
        }

        try {
          // Request permissions to open the account selection modal
          try {
            await window.ethereum.request({
              method: "wallet_requestPermissions",
              params: [{ eth_accounts: {} }],
            });
          } catch (err) {
            console.error("Permissions request failed", err);
          }

          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts",
          });
          handleAccountsChanged(accounts);
        } catch (error) {
          console.error(error);
        }
      }

      function disconnectWallet() {
        state.address = null;
        state.isRepresentative = false;
        state.signature = null;
        updateUI();
      }

      async function handleAccountsChanged(accounts) {
        if (accounts.length === 0) {
          disconnectWallet();
        } else {
          state.address = accounts[0];
          await checkRepresentativeStatus(accounts[0]);
          updateUI();
        }
      }

      async function checkRepresentativeStatus(address) {
        try {
          const provider = new ethers.BrowserProvider(window.ethereum);
          const contract = new ethers.Contract(
            CONTRACT_ADDRESS,
            ABI_FRAGMENT,
            provider
          );
          const isRep = await contract.isRepresentative(address);
          console.log(`Is representative: ${isRep}`);
          state.isRepresentative = isRep;
        } catch (error) {
          console.error("Error checking representative status:", error);
          // For testing purposes if contract fails/network wrong, we might want to fallback or alert
          // But strict requirement says "isRepresentative", so we default false on error
          state.isRepresentative = false;
        }
      }

      function updateUI() {
        // Wallet Info Header
        if (state.address) {
          els.btnConnect.classList.add("hidden");
          els.walletInfo.classList.remove("hidden");
          els.addressDisplay.textContent = `${state.address.slice(
            0,
            6
          )}...${state.address.slice(-4)}`;
        } else {
          els.btnConnect.classList.remove("hidden");
          els.walletInfo.classList.add("hidden");
        }

        // Main Content
        if (!state.address) {
          els.welcomeScreen.classList.remove("hidden");
          els.restrictedScreen.classList.add("hidden");
          els.appScreen.classList.add("hidden");
        } else if (!state.isRepresentative) {
          els.welcomeScreen.classList.add("hidden");
          els.restrictedScreen.classList.remove("hidden");
          els.appScreen.classList.add("hidden");
        } else {
          els.welcomeScreen.classList.add("hidden");
          els.restrictedScreen.classList.add("hidden");
          els.appScreen.classList.remove("hidden");
        }

        updateActionButton();
      }

      function toggleView() {
        state.isEditing = !state.isEditing;

        if (state.isEditing) {
          els.editForm.classList.remove("hidden");
          els.previewSection.classList.add("hidden");
          els.viewIconEdit.classList.add("hidden");
          els.viewIconPreview.classList.remove("hidden");
          els.viewText.textContent = "Anteprima";
          els.btnToggleView.classList.remove("btn-blue-light");
          els.btnToggleView.classList.add("btn-secondary");
        } else {
          updatePreviewContent();
          els.editForm.classList.add("hidden");
          els.previewSection.classList.remove("hidden");
          els.viewIconEdit.classList.remove("hidden");
          els.viewIconPreview.classList.add("hidden");
          els.viewText.textContent = "Modifica";
          els.btnToggleView.classList.remove("btn-secondary");
          els.btnToggleView.classList.add("btn-blue-light");
        }
      }

      function updatePreviewContent() {
        const d = state.formData;
        els.preview.name.textContent = d.representativeName || "[Nome Cognome]";
        els.preview.nameBottom.textContent = d.representativeName || "Firma";

        const dateObj = new Date(d.date);
        els.preview.date.textContent = !isNaN(dateObj)
          ? dateObj.toLocaleDateString("it-IT")
          : d.date;

        els.preview.start.textContent = d.startTime;
        els.preview.end.textContent = d.endTime;
        els.preview.location.textContent = d.location;

        if (d.mandatoryAttendance) {
          els.preview.mandatory.textContent =
            " alla quale dovranno obbligatoriamente partecipare tutti i rappresentanti degli studenti";
        } else {
          els.preview.mandatory.textContent = "";
        }

        els.preview.agenda.textContent = d.agenda;

        updatePreviewSignature();
      }

      function updatePreviewSignature() {
        const container = els.preview.signatureContainer;
        if (state.signature) {
          container.innerHTML = `<span style="color:#15803d; font-weight:500; margin-right:4px;">con firma digitale</span><span class="digital-signature">${state.signature}</span>`;
        } else {
          container.innerHTML = ""; // Clear first
          const btn = document.createElement("button");
          btn.className = "btn btn-blue-light";
          btn.style.cssText =
            "padding: 0.25rem 0.5rem; font-size: 0.75rem; vertical-align: middle; display: inline-flex; align-items: center; gap: 0.25rem;";
          btn.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg> Firma con MetaMask`;
          btn.onclick = handleSign;
          container.appendChild(btn);
        }
      }

      function handleAgendaKeydown(e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          const textarea = e.currentTarget;
          const { selectionStart, selectionEnd, value } = textarea;
          const textBefore = value.substring(0, selectionStart);
          const textAfter = value.substring(selectionEnd);
          const matches = textBefore.match(/(?:^|\n)(\d+)\.\s/g);
          let insertion = "\n";
          if (matches && matches.length > 0) {
            const lastMatch = matches[matches.length - 1];
            const numberMatch = lastMatch.match(/(\d+)/);
            if (numberMatch) {
              const nextNum = parseInt(numberMatch[1], 10) + 1;
              insertion = `\n${nextNum}. `;
            }
          }
          const newValue = textBefore + insertion + textAfter;
          state.formData.agenda = newValue;
          textarea.value = newValue;
          textarea.selectionStart = selectionStart + insertion.length;
          textarea.selectionEnd = selectionStart + insertion.length;
        }
      }

      async function handleSign() {
        if (typeof window.ethereum === "undefined") {
          alert("MetaMask non installato");
          return null;
        }

        try {
          const provider = new ethers.BrowserProvider(window.ethereum);
          const signer = await provider.getSigner();

          const message = `RICHIESTA ASSEMBLEA DI ISTITUTO
      
Rappresentante: ${state.formData.representativeName}
Data: ${state.formData.date}
Orario: ${state.formData.startTime} - ${state.formData.endTime}
Luogo: ${state.formData.location}${
            state.formData.mandatoryAttendance
              ? " alla quale dovranno obbligatoriamente partecipare tutti i rappresentanti degli studenti"
              : ""
          }
Ordine del Giorno:
${state.formData.agenda}`;

          const sig = await signer.signMessage(message);
          state.signature = sig;

          // If we are in preview mode, update the signature display
          if (!state.isEditing) {
            updatePreviewSignature();
          }

          updateActionButton();
          return sig;
        } catch (error) {
          console.error("Error signing:", error);
          alert("Errore durante la firma");
          return null;
        }
      }

      async function handleAction() {
        // If editing, switch to preview
        if (state.isEditing) {
          toggleView();
          // Wait a bit for render
          await new Promise((r) => setTimeout(r, 100));
        }

        if (!state.signature) {
          const sig = await handleSign();
          if (!sig) return;
          // Wait for signature render
          await new Promise((r) => setTimeout(r, 100));
        }

        downloadPDF();
      }

      async function downloadPDF() {
        try {
          const element = els.preview.pdf;

          if (typeof html2pdf === "undefined") {
            throw new Error("Libreria html2pdf non definita");
          }

          const opt = {
            margin: 0,
            filename: `Richiesta_Assemblea_${state.formData.date}.pdf`,
            image: { type: "jpeg", quality: 0.98 },
            html2canvas: { scale: 2, logging: false, useCORS: true },
            jsPDF: { unit: "mm", format: "a4", orientation: "portrait" },
          };

          await html2pdf().set(opt).from(element).save();
        } catch (error) {
          console.error("Error generating PDF:", error);
          alert("Errore generazione PDF: " + error.message);
        }
      }

      function updateActionButton() {
        if (state.signature) {
          els.btnAction.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg> Scarica PDF`;
        } else {
          els.btnAction.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg> Firma e Salva`;
        }
      }

      // Start
      init();
    </script>
  </body>
</html>
